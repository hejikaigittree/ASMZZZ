//
//  File generated by HDevelop for HALCON/DOTNET (C#) Version 12.0
//

using System.Windows;
using HalconDotNet;
namespace LFAOIRecipe.Algorithm
{
    public class Model_RegionAlg
    {

        // Procedures 
        // External procedures 
        // Chapter: Filters / Lines
        // Short Description: Calculates the parameters Sigma, Low, and High for lines_gauss from the maximum width and the contrast of the lines to be extracted. 
        // 区域算子更新 2020-06-15

        //2020-07-20 接口替换 创建黄金模板 
        //HTV_GenModels_TargetInspect_Recipe.hdvp
        //HTV_CreateGoldenImage_Match_Recipe.hdvp
        //HTV_create_model_recipe.hdvp

        //更新开始时间20200615 更新检测验证Demo

        // 在区域算子Demo: 更新HTV_confirm_mapping_matrix函数,添加HTV_clear_model函数--更新时间2020-07-09 垃圾回收提高运行速度

        // 在【表面检测】：更新HTV_read_frame_model函数，【单节点】中的此函数HTV_read_frame_model替换--更新时间2020-08-12 

        // 在【表面检测】：更新HTV_read_frame_recipe函数，【单节点】中的此函数HTV_read_frame_recipe替换--更新时间2020-08-12 

        // 在【表面检测】：替换接口HTV_read_frame_model.hdvp  2020-08-17

        // 在【表面检测】：替换接口HTV_read_cutreg_model.hdvp  2020-08-17

        //在【单节点Demo】： 替换接口JSCC_AOI_Inspect_Unit.hdvp ;   
        //                           JSCC_AOI_Inspect.hdvp   
        //                           HTV_frames_inspect.hdvp   
        //                    添加函数：HTV_ics_cut_region.hdvp   2020-08-17 

        //在【CutRegion】： 添加接口JSCC_AOI_Inspect_Gen_InspectReg_Unit   2020-08-17

        // 替换接口 2020-08-19  HTV_confirm_mapping_matrix

        // 替换接口 2020-08-20  HTV_read_frame_model, HTV_Apply_Measurement,HTV_Bond_Inspect_measure,HTV_read_wire_model,HTV_select_shortest_path.hdvp
        //HTV_Wire_Inspect_MVP.hdvp, HTV_WireSeg_Inspect_guass_pro.hdvp, HTV_WireSeg_Inspect_guass_sort.hdvp, HTV_WireSeg_Inspect_threshold.hdvp
        //select_shortest_path.hdvp,obtain_reference_point_direction.hdvp

        // 2020-08-21 接口替换  HTV_Create_Metrology_Model  
        // 2020-08-21 替换接口  HTV_read_cutreg_model  HTV_read_frame_recipe
        // 2020-08-21 替换接口  select_shortest_path
        // 2020-08-21 替换接口  obtain_reference_point_direction,HTV_WireSeg_Inspect_threshold,HTV_wires_inspect,HTV_Wire_Inspect_MVP,
        // HTV_select_shortest_path,HTV_Select_DieInspect_Result,HTV_read_frame_recipe,HTV_read_cutreg_model,HTV_ics_inspect,HTV_Ic_Shift_Inspect,
        // HTV_Ic_Inspect_GoldenModel,HTV_epoxys_inspect,HTV_bonds_inspect,HTV_Bond_Location,HTV_BLOB_Extract,HTV_Apply_Measurement,HTV_ics_cut_region,
        // JSCC_AOI_Inspect_Gen_CutReg_Unit,JSCC_AOI_Inspect_Unit

        // 2020-09-05 更新接口函数：HTV_GenModels_TargetInspect_Recipe, HTV_CreateGoldenImage_Match_Recipe, HTV_Bond_Location,
        // 2020-09-05 替换接口 HTV_Bond_Location, HTV_CreateGoldenImage_Match_Recipe
        // 2020-09-10 更新接口 HTV_CreateGoldenImage_Match_Recipe
        // 2020-09-15 替换接口 HTV_Bond_Inspect_measure，HTV_bonds_inspect，HTV_read_bond_model,HTV_Gen_HomMat_onWhat
        // 2020-10-19 替换接口函数 HTV_Gen_Bond_Region，HTV_Bond_Region_Location
        // 增加函数 HTV_Gen_Bond_measure，HTV_Gen_Bond_model，HTV_Gen_Ball_UserRegion
        // 2020-10-20 ：
        // 1、增加银胶焊点金线检测验证默认图集路径
        // 2、修改焊点测量报错提示
        // 3、开放焊点测量模型参数DistanceThreshold和MearsureSelect 
        // 4、修改IC检测亮暗图灰度值显示bug
        // 5、保存与读取freeRegion的xml
        // 6、修改read模型和参数解析文件
        // 7、更新HTV_Create_Metrology_Model

        //2020-12-05 添加使用多框架模板定位功能：
        //1、替换接口函数：HTV_CreateLocModel
        //2、替换接口函数：HTV_create_model_recipe
        //3、开放起始角度，角度范围参数

        #region 创建黄金模板
        public static void HTV_GenModels_TargetInspect_Recipe(HObject ho_i_Image, HObject ho_i_TarRegs,
            HObject ho_i_MatchRegs, HObject ho_i_InspectRegs, HObject ho_i_RejectRegs, HObject ho_i_SubRegs,
            out HObject ho_o_MeanImage, out HObject ho_o_StdImage, HTuple hv_i_ImageFiles,
            HTuple hv_i_ModelPath, HTuple hv_i_RecipePath, HTuple hv_i_IcOnWhat, HTuple hv_i_ModelType,
            HTuple hv_i_MultiModelMode, HTuple hv_i_FindIcImgIdx, HTuple hv_i_IcGoldenImgIdx,
            HTuple hv_i_MinTrainSet, HTuple hv_i_IsRefine, HTuple hv_i_RefineThresh, HTuple hv_i_IsGoldenMatchModel,
            out HTuple hv_o_ModelID)
        {




            // Local iconic variables 

            HObject ho_curReg = null, ho_curImage = null, ho__ImgMean = null;

            // Local control variables 

            HTuple hv_Number = null, hv__AngleStart = new HTuple();
            HTuple hv__AngleExt = new HTuple(), hv__MinScore = new HTuple();
            HTuple hv_Index = null, hv__ModelID = new HTuple(), hv_o_ErrCode = null;
            HTuple hv_o_ErrString = null;
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_MeanImage);
            HOperatorSet.GenEmptyObj(out ho_o_StdImage);
            HOperatorSet.GenEmptyObj(out ho_curReg);
            HOperatorSet.GenEmptyObj(out ho_curImage);
            HOperatorSet.GenEmptyObj(out ho__ImgMean);
            //**************************************************************
            //生成用于目标定位的匹配模板,保存模板ID和类型；创建用于目标检测的黄金比对图像，保存其均值图像和方差图像
            //i_Image: 目标图像
            //i_TarRegs: 目标所在的区域（一个区域包含一个完整目标，视野内有几个待检目标，就需要给出几个区域）
            //i_MatchRegs: 在目标区域内定位目标的匹配区（要求该区域细节较多，容易区分），一个匹配区创建一个模板，若需要将几个区域联合创建一个模板，需要将区域union在一起
            //i_InspectRegs: 在目标区域内检测目标的检测区（检测缺陷的区域，基于该区域建立黄金比对模板）
            //i_RejectRegs: 免检区域（检测区内部）
            //i_SubRegs: 重点检测区域（检测区内部）
            //o_MeanImage: 黄金比对模板的均值图像
            //o_StdImage: 黄金比对模板的方差图像
            //i_ImageFiles: 用于生成黄金比对模板的图像序列（字符串数组，为图像文件路径）
            //i_ModelType: 用于创建目标定位匹配模板的类型，ncc or shape
            //i_MultiModelMode：是否多模板模式（用于目标检测，当光照不均时，可选择对视野中每一个目标区域分别建立一个黄金比对模板），１为多模板模式，０为单模板模式
            //i_ImageListIndexBegin: 生成黄金比对模板的基准图像在图像序列中的索引值
            //i_ImageChannelIndex:生成黄金比对模板的图像在三通道图像中的索引值
            //i_MinTrainSet: 生成黄金比对模板的最小图像训练集大小
            //i_IsRefine:是否对生成的黄金比对模板进行精炼
            //i_RefineThresh:精炼阈值
            //i_IsGoldenMatchModel:是否用黄金比对模板重新生成目标定位匹配模板
            //o_ModelID:目标定位匹配模板ＩＤ
            //**************************************************************

            //生成匹配模板
            HOperatorSet.CountObj(ho_i_MatchRegs, out hv_Number);
            hv_o_ModelID = new HTuple();
            if ((int)(new HTuple(hv_i_ModelType.TupleEqual(0))) != 0)
            {
                hv__AngleStart = -((new HTuple(22.5)).TupleRad());
                hv__AngleExt = (new HTuple(45)).TupleRad();
                hv__MinScore = 0.6;
            }
            else
            {
                hv__AngleStart = -((new HTuple(180)).TupleRad());
                hv__AngleExt = (new HTuple(360)).TupleRad();
                hv__MinScore = 0.6;
            }
            HTuple end_val34 = hv_Number;
            HTuple step_val34 = 1;
            for (hv_Index = 1; hv_Index.Continue(end_val34, step_val34); hv_Index = hv_Index.TupleAdd(step_val34))
            {
                ho_curReg.Dispose();
                HOperatorSet.SelectObj(ho_i_MatchRegs, out ho_curReg, hv_Index);
                HTV_create_model_recipe(ho_i_Image, ho_curReg, hv_i_ModelType, hv__AngleStart,
                    hv__AngleExt, out hv__ModelID);
                hv_o_ModelID = hv_o_ModelID.TupleConcat(hv__ModelID);
            }

            //生成黄金模板比对图像（均值图像和方差图像）
            ho_o_MeanImage.Dispose(); ho_o_StdImage.Dispose();
            HTV_CreateGoldenImage_Match_Recipe(ho_i_TarRegs, ho_i_MatchRegs, ho_i_InspectRegs,
                out ho_o_MeanImage, out ho_o_StdImage, hv_i_ModelType, hv_o_ModelID, hv__AngleStart,
                hv__AngleExt, hv__MinScore, hv_i_MultiModelMode, hv_i_ImageFiles, hv_i_ModelPath,
                hv_i_RecipePath, hv_i_IcOnWhat, hv_i_FindIcImgIdx, hv_i_IcGoldenImgIdx, hv_i_MinTrainSet,
                hv_i_IsRefine, hv_i_RefineThresh, out hv_o_ErrCode, out hv_o_ErrString);

            //根据黄金图生成匹配模板
            if ((int)(hv_i_IsGoldenMatchModel) != 0)
            {
                ho_curImage.Dispose();
                HOperatorSet.SelectObj(ho_o_MeanImage, out ho_curImage, 1);
                ho__ImgMean.Dispose();
                HOperatorSet.ConvertImageType(ho_curImage, out ho__ImgMean, "byte");
                HTV_clear_model_recipe(hv_o_ModelID, hv_i_ModelType);
                hv_o_ModelID = new HTuple();
                HTuple end_val49 = hv_Number;
                HTuple step_val49 = 1;
                for (hv_Index = 1; hv_Index.Continue(end_val49, step_val49); hv_Index = hv_Index.TupleAdd(step_val49))
                {
                    ho_curReg.Dispose();
                    HOperatorSet.SelectObj(ho_i_MatchRegs, out ho_curReg, hv_Index);
                    HTV_create_model_recipe(ho__ImgMean, ho_curReg, hv_i_ModelType, hv__AngleStart,
                        hv__AngleExt, out hv__ModelID);
                    hv_o_ModelID = hv_o_ModelID.TupleConcat(hv__ModelID);
                }
            }

            ho_curReg.Dispose();
            ho_curImage.Dispose();
            ho__ImgMean.Dispose();

            return;
        }

        public static void HTV_clear_model_recipe(HTuple hv_i_ModelID, HTuple hv_i_ModelType)
        {



            // Local control variables 

            HTuple hv_Index = null;
            // Initialize local and output iconic variables 
            for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_i_ModelID.TupleLength())) - 1); hv_Index = (int)hv_Index + 1)
            {
                if ((int)(new HTuple(hv_i_ModelType.TupleEqual(0))) != 0)
                {
                    HOperatorSet.ClearNccModel(hv_i_ModelID.TupleSelect(hv_Index));
                }
                else if ((int)(new HTuple(hv_i_ModelType.TupleEqual(1))) != 0)
                {
                    HOperatorSet.ClearShapeModel(hv_i_ModelID.TupleSelect(hv_Index));
                }
                else
                {
                    throw new HalconException("Wrong argument [modelType]=" + hv_i_ModelType);
                }
            }

            return;
        }

        //2020-12-05 
        public static void HTV_create_model_recipe(HObject ho_i_Image, HObject ho_i_ROI, HTuple hv_i_ModelType,
            HTuple hv_i_AngleStart, HTuple hv_i_AngleExt, out HTuple hv_o_ModelID)
        {




            // Local iconic variables 

            HObject ho_ImageReduced;

            // Local control variables 

            HTuple hv_Area = null, hv__regionRow = null;
            HTuple hv__regionCol = null;
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_ImageReduced);
            hv_o_ModelID = new HTuple();
            try
            {
                //**********************************

                //*********************************************************************
                //
                ho_ImageReduced.Dispose();
                HOperatorSet.ReduceDomain(ho_i_Image, ho_i_ROI, out ho_ImageReduced);
                HOperatorSet.AreaCenter(ho_i_ROI, out hv_Area, out hv__regionRow, out hv__regionCol);
                if ((int)(new HTuple(hv_i_ModelType.TupleEqual(0))) != 0)
                {
                    HOperatorSet.CreateNccModel(ho_ImageReduced, "auto", hv_i_AngleStart, hv_i_AngleExt,
                        "auto", "use_polarity", out hv_o_ModelID);
                    //
                    HOperatorSet.SetNccModelOrigin(hv_o_ModelID, -hv__regionRow, -hv__regionCol);
                }
                else if ((int)(new HTuple(hv_i_ModelType.TupleEqual(1))) != 0)
                {
                    HOperatorSet.CreateShapeModel(ho_ImageReduced, "auto", hv_i_AngleStart, hv_i_AngleExt,
                        "auto", "auto", "use_polarity", "auto", "auto", out hv_o_ModelID);
                    //
                    HOperatorSet.SetShapeModelOrigin(hv_o_ModelID, -hv__regionRow, -hv__regionCol);
                }
                else
                {
                    throw new HalconException("Wrong argument [modelType]=" + hv_i_ModelType);
                }
                ho_ImageReduced.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_ImageReduced.Dispose();

                throw HDevExpDefaultException;
            }
        }

        //被替换
        //public static void HTV_create_model_recipe(HObject ho_i_Image, HObject ho_i_ROI, HTuple hv_i_ModelType,
        //    HTuple hv_i_AngleStart, HTuple hv_i_AngleExt, out HTuple hv_o_ModelID)
        //{




        //    // Local iconic variables 

        //    HObject ho_ImageReduced, ho_Edges;

        //    // Local control variables 

        //    HTuple hv_Area = null, hv__regionRow = null;
        //    HTuple hv__regionCol = null;
        //    // Initialize local and output iconic variables 
        //    HOperatorSet.GenEmptyObj(out ho_ImageReduced);
        //    HOperatorSet.GenEmptyObj(out ho_Edges);
        //    hv_o_ModelID = new HTuple();
        //    ho_ImageReduced.Dispose();
        //    HOperatorSet.ReduceDomain(ho_i_Image, ho_i_ROI, out ho_ImageReduced);
        //    //ho_Edges.Dispose();
        //    //HOperatorSet.EdgesSubPix(ho_ImageReduced, out ho_Edges, "canny", 1, 20, 40);

        //    HOperatorSet.AreaCenter(ho_i_ROI, out hv_Area, out hv__regionRow, out hv__regionCol);
        //    if ((int)(new HTuple(hv_i_ModelType.TupleEqual(0))) != 0)
        //    {
        //        HOperatorSet.CreateNccModel(ho_ImageReduced, "auto", hv_i_AngleStart, hv_i_AngleExt,
        //            "auto", "use_polarity", out hv_o_ModelID);
        //        HOperatorSet.SetNccModelOrigin(hv_o_ModelID, -hv__regionRow, -hv__regionCol);
        //    }
        //    else if ((int)(new HTuple(hv_i_ModelType.TupleEqual(1))) != 0)
        //    {
        //        HOperatorSet.CreateShapeModel(ho_ImageReduced, "auto", hv_i_AngleStart, hv_i_AngleExt,
        //            "auto", "auto", "use_polarity", "auto", "auto", out hv_o_ModelID);
        //        HOperatorSet.SetShapeModelOrigin(hv_o_ModelID, -hv__regionRow, -hv__regionCol);
        //    }
        //    else
        //    {
        //        throw new HalconException("Wrong argument [modelType]=" + hv_i_ModelType);
        //    }
        //    ho_ImageReduced.Dispose();
        //    ho_Edges.Dispose();

        //    return;
        //}

        public static void HTV_CreateGoldenImage_Match_Recipe(HObject ho_i_TarRegs, HObject ho_i_MatchRegs,
            HObject ho_i_InspectRegs, out HObject ho_o_MeanImage, out HObject ho_o_StdImage,
            HTuple hv_i_ModelType, HTuple hv_i_ModelID, HTuple hv_i_AngleStart, HTuple hv_i_AngleExt,
            HTuple hv_i_MinScore, HTuple hv_i_MultiModelMode, HTuple hv_i_ImageFiles, HTuple hv_i_ModelPath,
            HTuple hv_i_RecipePath, HTuple hv_i_IcOnWhat, HTuple hv_i_FindIcImgIdx, HTuple hv_i_IcGoldenImgIdx,
            HTuple hv_i_MinTrainSet, HTuple hv_i_IsRefine, HTuple hv_i_RefineThresh, out HTuple hv_o_ErrCode,
            out HTuple hv_o_ErrString)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_OriImgs, ho_IcGoldenImg, ho_FindIcImg;
            HObject ho_Image = null, ho_Image1 = null, ho_ChannelImage1 = null;
            HObject ho__ImgSumArr, ho__Img2SumArr, ho_curROI = null, ho__ImgSum = null;
            HObject ho__Img2Sum = null, ho__ImgSumPart = null, ho__Img2SumPart = null;
            HObject ho__ImgArr = null, ho_OriImg = null, ho_Imgs = null, ho_curMatchReg = null;
            HObject ho__InspectReg = null, ho__MatchReg = null, ho__SearchReg = null;
            HObject ho_ImageReduced = null, ho_ImageAffinTrans = null, ho__goldenImage = null;
            HObject ho__goldenImagePart = null, ho_ImageConvertedPart = null;
            HObject ho_ImageResultPart = null, ho_MutiImage = null, ho__ImgSumTemp = null;
            HObject ho__Img2SumTemp = null, ho__ImgMean = null, ho__Img2Mean = null;
            HObject ho_ImageResult1 = null, ho__ImgDev = null, ho__ImgStd = null;
            HObject ho_RankImg = null, ho_NewMutiImage = null, ho__ImgMeanPart = null;
            HObject ho_ImageScaled1 = null, ho__ImgLight = null, ho__ImgDark = null;
            HObject ho__ImgMeanByte = null, ho__ImgMeanLight = null, ho__ImgMeanDark = null;
            HObject ho__ImgCount = null, ho__ImgCountPart = null, ho__ImgLightPart = null;
            HObject ho__ImgDarkPart = null, ho__ImgMeanLightPart = null;
            HObject ho__ImgMeanDarkPart = null, ho_ObjectSelected = null;
            HObject ho_ImageReduced1 = null, ho__LightReg = null, ho__DarkReg = null;
            HObject ho_RegionUnion00 = null, ho__MeanLightReg = null, ho__MeanDarkReg = null;
            HObject ho_RegionUnion01 = null, ho_RegionUnion = null, ho_ConnectedRegions = null;
            HObject ho_RegionSelect = null, ho_RegionUnionSelect = null;
            HObject ho_RegionDilation1 = null, ho_BinImage1 = null, ho_ImageConverted3 = null;
            HObject ho_ImageConverted4 = null, ho_ImageResult6 = null, ho_ImageResult4 = null;
            HObject ho__ImgCountReg = null, ho_BinImage2 = null, ho_ImageBin01 = null;
            HObject ho__ImgCountNew = null, ho_BinImage3 = null, ho_ImageBin10 = null;
            HObject ho__ImgMeanReduced = null, ho__ImgMean2Reduced = null;
            HObject ho__ImgMeanTmp = null, ho__Img2MeanTmp = null, ho__ImgDevNew = null;
            HObject ho__ImgMeanAll = null, ho__ImgStdAll = null;

            HObjectVector hvec__ImgArrVec = new HObjectVector(1);

            // Local control variables 

            HTuple hv_o_ErrStr = new HTuple(), hv_Index1 = null;
            HTuple hv_cnt = null, hv_LtRow = null, hv_LtColumn = null;
            HTuple hv_RbRow = null, hv_RbColumn = null, hv_WidthPart = null;
            HTuple hv_HeightPart = null, hv_Width = null, hv_Height = null;
            HTuple hv__DieNum = null, hv__TrainSetNum = null, hv__MatchModelNum = null;
            HTuple hv_IndexROI = null, hv_IndexFiles = new HTuple();
            HTuple hv_maxScore = new HTuple(), hv_matchRow = new HTuple();
            HTuple hv_matchCol = new HTuple(), hv_matchAngle = new HTuple();
            HTuple hv_i_MatchNum = new HTuple(), hv_IndexModel = new HTuple();
            HTuple hv__FrameHomMat2D = new HTuple(), hv__ErrCode = new HTuple();
            HTuple hv__ErrStr = new HTuple(), hv__ErrDilCode = new HTuple();
            HTuple hv__ErrDilStr = new HTuple(), hv_Row = new HTuple();
            HTuple hv_Column = new HTuple(), hv_Angle = new HTuple();
            HTuple hv_Score = new HTuple(), hv_HomMat2D1 = new HTuple();
            HTuple hv__ModelNum = new HTuple(), hv__Sum = new HTuple();
            HTuple hv_i = new HTuple(), hv_ImgNum = new HTuple(), hv_idx = new HTuple();
            HTuple hv_j = new HTuple(), hv_Number = new HTuple(), hv_Min = new HTuple();
            HTuple hv_Max = new HTuple(), hv_Range = new HTuple();
            HTuple hv_MinImgNum = new HTuple(), hv__frameLocPara = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_MeanImage);
            HOperatorSet.GenEmptyObj(out ho_o_StdImage);
            HOperatorSet.GenEmptyObj(out ho_OriImgs);
            HOperatorSet.GenEmptyObj(out ho_IcGoldenImg);
            HOperatorSet.GenEmptyObj(out ho_FindIcImg);
            HOperatorSet.GenEmptyObj(out ho_Image);
            HOperatorSet.GenEmptyObj(out ho_Image1);
            HOperatorSet.GenEmptyObj(out ho_ChannelImage1);
            HOperatorSet.GenEmptyObj(out ho__ImgSumArr);
            HOperatorSet.GenEmptyObj(out ho__Img2SumArr);
            HOperatorSet.GenEmptyObj(out ho_curROI);
            HOperatorSet.GenEmptyObj(out ho__ImgSum);
            HOperatorSet.GenEmptyObj(out ho__Img2Sum);
            HOperatorSet.GenEmptyObj(out ho__ImgSumPart);
            HOperatorSet.GenEmptyObj(out ho__Img2SumPart);
            HOperatorSet.GenEmptyObj(out ho__ImgArr);
            HOperatorSet.GenEmptyObj(out ho_OriImg);
            HOperatorSet.GenEmptyObj(out ho_Imgs);
            HOperatorSet.GenEmptyObj(out ho_curMatchReg);
            HOperatorSet.GenEmptyObj(out ho__InspectReg);
            HOperatorSet.GenEmptyObj(out ho__MatchReg);
            HOperatorSet.GenEmptyObj(out ho__SearchReg);
            HOperatorSet.GenEmptyObj(out ho_ImageReduced);
            HOperatorSet.GenEmptyObj(out ho_ImageAffinTrans);
            HOperatorSet.GenEmptyObj(out ho__goldenImage);
            HOperatorSet.GenEmptyObj(out ho__goldenImagePart);
            HOperatorSet.GenEmptyObj(out ho_ImageConvertedPart);
            HOperatorSet.GenEmptyObj(out ho_ImageResultPart);
            HOperatorSet.GenEmptyObj(out ho_MutiImage);
            HOperatorSet.GenEmptyObj(out ho__ImgSumTemp);
            HOperatorSet.GenEmptyObj(out ho__Img2SumTemp);
            HOperatorSet.GenEmptyObj(out ho__ImgMean);
            HOperatorSet.GenEmptyObj(out ho__Img2Mean);
            HOperatorSet.GenEmptyObj(out ho_ImageResult1);
            HOperatorSet.GenEmptyObj(out ho__ImgDev);
            HOperatorSet.GenEmptyObj(out ho__ImgStd);
            HOperatorSet.GenEmptyObj(out ho_RankImg);
            HOperatorSet.GenEmptyObj(out ho_NewMutiImage);
            HOperatorSet.GenEmptyObj(out ho__ImgMeanPart);
            HOperatorSet.GenEmptyObj(out ho_ImageScaled1);
            HOperatorSet.GenEmptyObj(out ho__ImgLight);
            HOperatorSet.GenEmptyObj(out ho__ImgDark);
            HOperatorSet.GenEmptyObj(out ho__ImgMeanByte);
            HOperatorSet.GenEmptyObj(out ho__ImgMeanLight);
            HOperatorSet.GenEmptyObj(out ho__ImgMeanDark);
            HOperatorSet.GenEmptyObj(out ho__ImgCount);
            HOperatorSet.GenEmptyObj(out ho__ImgCountPart);
            HOperatorSet.GenEmptyObj(out ho__ImgLightPart);
            HOperatorSet.GenEmptyObj(out ho__ImgDarkPart);
            HOperatorSet.GenEmptyObj(out ho__ImgMeanLightPart);
            HOperatorSet.GenEmptyObj(out ho__ImgMeanDarkPart);
            HOperatorSet.GenEmptyObj(out ho_ObjectSelected);
            HOperatorSet.GenEmptyObj(out ho_ImageReduced1);
            HOperatorSet.GenEmptyObj(out ho__LightReg);
            HOperatorSet.GenEmptyObj(out ho__DarkReg);
            HOperatorSet.GenEmptyObj(out ho_RegionUnion00);
            HOperatorSet.GenEmptyObj(out ho__MeanLightReg);
            HOperatorSet.GenEmptyObj(out ho__MeanDarkReg);
            HOperatorSet.GenEmptyObj(out ho_RegionUnion01);
            HOperatorSet.GenEmptyObj(out ho_RegionUnion);
            HOperatorSet.GenEmptyObj(out ho_ConnectedRegions);
            HOperatorSet.GenEmptyObj(out ho_RegionSelect);
            HOperatorSet.GenEmptyObj(out ho_RegionUnionSelect);
            HOperatorSet.GenEmptyObj(out ho_RegionDilation1);
            HOperatorSet.GenEmptyObj(out ho_BinImage1);
            HOperatorSet.GenEmptyObj(out ho_ImageConverted3);
            HOperatorSet.GenEmptyObj(out ho_ImageConverted4);
            HOperatorSet.GenEmptyObj(out ho_ImageResult6);
            HOperatorSet.GenEmptyObj(out ho_ImageResult4);
            HOperatorSet.GenEmptyObj(out ho__ImgCountReg);
            HOperatorSet.GenEmptyObj(out ho_BinImage2);
            HOperatorSet.GenEmptyObj(out ho_ImageBin01);
            HOperatorSet.GenEmptyObj(out ho__ImgCountNew);
            HOperatorSet.GenEmptyObj(out ho_BinImage3);
            HOperatorSet.GenEmptyObj(out ho_ImageBin10);
            HOperatorSet.GenEmptyObj(out ho__ImgMeanReduced);
            HOperatorSet.GenEmptyObj(out ho__ImgMean2Reduced);
            HOperatorSet.GenEmptyObj(out ho__ImgMeanTmp);
            HOperatorSet.GenEmptyObj(out ho__Img2MeanTmp);
            HOperatorSet.GenEmptyObj(out ho__ImgDevNew);
            HOperatorSet.GenEmptyObj(out ho__ImgMeanAll);
            HOperatorSet.GenEmptyObj(out ho__ImgStdAll);
            try
            {
                //**************************************************************
                //生成用于目标定位的匹配模板,保存模板ID和类型；创建用于目标检测的黄金比对图像，保存其均值图像和方差图像
                //**************************************************************

                hv_o_ErrCode = -2;
                hv_o_ErrString = "initializing";

                //检查输入通道有效性 ----注释掉，图层索引不限于1，2，3
                //if ((int)((new HTuple((new HTuple(hv_i_FindIcImgIdx.TupleNotEqual(1))).TupleAnd(
                //    new HTuple(hv_i_FindIcImgIdx.TupleNotEqual(2))))).TupleAnd(new HTuple(hv_i_FindIcImgIdx.TupleNotEqual(
                //    3)))) != 0)
                //{
                //    hv_o_ErrCode = -1;
                //    hv_o_ErrStr = "i_FindIcImgIdx is invalid!";
                //    ho_OriImgs.Dispose();
                //    ho_IcGoldenImg.Dispose();
                //    ho_FindIcImg.Dispose();
                //    ho_Image.Dispose();
                //    ho_Image1.Dispose();
                //    ho_ChannelImage1.Dispose();
                //    ho__ImgSumArr.Dispose();
                //    ho__Img2SumArr.Dispose();
                //    ho_curROI.Dispose();
                //    ho__ImgSum.Dispose();
                //    ho__Img2Sum.Dispose();
                //    ho__ImgSumPart.Dispose();
                //    ho__Img2SumPart.Dispose();
                //    ho__ImgArr.Dispose();
                //    ho_OriImg.Dispose();
                //    ho_Imgs.Dispose();
                //    ho_curMatchReg.Dispose();
                //    ho__InspectReg.Dispose();
                //    ho__MatchReg.Dispose();
                //    ho__SearchReg.Dispose();
                //    ho_ImageReduced.Dispose();
                //    ho_ImageAffinTrans.Dispose();
                //    ho__goldenImage.Dispose();
                //    ho__goldenImagePart.Dispose();
                //    ho_ImageConvertedPart.Dispose();
                //    ho_ImageResultPart.Dispose();
                //    ho_MutiImage.Dispose();
                //    ho__ImgSumTemp.Dispose();
                //    ho__Img2SumTemp.Dispose();
                //    ho__ImgMean.Dispose();
                //    ho__Img2Mean.Dispose();
                //    ho_ImageResult1.Dispose();
                //    ho__ImgDev.Dispose();
                //    ho__ImgStd.Dispose();
                //    ho_RankImg.Dispose();
                //    ho_NewMutiImage.Dispose();
                //    ho__ImgMeanPart.Dispose();
                //    ho_ImageScaled1.Dispose();
                //    ho__ImgLight.Dispose();
                //    ho__ImgDark.Dispose();
                //    ho__ImgMeanByte.Dispose();
                //    ho__ImgMeanLight.Dispose();
                //    ho__ImgMeanDark.Dispose();
                //    ho__ImgCount.Dispose();
                //    ho__ImgCountPart.Dispose();
                //    ho__ImgLightPart.Dispose();
                //    ho__ImgDarkPart.Dispose();
                //    ho__ImgMeanLightPart.Dispose();
                //    ho__ImgMeanDarkPart.Dispose();
                //    ho_ObjectSelected.Dispose();
                //    ho_ImageReduced1.Dispose();
                //    ho__LightReg.Dispose();
                //    ho__DarkReg.Dispose();
                //    ho_RegionUnion00.Dispose();
                //    ho__MeanLightReg.Dispose();
                //    ho__MeanDarkReg.Dispose();
                //    ho_RegionUnion01.Dispose();
                //    ho_RegionUnion.Dispose();
                //    ho_ConnectedRegions.Dispose();
                //    ho_RegionSelect.Dispose();
                //    ho_RegionUnionSelect.Dispose();
                //    ho_RegionDilation1.Dispose();
                //    ho_BinImage1.Dispose();
                //    ho_ImageConverted3.Dispose();
                //    ho_ImageConverted4.Dispose();
                //    ho_ImageResult6.Dispose();
                //    ho_ImageResult4.Dispose();
                //    ho__ImgCountReg.Dispose();
                //    ho_BinImage2.Dispose();
                //    ho_ImageBin01.Dispose();
                //    ho__ImgCountNew.Dispose();
                //    ho_BinImage3.Dispose();
                //    ho_ImageBin10.Dispose();
                //    ho__ImgMeanReduced.Dispose();
                //    ho__ImgMean2Reduced.Dispose();
                //    ho__ImgMeanTmp.Dispose();
                //    ho__Img2MeanTmp.Dispose();
                //    ho__ImgDevNew.Dispose();
                //    ho__ImgMeanAll.Dispose();
                //    ho__ImgStdAll.Dispose();
                //    hvec__ImgArrVec.Dispose();

                //    return;
                //}

                //if ((int)((new HTuple((new HTuple(hv_i_IcGoldenImgIdx.TupleNotEqual(1))).TupleAnd(
                //    new HTuple(hv_i_IcGoldenImgIdx.TupleNotEqual(2))))).TupleAnd(new HTuple(hv_i_IcGoldenImgIdx.TupleNotEqual(
                //    3)))) != 0)
                //{
                //    hv_o_ErrCode = -1;
                //    hv_o_ErrStr = "i_IcGoldenImgIdx is invalid!";
                //    ho_OriImgs.Dispose();
                //    ho_IcGoldenImg.Dispose();
                //    ho_FindIcImg.Dispose();
                //    ho_Image.Dispose();
                //    ho_Image1.Dispose();
                //    ho_ChannelImage1.Dispose();
                //    ho__ImgSumArr.Dispose();
                //    ho__Img2SumArr.Dispose();
                //    ho_curROI.Dispose();
                //    ho__ImgSum.Dispose();
                //    ho__Img2Sum.Dispose();
                //    ho__ImgSumPart.Dispose();
                //    ho__Img2SumPart.Dispose();
                //    ho__ImgArr.Dispose();
                //    ho_OriImg.Dispose();
                //    ho_Imgs.Dispose();
                //    ho_curMatchReg.Dispose();
                //    ho__InspectReg.Dispose();
                //    ho__MatchReg.Dispose();
                //    ho__SearchReg.Dispose();
                //    ho_ImageReduced.Dispose();
                //    ho_ImageAffinTrans.Dispose();
                //    ho__goldenImage.Dispose();
                //    ho__goldenImagePart.Dispose();
                //    ho_ImageConvertedPart.Dispose();
                //    ho_ImageResultPart.Dispose();
                //    ho_MutiImage.Dispose();
                //    ho__ImgSumTemp.Dispose();
                //    ho__Img2SumTemp.Dispose();
                //    ho__ImgMean.Dispose();
                //    ho__Img2Mean.Dispose();
                //    ho_ImageResult1.Dispose();
                //    ho__ImgDev.Dispose();
                //    ho__ImgStd.Dispose();
                //    ho_RankImg.Dispose();
                //    ho_NewMutiImage.Dispose();
                //    ho__ImgMeanPart.Dispose();
                //    ho_ImageScaled1.Dispose();
                //    ho__ImgLight.Dispose();
                //    ho__ImgDark.Dispose();
                //    ho__ImgMeanByte.Dispose();
                //    ho__ImgMeanLight.Dispose();
                //    ho__ImgMeanDark.Dispose();
                //    ho__ImgCount.Dispose();
                //    ho__ImgCountPart.Dispose();
                //    ho__ImgLightPart.Dispose();
                //    ho__ImgDarkPart.Dispose();
                //    ho__ImgMeanLightPart.Dispose();
                //    ho__ImgMeanDarkPart.Dispose();
                //    ho_ObjectSelected.Dispose();
                //    ho_ImageReduced1.Dispose();
                //    ho__LightReg.Dispose();
                //    ho__DarkReg.Dispose();
                //    ho_RegionUnion00.Dispose();
                //    ho__MeanLightReg.Dispose();
                //    ho__MeanDarkReg.Dispose();
                //    ho_RegionUnion01.Dispose();
                //    ho_RegionUnion.Dispose();
                //    ho_ConnectedRegions.Dispose();
                //    ho_RegionSelect.Dispose();
                //    ho_RegionUnionSelect.Dispose();
                //    ho_RegionDilation1.Dispose();
                //    ho_BinImage1.Dispose();
                //    ho_ImageConverted3.Dispose();
                //    ho_ImageConverted4.Dispose();
                //    ho_ImageResult6.Dispose();
                //    ho_ImageResult4.Dispose();
                //    ho__ImgCountReg.Dispose();
                //    ho_BinImage2.Dispose();
                //    ho_ImageBin01.Dispose();
                //    ho__ImgCountNew.Dispose();
                //    ho_BinImage3.Dispose();
                //    ho_ImageBin10.Dispose();
                //    ho__ImgMeanReduced.Dispose();
                //    ho__ImgMean2Reduced.Dispose();
                //    ho__ImgMeanTmp.Dispose();
                //    ho__Img2MeanTmp.Dispose();
                //    ho__ImgDevNew.Dispose();
                //    ho__ImgMeanAll.Dispose();
                //    ho__ImgStdAll.Dispose();
                //    hvec__ImgArrVec.Dispose();

                //    return;
                //}
                //------------------------------------------------------

                //导入所有图像
                ho_OriImgs.Dispose();
                HOperatorSet.GenEmptyObj(out ho_OriImgs);
                ho_IcGoldenImg.Dispose();
                HOperatorSet.GenEmptyObj(out ho_IcGoldenImg);
                ho_FindIcImg.Dispose();
                HOperatorSet.GenEmptyObj(out ho_FindIcImg);
                for (hv_Index1 = 0; (int)hv_Index1 <= (int)((new HTuple(hv_i_ImageFiles.TupleLength()
                    )) - 1); hv_Index1 = (int)hv_Index1 + 1)
                {
                    ho_Image.Dispose();
                    HOperatorSet.ReadImage(out ho_Image, hv_i_ImageFiles.TupleSelect(hv_Index1));
                    //count_channels (Image, Channels)
                    //*     if (Channels=3)
                    //decompose3 (Image, Image1, Image2, Image3)
                    //*     _Imgs := {Image1,Image2,Image3}
                    //*     else
                    //_Imgs := {Image,Image,Image}
                    //*     endif

                    //*     concat_obj (IcGoldenImg, _Imgs.at(i_IcGoldenImgIdx-1), IcGoldenImg)
                    //*     concat_obj (FindIcImg, _Imgs.at(i_FindIcImgIdx-1), FindIcImg)

                    //1121
                    ho_ChannelImage1.Dispose();
                    HOperatorSet.AccessChannel(ho_Image, out ho_ChannelImage1, hv_i_FindIcImgIdx);
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_FindIcImg, ho_ChannelImage1, out ExpTmpOutVar_0
                            );
                        ho_FindIcImg.Dispose();
                        ho_FindIcImg = ExpTmpOutVar_0;
                    }
                    ho_ChannelImage1.Dispose();
                    HOperatorSet.AccessChannel(ho_Image, out ho_ChannelImage1, hv_i_IcGoldenImgIdx);
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_IcGoldenImg, ho_ChannelImage1, out ExpTmpOutVar_0
                            );
                        ho_IcGoldenImg.Dispose();
                        ho_IcGoldenImg = ExpTmpOutVar_0;
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_OriImgs, ho_Image, out ExpTmpOutVar_0);
                        ho_OriImgs.Dispose();
                        ho_OriImgs = ExpTmpOutVar_0;
                    }

                }
                //生成黄金模板
                hv_cnt = 0;
                HOperatorSet.SmallestRectangle1(ho_i_InspectRegs, out hv_LtRow, out hv_LtColumn,
                    out hv_RbRow, out hv_RbColumn);
                hv_WidthPart = (hv_RbColumn - hv_LtColumn) + 1;
                hv_HeightPart = (hv_RbRow - hv_LtRow) + 1;
                HOperatorSet.GetImageSize(ho_Image, out hv_Width, out hv_Height);
                ho_o_MeanImage.Dispose();
                HOperatorSet.GenEmptyObj(out ho_o_MeanImage);
                ho_o_StdImage.Dispose();
                HOperatorSet.GenEmptyObj(out ho_o_StdImage);
                //计算中间图像
                ho__ImgSumArr.Dispose();
                HOperatorSet.GenEmptyObj(out ho__ImgSumArr);
                ho__Img2SumArr.Dispose();
                HOperatorSet.GenEmptyObj(out ho__Img2SumArr);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hvec__ImgArrVec = dh.Add(new HObjectVector(1));
                }
                HOperatorSet.CountObj(ho_i_TarRegs, out hv__DieNum);
                HOperatorSet.TupleGenConst(hv__DieNum, 0, out hv__TrainSetNum);
                hv__MatchModelNum = new HTuple(hv_i_ModelID.TupleLength());
                HTuple end_val60 = hv__DieNum;
                HTuple step_val60 = 1;
                for (hv_IndexROI = 1; hv_IndexROI.Continue(end_val60, step_val60); hv_IndexROI = hv_IndexROI.TupleAdd(step_val60))
                {
                    ho_curROI.Dispose();
                    HOperatorSet.SelectObj(ho_i_TarRegs, out ho_curROI, hv_IndexROI);
                    //HTV_gen_image_type_recipe (Image, _ImgSum, 'real')
                    //HTV_gen_image_type_recipe (Image, _Img2Sum, 'real')
                    ho__ImgSumPart.Dispose();
                    HOperatorSet.GenImageConst(out ho__ImgSumPart, "real", hv_WidthPart, hv_HeightPart);
                    ho__Img2SumPart.Dispose();
                    HOperatorSet.GenImageConst(out ho__Img2SumPart, "real", hv_WidthPart, hv_HeightPart);
                    ho__ImgArr.Dispose();
                    HOperatorSet.GenEmptyObj(out ho__ImgArr);
                    for (hv_IndexFiles = 1; (int)hv_IndexFiles <= (int)(new HTuple(hv_i_ImageFiles.TupleLength()
                        )); hv_IndexFiles = (int)hv_IndexFiles + 1)
                    {
                        ho_Image1.Dispose();
                        HOperatorSet.SelectObj(ho_IcGoldenImg, out ho_Image1, hv_IndexFiles);
                        ho_Image.Dispose();
                        HOperatorSet.SelectObj(ho_FindIcImg, out ho_Image, hv_IndexFiles);
                        //1121
                        ho_OriImg.Dispose();
                        HOperatorSet.SelectObj(ho_OriImgs, out ho_OriImg, hv_IndexFiles);
                        ho_Imgs.Dispose();
                        HOperatorSet.ImageToChannels(ho_OriImg, out ho_Imgs);

                        hv_maxScore = 0;
                        hv_matchRow = -1;
                        hv_matchCol = -1;
                        hv_matchAngle = 0;
                        hv_i_MatchNum = 1;
                        HTuple end_val79 = hv__MatchModelNum;
                        HTuple step_val79 = 1;
                        for (hv_IndexModel = 1; hv_IndexModel.Continue(end_val79, step_val79); hv_IndexModel = hv_IndexModel.TupleAdd(step_val79))
                        {
                            ho_curMatchReg.Dispose();
                            HOperatorSet.SelectObj(ho_i_MatchRegs, out ho_curMatchReg, hv_IndexModel);
                            //框架定位
                            HTV_confirm_mapping_matrix(ho_Imgs, ho_curROI, hv_i_ModelPath, hv_i_RecipePath,
                                hv_i_IcOnWhat, out hv__FrameHomMat2D, out hv__frameLocPara, out hv__ErrCode, out hv__ErrStr);

                            if ((int)(new HTuple(hv__ErrCode.TupleEqual(0))) != 0)
                            {
                                //映射检测区域
                                ho__InspectReg.Dispose();
                                HOperatorSet.AffineTransRegion(ho_i_InspectRegs, out ho__InspectReg,
                                    hv__FrameHomMat2D, "nearest_neighbor");
                                //映射匹配区域
                                ho__MatchReg.Dispose();
                                HOperatorSet.AffineTransRegion(ho_curMatchReg, out ho__MatchReg, hv__FrameHomMat2D,
                                    "nearest_neighbor");
                                //在映射粗定位区域下匹配
                                ho__SearchReg.Dispose();
                                HTV_region_dilation(ho__MatchReg, out ho__SearchReg, 60, out hv__ErrDilCode,
                                    out hv__ErrDilStr);
                                ho_ImageReduced.Dispose();
                                HOperatorSet.ReduceDomain(ho_Image, ho__SearchReg, out ho_ImageReduced
                                    );
                                if ((int)(new HTuple(hv_i_ModelType.TupleEqual(0))) != 0)
                                {
                                    HOperatorSet.FindNccModel(ho_ImageReduced, hv_i_ModelID.TupleSelect(
                                        hv_IndexModel - 1), hv_i_AngleStart, hv_i_AngleExt, 0.2, hv_i_MatchNum,
                                        0.5, "true", 0, out hv_Row, out hv_Column, out hv_Angle, out hv_Score);
                                }
                                else
                                {
                                    HOperatorSet.FindShapeModel(ho_ImageReduced, hv_i_ModelID.TupleSelect(
                                        hv_IndexModel - 1), hv_i_AngleStart, hv_i_AngleExt, 0.2, hv_i_MatchNum,
                                        0.5, "least_squares", 0, 0.9, out hv_Row, out hv_Column, out hv_Angle,
                                        out hv_Score);
                                }
                                if ((int)((new HTuple((new HTuple(hv_Score.TupleLength())).TupleGreater(
                                    0))).TupleAnd(new HTuple(hv_Score.TupleGreater(hv_maxScore)))) != 0)
                                {
                                    hv_maxScore = hv_Score.Clone();
                                    hv_matchRow = hv_Row.Clone();
                                    hv_matchCol = hv_Column.Clone();
                                    hv_matchAngle = hv_Angle.Clone();
                                }
                            }
                        }
                        if ((int)(new HTuple(hv_maxScore.TupleGreater(hv_i_MinScore))) != 0)
                        {
                            if (hv__TrainSetNum == null)
                                hv__TrainSetNum = new HTuple();
                            hv__TrainSetNum[hv_IndexROI - 1] = (hv__TrainSetNum.TupleSelect(hv_IndexROI - 1)) + 1;
                            HOperatorSet.VectorAngleToRigid(hv_matchRow, hv_matchCol, hv_matchAngle,
                                0, 0, 0, out hv_HomMat2D1);
                            ho_ImageAffinTrans.Dispose();
                            HOperatorSet.AffineTransImage(ho_Image1, out ho_ImageAffinTrans, hv_HomMat2D1,
                                "nearest_neighbor", "false");
                            //局部图操作，优化速度
                            ho__goldenImage.Dispose();
                            HOperatorSet.ReduceDomain(ho_ImageAffinTrans, ho_i_InspectRegs, out ho__goldenImage
                                );
                            //convert_image_type (_goldenImage, ImageConverted, 'real')
                            //add_image (_ImgSum, ImageConverted, _ImgSum, 1.0, 0)
                            //mult_image (ImageConverted, ImageConverted, ImageResult, 1.0, 0)
                            //add_image (_Img2Sum, ImageResult, _Img2Sum, 1.0, 0)
                            HOperatorSet.SmallestRectangle1(ho_i_InspectRegs, out hv_LtRow, out hv_LtColumn,
                                out hv_RbRow, out hv_RbColumn);
                            ho__goldenImagePart.Dispose();
                            HOperatorSet.CropRectangle1(ho_ImageAffinTrans, out ho__goldenImagePart,
                                hv_LtRow, hv_LtColumn, hv_RbRow, hv_RbColumn);
                            ho_ImageConvertedPart.Dispose();
                            HOperatorSet.ConvertImageType(ho__goldenImagePart, out ho_ImageConvertedPart,
                                "real");
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.AddImage(ho__ImgSumPart, ho_ImageConvertedPart, out ExpTmpOutVar_0,
                                    1.0, 0);
                                ho__ImgSumPart.Dispose();
                                ho__ImgSumPart = ExpTmpOutVar_0;
                            }
                            ho_ImageResultPart.Dispose();
                            HOperatorSet.MultImage(ho_ImageConvertedPart, ho_ImageConvertedPart,
                                out ho_ImageResultPart, 1.0, 0);
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.AddImage(ho__Img2SumPart, ho_ImageResultPart, out ExpTmpOutVar_0,
                                    1.0, 0);
                                ho__Img2SumPart.Dispose();
                                ho__Img2SumPart = ExpTmpOutVar_0;
                            }
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.ConcatObj(ho__ImgArr, ho__goldenImage, out ExpTmpOutVar_0
                                    );
                                ho__ImgArr.Dispose();
                                ho__ImgArr = ExpTmpOutVar_0;
                            }

                            if ((int)(new HTuple(hv_cnt.TupleLess(1))) != 0)
                            {
                                ho_MutiImage.Dispose();
                                HOperatorSet.CopyObj(ho_ImageConvertedPart, out ho_MutiImage, 1, 1);
                            }
                            else
                            {
                                {
                                    HObject ExpTmpOutVar_0;
                                    HOperatorSet.AppendChannel(ho_MutiImage, ho_ImageConvertedPart, out ExpTmpOutVar_0
                                        );
                                    ho_MutiImage.Dispose();
                                    ho_MutiImage = ExpTmpOutVar_0;
                                }
                            }
                            hv_cnt = hv_cnt + 1;

                        }
                    }
                    //还原坐标
                    ho__ImgSum.Dispose();
                    HOperatorSet.TileImagesOffset(ho__ImgSumPart, out ho__ImgSum, hv_LtRow, hv_LtColumn,
                        -1, -1, -1, -1, hv_Width, hv_Height);
                    ho__Img2Sum.Dispose();
                    HOperatorSet.TileImagesOffset(ho__Img2SumPart, out ho__Img2Sum, hv_LtRow,
                        hv_LtColumn, -1, -1, -1, -1, hv_Width, hv_Height);
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho__ImgSumArr, ho__ImgSum, out ExpTmpOutVar_0);
                        ho__ImgSumArr.Dispose();
                        ho__ImgSumArr = ExpTmpOutVar_0;
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho__Img2SumArr, ho__Img2Sum, out ExpTmpOutVar_0);
                        ho__Img2SumArr.Dispose();
                        ho__Img2SumArr = ExpTmpOutVar_0;
                    }
                    hvec__ImgArrVec[hv_IndexROI - 1] = new HObjectVector(ho__ImgArr.CopyObj(1, -1));
                }
                //确认黄金模板图像个数,对中间图像进行调整
                if ((int)(hv_i_MultiModelMode) != 0)
                {
                    //对视野内每个Die创建黄金模板
                    hv__ModelNum = hv__DieNum.Clone();
                }
                else
                {
                    //视野内的所有Die共用一个黄金模板
                    HOperatorSet.TupleSum(hv__TrainSetNum, out hv__Sum);
                    if ((int)(new HTuple(hv__Sum.TupleLess(hv_i_MinTrainSet))) != 0)
                    {
                        hv_o_ErrCode = -1;
                        hv_o_ErrString = "Training set not enough";
                        ho_OriImgs.Dispose();
                        ho_IcGoldenImg.Dispose();
                        ho_FindIcImg.Dispose();
                        ho_Image.Dispose();
                        ho_Image1.Dispose();
                        ho_ChannelImage1.Dispose();
                        ho__ImgSumArr.Dispose();
                        ho__Img2SumArr.Dispose();
                        ho_curROI.Dispose();
                        ho__ImgSum.Dispose();
                        ho__Img2Sum.Dispose();
                        ho__ImgSumPart.Dispose();
                        ho__Img2SumPart.Dispose();
                        ho__ImgArr.Dispose();
                        ho_OriImg.Dispose();
                        ho_Imgs.Dispose();
                        ho_curMatchReg.Dispose();
                        ho__InspectReg.Dispose();
                        ho__MatchReg.Dispose();
                        ho__SearchReg.Dispose();
                        ho_ImageReduced.Dispose();
                        ho_ImageAffinTrans.Dispose();
                        ho__goldenImage.Dispose();
                        ho__goldenImagePart.Dispose();
                        ho_ImageConvertedPart.Dispose();
                        ho_ImageResultPart.Dispose();
                        ho_MutiImage.Dispose();
                        ho__ImgSumTemp.Dispose();
                        ho__Img2SumTemp.Dispose();
                        ho__ImgMean.Dispose();
                        ho__Img2Mean.Dispose();
                        ho_ImageResult1.Dispose();
                        ho__ImgDev.Dispose();
                        ho__ImgStd.Dispose();
                        ho_RankImg.Dispose();
                        ho_NewMutiImage.Dispose();
                        ho__ImgMeanPart.Dispose();
                        ho_ImageScaled1.Dispose();
                        ho__ImgLight.Dispose();
                        ho__ImgDark.Dispose();
                        ho__ImgMeanByte.Dispose();
                        ho__ImgMeanLight.Dispose();
                        ho__ImgMeanDark.Dispose();
                        ho__ImgCount.Dispose();
                        ho__ImgCountPart.Dispose();
                        ho__ImgLightPart.Dispose();
                        ho__ImgDarkPart.Dispose();
                        ho__ImgMeanLightPart.Dispose();
                        ho__ImgMeanDarkPart.Dispose();
                        ho_ObjectSelected.Dispose();
                        ho_ImageReduced1.Dispose();
                        ho__LightReg.Dispose();
                        ho__DarkReg.Dispose();
                        ho_RegionUnion00.Dispose();
                        ho__MeanLightReg.Dispose();
                        ho__MeanDarkReg.Dispose();
                        ho_RegionUnion01.Dispose();
                        ho_RegionUnion.Dispose();
                        ho_ConnectedRegions.Dispose();
                        ho_RegionSelect.Dispose();
                        ho_RegionUnionSelect.Dispose();
                        ho_RegionDilation1.Dispose();
                        ho_BinImage1.Dispose();
                        ho_ImageConverted3.Dispose();
                        ho_ImageConverted4.Dispose();
                        ho_ImageResult6.Dispose();
                        ho_ImageResult4.Dispose();
                        ho__ImgCountReg.Dispose();
                        ho_BinImage2.Dispose();
                        ho_ImageBin01.Dispose();
                        ho__ImgCountNew.Dispose();
                        ho_BinImage3.Dispose();
                        ho_ImageBin10.Dispose();
                        ho__ImgMeanReduced.Dispose();
                        ho__ImgMean2Reduced.Dispose();
                        ho__ImgMeanTmp.Dispose();
                        ho__Img2MeanTmp.Dispose();
                        ho__ImgDevNew.Dispose();
                        ho__ImgMeanAll.Dispose();
                        ho__ImgStdAll.Dispose();
                        hvec__ImgArrVec.Dispose();

                        return;
                    }
                    if (hv__TrainSetNum == null)
                        hv__TrainSetNum = new HTuple();
                    hv__TrainSetNum[0] = hv__Sum;
                    ho__ImgArr.Dispose();
                    HOperatorSet.GenEmptyObj(out ho__ImgArr);
                    //HTV_gen_image_type_recipe (Image, _ImgSumTemp, 'real')
                    //HTV_gen_image_type_recipe (Image, _Img2SumTemp, 'real')
                    ho__ImgSumTemp.Dispose();
                    HOperatorSet.GenImageConst(out ho__ImgSumTemp, "real", hv_Width, hv_Height);
                    ho__Img2SumTemp.Dispose();
                    HOperatorSet.GenImageConst(out ho__Img2SumTemp, "real", hv_Width, hv_Height);
                    HTuple end_val157 = hv__DieNum - 1;
                    HTuple step_val157 = 1;
                    for (hv_i = 0; hv_i.Continue(end_val157, step_val157); hv_i = hv_i.TupleAdd(step_val157))
                    {
                        ho__ImgSum.Dispose();
                        HOperatorSet.SelectObj(ho__ImgSumArr, out ho__ImgSum, hv_i + 1);
                        ho__Img2Sum.Dispose();
                        HOperatorSet.SelectObj(ho__Img2SumArr, out ho__Img2Sum, hv_i + 1);
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.AddImage(ho__ImgSumTemp, ho__ImgSum, out ExpTmpOutVar_0, 1.0,
                                0);
                            ho__ImgSumTemp.Dispose();
                            ho__ImgSumTemp = ExpTmpOutVar_0;
                        }
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.AddImage(ho__Img2SumTemp, ho__Img2Sum, out ExpTmpOutVar_0,
                                1.0, 0);
                            ho__Img2SumTemp.Dispose();
                            ho__Img2SumTemp = ExpTmpOutVar_0;
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(ho__ImgArr, hvec__ImgArrVec[hv_i].O, out ExpTmpOutVar_0
                                );
                            ho__ImgArr.Dispose();
                            ho__ImgArr = ExpTmpOutVar_0;
                        }
                    }
                    ho__ImgSumArr.Dispose();
                    HOperatorSet.CopyObj(ho__ImgSumTemp, out ho__ImgSumArr, 1, 1);
                    ho__Img2SumArr.Dispose();
                    HOperatorSet.CopyObj(ho__Img2SumTemp, out ho__Img2SumArr, 1, 1);
                    hvec__ImgArrVec[0] = new HObjectVector(ho__ImgArr.CopyObj(1, -1));
                    hv__ModelNum = 1;
                }
                //生成黄金模板图像o_MeanImage和o_StdImage
                HTuple end_val170 = hv__ModelNum - 1;
                HTuple step_val170 = 1;
                for (hv_i = 0; hv_i.Continue(end_val170, step_val170); hv_i = hv_i.TupleAdd(step_val170))
                {
                    if ((int)(new HTuple(((hv__TrainSetNum.TupleSelect(hv_i))).TupleLess(hv_i_MinTrainSet))) != 0)
                    {
                        hv_o_ErrCode = -1;
                        hv_o_ErrString = "Training set not enough";
                        ho_OriImgs.Dispose();
                        ho_IcGoldenImg.Dispose();
                        ho_FindIcImg.Dispose();
                        ho_Image.Dispose();
                        ho_Image1.Dispose();
                        ho_ChannelImage1.Dispose();
                        ho__ImgSumArr.Dispose();
                        ho__Img2SumArr.Dispose();
                        ho_curROI.Dispose();
                        ho__ImgSum.Dispose();
                        ho__Img2Sum.Dispose();
                        ho__ImgSumPart.Dispose();
                        ho__Img2SumPart.Dispose();
                        ho__ImgArr.Dispose();
                        ho_OriImg.Dispose();
                        ho_Imgs.Dispose();
                        ho_curMatchReg.Dispose();
                        ho__InspectReg.Dispose();
                        ho__MatchReg.Dispose();
                        ho__SearchReg.Dispose();
                        ho_ImageReduced.Dispose();
                        ho_ImageAffinTrans.Dispose();
                        ho__goldenImage.Dispose();
                        ho__goldenImagePart.Dispose();
                        ho_ImageConvertedPart.Dispose();
                        ho_ImageResultPart.Dispose();
                        ho_MutiImage.Dispose();
                        ho__ImgSumTemp.Dispose();
                        ho__Img2SumTemp.Dispose();
                        ho__ImgMean.Dispose();
                        ho__Img2Mean.Dispose();
                        ho_ImageResult1.Dispose();
                        ho__ImgDev.Dispose();
                        ho__ImgStd.Dispose();
                        ho_RankImg.Dispose();
                        ho_NewMutiImage.Dispose();
                        ho__ImgMeanPart.Dispose();
                        ho_ImageScaled1.Dispose();
                        ho__ImgLight.Dispose();
                        ho__ImgDark.Dispose();
                        ho__ImgMeanByte.Dispose();
                        ho__ImgMeanLight.Dispose();
                        ho__ImgMeanDark.Dispose();
                        ho__ImgCount.Dispose();
                        ho__ImgCountPart.Dispose();
                        ho__ImgLightPart.Dispose();
                        ho__ImgDarkPart.Dispose();
                        ho__ImgMeanLightPart.Dispose();
                        ho__ImgMeanDarkPart.Dispose();
                        ho_ObjectSelected.Dispose();
                        ho_ImageReduced1.Dispose();
                        ho__LightReg.Dispose();
                        ho__DarkReg.Dispose();
                        ho_RegionUnion00.Dispose();
                        ho__MeanLightReg.Dispose();
                        ho__MeanDarkReg.Dispose();
                        ho_RegionUnion01.Dispose();
                        ho_RegionUnion.Dispose();
                        ho_ConnectedRegions.Dispose();
                        ho_RegionSelect.Dispose();
                        ho_RegionUnionSelect.Dispose();
                        ho_RegionDilation1.Dispose();
                        ho_BinImage1.Dispose();
                        ho_ImageConverted3.Dispose();
                        ho_ImageConverted4.Dispose();
                        ho_ImageResult6.Dispose();
                        ho_ImageResult4.Dispose();
                        ho__ImgCountReg.Dispose();
                        ho_BinImage2.Dispose();
                        ho_ImageBin01.Dispose();
                        ho__ImgCountNew.Dispose();
                        ho_BinImage3.Dispose();
                        ho_ImageBin10.Dispose();
                        ho__ImgMeanReduced.Dispose();
                        ho__ImgMean2Reduced.Dispose();
                        ho__ImgMeanTmp.Dispose();
                        ho__Img2MeanTmp.Dispose();
                        ho__ImgDevNew.Dispose();
                        ho__ImgMeanAll.Dispose();
                        ho__ImgStdAll.Dispose();
                        hvec__ImgArrVec.Dispose();

                        return;
                    }
                    ho__ImgSum.Dispose();
                    HOperatorSet.SelectObj(ho__ImgSumArr, out ho__ImgSum, hv_i + 1);
                    ho__Img2Sum.Dispose();
                    HOperatorSet.SelectObj(ho__Img2SumArr, out ho__Img2Sum, hv_i + 1);
                    ho__ImgMean.Dispose();
                    HOperatorSet.ScaleImage(ho__ImgSum, out ho__ImgMean, 1.0 / (hv__TrainSetNum.TupleSelect(
                        hv_i)), 0);
                    ho__Img2Mean.Dispose();
                    HOperatorSet.ScaleImage(ho__Img2Sum, out ho__Img2Mean, 1.0 / (hv__TrainSetNum.TupleSelect(
                        hv_i)), 0);
                    ho_ImageResult1.Dispose();
                    HOperatorSet.MultImage(ho__ImgMean, ho__ImgMean, out ho_ImageResult1, 1.0,
                        0);
                    ho__ImgDev.Dispose();
                    HOperatorSet.SubImage(ho__Img2Mean, ho_ImageResult1, out ho__ImgDev, 1.0,
                        0);
                    ho__ImgStd.Dispose();
                    HOperatorSet.SqrtImage(ho__ImgDev, out ho__ImgStd);
                    if ((int)(hv_i_IsRefine) != 0)
                    {
                        //采用rank_n计算的均值图
                        //去掉最暗和最亮的求均值图
                        HOperatorSet.CountChannels(ho_MutiImage, out hv_ImgNum);
                        HTuple end_val187 = hv_ImgNum - 3;
                        HTuple step_val187 = 1;
                        for (hv_idx = 2; hv_idx.Continue(end_val187, step_val187); hv_idx = hv_idx.TupleAdd(step_val187))
                        {
                            ho_RankImg.Dispose();
                            HOperatorSet.RankN(ho_MutiImage, out ho_RankImg, hv_idx + 1);
                            if ((int)(new HTuple(hv_idx.TupleLess(3))) != 0)
                            {
                                ho_NewMutiImage.Dispose();
                                HOperatorSet.CopyObj(ho_RankImg, out ho_NewMutiImage, 1, 1);
                            }
                            else
                            {
                                {
                                    HObject ExpTmpOutVar_0;
                                    HOperatorSet.AppendChannel(ho_NewMutiImage, ho_RankImg, out ExpTmpOutVar_0
                                        );
                                    ho_NewMutiImage.Dispose();
                                    ho_NewMutiImage = ExpTmpOutVar_0;
                                }
                            }
                        }

                        ho__ImgMeanPart.Dispose();
                        HOperatorSet.MeanN(ho_NewMutiImage, out ho__ImgMeanPart);
                        ho__ImgMean.Dispose();
                        HOperatorSet.TileImagesOffset(ho__ImgMeanPart, out ho__ImgMean, hv_LtRow,
                            hv_LtColumn, -1, -1, -1, -1, hv_Width, hv_Height);
                        //精炼
                        ho_ImageScaled1.Dispose();
                        HOperatorSet.ScaleImage(ho__ImgStd, out ho_ImageScaled1, hv_i_RefineThresh,
                            0);
                        ho__ImgLight.Dispose();
                        HOperatorSet.AddImage(ho__ImgMean, ho_ImageScaled1, out ho__ImgLight, 1.0,
                            0);
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConvertImageType(ho__ImgLight, out ExpTmpOutVar_0, "byte");
                            ho__ImgLight.Dispose();
                            ho__ImgLight = ExpTmpOutVar_0;
                        }
                        ho__ImgDark.Dispose();
                        HOperatorSet.SubImage(ho__ImgMean, ho_ImageScaled1, out ho__ImgDark, 1.0,
                            0);
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConvertImageType(ho__ImgDark, out ExpTmpOutVar_0, "byte");
                            ho__ImgDark.Dispose();
                            ho__ImgDark = ExpTmpOutVar_0;
                        }
                        //增加均值图的正负0.5倍灰度亮暗图过滤
                        ho__ImgMeanByte.Dispose();
                        HOperatorSet.ConvertImageType(ho__ImgMean, out ho__ImgMeanByte, "byte");
                        ho__ImgMeanLight.Dispose();
                        HOperatorSet.ScaleImage(ho__ImgMeanByte, out ho__ImgMeanLight, 1.5, 0);
                        ho__ImgMeanDark.Dispose();
                        HOperatorSet.ScaleImage(ho__ImgMeanByte, out ho__ImgMeanDark, 0.5, 0);
                        //HTV_gen_image_type_recipe (Image, _ImgCount, 'real')
                        //HTV_gen_image_type_recipe (Image, _ImgSum, 'real')
                        //HTV_gen_image_type_recipe (Image, _Img2Sum, 'real')
                        //局部图操作
                        ho__ImgCountPart.Dispose();
                        HOperatorSet.GenImageConst(out ho__ImgCountPart, "real", hv_WidthPart,
                            hv_HeightPart);
                        ho__ImgSumPart.Dispose();
                        HOperatorSet.GenImageConst(out ho__ImgSumPart, "real", hv_WidthPart, hv_HeightPart);
                        ho__Img2SumPart.Dispose();
                        HOperatorSet.GenImageConst(out ho__Img2SumPart, "real", hv_WidthPart, hv_HeightPart);
                        ho__ImgLightPart.Dispose();
                        HOperatorSet.CropRectangle1(ho__ImgLight, out ho__ImgLightPart, hv_LtRow,
                            hv_LtColumn, hv_RbRow, hv_RbColumn);
                        ho__ImgDarkPart.Dispose();
                        HOperatorSet.CropRectangle1(ho__ImgDark, out ho__ImgDarkPart, hv_LtRow,
                            hv_LtColumn, hv_RbRow, hv_RbColumn);
                        ho__ImgMeanLightPart.Dispose();
                        HOperatorSet.CropRectangle1(ho__ImgMeanLight, out ho__ImgMeanLightPart,
                            hv_LtRow, hv_LtColumn, hv_RbRow, hv_RbColumn);
                        ho__ImgMeanDarkPart.Dispose();
                        HOperatorSet.CropRectangle1(ho__ImgMeanDark, out ho__ImgMeanDarkPart, hv_LtRow,
                            hv_LtColumn, hv_RbRow, hv_RbColumn);
                        ho__ImgArr.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho__ImgArr = hvec__ImgArrVec[hv_i].O.CopyObj(1, -1);
                        }
                        HTuple end_val220 = hv__TrainSetNum.TupleSelect(
                            hv_i);
                        HTuple step_val220 = 1;
                        for (hv_j = 1; hv_j.Continue(end_val220, step_val220); hv_j = hv_j.TupleAdd(step_val220))
                        {
                            ho_ObjectSelected.Dispose();
                            HOperatorSet.SelectObj(ho__ImgArr, out ho_ObjectSelected, hv_j);
                            //局部图计算，优化效率
                            ho_ImageReduced1.Dispose();
                            HOperatorSet.CropRectangle1(ho_ObjectSelected, out ho_ImageReduced1,
                                hv_LtRow, hv_LtColumn, hv_RbRow, hv_RbColumn);
                            ho__LightReg.Dispose();
                            HOperatorSet.DynThreshold(ho_ImageReduced1, ho__ImgLightPart, out ho__LightReg,
                                1, "light");
                            ho__DarkReg.Dispose();
                            HOperatorSet.DynThreshold(ho_ImageReduced1, ho__ImgDarkPart, out ho__DarkReg,
                                1, "dark");
                            ho_RegionUnion00.Dispose();
                            HOperatorSet.Union2(ho__LightReg, ho__DarkReg, out ho_RegionUnion00);
                            //增加均值图的正负0.5倍灰度亮暗图过滤
                            ho__MeanLightReg.Dispose();
                            HOperatorSet.DynThreshold(ho_ImageReduced1, ho__ImgMeanLightPart, out ho__MeanLightReg,
                                1, "light");
                            ho__MeanDarkReg.Dispose();
                            HOperatorSet.DynThreshold(ho_ImageReduced1, ho__ImgMeanDarkPart, out ho__MeanDarkReg,
                                1, "dark");
                            ho_RegionUnion01.Dispose();
                            HOperatorSet.Union2(ho__MeanLightReg, ho__MeanDarkReg, out ho_RegionUnion01
                                );
                            ho_RegionUnion.Dispose();
                            HOperatorSet.Union2(ho_RegionUnion00, ho_RegionUnion01, out ho_RegionUnion
                                );
                            //此处去除单像素区域
                            ho_ConnectedRegions.Dispose();
                            HOperatorSet.Connection(ho_RegionUnion, out ho_ConnectedRegions);
                            ho_RegionSelect.Dispose();
                            HOperatorSet.SelectShape(ho_ConnectedRegions, out ho_RegionSelect, "area",
                                "and", 2, 9999);
                            HOperatorSet.CountObj(ho_RegionSelect, out hv_Number);
                            if ((int)(hv_Number) != 0)
                            {
                                ho_RegionUnionSelect.Dispose();
                                HOperatorSet.Union1(ho_RegionSelect, out ho_RegionUnionSelect);
                                ho_RegionDilation1.Dispose();
                                HOperatorSet.DilationCircle(ho_RegionUnionSelect, out ho_RegionDilation1,
                                    3.5);
                            }
                            else
                            {
                                ho_RegionDilation1.Dispose();
                                HOperatorSet.GenEmptyRegion(out ho_RegionDilation1);
                            }
                            //生成一个前景为0，背景为1的图，这样与原图相乘之后，前景区域部分就没有了
                            ho_BinImage1.Dispose();
                            HOperatorSet.RegionToBin(ho_RegionDilation1, out ho_BinImage1, 0, 1,
                                hv_WidthPart, hv_HeightPart);
                            ho_ImageConverted3.Dispose();
                            HOperatorSet.ConvertImageType(ho_BinImage1, out ho_ImageConverted3, "real");
                            ho_ImageConverted4.Dispose();
                            HOperatorSet.ConvertImageType(ho_ImageReduced1, out ho_ImageConverted4,
                                "real");
                            ho_ImageResult6.Dispose();
                            HOperatorSet.MultImage(ho_ImageConverted3, ho_ImageConverted4, out ho_ImageResult6,
                                1.0, 0);
                            //符合条件图片数统计
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.AddImage(ho__ImgSumPart, ho_ImageResult6, out ExpTmpOutVar_0,
                                    1.0, 0);
                                ho__ImgSumPart.Dispose();
                                ho__ImgSumPart = ExpTmpOutVar_0;
                            }
                            ho_ImageResult4.Dispose();
                            HOperatorSet.MultImage(ho_ImageResult6, ho_ImageResult6, out ho_ImageResult4,
                                1.0, 0);
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.AddImage(ho__Img2SumPart, ho_ImageResult4, out ExpTmpOutVar_0,
                                    1.0, 0);
                                ho__Img2SumPart.Dispose();
                                ho__Img2SumPart = ExpTmpOutVar_0;
                            }
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.AddImage(ho__ImgCountPart, ho_ImageConverted3, out ExpTmpOutVar_0,
                                    1.0, 0);
                                ho__ImgCountPart.Dispose();
                                ho__ImgCountPart = ExpTmpOutVar_0;
                            }
                            //大图计算
                            //reduce_domain (ObjectSelected, i_InspectRegs, ImageReduced1)
                            //dyn_threshold (ImageReduced1, _ImgLight, _LightReg, 1, 'light')
                            //dyn_threshold (ImageReduced1, _ImgDark, _DarkReg, 1, 'dark')
                            //union2 (_LightReg, _DarkReg, RegionUnion00)
                            //增加均值图的正负0.5倍灰度亮暗图过滤
                            //dyn_threshold (ImageReduced1, _ImgMeanLight, _MeanLightReg, 1, 'light')
                            //dyn_threshold (ImageReduced1, _ImgMeanDark, _MeanDarkReg, 1, 'dark')
                            //union2 (_MeanLightReg, _MeanDarkReg, RegionUnion01)
                            //union2 (RegionUnion00, RegionUnion01, RegionUnion)
                            //dilation_circle (RegionUnion, RegionDilation1, 3.5)
                            //生成一个前景为0，背景为1的图，这样与原图相乘之后，前景区域部分就没有了
                            //region_to_bin (RegionDilation1, BinImage1, 0, 1, Width, Height)
                            //convert_image_type (BinImage1, ImageConverted3, 'real')
                            //convert_image_type (ImageReduced1, ImageConverted4, 'real')
                            //mult_image (ImageConverted3, ImageConverted4, ImageResult6, 1.0, 0)
                            //符合条件图片数统计
                            //add_image (_ImgSum, ImageResult6, _ImgSum, 1.0, 0)
                            //mult_image (ImageResult6, ImageResult6, ImageResult4, 1.0, 0)
                            //add_image (_Img2Sum, ImageResult4, _Img2Sum, 1.0, 0)
                            //add_image (_ImgCount, ImageConverted3, _ImgCount, 1.0, 0)
                        }
                        //还原坐标
                        ho__ImgSum.Dispose();
                        HOperatorSet.TileImagesOffset(ho__ImgSumPart, out ho__ImgSum, hv_LtRow,
                            hv_LtColumn, -1, -1, -1, -1, hv_Width, hv_Height);
                        ho__Img2Sum.Dispose();
                        HOperatorSet.TileImagesOffset(ho__Img2SumPart, out ho__Img2Sum, hv_LtRow,
                            hv_LtColumn, -1, -1, -1, -1, hv_Width, hv_Height);
                        ho__ImgCount.Dispose();
                        HOperatorSet.TileImagesOffset(ho__ImgCountPart, out ho__ImgCount, hv_LtRow,
                            hv_LtColumn, -1, -1, -1, -1, hv_Width, hv_Height);
                        //符合条件最小图片数
                        HOperatorSet.MinMaxGray(ho_i_InspectRegs, ho__ImgCount, 0, out hv_Min,
                            out hv_Max, out hv_Range);
                        //对于小于MinImgNum的区域仍采用原均值图，只要考虑金线区方差大，过少图片得到的均值方差不具代表性
                        hv_MinImgNum = (hv_Max / 2) + 1;
                        ho__ImgCountReg.Dispose();
                        HOperatorSet.Threshold(ho__ImgCount, out ho__ImgCountReg, 0, hv_MinImgNum);
                        //更新图片数_ImgCount
                        ho_BinImage2.Dispose();
                        HOperatorSet.RegionToBin(ho__ImgCountReg, out ho_BinImage2, 0, 1, hv_Width,
                            hv_Height);
                        ho_ImageBin01.Dispose();
                        HOperatorSet.ConvertImageType(ho_BinImage2, out ho_ImageBin01, "real");
                        ho__ImgCountNew.Dispose();
                        HOperatorSet.MultImage(ho_ImageBin01, ho__ImgCount, out ho__ImgCountNew,
                            1.0, 0);
                        //金线区符合条件的图片数过少，采用原均值和方差
                        ho_BinImage3.Dispose();
                        HOperatorSet.RegionToBin(ho__ImgCountReg, out ho_BinImage3, 1, 0, hv_Width,
                            hv_Height);
                        ho_ImageBin10.Dispose();
                        HOperatorSet.ConvertImageType(ho_BinImage3, out ho_ImageBin10, "real");
                        ho__ImgMeanReduced.Dispose();
                        HOperatorSet.MultImage(ho_ImageBin10, ho__ImgMean, out ho__ImgMeanReduced,
                            1.0, 0);
                        ho__ImgMean2Reduced.Dispose();
                        HOperatorSet.MultImage(ho_ImageBin10, ho__Img2Mean, out ho__ImgMean2Reduced,
                            1.0, 0);
                        //_ImgCount为0的区域结果也为0
                        ho__ImgMeanTmp.Dispose();
                        HOperatorSet.DivImage(ho__ImgSum, ho__ImgCountNew, out ho__ImgMeanTmp,
                            1.0, 0);
                        ho__Img2MeanTmp.Dispose();
                        HOperatorSet.DivImage(ho__Img2Sum, ho__ImgCountNew, out ho__Img2MeanTmp,
                            1.0, 0);
                        ho__ImgMean.Dispose();
                        HOperatorSet.AddImage(ho__ImgMeanReduced, ho__ImgMeanTmp, out ho__ImgMean,
                            1.0, 0);
                        ho__Img2Mean.Dispose();
                        HOperatorSet.AddImage(ho__ImgMean2Reduced, ho__Img2MeanTmp, out ho__Img2Mean,
                            1.0, 0);
                        //更新方差
                        ho_ImageResult1.Dispose();
                        HOperatorSet.MultImage(ho__ImgMean, ho__ImgMean, out ho_ImageResult1, 1.0,
                            0);
                        ho__ImgDevNew.Dispose();
                        HOperatorSet.SubImage(ho__Img2Mean, ho_ImageResult1, out ho__ImgDevNew,
                            1.0, 0);
                        ho__ImgStd.Dispose();
                        HOperatorSet.SqrtImage(ho__ImgDevNew, out ho__ImgStd);
                    }
                    //非检测区为了与大图结果一致，实际上不会计算
                    ho__ImgMeanAll.Dispose();
                    HOperatorSet.GenImageConst(out ho__ImgMeanAll, "real", hv_Width, hv_Height);
                    ho__ImgStdAll.Dispose();
                    HOperatorSet.GenImageConst(out ho__ImgStdAll, "real", hv_Width, hv_Height);
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.PaintGray(ho__ImgMean, ho__ImgMeanAll, out ExpTmpOutVar_0);
                        ho__ImgMeanAll.Dispose();
                        ho__ImgMeanAll = ExpTmpOutVar_0;
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.PaintGray(ho__ImgStd, ho__ImgStdAll, out ExpTmpOutVar_0);
                        ho__ImgStdAll.Dispose();
                        ho__ImgStdAll = ExpTmpOutVar_0;
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_o_MeanImage, ho__ImgMeanAll, out ExpTmpOutVar_0
                            );
                        ho_o_MeanImage.Dispose();
                        //ho_o_MeanImage = ExpTmpOutVar_0;

                        // real转byte图，减少内存 1207 lw
                        HObject MeanImageConverted;
                        HOperatorSet.ConvertImageType(ExpTmpOutVar_0, out MeanImageConverted, "byte");
                        ho_o_MeanImage = MeanImageConverted;
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_o_StdImage, ho__ImgStdAll, out ExpTmpOutVar_0);
                        ho_o_StdImage.Dispose();
                        ho_o_StdImage = ExpTmpOutVar_0;
                    }
                }

                ho_OriImgs.Dispose();
                ho_IcGoldenImg.Dispose();
                ho_FindIcImg.Dispose();
                ho_Image.Dispose();
                ho_Image1.Dispose();
                ho_ChannelImage1.Dispose();
                ho__ImgSumArr.Dispose();
                ho__Img2SumArr.Dispose();
                ho_curROI.Dispose();
                ho__ImgSum.Dispose();
                ho__Img2Sum.Dispose();
                ho__ImgSumPart.Dispose();
                ho__Img2SumPart.Dispose();
                ho__ImgArr.Dispose();
                ho_OriImg.Dispose();
                ho_Imgs.Dispose();
                ho_curMatchReg.Dispose();
                ho__InspectReg.Dispose();
                ho__MatchReg.Dispose();
                ho__SearchReg.Dispose();
                ho_ImageReduced.Dispose();
                ho_ImageAffinTrans.Dispose();
                ho__goldenImage.Dispose();
                ho__goldenImagePart.Dispose();
                ho_ImageConvertedPart.Dispose();
                ho_ImageResultPart.Dispose();
                ho_MutiImage.Dispose();
                ho__ImgSumTemp.Dispose();
                ho__Img2SumTemp.Dispose();
                ho__ImgMean.Dispose();
                ho__Img2Mean.Dispose();
                ho_ImageResult1.Dispose();
                ho__ImgDev.Dispose();
                ho__ImgStd.Dispose();
                ho_RankImg.Dispose();
                ho_NewMutiImage.Dispose();
                ho__ImgMeanPart.Dispose();
                ho_ImageScaled1.Dispose();
                ho__ImgLight.Dispose();
                ho__ImgDark.Dispose();
                ho__ImgMeanByte.Dispose();
                ho__ImgMeanLight.Dispose();
                ho__ImgMeanDark.Dispose();
                ho__ImgCount.Dispose();
                ho__ImgCountPart.Dispose();
                ho__ImgLightPart.Dispose();
                ho__ImgDarkPart.Dispose();
                ho__ImgMeanLightPart.Dispose();
                ho__ImgMeanDarkPart.Dispose();
                ho_ObjectSelected.Dispose();
                ho_ImageReduced1.Dispose();
                ho__LightReg.Dispose();
                ho__DarkReg.Dispose();
                ho_RegionUnion00.Dispose();
                ho__MeanLightReg.Dispose();
                ho__MeanDarkReg.Dispose();
                ho_RegionUnion01.Dispose();
                ho_RegionUnion.Dispose();
                ho_ConnectedRegions.Dispose();
                ho_RegionSelect.Dispose();
                ho_RegionUnionSelect.Dispose();
                ho_RegionDilation1.Dispose();
                ho_BinImage1.Dispose();
                ho_ImageConverted3.Dispose();
                ho_ImageConverted4.Dispose();
                ho_ImageResult6.Dispose();
                ho_ImageResult4.Dispose();
                ho__ImgCountReg.Dispose();
                ho_BinImage2.Dispose();
                ho_ImageBin01.Dispose();
                ho__ImgCountNew.Dispose();
                ho_BinImage3.Dispose();
                ho_ImageBin10.Dispose();
                ho__ImgMeanReduced.Dispose();
                ho__ImgMean2Reduced.Dispose();
                ho__ImgMeanTmp.Dispose();
                ho__Img2MeanTmp.Dispose();
                ho__ImgDevNew.Dispose();
                ho__ImgMeanAll.Dispose();
                ho__ImgStdAll.Dispose();
                hvec__ImgArrVec.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_OriImgs.Dispose();
                ho_IcGoldenImg.Dispose();
                ho_FindIcImg.Dispose();
                ho_Image.Dispose();
                ho_Image1.Dispose();
                ho_ChannelImage1.Dispose();
                ho__ImgSumArr.Dispose();
                ho__Img2SumArr.Dispose();
                ho_curROI.Dispose();
                ho__ImgSum.Dispose();
                ho__Img2Sum.Dispose();
                ho__ImgSumPart.Dispose();
                ho__Img2SumPart.Dispose();
                ho__ImgArr.Dispose();
                ho_OriImg.Dispose();
                ho_Imgs.Dispose();
                ho_curMatchReg.Dispose();
                ho__InspectReg.Dispose();
                ho__MatchReg.Dispose();
                ho__SearchReg.Dispose();
                ho_ImageReduced.Dispose();
                ho_ImageAffinTrans.Dispose();
                ho__goldenImage.Dispose();
                ho__goldenImagePart.Dispose();
                ho_ImageConvertedPart.Dispose();
                ho_ImageResultPart.Dispose();
                ho_MutiImage.Dispose();
                ho__ImgSumTemp.Dispose();
                ho__Img2SumTemp.Dispose();
                ho__ImgMean.Dispose();
                ho__Img2Mean.Dispose();
                ho_ImageResult1.Dispose();
                ho__ImgDev.Dispose();
                ho__ImgStd.Dispose();
                ho_RankImg.Dispose();
                ho_NewMutiImage.Dispose();
                ho__ImgMeanPart.Dispose();
                ho_ImageScaled1.Dispose();
                ho__ImgLight.Dispose();
                ho__ImgDark.Dispose();
                ho__ImgMeanByte.Dispose();
                ho__ImgMeanLight.Dispose();
                ho__ImgMeanDark.Dispose();
                ho__ImgCount.Dispose();
                ho__ImgCountPart.Dispose();
                ho__ImgLightPart.Dispose();
                ho__ImgDarkPart.Dispose();
                ho__ImgMeanLightPart.Dispose();
                ho__ImgMeanDarkPart.Dispose();
                ho_ObjectSelected.Dispose();
                ho_ImageReduced1.Dispose();
                ho__LightReg.Dispose();
                ho__DarkReg.Dispose();
                ho_RegionUnion00.Dispose();
                ho__MeanLightReg.Dispose();
                ho__MeanDarkReg.Dispose();
                ho_RegionUnion01.Dispose();
                ho_RegionUnion.Dispose();
                ho_ConnectedRegions.Dispose();
                ho_RegionSelect.Dispose();
                ho_RegionUnionSelect.Dispose();
                ho_RegionDilation1.Dispose();
                ho_BinImage1.Dispose();
                ho_ImageConverted3.Dispose();
                ho_ImageConverted4.Dispose();
                ho_ImageResult6.Dispose();
                ho_ImageResult4.Dispose();
                ho__ImgCountReg.Dispose();
                ho_BinImage2.Dispose();
                ho_ImageBin01.Dispose();
                ho__ImgCountNew.Dispose();
                ho_BinImage3.Dispose();
                ho_ImageBin10.Dispose();
                ho__ImgMeanReduced.Dispose();
                ho__ImgMean2Reduced.Dispose();
                ho__ImgMeanTmp.Dispose();
                ho__Img2MeanTmp.Dispose();
                ho__ImgDevNew.Dispose();
                ho__ImgMeanAll.Dispose();
                ho__ImgStdAll.Dispose();
                hvec__ImgArrVec.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public static void HTV_CreateGoldenImage(HObject ho_i_MeanImage, HObject ho_i_StdImage,
            HObject ho_i_InspectRegs, HObject ho_i_SubRegs, out HObject ho_o_LightImage,
            out HObject ho_o_DarkImage, HTuple hv_i_LightFactor, HTuple hv_i_DarkFactor,
            HTuple hv_i_SobelFactor, out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 
            HObject ho_MeanImage;
            HObject ho_RegionDifference, ho_usualReg;
            HObject ho_AllRegs, ho_EdgeAmplitude, ho__ImgDark, ho__ImgLight;
            HObject ho_curReg = null, ho_ImageScaled = null, ho__NewStd = null;
            HObject ho_ImageScaled_D = null, ho_ImageSub_D = null, ho__sub_dark_thresh_image = null;
            HObject ho_ImageScaled_L = null, ho_ImageSub_L = null, ho__sub_light_thresh_image = null;
            HObject ho_dark_image_reduce = null, ho_light_image_reduce = null;

            // Local control variables 

            HTuple hv__stdNum = null, hv_meanNum = null;
            HTuple hv_regNum = null, hv_subNum = null, hv_factorNum1 = null;
            HTuple hv_factorNum2 = null, hv_factorNum3 = null, hv_num = new HTuple();
            HTuple hv_tmpTup = new HTuple(), hv_allNum = null, hv_idxReg = null;
            HTuple hv_i_DarkFactor_COPY_INP_TMP = hv_i_DarkFactor.Clone();
            HTuple hv_i_LightFactor_COPY_INP_TMP = hv_i_LightFactor.Clone();
            HTuple hv_i_SobelFactor_COPY_INP_TMP = hv_i_SobelFactor.Clone();

            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_LightImage);
            HOperatorSet.GenEmptyObj(out ho_o_DarkImage);
            HOperatorSet.GenEmptyObj(out ho_RegionDifference);
            HOperatorSet.GenEmptyObj(out ho_usualReg);
            HOperatorSet.GenEmptyObj(out ho_AllRegs);
            HOperatorSet.GenEmptyObj(out ho_EdgeAmplitude);
            HOperatorSet.GenEmptyObj(out ho__ImgDark);
            HOperatorSet.GenEmptyObj(out ho__ImgLight);
            HOperatorSet.GenEmptyObj(out ho_curReg);
            HOperatorSet.GenEmptyObj(out ho_ImageScaled);
            HOperatorSet.GenEmptyObj(out ho__NewStd);
            HOperatorSet.GenEmptyObj(out ho_ImageScaled_D);
            HOperatorSet.GenEmptyObj(out ho_ImageSub_D);
            HOperatorSet.GenEmptyObj(out ho__sub_dark_thresh_image);
            HOperatorSet.GenEmptyObj(out ho_ImageScaled_L);
            HOperatorSet.GenEmptyObj(out ho_ImageSub_L);
            HOperatorSet.GenEmptyObj(out ho__sub_light_thresh_image);
            HOperatorSet.GenEmptyObj(out ho_dark_image_reduce);
            HOperatorSet.GenEmptyObj(out ho_light_image_reduce);
            //**********   针对一个匹配模板生成黄金模板所需的均值图像和方差图像
            //i_MeanImage: 均值图像
            //i_StdImage： 方差图像
            //i_InspectRegs: 检测区域，允许一个检测区域
            //i_SubRegs： 重点检测区域，允许多个重点检测区域
            //o_LightImage: 黄金模板亮图像
            //o_DarkImage：黄金模板暗图像
            //i_LightFactor：生成亮图像的比例系数，为一个数组，非重点检测区系数在前，重点检测区系数在后，至少应该有一个数值
            //i_DarkFactor：生成暗图像的比例系数，为一个数组，非重点检测区系数在前，重点检测区系数在后，至少应该有一个数值
            //i_SobelFactor：用于调节方差图像的边缘比例系数，为一个数组，非重点检测区系数在前，重点检测区系数在后，至少应该有一个数值
            //o_ErrCode: 错误码，代表该算子执行过程中产生的错误，0-代表正常执行，自然数-代表错误类型，-1-代表异常，-2-代表未执行
            //o_ErrStr: 错误信息，对各种错误的具体描述

            //初始化
            ho_o_LightImage.Dispose();
            HOperatorSet.GenEmptyObj(out ho_o_LightImage);
            ho_o_DarkImage.Dispose();
            HOperatorSet.GenEmptyObj(out ho_o_DarkImage);
            hv_o_ErrCode = -2;
            hv_o_ErrStr = "initializing";

            //输入有效性测试
            //方差图像
            HOperatorSet.CountObj(ho_i_StdImage, out hv__stdNum);
            if ((int)(new HTuple(hv__stdNum.TupleEqual(0))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "std image is null";
                ho_RegionDifference.Dispose();
                ho_usualReg.Dispose();
                ho_AllRegs.Dispose();
                ho_EdgeAmplitude.Dispose();
                ho__ImgDark.Dispose();
                ho__ImgLight.Dispose();
                ho_curReg.Dispose();
                ho_ImageScaled.Dispose();
                ho__NewStd.Dispose();
                ho_ImageScaled_D.Dispose();
                ho_ImageSub_D.Dispose();
                ho__sub_dark_thresh_image.Dispose();
                ho_ImageScaled_L.Dispose();
                ho_ImageSub_L.Dispose();
                ho__sub_light_thresh_image.Dispose();
                ho_dark_image_reduce.Dispose();
                ho_light_image_reduce.Dispose();

                return;
            }
            //均值图像
            HOperatorSet.CountObj(ho_i_MeanImage, out hv_meanNum);
            if ((int)(new HTuple(hv_meanNum.TupleEqual(0))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "mean image is null";
                ho_RegionDifference.Dispose();
                ho_usualReg.Dispose();
                ho_AllRegs.Dispose();
                ho_EdgeAmplitude.Dispose();
                ho__ImgDark.Dispose();
                ho__ImgLight.Dispose();
                ho_curReg.Dispose();
                ho_ImageScaled.Dispose();
                ho__NewStd.Dispose();
                ho_ImageScaled_D.Dispose();
                ho_ImageSub_D.Dispose();
                ho__sub_dark_thresh_image.Dispose();
                ho_ImageScaled_L.Dispose();
                ho_ImageSub_L.Dispose();
                ho__sub_light_thresh_image.Dispose();
                ho_dark_image_reduce.Dispose();
                ho_light_image_reduce.Dispose();

                return;
            }
            //检测区域
            HOperatorSet.CountObj(ho_i_InspectRegs, out hv_regNum);
            if ((int)(new HTuple(hv_regNum.TupleEqual(0))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "inspect regions is null";
                ho_RegionDifference.Dispose();
                ho_usualReg.Dispose();
                ho_AllRegs.Dispose();
                ho_EdgeAmplitude.Dispose();
                ho__ImgDark.Dispose();
                ho__ImgLight.Dispose();
                ho_curReg.Dispose();
                ho_ImageScaled.Dispose();
                ho__NewStd.Dispose();
                ho_ImageScaled_D.Dispose();
                ho_ImageSub_D.Dispose();
                ho__sub_dark_thresh_image.Dispose();
                ho_ImageScaled_L.Dispose();
                ho_ImageSub_L.Dispose();
                ho__sub_light_thresh_image.Dispose();
                ho_dark_image_reduce.Dispose();
                ho_light_image_reduce.Dispose();

                return;
            }
            HOperatorSet.CountObj(ho_i_SubRegs, out hv_subNum);
            //参数
            hv_factorNum1 = new HTuple(hv_i_LightFactor_COPY_INP_TMP.TupleLength());
            if ((int)(new HTuple(hv_factorNum1.TupleEqual(0))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "para i_LightFactor is illegal";
                ho_RegionDifference.Dispose();
                ho_usualReg.Dispose();
                ho_AllRegs.Dispose();
                ho_EdgeAmplitude.Dispose();
                ho__ImgDark.Dispose();
                ho__ImgLight.Dispose();
                ho_curReg.Dispose();
                ho_ImageScaled.Dispose();
                ho__NewStd.Dispose();
                ho_ImageScaled_D.Dispose();
                ho_ImageSub_D.Dispose();
                ho__sub_dark_thresh_image.Dispose();
                ho_ImageScaled_L.Dispose();
                ho_ImageSub_L.Dispose();
                ho__sub_light_thresh_image.Dispose();
                ho_dark_image_reduce.Dispose();
                ho_light_image_reduce.Dispose();

                return;
            }
            hv_factorNum2 = new HTuple(hv_i_DarkFactor_COPY_INP_TMP.TupleLength());
            if ((int)(new HTuple(hv_factorNum2.TupleEqual(0))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "para i_DarkFactor is illegal";
                ho_RegionDifference.Dispose();
                ho_usualReg.Dispose();
                ho_AllRegs.Dispose();
                ho_EdgeAmplitude.Dispose();
                ho__ImgDark.Dispose();
                ho__ImgLight.Dispose();
                ho_curReg.Dispose();
                ho_ImageScaled.Dispose();
                ho__NewStd.Dispose();
                ho_ImageScaled_D.Dispose();
                ho_ImageSub_D.Dispose();
                ho__sub_dark_thresh_image.Dispose();
                ho_ImageScaled_L.Dispose();
                ho_ImageSub_L.Dispose();
                ho__sub_light_thresh_image.Dispose();
                ho_dark_image_reduce.Dispose();
                ho_light_image_reduce.Dispose();

                return;
            }
            hv_factorNum3 = new HTuple(hv_i_SobelFactor_COPY_INP_TMP.TupleLength());
            if ((int)(new HTuple(hv_factorNum3.TupleEqual(0))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "para i_SobelFactor is illegal";
                ho_RegionDifference.Dispose();
                ho_usualReg.Dispose();
                ho_AllRegs.Dispose();
                ho_EdgeAmplitude.Dispose();
                ho__ImgDark.Dispose();
                ho__ImgLight.Dispose();
                ho_curReg.Dispose();
                ho_ImageScaled.Dispose();
                ho__NewStd.Dispose();
                ho_ImageScaled_D.Dispose();
                ho_ImageSub_D.Dispose();
                ho__sub_dark_thresh_image.Dispose();
                ho_ImageScaled_L.Dispose();
                ho_ImageSub_L.Dispose();
                ho__sub_light_thresh_image.Dispose();
                ho_dark_image_reduce.Dispose();
                ho_light_image_reduce.Dispose();

                return;
            }
            //确定每个区域的参数,每个重点检测区和非重点检测区分别调用各自的参数
            if ((int)(new HTuple(hv_factorNum1.TupleLess(hv_subNum + 1))) != 0)
            {
                hv_num = (hv_subNum + 1) - hv_factorNum1;
                HOperatorSet.TupleGenConst(hv_num, hv_i_LightFactor_COPY_INP_TMP.TupleSelect(
                    hv_factorNum1 - 1), out hv_tmpTup);
                hv_i_LightFactor_COPY_INP_TMP = hv_i_LightFactor_COPY_INP_TMP.TupleConcat(hv_tmpTup);
            }
            if ((int)(new HTuple(hv_factorNum2.TupleLess(hv_subNum + 1))) != 0)
            {
                hv_num = (hv_subNum + 1) - hv_factorNum2;
                HOperatorSet.TupleGenConst(hv_num, hv_i_DarkFactor_COPY_INP_TMP.TupleSelect(
                    hv_factorNum2 - 1), out hv_tmpTup);
                hv_i_DarkFactor_COPY_INP_TMP = hv_i_DarkFactor_COPY_INP_TMP.TupleConcat(hv_tmpTup);
            }
            if ((int)(new HTuple(hv_factorNum3.TupleLess(hv_subNum + 1))) != 0)
            {
                hv_num = (hv_subNum + 1) - hv_factorNum3;
                HOperatorSet.TupleGenConst(hv_num, hv_i_SobelFactor_COPY_INP_TMP.TupleSelect(
                    hv_factorNum3 - 1), out hv_tmpTup);
                hv_i_SobelFactor_COPY_INP_TMP = hv_i_SobelFactor_COPY_INP_TMP.TupleConcat(hv_tmpTup);
            }

            //区分重点检测区和非重点检测区，未指定重点检测区，则整个检测区都作为非重点检测区
            //非重点检测区
            ho_RegionDifference.Dispose();
            HOperatorSet.Difference(ho_i_InspectRegs, ho_i_SubRegs, out ho_RegionDifference
                );
            ho_usualReg.Dispose();
            HOperatorSet.Union1(ho_RegionDifference, out ho_usualReg);
            //所有检测区域，非重点检测区在前，重点检测区在后
            ho_AllRegs.Dispose();
            HOperatorSet.ConcatObj(ho_usualReg, ho_i_SubRegs, out ho_AllRegs);
            hv_allNum = hv_subNum + 1;
            //对均值图进行sobel边缘检测，提取边缘幅度
            ho_EdgeAmplitude.Dispose();
            // 均值图byte转real 1207 lw
            HOperatorSet.ConvertImageType(ho_i_MeanImage, out ho_MeanImage, "real");
            HOperatorSet.SobelAmp(ho_MeanImage, out ho_EdgeAmplitude, "sum_abs", 5);
            //亮图像和暗图像初始化为0图像
            ho__ImgDark.Dispose();
            HTV_gen_image_type_recipe(ho_i_MeanImage, out ho__ImgDark, "byte");
            ho__ImgLight.Dispose();
            HTV_gen_image_type_recipe(ho_i_MeanImage, out ho__ImgLight, "byte");
            //对每个检测区域分别计算亮阈值和暗阈值
            HTuple end_val91 = hv_allNum - 1;
            HTuple step_val91 = 1;
            for (hv_idxReg = 0; hv_idxReg.Continue(end_val91, step_val91); hv_idxReg = hv_idxReg.TupleAdd(step_val91))
            {
                //选取当前检测区域
                ho_curReg.Dispose();
                HOperatorSet.SelectObj(ho_AllRegs, out ho_curReg, hv_idxReg + 1);
                //由边缘系数i_SobelScaleFactor计算边缘增强的部分，叠加到方差信息中
                ho_ImageScaled.Dispose();
                HOperatorSet.ScaleImage(ho_EdgeAmplitude, out ho_ImageScaled, hv_i_SobelFactor_COPY_INP_TMP.TupleSelect(
                    hv_idxReg), 0);
                ho__NewStd.Dispose();
                HOperatorSet.AddImage(ho_i_StdImage, ho_ImageScaled, out ho__NewStd, 1.0, 0);
                //暗图像生成：均值-方差系数*方差
                ho_ImageScaled_D.Dispose();
                HOperatorSet.ScaleImage(ho__NewStd, out ho_ImageScaled_D, hv_i_DarkFactor_COPY_INP_TMP.TupleSelect(
                    hv_idxReg), 0);
                ho_ImageSub_D.Dispose();
                HOperatorSet.SubImage(ho_MeanImage, ho_ImageScaled_D, out ho_ImageSub_D,
                    1.0, 0);
                ho__sub_dark_thresh_image.Dispose();
                HOperatorSet.ConvertImageType(ho_ImageSub_D, out ho__sub_dark_thresh_image,
                    "byte");
                //亮图像生成：均值+方差系数*方差
                ho_ImageScaled_L.Dispose();
                HOperatorSet.ScaleImage(ho__NewStd, out ho_ImageScaled_L, hv_i_LightFactor_COPY_INP_TMP.TupleSelect(
                    hv_idxReg), 0);
                ho_ImageSub_L.Dispose();
                HOperatorSet.AddImage(ho_MeanImage, ho_ImageScaled_L, out ho_ImageSub_L,
                    1.0, 0);
                ho__sub_light_thresh_image.Dispose();
                HOperatorSet.ConvertImageType(ho_ImageSub_L, out ho__sub_light_thresh_image,
                    "byte");
                //截取当前检测区域的部分填充到结果图像中
                ho_dark_image_reduce.Dispose();
                HOperatorSet.ReduceDomain(ho__sub_dark_thresh_image, ho_curReg, out ho_dark_image_reduce
                    );
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.PaintGray(ho_dark_image_reduce, ho__ImgDark, out ExpTmpOutVar_0
                        );
                    ho__ImgDark.Dispose();
                    ho__ImgDark = ExpTmpOutVar_0;
                }
                ho_light_image_reduce.Dispose();
                HOperatorSet.ReduceDomain(ho__sub_light_thresh_image, ho_curReg, out ho_light_image_reduce
                    );
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.PaintGray(ho_light_image_reduce, ho__ImgLight, out ExpTmpOutVar_0
                        );
                    ho__ImgLight.Dispose();
                    ho__ImgLight = ExpTmpOutVar_0;
                }
            }

            {
                HObject ExpTmpOutVar_0;
                HOperatorSet.ConcatObj(ho_o_LightImage, ho__ImgLight, out ExpTmpOutVar_0);
                ho_o_LightImage.Dispose();
                ho_o_LightImage = ExpTmpOutVar_0;
            }
            {
                HObject ExpTmpOutVar_0;
                HOperatorSet.ConcatObj(ho_o_DarkImage, ho__ImgDark, out ExpTmpOutVar_0);
                ho_o_DarkImage.Dispose();
                ho_o_DarkImage = ExpTmpOutVar_0;
            }

            hv_o_ErrCode = 0;
            hv_o_ErrStr = "golden images created";

            ho_RegionDifference.Dispose();
            ho_usualReg.Dispose();
            ho_AllRegs.Dispose();
            ho_EdgeAmplitude.Dispose();
            ho_MeanImage.Dispose();
            ho__ImgDark.Dispose();
            ho__ImgLight.Dispose();
            ho_curReg.Dispose();
            ho_ImageScaled.Dispose();
            ho__NewStd.Dispose();
            ho_ImageScaled_D.Dispose();
            ho_ImageSub_D.Dispose();
            ho__sub_dark_thresh_image.Dispose();
            ho_ImageScaled_L.Dispose();
            ho_ImageSub_L.Dispose();
            ho__sub_light_thresh_image.Dispose();
            ho_dark_image_reduce.Dispose();
            ho_light_image_reduce.Dispose();

            return;
        }

        public static void HTV_gen_image_type_recipe(HObject ho_i_Image, out HObject ho_o_Image,
            HTuple hv_i_Type)
        {




            // Local iconic variables 

            HObject ho_ImageCleared;
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_Image);
            HOperatorSet.GenEmptyObj(out ho_ImageCleared);
            //******  根据输入图像,生成指定数值类型的对应0值图像
            //******  参数说明:
            //******      i_Image: 输入图像
            //******      o_Image: 输出0值图像
            //******      i_Type: 输出图像数值类型

            ho_ImageCleared.Dispose();
            HOperatorSet.GenImageProto(ho_i_Image, out ho_ImageCleared, 0);
            ho_o_Image.Dispose();
            HOperatorSet.ConvertImageType(ho_ImageCleared, out ho_o_Image, hv_i_Type);
            ho_ImageCleared.Dispose();

            return;
        }

        #endregion

        #region 创建定位模板
        //2020-12-05
        public static void HTV_CreateLocModel(HObject ho_i_Image, HObject ho_i_MatchRegs, HTuple hv_i_ModelType,
    		HTuple hv_i_AngleStart, HTuple hv_i_AngleExt, out HTuple hv_o_ModelID)
        {




            // Local iconic variables 

            HObject ho_curReg = null;

            // Local control variables 

            HTuple hv_Number = null, hv_Index = null, hv__ModelID = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_curReg);
            try
            {
                //生成匹配模板,一个匹配区生成一个模板
                //i_Image: 目标图像
                //i_MatchRegs: 在目标区域内定位目标的匹配区（要求该区域细节较多，容易区分），一个匹配区创建一个模板，若需要将几个区域联合创建一个模板，需要将区域union在一起
                //i_ModelType: 用于创建目标定位匹配模板的类型，ncc or shape
                //o_ModelID:目标定位匹配模板ID
                //*******************************************************************************
                HOperatorSet.CountObj(ho_i_MatchRegs, out hv_Number);
                hv_o_ModelID = new HTuple();

                //创建多个匹配模板

                HTuple end_val11 = hv_Number;
                HTuple step_val11 = 1;
                for (hv_Index = 1; hv_Index.Continue(end_val11, step_val11); hv_Index = hv_Index.TupleAdd(step_val11))
                {
                    ho_curReg.Dispose();
                    HOperatorSet.SelectObj(ho_i_MatchRegs, out ho_curReg, hv_Index);
                    HTV_create_model_recipe(ho_i_Image, ho_curReg, hv_i_ModelType, hv_i_AngleStart.TupleRad(),
                        hv_i_AngleExt.TupleRad(), out hv__ModelID);
                    hv_o_ModelID = hv_o_ModelID.TupleConcat(hv__ModelID);
                }

                ho_curReg.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_curReg.Dispose();

                throw HDevExpDefaultException;
            }
        }

        //被替换
        //public static void HTV_CreateLocModel(HObject ho_i_Image, HObject ho_i_MatchRegs, HTuple hv_i_ModelType,
        //    out HTuple hv_o_ModelID)
        //{
        //    // Local iconic variables 

        //    HObject ho_curReg = null;

        //    // Local control variables 

        //    HTuple hv_Number = null, hv__AngleStart = new HTuple();
        //    HTuple hv__AngleExt = new HTuple(), hv_Index = null, hv__ModelID = new HTuple();
        //    // Initialize local and output iconic variables 
        //    HOperatorSet.GenEmptyObj(out ho_curReg);
        //    //生成匹配模板,一个匹配区生成一个模板
        //    //i_Image: 目标图像
        //    //i_MatchRegs: 在目标区域内定位目标的匹配区（要求该区域细节较多，容易区分），一个匹配区创建一个模板，若需要将几个区域联合创建一个模板，需要将区域union在一起
        //    //i_ModelType: 用于创建目标定位匹配模板的类型，ncc or shape
        //    //o_ModelID:目标定位匹配模板ＩＤ
        //    HOperatorSet.CountObj(ho_i_MatchRegs, out hv_Number);
        //    hv_o_ModelID = new HTuple();
        //    if ((int)(new HTuple(hv_i_ModelType.TupleEqual(0))) != 0)
        //    {
        //        hv__AngleStart = -((new HTuple(20)).TupleRad());
        //        hv__AngleExt = (new HTuple(45)).TupleRad();
        //    }
        //    else
        //    {
        //        hv__AngleStart = -((new HTuple(180)).TupleRad());
        //        hv__AngleExt = (new HTuple(360)).TupleRad();
        //    }
        //    HTuple end_val14 = hv_Number;
        //    HTuple step_val14 = 1;
        //    for (hv_Index = 1; hv_Index.Continue(end_val14, step_val14); hv_Index = hv_Index.TupleAdd(step_val14))
        //    {
        //        ho_curReg.Dispose();
        //        HOperatorSet.SelectObj(ho_i_MatchRegs, out ho_curReg, hv_Index);
        //        HTV_create_model_recipe(ho_i_Image, ho_curReg, hv_i_ModelType, hv__AngleStart,
        //            hv__AngleExt, out hv__ModelID);
        //        hv_o_ModelID = hv_o_ModelID.TupleConcat(hv__ModelID);
        //    }

        //    ho_curReg.Dispose();

        //    return;
        //}

        #endregion


        #region  框架 钉架 桥接 检测验证
        public static void HTV_Frame_Location(HObject ho_i_Image, HObject ho_i_SearchReg, HObject ho_i_MatchRegs,
            HObject ho_i_FrameRegion, out HObject ho_o_FailRegs, HTuple hv_i_ModelType,
            HTuple hv_i_ModelID, HTuple hv_i_DilationSize, HTuple hv_i_Score, HTuple hv_i_AngleStart,
            HTuple hv_i_AngleExt, HTuple hv_i_MatchNum, HTuple hv_i_DefectImgIdx, out HTuple hv_o_LocPara,
            out HTuple hv_o_HomMatMod2Img, out HTuple hv_o_DefectType, out HTuple hv_o_DefectImgIdx,
            out HTupleVector/*{eTupleVector,Dim=1}*/ hvec_o_DefectValue, out HTuple hv_o_ErrCode,
            out HTuple hv_o_ErrStr)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho__EmptyFailReg, ho__FrameRegion = null;

            // Local control variables 

            HTuple hv__LocPara = null, hv__HomMatMod2Img = null;
            HTuple hv__Scores = null, hv__frameErrCode = null, hv__frameErrStr = null;
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_FailRegs);
            HOperatorSet.GenEmptyObj(out ho__EmptyFailReg);
            HOperatorSet.GenEmptyObj(out ho__FrameRegion);
            try
            {
                //**************************************************************************************************
                //---函数：HTV_Frame_Location
                //---作用：Frame模板匹配，定位框架
                //---参数：
                //===图标参数
                //---输入图形对象
                //  i_Image：输入图像，在图像中寻找匹配对象
                //  i_SearchReg：搜索区域，在区域内匹配目标对象
                //  o_FailRegs：定位失败区域
                //===控制参数
                //---模板匹配参数
                //  i_ModelType：模板类型，一般使用ncc和shape作为定位模板，该参数为整数类型，0-ncc，1-shape
                //  i_ModelID：模板ID号，创建匹配模板时返回值，通常由模板文件读入
                //  i_Score：最小匹配分数
                //  i_AngleStart：匹配定位起始角度
                //  i_AngleExt：匹配定位起角度范围
                //  i_MatchNum：需要匹配的目标个数
                //---输出定位结果
                //  o_LocPara: 匹配对象的位置信息
                //  o_HomMatMod2Img: 输出模板到图像的映射矩阵--从模板到检测图像的映射关系
                //  o_DefectType：输出的检测得到的异常区域的缺陷类型
                //  o_ErrCode：错误码，代表该算子执行过程中产生的错误，0-代表执行正常，自然数-代表执行错误，-1-代表执行错误，-2-代表未执行
                //  o_ErrStr：错误信息，对各种错误的具体描述
                //**************************************************************************************************

                //初始化
                ho__EmptyFailReg.Dispose();
                HOperatorSet.GenEmptyObj(out ho__EmptyFailReg);
                ho_o_FailRegs.Dispose();
                ho_o_FailRegs = ho__EmptyFailReg.CopyObj(1, -1);
                hv_o_DefectType = new HTuple();
                hv_o_DefectImgIdx = new HTuple();
                hvec_o_DefectValue = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(-2))));
                //
                hv_o_LocPara = new HTuple();
                hv_o_LocPara[0] = -2;
                hv_o_LocPara[1] = -2;
                hv_o_LocPara[2] = -2;
                hv_o_HomMatMod2Img = new HTuple();
                hv_o_HomMatMod2Img[0] = -2;
                hv_o_HomMatMod2Img[1] = -2;
                hv_o_HomMatMod2Img[2] = -2;
                hv_o_HomMatMod2Img[3] = -2;
                hv_o_HomMatMod2Img[4] = -2;
                hv_o_HomMatMod2Img[5] = -2;
                hv_o_ErrCode = -2;
                hv_o_ErrStr = "initializing";
                //
                HTV_multi_match_region_location_frame(ho_i_Image, ho_i_SearchReg, ho_i_MatchRegs,
                    ho_i_FrameRegion, hv_i_ModelType, hv_i_ModelID, hv_i_DilationSize, hv_i_Score,
                    hv_i_AngleStart, hv_i_AngleExt, hv_i_MatchNum, out hv__LocPara, out hv__HomMatMod2Img,
                    out hv__Scores, out hv__frameErrCode, out hv__frameErrStr);

                if ((int)(new HTuple(hv__frameErrCode.TupleEqual(0))) != 0)
                {
                    //
                    //正常输出错误码为0，FailReg为ResultReg
                    hv_o_DefectType = hv_o_DefectType.TupleConcat(0);
                    hv_o_DefectImgIdx = hv_o_DefectImgIdx.TupleConcat(hv_i_DefectImgIdx);
                    hvec_o_DefectValue = (new HTupleVector(1).Insert(0, new HTupleVector(hv__Scores)));
                    ho__FrameRegion.Dispose();
                    HOperatorSet.AffineTransRegion(ho_i_FrameRegion, out ho__FrameRegion, hv__HomMatMod2Img,
                        "nearest_neighbor");
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_o_FailRegs, ho__FrameRegion, out ExpTmpOutVar_0
                            );
                        ho_o_FailRegs.Dispose();
                        ho_o_FailRegs = ExpTmpOutVar_0;
                    }

                    hv_o_HomMatMod2Img = hv__HomMatMod2Img.Clone();
                    hv_o_LocPara = hv__LocPara.Clone();
                }
                else
                {
                    hv_o_DefectType = hv_o_DefectType.TupleConcat(27);
                    hv_o_DefectImgIdx = hv_o_DefectImgIdx.TupleConcat(hv_i_DefectImgIdx);
                    hvec_o_DefectValue = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(-1))));
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_o_FailRegs, ho_i_SearchReg, out ExpTmpOutVar_0);
                        ho_o_FailRegs.Dispose();
                        ho_o_FailRegs = ExpTmpOutVar_0;
                    }
                    hv_o_ErrCode = 1;
                    hv_o_ErrStr = "find frame error!";
                    ho__EmptyFailReg.Dispose();
                    ho__FrameRegion.Dispose();

                    return;
                }

                hv_o_ErrCode = 0;
                hv_o_ErrStr = "find frame successful";
                ho__EmptyFailReg.Dispose();
                ho__FrameRegion.Dispose();

                return;


            }
            catch (HalconException HDevExpDefaultException)
            {
                ho__EmptyFailReg.Dispose();
                ho__FrameRegion.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public static void HTV_multi_match_region_location_frame(HObject ho_i_Image, HObject ho_i_SearchReg,
            HObject ho_i_matchRegions, HObject ho_i_frameRegion, HTuple hv_i_ModelType,
            HTuple hv_i_PosModel, HTuple hv_i_DilationSize, HTuple hv_i_MinMatchScore, HTuple hv_i_MatchStartAngle,
            HTuple hv_i_MatchAngleExt, HTuple hv_i_MatchNum, out HTuple hv_o_LocPara, out HTuple hv_o_HomMatMod2Img,
            out HTuple hv_o_Scores, out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_match_region = null, ho_matchRegion = null;
            HObject ho_RegionDilation = null, ho__SearchReg = null, ho_match_region_affine = null;
            HObject ho__FrameRegion = null;

            // Local control variables 

            HTuple hv_real_rows = null, hv_real_cols = null;
            HTuple hv_model_row = null, hv_model_col = null, hv_idxId = null;
            HTuple hv_Row1 = new HTuple(), hv_Col1 = new HTuple();
            HTuple hv_Row2 = new HTuple(), hv_Col2 = new HTuple();
            HTuple hv_width = new HTuple(), hv_height = new HTuple();
            HTuple hv_DilationSize = new HTuple(), hv_RegArea = new HTuple();
            HTuple hv_RegRow = new HTuple(), hv_RegCol = new HTuple();
            HTuple hv__LocPara = new HTuple(), hv__Score = new HTuple();
            HTuple hv__ErrLocCode = new HTuple(), hv__ErrLocStr = new HTuple();
            HTuple hv_Area1 = new HTuple(), hv_m_row = new HTuple();
            HTuple hv_m_col = new HTuple(), hv_Tem_HomMatMod2Img = new HTuple();
            HTuple hv_Area = new HTuple(), hv_r_row = new HTuple();
            HTuple hv_r_col = new HTuple(), hv_RowM = null, hv_ColumnM = null;
            HTuple hv_PhiM = null, hv_LengthM1 = null, hv_LengthM2 = null;
            HTuple hv_Row = new HTuple(), hv_Column = new HTuple();
            HTuple hv_Phi = new HTuple(), hv_Length1 = new HTuple();
            HTuple hv_Length2 = new HTuple(), hv__Phi = new HTuple();
            HTuple hv_model_Phi = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_match_region);
            HOperatorSet.GenEmptyObj(out ho_matchRegion);
            HOperatorSet.GenEmptyObj(out ho_RegionDilation);
            HOperatorSet.GenEmptyObj(out ho__SearchReg);
            HOperatorSet.GenEmptyObj(out ho_match_region_affine);
            HOperatorSet.GenEmptyObj(out ho__FrameRegion);
            try
            {
                //*****************************************************
                //add by wj
                //*******************************************************
                //初始化
                hv_o_LocPara = new HTuple();
                hv_o_LocPara[0] = -2;
                hv_o_LocPara[1] = -2;
                hv_o_LocPara[2] = -2;
                //
                hv_o_HomMatMod2Img = new HTuple();
                hv_o_HomMatMod2Img[0] = -2;
                hv_o_HomMatMod2Img[1] = -2;
                hv_o_HomMatMod2Img[2] = -2;
                hv_o_HomMatMod2Img[3] = -2;
                hv_o_HomMatMod2Img[4] = -2;
                hv_o_HomMatMod2Img[5] = -2;
                hv_o_Scores = new HTuple();
                //
                hv_o_ErrCode = -2;
                hv_o_ErrStr = "initializing!";
                //---------获取Frame*的模板定位映射矩阵

                hv_real_rows = new HTuple();
                hv_real_cols = new HTuple();
                //
                hv_model_row = new HTuple();
                hv_model_col = new HTuple();

                for (hv_idxId = 0; (int)hv_idxId <= (int)((new HTuple(hv_i_PosModel.TupleLength()
                    )) - 1); hv_idxId = (int)hv_idxId + 1)
                {
                    //
                    //搜索区域为匹配区膨胀区域，默认膨胀长宽,此基础上膨胀外部设置参数尺寸  mod by lw
                    ho_match_region.Dispose();
                    HOperatorSet.SelectObj(ho_i_matchRegions, out ho_match_region, hv_idxId + 1);
                    //防止传入为去掉免检区域后分为两个情况
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.Union1(ho_match_region, out ExpTmpOutVar_0);
                        ho_match_region.Dispose();
                        ho_match_region = ExpTmpOutVar_0;
                    }
                    HOperatorSet.SmallestRectangle1(ho_match_region, out hv_Row1, out hv_Col1,
                        out hv_Row2, out hv_Col2);
                    ho_matchRegion.Dispose();
                    HOperatorSet.GenRectangle1(out ho_matchRegion, hv_Row1, hv_Col1, hv_Row2,
                        hv_Col2);
                    hv_width = ((hv_Col2 - hv_Col1)).TupleAbs();
                    hv_height = ((hv_Row2 - hv_Row1)).TupleAbs();
                    hv_DilationSize = hv_width.TupleMax2(hv_height);
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.DilationRectangle1(ho_matchRegion, out ExpTmpOutVar_0, hv_DilationSize,
                            hv_DilationSize);
                        ho_matchRegion.Dispose();
                        ho_matchRegion = ExpTmpOutVar_0;
                    }
                    ho_RegionDilation.Dispose();
                    HOperatorSet.DilationRectangle1(ho_matchRegion, out ho_RegionDilation, hv_i_DilationSize,
                        hv_i_DilationSize);
                    ho__SearchReg.Dispose();
                    HOperatorSet.Intersection(ho_i_SearchReg, ho_RegionDilation, out ho__SearchReg
                        );

                    //如果搜索区为空，即为小芯片多die情况，则用die区 mod by lw
                    HOperatorSet.AreaCenter(ho__SearchReg, out hv_RegArea, out hv_RegRow, out hv_RegCol);
                    if ((int)(new HTuple(hv_RegArea.TupleEqual(0))) != 0)
                    {
                        ho__SearchReg.Dispose();
                        ho__SearchReg = ho_i_SearchReg.CopyObj(1, -1);
                    }

                    //
                    HTV_Loc_Match(ho_i_Image, ho__SearchReg, hv_i_ModelType, hv_i_PosModel.TupleSelect(
                        hv_idxId), hv_i_MinMatchScore, hv_i_MatchStartAngle, hv_i_MatchAngleExt,
                        hv_i_MatchNum, out hv__LocPara, out hv__Score, out hv__ErrLocCode, out hv__ErrLocStr);
                    //
                    hv_o_Scores = hv_o_Scores.TupleConcat(hv__Score);
                    //
                    //保存匹配区域点
                    if ((int)(new HTuple(hv__Score.TupleGreater(hv_i_MinMatchScore))) != 0)
                    {
                        //
                        //模板匹配区域求取中心
                        HOperatorSet.AreaCenter(ho_match_region, out hv_Area1, out hv_m_row, out hv_m_col);
                        hv_model_row = hv_model_row.TupleConcat(hv_m_row);
                        hv_model_col = hv_model_col.TupleConcat(hv_m_col);
                        //
                        //生成当前匹配的映射矩阵
                        HOperatorSet.VectorAngleToRigid(0, 0, 0, hv__LocPara.TupleSelect(0), hv__LocPara.TupleSelect(
                            1), hv__LocPara.TupleSelect(2), out hv_Tem_HomMatMod2Img);
                        //映射匹配区域
                        ho_match_region_affine.Dispose();
                        HOperatorSet.AffineTransRegion(ho_match_region, out ho_match_region_affine,
                            hv_Tem_HomMatMod2Img, "nearest_neighbor");
                        HOperatorSet.AreaCenter(ho_match_region_affine, out hv_Area, out hv_r_row,
                            out hv_r_col);
                        hv_real_rows = hv_real_rows.TupleConcat(hv_r_row);
                        hv_real_cols = hv_real_cols.TupleConcat(hv_r_col);
                    }

                    //异常
                    if ((int)(new HTuple(hv__ErrLocCode.TupleLess(0))) != 0)
                    {
                        hv_o_ErrCode = -1;
                        hv_o_ErrStr = "no frame is found" + hv__ErrLocStr;
                        ho_match_region.Dispose();
                        ho_matchRegion.Dispose();
                        ho_RegionDilation.Dispose();
                        ho__SearchReg.Dispose();
                        ho_match_region_affine.Dispose();
                        ho__FrameRegion.Dispose();

                        return;
                    }
                }

                //兼容参考位置为框架和模板芯片的两种模式 0120
                HOperatorSet.SmallestRectangle2(ho_i_frameRegion, out hv_RowM, out hv_ColumnM,
                    out hv_PhiM, out hv_LengthM1, out hv_LengthM2);

                //计算映射矩阵并输出
                if ((int)(new HTuple((new HTuple(hv_real_rows.TupleLength())).TupleGreaterEqual(
                    3))) != 0)
                {
                    //找到大于等于三个点的情况
                    HOperatorSet.VectorToRigid(hv_model_row, hv_model_col, hv_real_rows, hv_real_cols,
                        out hv_o_HomMatMod2Img);
                    ho__FrameRegion.Dispose();
                    HOperatorSet.AffineTransRegion(ho_i_frameRegion, out ho__FrameRegion, hv_o_HomMatMod2Img,
                        "nearest_neighbor");
                    //--------求框架区域中心并输出
                    HOperatorSet.SmallestRectangle2(ho__FrameRegion, out hv_Row, out hv_Column,
                        out hv_Phi, out hv_Length1, out hv_Length2);
                    //兼容参考位置为框架和模板芯片的两种模式
                    if ((int)((new HTuple(hv_LengthM1.TupleLess(5))).TupleAnd(new HTuple(hv_LengthM2.TupleLess(
                        5)))) != 0)
                    {
                        hv_o_LocPara = new HTuple();
                        hv_o_LocPara[0] = 0;
                        hv_o_LocPara[1] = 0;
                        hv_o_LocPara[2] = 0;
                    }
                    else
                    {
                        hv_o_LocPara = new HTuple();
                        hv_o_LocPara = hv_o_LocPara.TupleConcat(hv_Row);
                        hv_o_LocPara = hv_o_LocPara.TupleConcat(hv_Column);
                        hv_o_LocPara = hv_o_LocPara.TupleConcat(hv_Phi);
                    }
                }
                else if ((int)(new HTuple((new HTuple(hv_real_rows.TupleLength())).TupleEqual(
                    2))) != 0)
                {
                    //找到两个点的情况
                    HOperatorSet.AngleLx(hv_real_rows.TupleSelect(0), hv_real_cols.TupleSelect(
                        0), hv_real_rows.TupleSelect(1), hv_real_cols.TupleSelect(1), out hv__Phi);
                    HOperatorSet.AngleLx(hv_model_row.TupleSelect(0), hv_model_col.TupleSelect(
                        0), hv_model_row.TupleSelect(1), hv_model_col.TupleSelect(1), out hv_model_Phi);
                    HOperatorSet.VectorAngleToRigid(hv_model_row.TupleSelect(0), hv_model_col.TupleSelect(
                        0), hv_model_Phi, hv_real_rows.TupleSelect(0), hv_real_cols.TupleSelect(
                        0), hv__Phi, out hv_o_HomMatMod2Img);
                    ho__FrameRegion.Dispose();
                    HOperatorSet.AffineTransRegion(ho_i_frameRegion, out ho__FrameRegion, hv_o_HomMatMod2Img,
                        "nearest_neighbor");
                    //--------求框架区域中心并输出
                    HOperatorSet.SmallestRectangle2(ho__FrameRegion, out hv_Row, out hv_Column,
                        out hv_Phi, out hv_Length1, out hv_Length2);
                    //兼容参考位置为框架和模板芯片的两种模式
                    if ((int)((new HTuple(hv_LengthM1.TupleLess(5))).TupleAnd(new HTuple(hv_LengthM2.TupleLess(
                        5)))) != 0)
                    {
                        hv_o_LocPara = new HTuple();
                        hv_o_LocPara[0] = 0;
                        hv_o_LocPara[1] = 0;
                        hv_o_LocPara[2] = 0;
                    }
                    else
                    {
                        hv_o_LocPara = new HTuple();
                        hv_o_LocPara = hv_o_LocPara.TupleConcat(hv_Row);
                        hv_o_LocPara = hv_o_LocPara.TupleConcat(hv_Column);
                        hv_o_LocPara = hv_o_LocPara.TupleConcat(hv_Phi);
                    }
                    //
                }
                else if ((int)(new HTuple((new HTuple(hv_real_rows.TupleLength())).TupleEqual(
                    1))) != 0)
                {
                    //找到一个点的情况
                    hv_o_HomMatMod2Img = hv_Tem_HomMatMod2Img.Clone();
                    ho__FrameRegion.Dispose();
                    HOperatorSet.AffineTransRegion(ho_i_frameRegion, out ho__FrameRegion, hv_o_HomMatMod2Img,
                        "nearest_neighbor");
                    //--------求框架区域中心并输出
                    HOperatorSet.SmallestRectangle2(ho__FrameRegion, out hv_Row, out hv_Column,
                        out hv_Phi, out hv_Length1, out hv_Length2);
                    //兼容参考位置为框架和模板芯片的两种模式
                    if ((int)((new HTuple(hv_LengthM1.TupleLess(5))).TupleAnd(new HTuple(hv_LengthM2.TupleLess(
                        5)))) != 0)
                    {
                        hv_o_LocPara = new HTuple();
                        hv_o_LocPara[0] = 0;
                        hv_o_LocPara[1] = 0;
                        hv_o_LocPara[2] = 0;
                    }
                    else
                    {
                        hv_o_LocPara = new HTuple();
                        hv_o_LocPara = hv_o_LocPara.TupleConcat(hv_Row);
                        hv_o_LocPara = hv_o_LocPara.TupleConcat(hv_Column);
                        hv_o_LocPara = hv_o_LocPara.TupleConcat(hv_Phi);
                    }
                    //
                }
                else
                {
                    //
                    hv_o_ErrCode = 1;
                    hv_o_ErrStr = "find frame error!";
                    ho_match_region.Dispose();
                    ho_matchRegion.Dispose();
                    ho_RegionDilation.Dispose();
                    ho__SearchReg.Dispose();
                    ho_match_region_affine.Dispose();
                    ho__FrameRegion.Dispose();

                    return;
                }
                //
                hv_o_ErrCode = 0;
                hv_o_ErrStr = "find frame ok!";
                ho_match_region.Dispose();
                ho_matchRegion.Dispose();
                ho_RegionDilation.Dispose();
                ho__SearchReg.Dispose();
                ho_match_region_affine.Dispose();
                ho__FrameRegion.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_match_region.Dispose();
                ho_matchRegion.Dispose();
                ho_RegionDilation.Dispose();
                ho__SearchReg.Dispose();
                ho_match_region_affine.Dispose();
                ho__FrameRegion.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public static void HTV_Loc_Match(HObject ho_i_Image, HObject ho_i_SearchReg, HTuple hv_i_ModelType,
            HTuple hv_i_ModelID, HTuple hv_i_Score, HTuple hv_i_AngleStart, HTuple hv_i_AngleExt,
            HTuple hv_i_MatchNum, out HTuple hv_o_LocPara, out HTuple hv_o_Score, out HTuple hv_o_ErrCode,
            out HTuple hv_o_ErrStr)
        {




            // Local iconic variables 

            HObject ho_searchImage;

            // Local control variables 

            HTuple hv_imgNum = null, hv_regNum = null;
            HTuple hv_Row = new HTuple(), hv_Column = new HTuple();
            HTuple hv_Angle = new HTuple(), hv_Score = new HTuple();
            HTuple hv_tarNum = new HTuple(), hv_idx = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_searchImage);
            hv_o_Score = new HTuple();
            try
            {
                //**********     通过模板匹配的方式定位目标
                // i_Image: 输入图像，在图像中寻找匹配对象
                // i_SearchReg: 搜索区域，在区域内匹配目标对象
                // i_ModelType: 模板类型，一般使用ncc和shape定位模板，该参数为整型类型，0-ncc，1-shape
                // i_ModelID: 模板ID号，创建匹配模板时返回值，通常由模板文件读入
                // i_Score: 最小匹配分数
                // i_AngleStart: 匹配定位起始角度
                // i_AngleExt: 匹配定位角度范围
                // i_MatchNum: 需要匹配的目标个数
                // o_LocPara: 匹配对象的位置信息
                // o_ErrCode: 错误码，代表该算子执行过程中产生的错误，0-代表正常执行，自然数-代表错误类型，-1-代表异常，-2-代表未执行
                // o_ErrStr: 错误信息，对各种错误的具体描述

                //初始化
                hv_o_ErrCode = -2;
                hv_o_ErrStr = "initializing";
                HOperatorSet.TupleGenConst(3 * hv_i_MatchNum, -2, out hv_o_LocPara);

                //输入有效性测试
                HOperatorSet.CountObj(ho_i_Image, out hv_imgNum);
                if ((int)(new HTuple(hv_imgNum.TupleEqual(0))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "input image is null";
                    ho_searchImage.Dispose();

                    return;
                }
                HOperatorSet.CountObj(ho_i_SearchReg, out hv_regNum);
                if ((int)(new HTuple(hv_regNum.TupleLess(1))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "search region is empty";
                    ho_searchImage.Dispose();

                    return;
                }
                if ((int)(new HTuple((new HTuple(hv_i_ModelType.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "para i_ModelType is illegal";
                    ho_searchImage.Dispose();

                    return;
                }
                if ((int)((new HTuple((new HTuple(hv_i_ModelID.TupleLength())).TupleEqual(0))).TupleOr(
                    new HTuple(hv_i_ModelID.TupleLess(0)))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "para i_ModelID is illegal";
                    ho_searchImage.Dispose();

                    return;
                }
                if ((int)((new HTuple((new HTuple((new HTuple(hv_i_Score.TupleLength())).TupleEqual(
                    0))).TupleOr(new HTuple(hv_i_Score.TupleLess(0))))).TupleOr(new HTuple(hv_i_Score.TupleGreater(
                    1)))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "para i_Score is illegal";
                    ho_searchImage.Dispose();

                    return;
                }
                if ((int)(new HTuple((new HTuple(hv_i_AngleStart.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "para i_AngleStart is illegal";
                    ho_searchImage.Dispose();

                    return;
                }
                if ((int)(new HTuple((new HTuple(hv_i_AngleExt.TupleLength())).TupleEqual(0))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "para i_AngleExt is illegal";
                    ho_searchImage.Dispose();

                    return;
                }
                if ((int)((new HTuple((new HTuple(hv_i_MatchNum.TupleLength())).TupleEqual(
                    0))).TupleOr(new HTuple(hv_i_MatchNum.TupleLess(0)))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "para i_MatchNum is illegal";
                    ho_searchImage.Dispose();

                    return;
                }

                //根据匹配类型选择算法进行模板匹配
                ho_searchImage.Dispose();
                HOperatorSet.ReduceDomain(ho_i_Image, ho_i_SearchReg, out ho_searchImage);
                if ((int)(new HTuple(hv_i_ModelType.TupleEqual("ncc"))) != 0)
                {
                    HOperatorSet.FindNccModel(ho_searchImage, hv_i_ModelID, hv_i_AngleStart,
                        hv_i_AngleExt, hv_i_Score, hv_i_MatchNum, 0.5, "true", 0, out hv_Row,
                        out hv_Column, out hv_Angle, out hv_Score);
                    //输出匹配结果
                    hv_o_Score = hv_Score.Clone();
                }
                else if ((int)(new HTuple(hv_i_ModelType.TupleEqual("shape"))) != 0)
                {
                    HOperatorSet.FindShapeModel(ho_searchImage, hv_i_ModelID, hv_i_AngleStart,
                        hv_i_AngleExt, hv_i_Score, hv_i_MatchNum, 0.5, "least_squares", 0, 0.9,
                        out hv_Row, out hv_Column, out hv_Angle, out hv_Score);
                    //输出匹配结果
                    hv_o_Score = hv_Score.Clone();
                }
                else
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "unsupported model type!";
                    ho_searchImage.Dispose();

                    return;
                }
                //未找到足够多的对象，将匹配到的对象信息保存到输出位置参数的靠前位置
                if ((int)(new HTuple((new HTuple(hv_Score.TupleLength())).TupleLess(hv_i_MatchNum))) != 0)
                {
                    hv_o_ErrCode = 1;
                    hv_o_ErrStr = "one or more target matching is fail";
                    hv_tarNum = new HTuple(hv_Row.TupleLength());
                    HTuple end_val82 = hv_tarNum - 1;
                    HTuple step_val82 = 1;
                    for (hv_idx = 0; hv_idx.Continue(end_val82, step_val82); hv_idx = hv_idx.TupleAdd(step_val82))
                    {
                        if (hv_o_LocPara == null)
                            hv_o_LocPara = new HTuple();
                        hv_o_LocPara[hv_idx * 3] = hv_Row.TupleSelect(hv_idx);
                        if (hv_o_LocPara == null)
                            hv_o_LocPara = new HTuple();
                        hv_o_LocPara[(hv_idx * 3) + 1] = hv_Column.TupleSelect(hv_idx);
                        if (hv_o_LocPara == null)
                            hv_o_LocPara = new HTuple();
                        hv_o_LocPara[(hv_idx * 3) + 2] = hv_Angle.TupleSelect(hv_idx);
                    }
                    ho_searchImage.Dispose();

                    return;
                }
                //将匹配到的对象位置信息保存到输出参数数组中
                HTuple end_val90 = hv_i_MatchNum - 1;
                HTuple step_val90 = 1;
                for (hv_idx = 0; hv_idx.Continue(end_val90, step_val90); hv_idx = hv_idx.TupleAdd(step_val90))
                {
                    if (hv_o_LocPara == null)
                        hv_o_LocPara = new HTuple();
                    hv_o_LocPara[hv_idx * 3] = hv_Row.TupleSelect(hv_idx);
                    if (hv_o_LocPara == null)
                        hv_o_LocPara = new HTuple();
                    hv_o_LocPara[(hv_idx * 3) + 1] = hv_Column.TupleSelect(hv_idx);
                    if (hv_o_LocPara == null)
                        hv_o_LocPara = new HTuple();
                    hv_o_LocPara[(hv_idx * 3) + 2] = hv_Angle.TupleSelect(hv_idx);
                }

                hv_o_ErrCode = 0;
                hv_o_ErrStr = "model match successful";

                ho_searchImage.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_searchImage.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public static void HTV_Frame_Inspect(HObject ho_i_Image, HObject ho_i_InspectReg, HObject ho_i_RegjectReg,
            out HObject ho_o_FailRegs, HTuple hv_i_HomMatMod2Img, HTupleVector/*{eTupleVector,Dim=1}*/ hvec_i_RegSegParas,
            HTuple hv_i_CloseSize, HTuple hv_i_MinLength, HTuple hv_i_MinWidth, HTuple hv_i_MinArea,
            HTuple hv_i_SelOperation, HTuple hv_i_ImgIdx, out HTuple hv_o_DefectType, out HTuple hv_o_DefectImgIdx,
            out HTupleVector/*{eTupleVector,Dim=1}*/ hvec_o_DefectValue, out HTuple hv_o_ErrCode,
            out HTuple hv_o_ErrStr)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho__EmptyFailReg, ho__Targets, ho_RegionUnion = null;

            // Local control variables 

            HTuple hv__ErrInsCode = null, hv__ErrInsStr = null;
            HTuple hv_Area = new HTuple(), hv_Row = new HTuple(), hv_Column = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_FailRegs);
            HOperatorSet.GenEmptyObj(out ho__EmptyFailReg);
            HOperatorSet.GenEmptyObj(out ho__Targets);
            HOperatorSet.GenEmptyObj(out ho_RegionUnion);
            try
            {
                //**************************************************************************************************
                //---函数：HTV_Frame_Inspect
                //---作用：Frame表面检测
                //---参数：
                //===图标参数
                //  i_Image：输入图像，Object类型
                //  i_InspectReg：检测区域，在该区域中进行表面污染检测
                //  i_RejectReg：检测得到的拒绝区
                //  o_FailRegs：输出检测结果的错误区域的HobjectVector
                //===控制参数
                //  i_HomMatMod2Img: 输出模板到图像的映射矩阵
                //  i_RegSegParas：区域分割参数
                //  i_CloseSize：闭运算尺寸
                //  i_MinLength：缺陷最小外接矩形半长,为一个向量，针对各重点检测区和非重点检测区分别设置不同参数
                //　 i_MinWidth：缺陷最小外接矩形半宽,为一个向量，针对各重点检测区和非重点检测区分别设置不同参数
                //  i_MinArea：缺陷最小面积,为一个向量，针对各重点检测区和非重点检测区分别设置不同参数
                //  i_SelOperation：形状选择算子and或or等
                //  o_DefectType：输出的检测得到的异常区域的缺陷类型
                //  o_ErrCode: 错误码，代表该算子执行过程中产生的错误，0-代表正常执行，-1-代表异常，-2-代表未执行
                //  o_ErrStr: 错误信息，对各种错误的具体描述
                //**************************************************************************************************

                //初始化
                ho__EmptyFailReg.Dispose();
                HOperatorSet.GenEmptyObj(out ho__EmptyFailReg);
                ho_o_FailRegs.Dispose();
                ho_o_FailRegs = ho__EmptyFailReg.CopyObj(1, -1);
                hv_o_DefectType = new HTuple();
                hv_o_DefectImgIdx = new HTuple();
                hvec_o_DefectValue = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(-2))));
                hv_o_ErrCode = -2;
                hv_o_ErrStr = "initializing";

                //区域表面检测
                ho__Targets.Dispose();
                HTV_Region_Surface_Inspect(ho_i_Image, ho_i_InspectReg, ho_i_RegjectReg, out ho__Targets,
                    hv_i_HomMatMod2Img, hvec_i_RegSegParas, hv_i_CloseSize, hv_i_MinLength,
                    hv_i_MinWidth, hv_i_MinArea, hv_i_SelOperation, out hv__ErrInsCode, out hv__ErrInsStr);

                if ((int)(new HTuple(hv__ErrInsCode.TupleLess(0))) != 0)
                {
                    //参数异常
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "Frame Region " + hv__ErrInsStr;
                }
                else if ((int)(new HTuple(hv__ErrInsCode.TupleGreater(0))) != 0)
                {
                    //表面有缺陷
                    hv_o_DefectType = hv_o_DefectType.TupleConcat(30);
                    hv_o_DefectImgIdx = hv_o_DefectImgIdx.TupleConcat(hv_i_ImgIdx);
                    //
                    ho_RegionUnion.Dispose();
                    HOperatorSet.Union1(ho__Targets, out ho_RegionUnion);
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_o_FailRegs, ho_RegionUnion, out ExpTmpOutVar_0);
                        ho_o_FailRegs.Dispose();
                        ho_o_FailRegs = ExpTmpOutVar_0;
                    }
                    //异物信息独立统计 lw
                    HOperatorSet.AreaCenter(ho__Targets, out hv_Area, out hv_Row, out hv_Column);
                    hvec_o_DefectValue = (((new HTupleVector(1).Insert(0, new HTupleVector(hv_Area))).Insert(
                        1, new HTupleVector(hv_Row))).Insert(2, new HTupleVector(hv_Column)));
                    hv_o_ErrCode = 1;
                    hv_o_ErrStr = "Frame Region is dirty!";
                }
                else
                {
                    //表面正常
                    hvec_o_DefectValue = (((new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(0)))).Insert(
                        1, new HTupleVector(new HTuple(0)))).Insert(2, new HTupleVector(new HTuple(0))));
                    hv_o_ErrCode = 0;
                    hv_o_ErrStr = "Frame Region is clear!";
                }

                ho__EmptyFailReg.Dispose();
                ho__Targets.Dispose();
                ho_RegionUnion.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho__EmptyFailReg.Dispose();
                ho__Targets.Dispose();
                ho_RegionUnion.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public static void HTV_PegRack_Inspect(HObject ho_i_Image, HObject ho_i_InspectReg, HObject ho_i_RejectRegs,
            HObject ho_i_SubReg, out HObject ho_o_FailRegs, HTuple hv_i_HomMatMod2Img, HTuple hv_i_GrayThresh,
            HTuple hv_i_CloseOrOpenSize, HTuple hv_i_AdaptiveMethod, HTuple hv_i_BlockSize,
            HTuple hv_i_Contrast, HTuple hv_i_CloseSize, HTuple hv_i_MinLength, HTuple hv_i_MinWidth,
            HTuple hv_i_MinArea, HTuple hv_i_SelOperation, HTuple hv_i_LightOrDark, out HTuple hv_o_DefectType,
            out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho__EmptyFailReg, ho__PegRackTargets;
            HObject ho__BridgeTargets, ho_RegionUnion = null;

            // Local control variables 

            HTuple hv_HomMatSum = null, hv__ErrPegRackCode = null;
            HTuple hv__ErrPegRackStr = null, hv__ErrBridgeCode = null;
            HTuple hv__ErrBridgeStr = null;
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_FailRegs);
            HOperatorSet.GenEmptyObj(out ho__EmptyFailReg);
            HOperatorSet.GenEmptyObj(out ho__PegRackTargets);
            HOperatorSet.GenEmptyObj(out ho__BridgeTargets);
            HOperatorSet.GenEmptyObj(out ho_RegionUnion);
            //*************************************************************
            //--钉架表面检测、桥接区域检测：1.钉架区域表面检测；2.桥接区域检测
            //--参数说明：wj-2020-03-02 modified
            //*******************图标参数
            //  i_Images：输入图像序列，Object类型
            //  i_InspectReg：检测区域，在该区域中进行表面污染检测
            //  i_RejectRegs：拒绝区域，即免检区域，一般在检测区域内部容易造成干扰的区域或不感兴趣的区域
            //  i_SubReg：重点检测区域，在框架表面检测中不需要检测，为空对象
            //  o_FailRegs：输出检测结果的错误区域的HobjectVector
            //*******************控制参数
            //---钉架表面、桥接区域检测参数
            //  i_AdaptiveMethod：局部阈值分割方法，取值为'mean'  'median'   'gauss'
            //  i_BlockSize: 邻域大小，即局部阈值分割的尺寸
            //  i_Contrast: 灰度对比度，即超过阈值多大的范围视为感兴趣的目标
            //  i_CloseSize：闭运算尺寸
            //  i_MinLength：缺陷最小外接矩形半长,为一个向量，针对各重点检测区和非重点检测区分别设置不同参数
            //　 i_MinWidth：缺陷最小外接矩形半宽,为一个向量，针对各重点检测区和非重点检测区分别设置不同参数
            //  i_MinArea：缺陷最小面积,为一个向量，针对各重点检测区和非重点检测区分别设置不同参数
            //  i_SelOperation：形状选择算子and或or等
            //  o_DefectValue：输出的异常区域实际检测得到的检测值，at[0]:钉架缺陷区域面积大小，at[1]:桥接缺陷区域面积大小
            //  o_DefectType：输出的检测得到的异常区域的缺陷类型
            //  o_ErrCode: 错误码，代表该算子执行过程中产生的错误，0-代表正常执行，-1-代表异常，-2-代表未执行
            //  o_ErrStr: 错误信息，对各种错误的具体描述
            //***************************************************************

            //初始化
            ho__EmptyFailReg.Dispose();
            HOperatorSet.GenEmptyObj(out ho__EmptyFailReg);

            hv_o_DefectType = new HTuple();
            ho_o_FailRegs.Dispose();
            ho_o_FailRegs = ho__EmptyFailReg.CopyObj(1, -1);

            hv_o_ErrCode = -2;
            hv_o_ErrStr = "initializing";

            //传入映射矩阵有效性测试
            HOperatorSet.TupleSum(hv_i_HomMatMod2Img, out hv_HomMatSum);
            if ((int)(new HTuple(hv_HomMatSum.TupleEqual(-12))) != 0)
            {
                hv_o_ErrCode = 1;
                hv_o_ErrStr = "mapping matrix is invalid!";
                ho__EmptyFailReg.Dispose();
                ho__PegRackTargets.Dispose();
                ho__BridgeTargets.Dispose();
                ho_RegionUnion.Dispose();

                return;
            }

            //钉架表面检测
            ho__PegRackTargets.Dispose();
            HTV_PegRack_Surface_ExistRejectReg(ho_i_Image, ho_i_InspectReg, ho_i_RejectRegs,
                ho_i_SubReg, out ho__PegRackTargets, hv_i_HomMatMod2Img, hv_i_GrayThresh,
                hv_i_CloseOrOpenSize, hv_i_LightOrDark, hv_i_AdaptiveMethod, hv_i_BlockSize,
                hv_i_Contrast, hv_i_CloseSize, hv_i_MinLength, hv_i_MinWidth, hv_i_MinArea,
                hv_i_SelOperation, out hv__ErrPegRackCode, out hv__ErrPegRackStr);
            if ((int)(new HTuple(hv__ErrPegRackCode.TupleLess(0))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = hv__ErrPegRackStr.Clone();
                ho__EmptyFailReg.Dispose();
                ho__PegRackTargets.Dispose();
                ho__BridgeTargets.Dispose();
                ho_RegionUnion.Dispose();

                return;
            }

            //桥接区域检测
            ho__BridgeTargets.Dispose();
            HTV_PegRack_Bridging_ExistRejectReg(ho_i_Image, ho_i_InspectReg, ho_i_RejectRegs,
                ho_i_SubReg, out ho__BridgeTargets, hv_i_HomMatMod2Img, hv_i_GrayThresh,
                hv_i_CloseOrOpenSize, hv_i_AdaptiveMethod, hv_i_BlockSize, hv_i_Contrast,
                hv_i_CloseSize, hv_i_MinLength, hv_i_MinWidth, hv_i_MinArea, hv_i_SelOperation,
                hv_i_LightOrDark, out hv__ErrBridgeCode, out hv__ErrBridgeStr);
            if ((int)(new HTuple(hv__ErrBridgeCode.TupleLess(1))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = hv__ErrBridgeStr.Clone();
                ho__EmptyFailReg.Dispose();
                ho__PegRackTargets.Dispose();
                ho__BridgeTargets.Dispose();
                ho_RegionUnion.Dispose();

                return;
            }

            //钉架区域检测结果
            if ((int)(new HTuple(hv__ErrPegRackCode.TupleGreater(0))) != 0)
            {
                ho_RegionUnion.Dispose();
                HOperatorSet.Union1(ho__PegRackTargets, out ho_RegionUnion);
                hv_o_DefectType = hv_o_DefectType.TupleConcat(31);
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.ConcatObj(ho_o_FailRegs, ho_RegionUnion, out ExpTmpOutVar_0);
                    ho_o_FailRegs.Dispose();
                    ho_o_FailRegs = ExpTmpOutVar_0;
                }
                ho_o_FailRegs.Dispose();
                ho_o_FailRegs = ho_RegionUnion.CopyObj(1, -1);
            }
            //桥接区域检测结果
            if ((int)(new HTuple(hv__ErrBridgeCode.TupleGreater(0))) != 0)
            {
                ho_RegionUnion.Dispose();
                HOperatorSet.Union1(ho__BridgeTargets, out ho_RegionUnion);
                hv_o_DefectType = hv_o_DefectType.TupleConcat(29);
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.ConcatObj(ho_o_FailRegs, ho_RegionUnion, out ExpTmpOutVar_0);
                    ho_o_FailRegs.Dispose();
                    ho_o_FailRegs = ExpTmpOutVar_0;
                }
            }

            //函数结果输出
            if ((int)((new HTuple(hv__ErrPegRackCode.TupleGreater(0))).TupleOr(new HTuple(hv__ErrBridgeCode.TupleGreater(
                0)))) != 0)
            {
                hv_o_ErrCode = 1;
                hv_o_ErrStr = hv__ErrPegRackStr + hv__ErrBridgeStr;
                ho__EmptyFailReg.Dispose();
                ho__PegRackTargets.Dispose();
                ho__BridgeTargets.Dispose();
                ho_RegionUnion.Dispose();

                return;
            }
            else
            {
                hv_o_ErrCode = 0;
                hv_o_ErrStr = hv__ErrPegRackStr + hv__ErrBridgeStr;
                ho__EmptyFailReg.Dispose();
                ho__PegRackTargets.Dispose();
                ho__BridgeTargets.Dispose();
                ho_RegionUnion.Dispose();

                return;
            }

        }

        public static void HTV_Frame_Surface_ExistRejectReg(HObject ho_i_Image, HObject ho_i_InspectReg,
            HObject ho_i_RejectRegs, HObject ho_i_SubReg, out HObject ho_o_Targets, HTuple hv_i_HomMatMod2Img,
            HTuple hv_i_AdaptiveMethod, HTuple hv_i_BlockSize, HTuple hv_i_Contrast, HTuple hv_i_CloseSize,
            HTuple hv_i_MinLength, HTuple hv_i_MinWidth, HTuple hv_i_MinArea, HTuple hv_i_SelOperation,
            HTuple hv_i_LightOrDark, out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {




            // Local iconic variables 

            HObject ho__InspectReg, ho__Image, ho__SubReg;
            HObject ho__RejectRegs, ho_RegUnion, ho_RegionDifference;
            HObject ho__FrameSurfaceImage, ho__SegImage;

            // Local control variables 

            HTuple hv__ThresholdErrCode = null, hv__ThresholdErrStr = null;
            HTuple hv__BlobErrCode = new HTuple(), hv__BlobErrStr = new HTuple();
            HTuple hv_Number = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_Targets);
            HOperatorSet.GenEmptyObj(out ho__InspectReg);
            HOperatorSet.GenEmptyObj(out ho__Image);
            HOperatorSet.GenEmptyObj(out ho__SubReg);
            HOperatorSet.GenEmptyObj(out ho__RejectRegs);
            HOperatorSet.GenEmptyObj(out ho_RegUnion);
            HOperatorSet.GenEmptyObj(out ho_RegionDifference);
            HOperatorSet.GenEmptyObj(out ho__FrameSurfaceImage);
            HOperatorSet.GenEmptyObj(out ho__SegImage);
            //*************************************************************
            //--Frame表面检测：使用自行应阈值分割提取缺陷区域，并进行符合要求的缺陷目标提取
            // i_Image：输入图像，在图像中进行Frame表面污染检测
            // i_InspectReg：检测区域，在该区域中进行表面污染检测
            // i_RejectRegs：拒绝区域，即免检区域，一般在检测区域内部容易造成干扰的区域或不感兴趣的区域
            // i_SubReg：重点检测区域，在框架表面检测中不需要检测，为空对象
            // o_Targets：符合要求的框架缺陷目标
            // i_HomMatMod2Img: Frame模板到图像的映射矩阵--从模板到检测图像的映射关系
            // i_AdaptiveMethod：局部阈值分割方法，取值为'mean'  'median'   'gauss'
            // i_BlockSize: 邻域大小，即局部阈值分割的尺寸
            // i_Contrast: 灰度对比度，即超过阈值多大的范围视为感兴趣的目标
            // i_CloseSize：闭运算尺寸
            // i_MinLength：缺陷最小外接矩形半长,为一个向量，针对各重点检测区和非重点检测区分别设置不同参数
            //　i_MinWidth：缺陷最小外接矩形半宽,为一个向量，针对各重点检测区和非重点检测区分别设置不同参数
            // i_MinArea：缺陷最小面积,为一个向量，针对各重点检测区和非重点检测区分别设置不同参数
            // i_SelOperation：形状选择算子and或or等
            // o_ErrCode: 错误码，代表该算子执行过程中产生的错误，0-代表正常执行，自然数-代表错误类型，-1-代表异常，-2-代表未执行
            // o_ErrStr: 错误信息，对各种错误的具体描述
            //***************************************************************
            //初始化
            ho_o_Targets.Dispose();
            HOperatorSet.GenEmptyObj(out ho_o_Targets);
            hv_o_ErrCode = -2;
            hv_o_ErrStr = "initializing";

            //变换检测区域并获取检测待处理图像
            ho__InspectReg.Dispose();
            HOperatorSet.AffineTransRegion(ho_i_InspectReg, out ho__InspectReg, hv_i_HomMatMod2Img,
                "nearest_neighbor");
            ho__Image.Dispose();
            HOperatorSet.ReduceDomain(ho_i_Image, ho__InspectReg, out ho__Image);
            //变换重点检测区域
            ho__SubReg.Dispose();
            HOperatorSet.AffineTransRegion(ho_i_SubReg, out ho__SubReg, hv_i_HomMatMod2Img,
                "nearest_neighbor");
            //变换拒绝区域
            ho__RejectRegs.Dispose();
            HOperatorSet.AffineTransRegion(ho_i_RejectRegs, out ho__RejectRegs, hv_i_HomMatMod2Img,
                "nearest_neighbor");
            ho_RegUnion.Dispose();
            HOperatorSet.Union1(ho__RejectRegs, out ho_RegUnion);

            //框架表面检测区域获取
            ho_RegionDifference.Dispose();
            HOperatorSet.Difference(ho__InspectReg, ho_RegUnion, out ho_RegionDifference);
            ho__FrameSurfaceImage.Dispose();
            HOperatorSet.ReduceDomain(ho__Image, ho_RegionDifference, out ho__FrameSurfaceImage
                );

            //自适应提取检测区域目标
            ho__SegImage.Dispose();
            HTV_Adaptive_Threshold(ho__FrameSurfaceImage, out ho__SegImage, hv_i_AdaptiveMethod,
                hv_i_BlockSize, hv_i_Contrast, hv_i_LightOrDark, out hv__ThresholdErrCode,
                out hv__ThresholdErrStr);

            if ((int)(new HTuple(hv__ThresholdErrCode.TupleEqual(0))) != 0)
            {
                //对阈值分割后的目标区域图像进行BLOB分析
                ho_o_Targets.Dispose();
                HTV_BLOB_Extract(ho__SegImage, ho__InspectReg, ho__SubReg, out ho_o_Targets,
                    hv_i_CloseSize, hv_i_MinLength, hv_i_MinWidth, hv_i_MinArea, hv_i_SelOperation,
                    out hv__BlobErrCode, out hv__BlobErrStr);


                //对Blob分析后的结果进行缺陷判断
                HOperatorSet.CountObj(ho_o_Targets, out hv_Number);
                if ((int)((new HTuple(hv__BlobErrCode.TupleEqual(0))).TupleAnd(new HTuple(hv_Number.TupleGreaterEqual(
                    1)))) != 0)
                {
                    hv_o_ErrCode = 1;
                    hv_o_ErrStr = "Frame-Surface is dirty";
                    ho__InspectReg.Dispose();
                    ho__Image.Dispose();
                    ho__SubReg.Dispose();
                    ho__RejectRegs.Dispose();
                    ho_RegUnion.Dispose();
                    ho_RegionDifference.Dispose();
                    ho__FrameSurfaceImage.Dispose();
                    ho__SegImage.Dispose();

                    return;
                }
                else if ((int)((new HTuple(hv__BlobErrCode.TupleEqual(0))).TupleAnd(
                    new HTuple(hv_Number.TupleEqual(0)))) != 0)
                {
                    hv_o_ErrCode = 0;
                    hv_o_ErrStr = "Frame-Surface is clear";
                    ho__InspectReg.Dispose();
                    ho__Image.Dispose();
                    ho__SubReg.Dispose();
                    ho__RejectRegs.Dispose();
                    ho_RegUnion.Dispose();
                    ho_RegionDifference.Dispose();
                    ho__FrameSurfaceImage.Dispose();
                    ho__SegImage.Dispose();

                    return;
                }
                else
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "Fail to Frame-Surface Blob_Extract" + hv__BlobErrStr;
                }

            }
            else
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "Fail to Frame-Surface threshold" + hv__ThresholdErrStr;
                ho__InspectReg.Dispose();
                ho__Image.Dispose();
                ho__SubReg.Dispose();
                ho__RejectRegs.Dispose();
                ho_RegUnion.Dispose();
                ho_RegionDifference.Dispose();
                ho__FrameSurfaceImage.Dispose();
                ho__SegImage.Dispose();

                return;
            }
        }

        public static void HTV_PegRack_Bridging_ExistRejectReg(HObject ho_i_Image, HObject ho_i_InspectReg,
            HObject ho_i_RejectRegs, HObject ho_i_SubReg, out HObject ho_o_Targets, HTuple hv_i_HomMatMod2Img,
            HTuple hv_i_GrayThresh, HTuple hv_i_CloseOrOpenSize, HTuple hv_i_AdaptiveMethod,
            HTuple hv_i_BlockSize, HTuple hv_i_Contrast, HTuple hv_i_CloseSize, HTuple hv_i_MinLength,
            HTuple hv_i_MinWidth, HTuple hv_i_MinArea, HTuple hv_i_SelOperation, HTuple hv_i_LightOrDark,
            out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {




            // Local iconic variables 

            HObject ho__InspectReg, ho__Image, ho__SubReg;
            HObject ho__RejectRegs, ho_RegUnion, ho_RegionDifference;
            HObject ho_ImageReduced, ho__BridgeReg, ho_RegionOpening;
            HObject ho_RegionErosion, ho__BridgeImage, ho__SegImage;

            // Local control variables 

            HTuple hv__ThresholdErrCode = null, hv__ThresholdErrStr = null;
            HTuple hv__BlobErrCode = new HTuple(), hv__BlobErrStr = new HTuple();
            HTuple hv_Number = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_Targets);
            HOperatorSet.GenEmptyObj(out ho__InspectReg);
            HOperatorSet.GenEmptyObj(out ho__Image);
            HOperatorSet.GenEmptyObj(out ho__SubReg);
            HOperatorSet.GenEmptyObj(out ho__RejectRegs);
            HOperatorSet.GenEmptyObj(out ho_RegUnion);
            HOperatorSet.GenEmptyObj(out ho_RegionDifference);
            HOperatorSet.GenEmptyObj(out ho_ImageReduced);
            HOperatorSet.GenEmptyObj(out ho__BridgeReg);
            HOperatorSet.GenEmptyObj(out ho_RegionOpening);
            HOperatorSet.GenEmptyObj(out ho_RegionErosion);
            HOperatorSet.GenEmptyObj(out ho__BridgeImage);
            HOperatorSet.GenEmptyObj(out ho__SegImage);
            //*************************************************************
            //--Frame表面检测：使用自行应阈值分割提取缺陷区域，并进行符合要求的缺陷目标提取
            // i_Image：输入图像，在图像中进行Frame表面污染检测
            // i_InspectReg：检测区域，在该区域中进行表面污染检测
            // i_RejectRegs：拒绝区域，即免检区域，一般在检测区域内部容易造成干扰的区域或不感兴趣的区域
            // i_SubReg：重点检测区域，在框架表面检测中不需要检测，为空对象
            // o_Targets：符合要求的框架缺陷目标
            // i_HomMatMod2Img: Frame模板到图像的映射矩阵--从模板到检测图像的映射关系
            // i_AdaptiveMethod：局部阈值分割方法，取值为'mean'  'median'   'gauss'
            // i_BlockSize: 邻域大小，即局部阈值分割的尺寸
            // i_Contrast: 灰度对比度，即超过阈值多大的范围视为感兴趣的目标
            // i_CloseSize：闭运算尺寸
            // i_MinLength：缺陷最小外接矩形半长,为一个向量，针对各重点检测区和非重点检测区分别设置不同参数
            //　i_MinWidth：缺陷最小外接矩形半宽,为一个向量，针对各重点检测区和非重点检测区分别设置不同参数
            // i_MinArea：缺陷最小面积,为一个向量，针对各重点检测区和非重点检测区分别设置不同参数
            // i_SelOperation：形状选择算子and或or等
            // o_ErrCode: 错误码，代表该算子执行过程中产生的错误，0-代表正常执行，正整数-代表错误类型，-1-代表异常，-2-代表未执行
            // o_ErrStr: 错误信息，对各种错误的具体描述
            //***************************************************************

            //初始化
            ho_o_Targets.Dispose();
            HOperatorSet.GenEmptyObj(out ho_o_Targets);
            hv_o_ErrCode = -2;
            hv_o_ErrStr = "initializing";

            //变换检测区域并获取检测待处理图像
            ho__InspectReg.Dispose();
            HOperatorSet.AffineTransRegion(ho_i_InspectReg, out ho__InspectReg, hv_i_HomMatMod2Img,
                "nearest_neighbor");
            ho__Image.Dispose();
            HOperatorSet.ReduceDomain(ho_i_Image, ho__InspectReg, out ho__Image);
            //变换重点检测区域
            ho__SubReg.Dispose();
            HOperatorSet.AffineTransRegion(ho_i_SubReg, out ho__SubReg, hv_i_HomMatMod2Img,
                "nearest_neighbor");
            //变换拒绝区域
            ho__RejectRegs.Dispose();
            HOperatorSet.AffineTransRegion(ho_i_RejectRegs, out ho__RejectRegs, hv_i_HomMatMod2Img,
                "nearest_neighbor");
            ho_RegUnion.Dispose();
            HOperatorSet.Union1(ho__RejectRegs, out ho_RegUnion);
            //桥接区域检测获取
            ho_RegionDifference.Dispose();
            HOperatorSet.Difference(ho__InspectReg, ho_RegUnion, out ho_RegionDifference);
            ho_ImageReduced.Dispose();
            HOperatorSet.ReduceDomain(ho__Image, ho_RegionDifference, out ho_ImageReduced
                );

            ho__BridgeReg.Dispose();
            HOperatorSet.Threshold(ho_ImageReduced, out ho__BridgeReg, 0, hv_i_GrayThresh);
            ho_RegionOpening.Dispose();
            HOperatorSet.OpeningCircle(ho__BridgeReg, out ho_RegionOpening, hv_i_CloseOrOpenSize);
            ho_RegionErosion.Dispose();
            HOperatorSet.ErosionCircle(ho_RegionOpening, out ho_RegionErosion, hv_i_CloseOrOpenSize);
            ho__BridgeImage.Dispose();
            HOperatorSet.ReduceDomain(ho__Image, ho_RegionErosion, out ho__BridgeImage);

            //自适应提取检测区域目标
            ho__SegImage.Dispose();
            HTV_Adaptive_Threshold(ho__BridgeImage, out ho__SegImage, hv_i_AdaptiveMethod,
                hv_i_BlockSize, hv_i_Contrast, hv_i_LightOrDark, out hv__ThresholdErrCode,
                out hv__ThresholdErrStr);


            if ((int)(new HTuple(hv__ThresholdErrCode.TupleEqual(0))) != 0)
            {
                //对阈值分割后的目标区域图像进行BLOB分析
                ho_o_Targets.Dispose();
                HTV_BLOB_Extract(ho__SegImage, ho__InspectReg, ho__SubReg, out ho_o_Targets,
                    hv_i_CloseSize, hv_i_MinLength, hv_i_MinWidth, hv_i_MinArea, hv_i_SelOperation,
                    out hv__BlobErrCode, out hv__BlobErrStr);


                //对Blob分析后的结果进行缺陷判断
                HOperatorSet.CountObj(ho_o_Targets, out hv_Number);
                if ((int)((new HTuple(hv__BlobErrCode.TupleEqual(0))).TupleAnd(new HTuple(hv_Number.TupleGreaterEqual(
                    1)))) != 0)
                {
                    hv_o_ErrCode = 1;
                    hv_o_ErrStr = "Bridging-Surface is dirty";
                    ho__InspectReg.Dispose();
                    ho__Image.Dispose();
                    ho__SubReg.Dispose();
                    ho__RejectRegs.Dispose();
                    ho_RegUnion.Dispose();
                    ho_RegionDifference.Dispose();
                    ho_ImageReduced.Dispose();
                    ho__BridgeReg.Dispose();
                    ho_RegionOpening.Dispose();
                    ho_RegionErosion.Dispose();
                    ho__BridgeImage.Dispose();
                    ho__SegImage.Dispose();

                    return;
                }
                else if ((int)((new HTuple(hv__BlobErrCode.TupleEqual(0))).TupleAnd(
                    new HTuple(hv_Number.TupleEqual(0)))) != 0)
                {
                    hv_o_ErrCode = 0;
                    hv_o_ErrStr = "Bridging-Surface is clear";
                    ho__InspectReg.Dispose();
                    ho__Image.Dispose();
                    ho__SubReg.Dispose();
                    ho__RejectRegs.Dispose();
                    ho_RegUnion.Dispose();
                    ho_RegionDifference.Dispose();
                    ho_ImageReduced.Dispose();
                    ho__BridgeReg.Dispose();
                    ho_RegionOpening.Dispose();
                    ho_RegionErosion.Dispose();
                    ho__BridgeImage.Dispose();
                    ho__SegImage.Dispose();

                    return;
                }
                else
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "Fail to Bridging-Surface Blob_Extract" + hv__BlobErrStr;
                }

            }
            else
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "Fail to Bridging-Surface threshold" + hv__ThresholdErrStr;
                ho__InspectReg.Dispose();
                ho__Image.Dispose();
                ho__SubReg.Dispose();
                ho__RejectRegs.Dispose();
                ho_RegUnion.Dispose();
                ho_RegionDifference.Dispose();
                ho_ImageReduced.Dispose();
                ho__BridgeReg.Dispose();
                ho_RegionOpening.Dispose();
                ho_RegionErosion.Dispose();
                ho__BridgeImage.Dispose();
                ho__SegImage.Dispose();

                return;
            }

        }

        public static void HTV_Adaptive_Threshold(HObject ho_i_Image, out HObject ho_o_SegImage,
    		HTuple hv_i_AdaptiveMethod, HTuple hv_i_BlockSize, HTuple hv_i_Contrast, HTuple hv_i_LightOrDark,
    		out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {




            // Local iconic variables 

            HObject ho_blurImage = null, ho_ImageSub = null;

            // Local control variables 

            HTuple hv_imgNum = null, hv_IsString = null;
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_SegImage);
            HOperatorSet.GenEmptyObj(out ho_blurImage);
            HOperatorSet.GenEmptyObj(out ho_ImageSub);
            //************   自适应阈值分割，可分别选用均值滤波、高斯滤波或中值滤波方法
            //i_Image: 待处理图像，要求时reduce_domain之后的目标区域图像
            //i_RejectRegs: 拒绝区域，即免检区域，一般在检测区域内部容易造成干扰的区域或不感兴趣的区域
            //o_SegImage: 阈值分割后的目标区域图像，常用于接下来的BLOB分析
            //i_AdaptiveMethod: 局部阈值分割方法，取值为'mean'  'median'   'gauss'
            //i_BlockSize: 邻域大小，即局部阈值分割的尺寸
            //i_Contrast: 灰度对比度，即超过阈值多大的范围视为感兴趣的目标
            //o_ErrCode: 错误码，代表该算子执行过程中产生的错误，0-代表正常执行，自然数-代表错误类型，-1-代表异常，-2-代表未执行
            //o_ErrStr: 错误信息，对各种错误的具体描述

            //初始化
            ho_o_SegImage.Dispose();
            HOperatorSet.GenEmptyObj(out ho_o_SegImage);
            hv_o_ErrCode = -2;
            hv_o_ErrStr = "initializing";

            //输入合法性判断
            //输入图像
            HOperatorSet.CountObj(ho_i_Image, out hv_imgNum);
            if ((int)(new HTuple(hv_imgNum.TupleEqual(0))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "input image is null";
                ho_blurImage.Dispose();
                ho_ImageSub.Dispose();

                return;
            }
            //其他参数
            HOperatorSet.TupleIsString(hv_i_AdaptiveMethod, out hv_IsString);
            if ((int)(new HTuple(hv_IsString.TupleEqual("false"))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "i_AdaptiveMethod must be string";
                ho_blurImage.Dispose();
                ho_ImageSub.Dispose();

                return;
            }
            if ((int)((new HTuple((new HTuple(hv_i_BlockSize.TupleLength())).TupleEqual(0))).TupleOr(
                new HTuple(hv_i_BlockSize.TupleLess(0)))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "i_BlockSize must be greater than 0";
                ho_blurImage.Dispose();
                ho_ImageSub.Dispose();

                return;
            }
            if ((int)((new HTuple((new HTuple(hv_i_Contrast.TupleLength())).TupleEqual(0))).TupleOr(
                new HTuple(hv_i_Contrast.TupleLess(0)))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "i_Contrast must be greater than 0";
                ho_blurImage.Dispose();
                ho_ImageSub.Dispose();

                return;
            }

            //算法处理
            if ((int)(new HTuple(hv_i_AdaptiveMethod.TupleEqual("mean"))) != 0)
            {
                ho_blurImage.Dispose();
                HOperatorSet.MeanImage(ho_i_Image, out ho_blurImage, hv_i_BlockSize + 3, hv_i_BlockSize);
            }
            else if ((int)(new HTuple(hv_i_AdaptiveMethod.TupleEqual("gauss"))) != 0)
            {
                ho_blurImage.Dispose();
                HOperatorSet.GaussFilter(ho_i_Image, out ho_blurImage, hv_i_BlockSize);
            }
            else if ((int)(new HTuple(hv_i_AdaptiveMethod.TupleEqual("median"))) != 0)
            {
                ho_blurImage.Dispose();
                HOperatorSet.MedianImage(ho_i_Image, out ho_blurImage, "square", hv_i_BlockSize,
                    "mirrored");
            }
            else
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "unsupport adaptive method";
                ho_blurImage.Dispose();
                ho_ImageSub.Dispose();

                return;
            }
            //阈值处理，考虑对比度要求
            if ((int)(new HTuple(hv_i_LightOrDark.TupleEqual("light"))) != 0)
            {
                ho_ImageSub.Dispose();
                HOperatorSet.SubImage(ho_i_Image, ho_blurImage, out ho_ImageSub, 1, 0);
                ho_o_SegImage.Dispose();
                HOperatorSet.Threshold(ho_ImageSub, out ho_o_SegImage, hv_i_Contrast, 255);
            }
            else if ((int)(new HTuple(hv_i_LightOrDark.TupleEqual("dark"))) != 0)
            {
                ho_ImageSub.Dispose();
                HOperatorSet.SubImage(ho_blurImage, ho_i_Image, out ho_ImageSub, 1, 0);
                ho_o_SegImage.Dispose();
                HOperatorSet.Threshold(ho_ImageSub, out ho_o_SegImage, hv_i_Contrast, 255);
            }

            //目标区域的优化


            hv_o_ErrCode = 0;
            hv_o_ErrStr = "adaptive threshold successful";

            ho_blurImage.Dispose();
            ho_ImageSub.Dispose();

            return;
        }

        public static void HTV_Adaptive_Threshold_Opt(HObject ho_i_Image, out HObject ho_o_SegImage,
            HTuple hv_i_AdaptiveMethod, HTuple hv_i_BlockSize, HTuple hv_i_Contrast, HTuple hv_i_LightOrDark,
            out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {




            // Local iconic variables 

            HObject ho_blurImage = null, ho_ImageSub = null;
            HObject ho__SegImage0 = null, ho_ImageSubLight = null, ho__SegImageLight = null;
            HObject ho_ImageSubDark = null, ho__SegImageDark = null;

            // Local control variables 

            HTuple hv_imgNum = null, hv_IsString = null;
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_SegImage);
            HOperatorSet.GenEmptyObj(out ho_blurImage);
            HOperatorSet.GenEmptyObj(out ho_ImageSub);
            HOperatorSet.GenEmptyObj(out ho__SegImage0);
            HOperatorSet.GenEmptyObj(out ho_ImageSubLight);
            HOperatorSet.GenEmptyObj(out ho__SegImageLight);
            HOperatorSet.GenEmptyObj(out ho_ImageSubDark);
            HOperatorSet.GenEmptyObj(out ho__SegImageDark);
            try
            {
                //************   自适应阈值分割，可分别选用均值滤波、中值滤波方法
                //i_Image: 待处理图像，要求时reduce_domain之后的目标区域图像
                //i_RejectRegs: 拒绝区域，即免检区域，一般在检测区域内部容易造成干扰的区域或不感兴趣的区域
                //o_SegImage: 阈值分割后的目标区域图像，常用于接下来的BLOB分析
                //i_AdaptiveMethod: 局部阈值分割方法，取值为'mean'  'median'
                //i_BlockSize: 邻域大小，即局部阈值分割的尺寸
                //i_Contrast: 灰度对比度，即超过阈值多大的范围视为感兴趣的目标
                //o_ErrCode: 错误码，代表该算子执行过程中产生的错误，0-代表正常执行，自然数-代表错误类型，-1-代表异常，-2-代表未执行
                //o_ErrStr: 错误信息，对各种错误的具体描述

                //初始化
                ho_o_SegImage.Dispose();
                HOperatorSet.GenEmptyObj(out ho_o_SegImage);
                hv_o_ErrCode = -2;
                hv_o_ErrStr = "initializing";

                //输入合法性判断
                //输入图像
                HOperatorSet.CountObj(ho_i_Image, out hv_imgNum);
                if ((int)(new HTuple(hv_imgNum.TupleEqual(0))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "input image is null";
                    ho_blurImage.Dispose();
                    ho_ImageSub.Dispose();
                    ho__SegImage0.Dispose();
                    ho_ImageSubLight.Dispose();
                    ho__SegImageLight.Dispose();
                    ho_ImageSubDark.Dispose();
                    ho__SegImageDark.Dispose();

                    return;
                }
                //其他参数
                HOperatorSet.TupleIsString(hv_i_AdaptiveMethod, out hv_IsString);
                if ((int)(new HTuple(hv_IsString.TupleEqual("false"))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "i_AdaptiveMethod must be string";
                    ho_blurImage.Dispose();
                    ho_ImageSub.Dispose();
                    ho__SegImage0.Dispose();
                    ho_ImageSubLight.Dispose();
                    ho__SegImageLight.Dispose();
                    ho_ImageSubDark.Dispose();
                    ho__SegImageDark.Dispose();

                    return;
                }
                if ((int)((new HTuple((new HTuple(hv_i_BlockSize.TupleLength())).TupleEqual(
                    0))).TupleOr(new HTuple(hv_i_BlockSize.TupleLess(0)))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "i_BlockSize must be greater than 0";
                    ho_blurImage.Dispose();
                    ho_ImageSub.Dispose();
                    ho__SegImage0.Dispose();
                    ho_ImageSubLight.Dispose();
                    ho__SegImageLight.Dispose();
                    ho_ImageSubDark.Dispose();
                    ho__SegImageDark.Dispose();

                    return;
                }
                if ((int)((new HTuple((new HTuple(hv_i_Contrast.TupleLength())).TupleEqual(
                    0))).TupleOr(new HTuple(hv_i_Contrast.TupleLess(0)))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "i_Contrast must be greater than 0";
                    ho_blurImage.Dispose();
                    ho_ImageSub.Dispose();
                    ho__SegImage0.Dispose();
                    ho_ImageSubLight.Dispose();
                    ho__SegImageLight.Dispose();
                    ho_ImageSubDark.Dispose();
                    ho__SegImageDark.Dispose();

                    return;
                }

                //算法处理
                if ((int)(new HTuple(hv_i_AdaptiveMethod.TupleEqual("mean"))) != 0)
                {
                    ho_blurImage.Dispose();
                    HOperatorSet.MeanImage(ho_i_Image, out ho_blurImage, hv_i_BlockSize, hv_i_BlockSize);
                }
                else if ((int)(new HTuple(hv_i_AdaptiveMethod.TupleEqual("median"))) != 0)
                {
                    ho_blurImage.Dispose();
                    HOperatorSet.MedianImage(ho_i_Image, out ho_blurImage, "square", hv_i_BlockSize,
                        "mirrored");
                }
                else
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "unsupport adaptive method";
                    ho_blurImage.Dispose();
                    ho_ImageSub.Dispose();
                    ho__SegImage0.Dispose();
                    ho_ImageSubLight.Dispose();
                    ho__SegImageLight.Dispose();
                    ho_ImageSubDark.Dispose();
                    ho__SegImageDark.Dispose();

                    return;
                }

                //阈值处理，考虑对比度要求
                if ((int)(new HTuple(hv_i_LightOrDark.TupleEqual("light"))) != 0)
                {
                    ho_ImageSub.Dispose();
                    HOperatorSet.SubImage(ho_i_Image, ho_blurImage, out ho_ImageSub, 1, 0);
                    ho__SegImage0.Dispose();
                    HOperatorSet.Threshold(ho_ImageSub, out ho__SegImage0, hv_i_Contrast, 255);
                }
                else if ((int)(new HTuple(hv_i_LightOrDark.TupleEqual("dark"))) != 0)
                {
                    ho_ImageSub.Dispose();
                    HOperatorSet.SubImage(ho_blurImage, ho_i_Image, out ho_ImageSub, 1, 0);
                    ho__SegImage0.Dispose();
                    HOperatorSet.Threshold(ho_ImageSub, out ho__SegImage0, hv_i_Contrast, 255);
                }
                else if ((int)(new HTuple(hv_i_LightOrDark.TupleEqual("all"))) != 0)
                {
                    ho_ImageSubLight.Dispose();
                    HOperatorSet.SubImage(ho_i_Image, ho_blurImage, out ho_ImageSubLight, 1,
                        0);
                    ho__SegImageLight.Dispose();
                    HOperatorSet.Threshold(ho_ImageSubLight, out ho__SegImageLight, hv_i_Contrast,
                        255);
                    ho_ImageSubDark.Dispose();
                    HOperatorSet.SubImage(ho_blurImage, ho_i_Image, out ho_ImageSubDark, 1, 0);
                    ho__SegImageDark.Dispose();
                    HOperatorSet.Threshold(ho_ImageSubDark, out ho__SegImageDark, hv_i_Contrast,
                        255);
                    ho__SegImage0.Dispose();
                    HOperatorSet.Union2(ho__SegImageLight, ho__SegImageDark, out ho__SegImage0
                        );
                }

                //开运算去除单像素 add by lw 1223
                ho_o_SegImage.Dispose();
                HOperatorSet.OpeningCircle(ho__SegImage0, out ho_o_SegImage, 1);

                hv_o_ErrCode = 0;
                hv_o_ErrStr = "adaptive threshold successful";

                ho_blurImage.Dispose();
                ho_ImageSub.Dispose();
                ho__SegImage0.Dispose();
                ho_ImageSubLight.Dispose();
                ho__SegImageLight.Dispose();
                ho_ImageSubDark.Dispose();
                ho__SegImageDark.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_blurImage.Dispose();
                ho_ImageSub.Dispose();
                ho__SegImage0.Dispose();
                ho_ImageSubLight.Dispose();
                ho__SegImageLight.Dispose();
                ho_ImageSubDark.Dispose();
                ho__SegImageDark.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public static void HTV_BLOB_Extract(HObject ho_i_SegImage, HObject ho_i_InspectReg, HObject ho_i_SubReg,
            out HObject ho_o_Targets, HTuple hv_i_CloseSize, HTuple hv_i_MinLength, HTuple hv_i_MinWidth,
            HTuple hv_i_MinArea, HTuple hv_i_SelOperation, out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_ConnectedRegions, ho_RegionDifference = null;
            HObject ho_RegionUnion = null, ho__AllRegs = null, ho_objRegion = null;
            HObject ho_ObjectSelected = null, ho_EmptyObject = null, ho_ObjectSelected1 = null;
            HObject ho_RegionIntersection = null, ho_RegionClosing = null;
            HObject ho_ConnectedRegions1 = null, ho_SelectedRegions = null;

            // Local control variables 

            HTuple hv_imgNum = null, hv_regNum = null;
            HTuple hv_IsString = null, hv__NumSub = null, hv__Rect2Len1 = null;
            HTuple hv__Rect2Len2 = null, hv_num = new HTuple(), hv_tmpTup = new HTuple();
            HTuple hv__Num = new HTuple(), hv_i = new HTuple(), hv_j = new HTuple();
            HTuple hv__Area = new HTuple(), hv__Row = new HTuple();
            HTuple hv__Column = new HTuple();
            HTuple hv_i_MinArea_COPY_INP_TMP = hv_i_MinArea.Clone();

            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_Targets);
            HOperatorSet.GenEmptyObj(out ho_ConnectedRegions);
            HOperatorSet.GenEmptyObj(out ho_RegionDifference);
            HOperatorSet.GenEmptyObj(out ho_RegionUnion);
            HOperatorSet.GenEmptyObj(out ho__AllRegs);
            HOperatorSet.GenEmptyObj(out ho_objRegion);
            HOperatorSet.GenEmptyObj(out ho_ObjectSelected);
            HOperatorSet.GenEmptyObj(out ho_EmptyObject);
            HOperatorSet.GenEmptyObj(out ho_ObjectSelected1);
            HOperatorSet.GenEmptyObj(out ho_RegionIntersection);
            HOperatorSet.GenEmptyObj(out ho_RegionClosing);
            HOperatorSet.GenEmptyObj(out ho_ConnectedRegions1);
            HOperatorSet.GenEmptyObj(out ho_SelectedRegions);
            //***********************************************************************
            // 缺陷目标提取：提取连通区域，按照面积、长、宽进行筛选
            //　i_SegImage：图像分割后的二值图像
            //　i_InspectReg：检测区域
            //　i_SubReg：重点检测区域
            //　o_Targets：符合要求的缺陷目标
            //　i_CloseSize：闭运算尺寸
            //　i_MinLength：缺陷最小外接矩形半长,为一个向量，针对各重点检测区和非重点检测区分别设置不同参数
            //　i_MinWidth：缺陷最小外接矩形半宽,为一个向量，针对各重点检测区和非重点检测区分别设置不同参数
            //　i_MinArea：缺陷最小面积,为一个向量，针对各重点检测区和非重点检测区分别设置不同参数
            //　i_SelOperation：形状选择算子and或or等
            //o_ErrCode: 错误码，代表该算子执行过程中产生的错误，0-代表正常执行，自然数-代表错误类型，-1-代表异常，-2-代表未执行
            //o_ErrStr: 错误信息，对各种错误的具体描述
            //***********************************************************************

            //初始化
            ho_o_Targets.Dispose();
            HOperatorSet.GenEmptyObj(out ho_o_Targets);
            hv_o_ErrCode = -2;
            hv_o_ErrStr = "initializing";

            //输入合法性判断
            HOperatorSet.CountObj(ho_i_SegImage, out hv_imgNum);
            if ((int)(new HTuple(hv_imgNum.TupleEqual(0))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "input image is null";
                ho_ConnectedRegions.Dispose();
                ho_RegionDifference.Dispose();
                ho_RegionUnion.Dispose();
                ho__AllRegs.Dispose();
                ho_objRegion.Dispose();
                ho_ObjectSelected.Dispose();
                ho_EmptyObject.Dispose();
                ho_ObjectSelected1.Dispose();
                ho_RegionIntersection.Dispose();
                ho_RegionClosing.Dispose();
                ho_ConnectedRegions1.Dispose();
                ho_SelectedRegions.Dispose();

                return;
            }
            HOperatorSet.CountObj(ho_i_InspectReg, out hv_regNum);
            if ((int)(new HTuple(hv_regNum.TupleEqual(0))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "ispect region is null";
                ho_ConnectedRegions.Dispose();
                ho_RegionDifference.Dispose();
                ho_RegionUnion.Dispose();
                ho__AllRegs.Dispose();
                ho_objRegion.Dispose();
                ho_ObjectSelected.Dispose();
                ho_EmptyObject.Dispose();
                ho_ObjectSelected1.Dispose();
                ho_RegionIntersection.Dispose();
                ho_RegionClosing.Dispose();
                ho_ConnectedRegions1.Dispose();
                ho_SelectedRegions.Dispose();

                return;
            }
            if ((int)((new HTuple((new HTuple(hv_i_CloseSize.TupleLength())).TupleEqual(0))).TupleOr(
                new HTuple(hv_i_CloseSize.TupleLess(0)))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "i_CloseSize must be greater than 0";
                ho_ConnectedRegions.Dispose();
                ho_RegionDifference.Dispose();
                ho_RegionUnion.Dispose();
                ho__AllRegs.Dispose();
                ho_objRegion.Dispose();
                ho_ObjectSelected.Dispose();
                ho_EmptyObject.Dispose();
                ho_ObjectSelected1.Dispose();
                ho_RegionIntersection.Dispose();
                ho_RegionClosing.Dispose();
                ho_ConnectedRegions1.Dispose();
                ho_SelectedRegions.Dispose();

                return;
            }
            if ((int)((new HTuple((new HTuple(hv_i_MinLength.TupleLength())).TupleEqual(0))).TupleOr(
                new HTuple(((hv_i_MinLength.TupleSelect(0))).TupleLess(0)))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "i_MinLength must be an array and the value be greater than 0";
                ho_ConnectedRegions.Dispose();
                ho_RegionDifference.Dispose();
                ho_RegionUnion.Dispose();
                ho__AllRegs.Dispose();
                ho_objRegion.Dispose();
                ho_ObjectSelected.Dispose();
                ho_EmptyObject.Dispose();
                ho_ObjectSelected1.Dispose();
                ho_RegionIntersection.Dispose();
                ho_RegionClosing.Dispose();
                ho_ConnectedRegions1.Dispose();
                ho_SelectedRegions.Dispose();

                return;
            }
            if ((int)((new HTuple((new HTuple(hv_i_MinWidth.TupleLength())).TupleEqual(0))).TupleOr(
                new HTuple(((hv_i_MinWidth.TupleSelect(0))).TupleLess(0)))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "i_MinWidth must be an array and the value be greater than 0";
                ho_ConnectedRegions.Dispose();
                ho_RegionDifference.Dispose();
                ho_RegionUnion.Dispose();
                ho__AllRegs.Dispose();
                ho_objRegion.Dispose();
                ho_ObjectSelected.Dispose();
                ho_EmptyObject.Dispose();
                ho_ObjectSelected1.Dispose();
                ho_RegionIntersection.Dispose();
                ho_RegionClosing.Dispose();
                ho_ConnectedRegions1.Dispose();
                ho_SelectedRegions.Dispose();

                return;
            }
            if ((int)((new HTuple((new HTuple(hv_i_MinArea_COPY_INP_TMP.TupleLength())).TupleEqual(
                0))).TupleOr(new HTuple(((hv_i_MinArea_COPY_INP_TMP.TupleSelect(0))).TupleLess(
                0)))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "i_MinArea must be an array and the value be greater than 0";
                ho_ConnectedRegions.Dispose();
                ho_RegionDifference.Dispose();
                ho_RegionUnion.Dispose();
                ho__AllRegs.Dispose();
                ho_objRegion.Dispose();
                ho_ObjectSelected.Dispose();
                ho_EmptyObject.Dispose();
                ho_ObjectSelected1.Dispose();
                ho_RegionIntersection.Dispose();
                ho_RegionClosing.Dispose();
                ho_ConnectedRegions1.Dispose();
                ho_SelectedRegions.Dispose();

                return;
            }
            HOperatorSet.TupleIsString(hv_i_SelOperation, out hv_IsString);
            if ((int)(new HTuple(hv_IsString.TupleEqual("false"))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "i_SelOperation must be string";
                ho_ConnectedRegions.Dispose();
                ho_RegionDifference.Dispose();
                ho_RegionUnion.Dispose();
                ho__AllRegs.Dispose();
                ho_objRegion.Dispose();
                ho_ObjectSelected.Dispose();
                ho_EmptyObject.Dispose();
                ho_ObjectSelected1.Dispose();
                ho_RegionIntersection.Dispose();
                ho_RegionClosing.Dispose();
                ho_ConnectedRegions1.Dispose();
                ho_SelectedRegions.Dispose();

                return;
            }

            //算法主体
            ho_ConnectedRegions.Dispose();
            HOperatorSet.Connection(ho_i_SegImage, out ho_ConnectedRegions);
            HOperatorSet.CountObj(ho_i_SubReg, out hv__NumSub);
            hv__Rect2Len1 = hv_i_MinLength / 2.0;
            hv__Rect2Len2 = hv_i_MinWidth / 2.0;
            //确定每个区域的参数,每个重点检测区和非重点检测区分别调用各自的参数,参数不够时，复制最后一个参数
            if ((int)(new HTuple((new HTuple(hv_i_MinLength.TupleLength())).TupleLess(hv__NumSub + 1))) != 0)
            {
                hv_num = (hv__NumSub + 1) - (new HTuple(hv_i_MinLength.TupleLength()));
                HOperatorSet.TupleGenConst(hv_num, hv__Rect2Len1.TupleSelect((new HTuple(hv_i_MinLength.TupleLength()
                    )) - 1), out hv_tmpTup);
                hv__Rect2Len1 = hv__Rect2Len1.TupleConcat(hv_tmpTup);
            }
            if ((int)(new HTuple((new HTuple(hv_i_MinWidth.TupleLength())).TupleLess(hv__NumSub + 1))) != 0)
            {
                hv_num = (hv__NumSub + 1) - (new HTuple(hv_i_MinWidth.TupleLength()));
                HOperatorSet.TupleGenConst(hv_num, hv__Rect2Len2.TupleSelect((new HTuple(hv_i_MinWidth.TupleLength()
                    )) - 1), out hv_tmpTup);
                hv__Rect2Len2 = hv__Rect2Len2.TupleConcat(hv_tmpTup);
            }
            if ((int)(new HTuple((new HTuple(hv_i_MinArea_COPY_INP_TMP.TupleLength())).TupleLess(
                hv__NumSub + 1))) != 0)
            {
                hv_num = (hv__NumSub + 1) - (new HTuple(hv_i_MinArea_COPY_INP_TMP.TupleLength()
                    ));
                HOperatorSet.TupleGenConst(hv_num, hv_i_MinArea_COPY_INP_TMP.TupleSelect((new HTuple(hv_i_MinArea_COPY_INP_TMP.TupleLength()
                    )) - 1), out hv_tmpTup);
                hv_i_MinArea_COPY_INP_TMP = hv_i_MinArea_COPY_INP_TMP.TupleConcat(hv_tmpTup);
            }

            if ((int)(new HTuple(hv__NumSub.TupleGreater(0))) != 0)
            {
                //检测矩形框中除去OK品参考子区域外的部分单独作为一个整体区域
                ho_RegionDifference.Dispose();
                HOperatorSet.Difference(ho_i_InspectReg, ho_i_SubReg, out ho_RegionDifference
                    );
                ho_RegionUnion.Dispose();
                HOperatorSet.Union1(ho_RegionDifference, out ho_RegionUnion);
                //_AllRegs中，第一个区域为非重点区域，其他区域为重点检测区域
                ho__AllRegs.Dispose();
                HOperatorSet.ConcatObj(ho_RegionUnion, ho_i_SubReg, out ho__AllRegs);

                //连通区域个数，为逐次比较内循环次数
                HOperatorSet.CountObj(ho_ConnectedRegions, out hv__Num);
                //不能采用gen_empty_region,空区域在copy_obj时会增加一个计数值,故:没有缺陷的情况下会有报错
                ho_objRegion.Dispose();
                HOperatorSet.GenEmptyObj(out ho_objRegion);
                HTuple end_val93 = hv__NumSub;
                HTuple step_val93 = 1;
                for (hv_i = 0; hv_i.Continue(end_val93, step_val93); hv_i = hv_i.TupleAdd(step_val93))
                {
                    //第一个区域使用非重点检测区域的参数，其他区域使用重点检测区域的参数(可分别设置)
                    ho_ObjectSelected.Dispose();
                    HOperatorSet.SelectObj(ho__AllRegs, out ho_ObjectSelected, hv_i + 1);
                    ho_EmptyObject.Dispose();
                    HOperatorSet.GenEmptyObj(out ho_EmptyObject);
                    HTuple end_val97 = hv__Num;
                    HTuple step_val97 = 1;
                    for (hv_j = 1; hv_j.Continue(end_val97, step_val97); hv_j = hv_j.TupleAdd(step_val97))
                    {
                        ho_ObjectSelected1.Dispose();
                        HOperatorSet.SelectObj(ho_ConnectedRegions, out ho_ObjectSelected1, hv_j);
                        //求两个区域的交集，并计算其面积和中心，判断缺陷是否在当前检测区域内
                        ho_RegionIntersection.Dispose();
                        HOperatorSet.Intersection(ho_ObjectSelected, ho_ObjectSelected1, out ho_RegionIntersection
                            );
                        HOperatorSet.AreaCenter(ho_RegionIntersection, out hv__Area, out hv__Row,
                            out hv__Column);
                        //由于count_obj作用于RegionIntersection时，对空区域的输出也为1，故增加对面积的判断，只有面积大于0才能确保区域相交
                        if ((int)(new HTuple(hv__Area.TupleGreater(0))) != 0)
                        {
                            //将位于当前检测区域内的缺陷合并在一起
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.Union2(ho_EmptyObject, ho_RegionIntersection, out ExpTmpOutVar_0
                                    );
                                ho_EmptyObject.Dispose();
                                ho_EmptyObject = ExpTmpOutVar_0;
                            }
                        }
                    }
                    //对当前检测区域内的缺陷进行闭运算，消除内部的空洞
                    ho_RegionClosing.Dispose();
                    HOperatorSet.ClosingCircle(ho_EmptyObject, out ho_RegionClosing, hv_i_CloseSize);
                    //提取连通区域，筛选符合检测要求（超过工艺许可）的缺陷
                    ho_ConnectedRegions1.Dispose();
                    HOperatorSet.Connection(ho_RegionClosing, out ho_ConnectedRegions1);
                    //get最小rect2值比实际小0.5pixel--lw
                    ho_SelectedRegions.Dispose();
                    HOperatorSet.SelectShape(ho_ConnectedRegions1, out ho_SelectedRegions, ((new HTuple("rect2_len1")).TupleConcat(
                        "rect2_len2")).TupleConcat("area"), hv_i_SelOperation, (((((hv__Rect2Len1.TupleSelect(
                        hv_i)) - 0.5)).TupleConcat((hv__Rect2Len2.TupleSelect(hv_i)) - 0.5))).TupleConcat(
                        hv_i_MinArea_COPY_INP_TMP.TupleSelect(hv_i)), ((new HTuple(99999)).TupleConcat(
                        99999)).TupleConcat(99999));
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_objRegion, ho_SelectedRegions, out ExpTmpOutVar_0
                            );
                        ho_objRegion.Dispose();
                        ho_objRegion = ExpTmpOutVar_0;
                    }
                }
                ho_o_Targets.Dispose();
                HOperatorSet.CopyObj(ho_objRegion, out ho_o_Targets, 1, -1);
            }
            else
            {
                //没有设置重点检测区时，整个检测区都是非重点检测区，直接筛选结果输出
                ho_o_Targets.Dispose();
                HOperatorSet.SelectShape(ho_ConnectedRegions, out ho_o_Targets, ((new HTuple("rect2_len1")).TupleConcat(
                    "rect2_len2")).TupleConcat("area"), hv_i_SelOperation, ((((hv__Rect2Len1.TupleMin()
                    )).TupleConcat(hv__Rect2Len2.TupleMin()))).TupleConcat(hv_i_MinArea_COPY_INP_TMP.TupleMin()
                    ), ((new HTuple(999999)).TupleConcat(999999)).TupleConcat(999999));
            }

            hv_o_ErrCode = 0;
            hv_o_ErrStr = "blob extraction successful!";

            ho_ConnectedRegions.Dispose();
            ho_RegionDifference.Dispose();
            ho_RegionUnion.Dispose();
            ho__AllRegs.Dispose();
            ho_objRegion.Dispose();
            ho_ObjectSelected.Dispose();
            ho_EmptyObject.Dispose();
            ho_ObjectSelected1.Dispose();
            ho_RegionIntersection.Dispose();
            ho_RegionClosing.Dispose();
            ho_ConnectedRegions1.Dispose();
            ho_SelectedRegions.Dispose();

            return;
        }

        public static void HTV_PegRack_Surface_ExistRejectReg(HObject ho_i_Image, HObject ho_i_InspectReg,
            HObject ho_i_RejectRegs, HObject ho_i_SubReg, out HObject ho_o_Targets, HTuple hv_i_HomMatMod2Img,
            HTuple hv_i_GrayThresh, HTuple hv_i_CloseOrOpenSize, HTuple hv_i_LightOrDark,
            HTuple hv_i_AdaptiveMethod, HTuple hv_i_BlockSize, HTuple hv_i_Contrast, HTuple hv_i_CloseSize,
            HTuple hv_i_MinLength, HTuple hv_i_MinWidth, HTuple hv_i_MinArea, HTuple hv_i_SelOperation,
            out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
    	{




            // Local iconic variables 

            HObject ho__InspectReg, ho__Image, ho__SubReg;
            HObject ho__RejectRegs, ho_RegUnion, ho_RegionDifference;
            HObject ho_ImageReduced, ho_Region, ho_RegionOpening, ho_RegionClosing;
            HObject ho__PegRackSurfaceReg, ho_RegionErosion, ho__PegRackSurfaceImage;
            HObject ho__SegImage;

            // Local control variables 

            HTuple hv_threshNum = null, hv_lowThresh = new HTuple();
            HTuple hv_highThresh = new HTuple(), hv__ThresholdErrCode = null;
            HTuple hv__ThresholdErrStr = null, hv__BlobErrCode = new HTuple();
            HTuple hv__BlobErrStr = new HTuple(), hv_Number = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_Targets);
            HOperatorSet.GenEmptyObj(out ho__InspectReg);
            HOperatorSet.GenEmptyObj(out ho__Image);
            HOperatorSet.GenEmptyObj(out ho__SubReg);
            HOperatorSet.GenEmptyObj(out ho__RejectRegs);
            HOperatorSet.GenEmptyObj(out ho_RegUnion);
            HOperatorSet.GenEmptyObj(out ho_RegionDifference);
            HOperatorSet.GenEmptyObj(out ho_ImageReduced);
            HOperatorSet.GenEmptyObj(out ho_Region);
            HOperatorSet.GenEmptyObj(out ho_RegionOpening);
            HOperatorSet.GenEmptyObj(out ho_RegionClosing);
            HOperatorSet.GenEmptyObj(out ho__PegRackSurfaceReg);
            HOperatorSet.GenEmptyObj(out ho_RegionErosion);
            HOperatorSet.GenEmptyObj(out ho__PegRackSurfaceImage);
            HOperatorSet.GenEmptyObj(out ho__SegImage);
            //*************************************************************
            //--Frame表面检测：使用自行应阈值分割提取缺陷区域，并进行符合要求的缺陷目标提取
            // i_Image：输入图像，在图像中进行Frame表面污染检测
            // i_InspectReg：检测区域，在该区域中进行表面污染检测
            // i_RejectRegs：拒绝区域，即免检区域，一般在检测区域内部容易造成干扰的区域或不感兴趣的区域
            // i_SubReg：重点检测区域，在框架表面检测中不需要检测，为空对象
            // o_Targets：符合要求的框架缺陷目标
            // i_HomMatMod2Img: Frame模板到图像的映射矩阵--从模板到检测图像的映射关系
            // i_GrayThresh：阈值分割阈值
            // i_CloseOrOpenSize：开运算、闭运算、腐蚀、膨胀尺寸
            // i_AdaptiveMethod：局部阈值分割方法，取值为'mean'  'median'   'gauss'
            // i_BlockSize: 邻域大小，即局部阈值分割的尺寸
            // i_Contrast: 灰度对比度，即超过阈值多大的范围视为感兴趣的目标
            // i_CloseSize：闭运算尺寸
            // i_MinLength：缺陷最小外接矩形半长,为一个向量，针对各重点检测区和非重点检测区分别设置不同参数
            //　i_MinWidth：缺陷最小外接矩形半宽,为一个向量，针对各重点检测区和非重点检测区分别设置不同参数
            // i_MinArea：缺陷最小面积,为一个向量，针对各重点检测区和非重点检测区分别设置不同参数
            // i_SelOperation：形状选择算子and或or等
            // o_ErrCode: 错误码，代表该算子执行过程中产生的错误，0-代表正常执行，正整数-代表错误类型，-1-代表异常，-2-代表未执行
            // o_ErrStr: 错误信息，对各种错误的具体描述
            //***************************************************************

            //初始化
            ho_o_Targets.Dispose();
            HOperatorSet.GenEmptyObj(out ho_o_Targets);
            hv_o_ErrCode = -2;
            hv_o_ErrStr = "initializing";

            //输入参数有效性测试
            if ((int)(new HTuple((new HTuple(hv_i_GrayThresh.TupleLength())).TupleLess(1))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "paras illegal";
                ho__InspectReg.Dispose();
                ho__Image.Dispose();
                ho__SubReg.Dispose();
                ho__RejectRegs.Dispose();
                ho_RegUnion.Dispose();
                ho_RegionDifference.Dispose();
                ho_ImageReduced.Dispose();
                ho_Region.Dispose();
                ho_RegionOpening.Dispose();
                ho_RegionClosing.Dispose();
                ho__PegRackSurfaceReg.Dispose();
                ho_RegionErosion.Dispose();
                ho__PegRackSurfaceImage.Dispose();
                ho__SegImage.Dispose();

                return;
            }

            if ((int)((new HTuple((new HTuple(hv_i_CloseOrOpenSize.TupleLength())).TupleLess(
                1))).TupleOr(new HTuple(hv_i_CloseOrOpenSize.TupleLess(1)))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "the para i_OpeningSize must greater than 0";
                ho__InspectReg.Dispose();
                ho__Image.Dispose();
                ho__SubReg.Dispose();
                ho__RejectRegs.Dispose();
                ho_RegUnion.Dispose();
                ho_RegionDifference.Dispose();
                ho_ImageReduced.Dispose();
                ho_Region.Dispose();
                ho_RegionOpening.Dispose();
                ho_RegionClosing.Dispose();
                ho__PegRackSurfaceReg.Dispose();
                ho_RegionErosion.Dispose();
                ho__PegRackSurfaceImage.Dispose();
                ho__SegImage.Dispose();

                return;
            }

            //阈值分割上下限参数
            hv_threshNum = new HTuple(hv_i_GrayThresh.TupleLength());
            if ((int)(new HTuple(hv_threshNum.TupleEqual(1))) != 0)
            {
                if ((int)(new HTuple(hv_i_LightOrDark.TupleEqual("light"))) != 0)
                {
                    hv_lowThresh = hv_i_GrayThresh.Clone();
                    hv_highThresh = 255;
                }
                else
                {
                    hv_lowThresh = 0;
                    hv_highThresh = hv_i_GrayThresh.Clone();
                }
            }
            else if ((int)(new HTuple(hv_threshNum.TupleEqual(2))) != 0)
            {
                hv_lowThresh = hv_i_GrayThresh[0];
                hv_highThresh = hv_i_GrayThresh[1];
            }


            //变换检测区域并获取检测待处理图像
            ho__InspectReg.Dispose();
            HOperatorSet.AffineTransRegion(ho_i_InspectReg, out ho__InspectReg, hv_i_HomMatMod2Img,
                "nearest_neighbor");
            ho__Image.Dispose();
            HOperatorSet.ReduceDomain(ho_i_Image, ho__InspectReg, out ho__Image);
            //变换重点检测区域
            ho__SubReg.Dispose();
            HOperatorSet.AffineTransRegion(ho_i_SubReg, out ho__SubReg, hv_i_HomMatMod2Img,
                "nearest_neighbor");
            //变换拒绝区域
            ho__RejectRegs.Dispose();
            HOperatorSet.AffineTransRegion(ho_i_RejectRegs, out ho__RejectRegs, hv_i_HomMatMod2Img,
                "nearest_neighbor");
            ho_RegUnion.Dispose();
            HOperatorSet.Union1(ho__RejectRegs, out ho_RegUnion);
            //----钉架表面检测区域获取
            //去掉桥接区域
            ho_RegionDifference.Dispose();
            HOperatorSet.Difference(ho__InspectReg, ho_RegUnion, out ho_RegionDifference);
            ho_ImageReduced.Dispose();
            HOperatorSet.ReduceDomain(ho__Image, ho_RegionDifference, out ho_ImageReduced
                );

            ho_Region.Dispose();
            HOperatorSet.Threshold(ho_ImageReduced, out ho_Region, 0, hv_i_GrayThresh);
            ho_RegionOpening.Dispose();
            HOperatorSet.OpeningCircle(ho_Region, out ho_RegionOpening, hv_i_CloseOrOpenSize);
            ho_RegionClosing.Dispose();
            HOperatorSet.ClosingCircle(ho_RegionOpening, out ho_RegionClosing, hv_i_CloseOrOpenSize);
            //获取钉架检测区域
            ho__PegRackSurfaceReg.Dispose();
            HOperatorSet.Difference(ho_RegionDifference, ho_RegionClosing, out ho__PegRackSurfaceReg
                );
            ho_RegionErosion.Dispose();
            HOperatorSet.ErosionCircle(ho__PegRackSurfaceReg, out ho_RegionErosion, hv_i_CloseOrOpenSize);
            //检测图像获取
            ho__PegRackSurfaceImage.Dispose();
            HOperatorSet.ReduceDomain(ho__Image, ho_RegionErosion, out ho__PegRackSurfaceImage
                );

            //自适应提取检测区域目标
            ho__SegImage.Dispose();
            HTV_Adaptive_Threshold(ho__PegRackSurfaceImage, out ho__SegImage, hv_i_AdaptiveMethod,
                hv_i_BlockSize, hv_i_Contrast, hv_i_LightOrDark, out hv__ThresholdErrCode,
                out hv__ThresholdErrStr);

            if ((int)(new HTuple(hv__ThresholdErrCode.TupleEqual(0))) != 0)
            {
                //对阈值分割后的目标区域图像进行BLOB分析
                ho_o_Targets.Dispose();
                HTV_BLOB_Extract(ho__SegImage, ho__InspectReg, ho__SubReg, out ho_o_Targets,
                    hv_i_CloseSize, hv_i_MinLength, hv_i_MinWidth, hv_i_MinArea, hv_i_SelOperation,
                    out hv__BlobErrCode, out hv__BlobErrStr);


                //对Blob分析后的结果进行缺陷判断
                HOperatorSet.CountObj(ho_o_Targets, out hv_Number);
                if ((int)((new HTuple(hv__BlobErrCode.TupleEqual(0))).TupleAnd(new HTuple(hv_Number.TupleGreaterEqual(
                    1)))) != 0)
                {
                    hv_o_ErrCode = 1;
                    hv_o_ErrStr = "PegRack-Surface is dirty";
                    ho__InspectReg.Dispose();
                    ho__Image.Dispose();
                    ho__SubReg.Dispose();
                    ho__RejectRegs.Dispose();
                    ho_RegUnion.Dispose();
                    ho_RegionDifference.Dispose();
                    ho_ImageReduced.Dispose();
                    ho_Region.Dispose();
                    ho_RegionOpening.Dispose();
                    ho_RegionClosing.Dispose();
                    ho__PegRackSurfaceReg.Dispose();
                    ho_RegionErosion.Dispose();
                    ho__PegRackSurfaceImage.Dispose();
                    ho__SegImage.Dispose();

                    return;
                }
                else if ((int)((new HTuple(hv__BlobErrCode.TupleEqual(0))).TupleAnd(
                    new HTuple(hv_Number.TupleEqual(0)))) != 0)
                {
                    hv_o_ErrCode = 0;
                    hv_o_ErrStr = "PegRack-Surface is clear";
                    ho__InspectReg.Dispose();
                    ho__Image.Dispose();
                    ho__SubReg.Dispose();
                    ho__RejectRegs.Dispose();
                    ho_RegUnion.Dispose();
                    ho_RegionDifference.Dispose();
                    ho_ImageReduced.Dispose();
                    ho_Region.Dispose();
                    ho_RegionOpening.Dispose();
                    ho_RegionClosing.Dispose();
                    ho__PegRackSurfaceReg.Dispose();
                    ho_RegionErosion.Dispose();
                    ho__PegRackSurfaceImage.Dispose();
                    ho__SegImage.Dispose();

                    return;
                }
                else
                {
                    //异常处理
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "Fail to PegRack-Surface Blob_Extract--" + hv__BlobErrStr;
                }

            }
            else
            {
                //异常处理
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "Fail to PegRack-Surface threshold" + hv__ThresholdErrStr;
                ho__InspectReg.Dispose();
                ho__Image.Dispose();
                ho__SubReg.Dispose();
                ho__RejectRegs.Dispose();
                ho_RegUnion.Dispose();
                ho_RegionDifference.Dispose();
                ho_ImageReduced.Dispose();
                ho_Region.Dispose();
                ho_RegionOpening.Dispose();
                ho_RegionClosing.Dispose();
                ho__PegRackSurfaceReg.Dispose();
                ho_RegionErosion.Dispose();
                ho__PegRackSurfaceImage.Dispose();
                ho__SegImage.Dispose();

                return;
            }

        }

        public static void HTV_Arrange_Pos(HTuple hv_i_ModelID, HTuple hv_i_ModelType, HTuple hv_i_Rows,
            HTuple hv_i_Cols, HTuple hv_i_Angles, out HTuple hv_o_Rows, out HTuple hv_o_Cols)
        {
            // Local control variables 

            HTuple hv__Row = new HTuple(), hv__Col = new HTuple();
            HTuple hv_i = null, hv_HomMat2D = new HTuple(), hv_Row = new HTuple();
            HTuple hv_Col = new HTuple();
            // Initialize local and output iconic variables 
            hv_o_Rows = new HTuple();
            hv_o_Cols = new HTuple();



            if ((int)(new HTuple(hv_i_ModelType.TupleEqual("ncc"))) != 0)
            {
                HOperatorSet.GetNccModelOrigin(hv_i_ModelID, out hv__Row, out hv__Col);
            }
            else if ((int)(new HTuple(hv_i_ModelType.TupleEqual("shape"))) != 0)
            {
                HOperatorSet.GetShapeModelOrigin(hv_i_ModelID, out hv__Row, out hv__Col);
            }
            else
            {
                //throw new HalconException("Wrong argument [ModelType]=" + hv_i_ModelType);

                return;
            }

            for (hv_i = 0; (int)hv_i <= (int)((new HTuple(hv_i_Rows.TupleLength())) - 1); hv_i = (int)hv_i + 1)
            {
                HOperatorSet.VectorAngleToRigid(0, 0, 0, hv_i_Rows.TupleSelect(hv_i), hv_i_Cols.TupleSelect(
                    hv_i), hv_i_Angles.TupleSelect(hv_i), out hv_HomMat2D);
                HOperatorSet.AffineTransPoint2d(hv_HomMat2D, -hv__Row, -hv__Col, out hv_Row,
                    out hv_Col);
                if (hv_o_Rows == null)
                    hv_o_Rows = new HTuple();
                hv_o_Rows[hv_i] = hv_Row;
                if (hv_o_Cols == null)
                    hv_o_Cols = new HTuple();
                hv_o_Cols[hv_i] = hv_Col;
            }


            return;
        }

        #endregion


        #region  IC 检测验证

        public static void HTV_Ic_Inspect_GoldenModel(HObject ho_i_Images, HObject ho_i_LightImg,
            HObject ho_i_DarkImg, HObject ho_i_MeanImg, HObject ho_i_InspectReg, HObject ho_i_MatchReg,
            HObject ho_i_RejectRegs, HObject ho_i_SubReg, out HObject ho_o_FailRegs, out HObject ho_o_IcReg,
            HTuple hv_i_ImageIndex, HTuple hv_i_TaskEnable, HTuple hv_i_HomMatMod2Img, HTuple hv_i_refLocPara,
            HTuple hv_i_ThreshGray, HTuple hv_i_LightOrDark, HTuple hv_i_CloseSize, HTuple hv_i_IcSizeTh,
            HTuple hv_i_DilationSize, HTuple hv_i_ModelType, HTuple hv_i_ModelID, HTuple hv_i_MinScore,
            HTuple hv_i_AngleStart, HTuple hv_i_AngleExt, HTuple hv_i_MatchNum, HTuple hv_i_RowDiffTh,
            HTuple hv_i_ColDiffTh, HTuple hv_i_AngleDiffTh, HTuple hv_i_GrayContrast, HTuple hv_i_MinLength,
            HTuple hv_i_MinWidth, HTuple hv_i_MinArea, HTuple hv_i_SelOperation, HTuple hv_i_isChromatismProcess,
            HTuple hv_i_isGlobalChromatism, HTupleVector/*{eTupleVector,Dim=2}*/ hvec_i_DefectValue,
            out HTuple hv_o_LocPara, out HTuple hv_o_HomMatMod2Img, out HTuple hv_o_DefectType,
            out HTupleVector/*{eTupleVector,Dim=2}*/ hvec_o_DefectValue, out HTuple hv_o_DefectImgIdx,
            out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho__EmptyFailReg, ho__InspectReg, ho__MatchReg;
            HObject ho_i_Image = null, ho__IcInspectReg = null, ho__Targets = null;
            HObject ho_RegionUnion = null, ho__SubFailReg = null, ho_SubFailReg = null;
            HObject ho_SubFailRegConnection = null, ho__ChippingFailReg = null;
            HObject ho_ChippingFailReg = null, ho_ChippingFailRegConnection = null;

            // Local control variables 

            HTuple hv_HomMatSum = null, hv_ExistEnable = null;
            HTuple hv_LocEnable = null, hv_ShiftEnable = null, hv_SurfaceEnable = null;
            HTuple hv__ErrExistCode = new HTuple(), hv__ErrExistStr = new HTuple();
            HTuple hv__LocPara = new HTuple(), hv__Score = new HTuple();
            HTuple hv__ErrLocCode = new HTuple(), hv__ErrLocStr = new HTuple();
            HTuple hv__ReverseLocPara = new HTuple(), hv__ErrErrorCode = new HTuple();
            HTuple hv__ErrErrorStr = new HTuple(), hv_IcRow = new HTuple();
            HTuple hv_IcCol = new HTuple(), hv_IcPhi = new HTuple();
            HTuple hv_Len1 = new HTuple(), hv_Len2 = new HTuple();
            HTuple hv__DiffPara = new HTuple(), hv__IcShiftFlag = new HTuple();
            HTuple hv__ShiftErrCode = new HTuple(), hv__ShiftErrStr = new HTuple();
            HTuple hv__ErrSurfaceCode = new HTuple(), hv__ErrSurfaceStr = new HTuple();
            HTuple hv_Area = new HTuple(), hv_Row = new HTuple(), hv_Column = new HTuple();
            HTuple hv_AreaSub = new HTuple(), hv_RowSub = new HTuple();
            HTuple hv_ColumnSub = new HTuple(), hv_Area1 = new HTuple();
            HTuple hv_Row1 = new HTuple(), hv_Column1 = new HTuple();
            HTuple hv_AreaChipping = new HTuple(), hv_RowChipping = new HTuple();
            HTuple hv_ColumnChipping = new HTuple();
            HTuple hv_i_refLocPara_COPY_INP_TMP = hv_i_refLocPara.Clone();

            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_FailRegs);
            HOperatorSet.GenEmptyObj(out ho_o_IcReg);
            HOperatorSet.GenEmptyObj(out ho__EmptyFailReg);
            HOperatorSet.GenEmptyObj(out ho__InspectReg);
            HOperatorSet.GenEmptyObj(out ho__MatchReg);
            HOperatorSet.GenEmptyObj(out ho_i_Image);
            HOperatorSet.GenEmptyObj(out ho__IcInspectReg);
            HOperatorSet.GenEmptyObj(out ho__Targets);
            HOperatorSet.GenEmptyObj(out ho_RegionUnion);
            HOperatorSet.GenEmptyObj(out ho__SubFailReg);
            HOperatorSet.GenEmptyObj(out ho_SubFailReg);
            HOperatorSet.GenEmptyObj(out ho_SubFailRegConnection);
            HOperatorSet.GenEmptyObj(out ho__ChippingFailReg);
            HOperatorSet.GenEmptyObj(out ho_ChippingFailReg);
            HOperatorSet.GenEmptyObj(out ho_ChippingFailRegConnection);
            try
            {
                //**************************************************************************************************
                //---函数：HTV_Ic_Inspect_GoldenModel
                //---作用：Ic区域检测算子：1.IC是否存在 2.IC定位 3.Ic 错误检测 3.旋转、偏移检测 4.表面检测
                //---参数：
                //===图标参数
                //  i_Images：输入图像
                //  i_LightImg：亮图阈值图
                //  i_DarkImg：暗图阈值图
                //  i_InspectReg：Ic检测区域，在该区域中进行表面污染检测
                //  i_MatchReg：Ic匹配区域
                //  i_RejectRegs：拒绝区域，即免检区域，一般在检测区域内部容易造成干扰的区域或不感兴趣的区域
                //  i_SubReg：重点检测区域，在Ic表面检测中需要检测，需要输入
                //  o_FailRegs：输出检测结果的错误区域的HobjectVector
                //  o_IcReg：实际检测的IC区域
                //===控制参数
                //---传入映射矩阵
                //  i_HomMatMod2Img: Frame模板到图像的映射矩阵--从模板到检测图像的映射关系
                //---Ic存在检测参数
                //  i_ThreshGray: 阈值分割的灰度阈值，可以为1个参数（灰度上限或下限）或2个参数（灰度上下限）
                //  i_LightOrDark：IC为亮目标或暗目标
                //  i_CloseSize: 为去除孔洞干扰进行闭运算的尺寸
                //  i_IcSizeTh: Ic目标的面积阈值，可以为1个参数（面积下限）或2个参数（面积上下限）
                //---模板匹配定位参数
                //  i_DilationSize：膨胀匹配区域获取搜索区域所需要的膨胀尺寸
                //  i_ModelType：模板类型，一般使用ncc和shape作为定位模板，该参数为整数类型，0-ncc，1-shape
                //  i_ModelID：模板ID号，创建匹配模板时返回值，通常由模板文件读入
                //  i_Score：最小匹配分数
                //  i_AngleStart：匹配定位起始角度
                //  i_AngleExt：匹配定位起角度范围
                //  i_MatchNum：需要匹配的目标个数
                //---偏移、旋转检测参数
                //  i_RefRow：判断IC是否偏移行参考
                //  i_RefCol：判断IC是否偏移列参考
                //  i_RefAngle：判断IC是否旋转角度参考
                //  i_RowDiffTh: 行方向偏移阈值
                //  i_ColDiffTh: 列方向偏移阈值
                //  i_AngleDiffTh: 角度偏移阈值
                //---Ic表面检测参数：使用动态阈值分割方法
                //  i_SobelScaleFactors:边缘提取系数
                //  i_DarkScaleFactors:生成暗图系数
                //  i_LightScaleFactors：生成亮图系数
                //  i_GrayContrast: 灰度对比度，即超过阈值多大的范围视为感兴趣的目标
                //  i_MinLength：缺陷最小外接矩形半长,为一个向量，针对各重点检测区和非重点检测区分别设置不同参数
                //  i_MinWidth：缺陷最小外接矩形半宽,为一个向量，针对各重点检测区和非重点检测区分别设置不同参数
                //  i_MinArea：缺陷最小面积,为一个向量，针对各重点检测区和非重点检测区分别设置不同参数
                //  i_SelOperation：形状选择算子and或or等
                //---输出
                //  o_HomMatMod2Img：输出Ic定位到的映射矩阵
                //  o_DefectValue：输出的异常区域实际检测得到的检测值
                //  o_DefectType：输出的检测得到的异常区域的缺陷类型
                //  o_ErrCode: 错误码，代表该算子执行过程中产生的错误，0-代表正常执行，-1-代表异常，-2-代表未执行
                //  o_ErrStr: 错误信息，对各种错误的具体描述
                //**************************************************************************************************

                //Ic检测结果初始化
                ho__EmptyFailReg.Dispose();
                HOperatorSet.GenEmptyObj(out ho__EmptyFailReg);

                ho_o_FailRegs.Dispose();
                ho_o_FailRegs = ho__EmptyFailReg.CopyObj(1, -1);
                ho_o_IcReg.Dispose();
                ho_o_IcReg = ho__EmptyFailReg.CopyObj(1, -1);
                hv_o_DefectType = new HTuple();
                hv_o_DefectImgIdx = new HTuple();
                hvec_o_DefectValue = hvec_i_DefectValue.Clone();
                //Ic定位位置
                hv_o_LocPara = new HTuple();
                hv_o_LocPara[0] = -2;
                hv_o_LocPara[1] = -2;
                hv_o_LocPara[2] = -2;
                //ic定位映射矩阵
                hv_o_HomMatMod2Img = new HTuple();
                hv_o_HomMatMod2Img[0] = -2;
                hv_o_HomMatMod2Img[1] = -2;
                hv_o_HomMatMod2Img[2] = -2;
                hv_o_HomMatMod2Img[3] = -2;
                hv_o_HomMatMod2Img[4] = -2;
                hv_o_HomMatMod2Img[5] = -2;
                hv_o_ErrCode = -2;
                hv_o_ErrStr = "initializing";

                //传入映射矩阵有效性测试
                HOperatorSet.TupleSum(hv_i_HomMatMod2Img, out hv_HomMatSum);
                if ((int)(new HTuple(hv_HomMatSum.TupleEqual(-12))) != 0)
                {

                    //输出缺陷值
                    hvec_o_DefectValue[3] = (((new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(0)))).Insert(
                        1, new HTupleVector(new HTuple(0)))).Insert(2, new HTupleVector(new HTuple(0))));
                    hvec_o_DefectValue[4] = (((new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(0)))).Insert(
                        1, new HTupleVector(new HTuple(0)))).Insert(2, new HTupleVector(new HTuple(0))));

                    hv_o_ErrCode = 1;
                    hv_o_ErrStr = "mapping matrix is invalid!";
                    ho__EmptyFailReg.Dispose();
                    ho__InspectReg.Dispose();
                    ho__MatchReg.Dispose();
                    ho_i_Image.Dispose();
                    ho__IcInspectReg.Dispose();
                    ho__Targets.Dispose();
                    ho_RegionUnion.Dispose();
                    ho__SubFailReg.Dispose();
                    ho_SubFailReg.Dispose();
                    ho_SubFailRegConnection.Dispose();
                    ho__ChippingFailReg.Dispose();
                    ho_ChippingFailReg.Dispose();
                    ho_ChippingFailRegConnection.Dispose();

                    return;
                }
                //
                //-----子任务使能
                hv_ExistEnable = hv_i_TaskEnable[0];
                hv_LocEnable = hv_i_TaskEnable[1];
                hv_ShiftEnable = hv_i_TaskEnable[2];
                hv_SurfaceEnable = hv_i_TaskEnable[3];

                //-----映射各区域
                //检测区域
                ho__InspectReg.Dispose();
                HOperatorSet.AffineTransRegion(ho_i_InspectReg, out ho__InspectReg, hv_i_HomMatMod2Img,
                    "nearest_neighbor");
                //匹配区域
                ho__MatchReg.Dispose();
                HOperatorSet.AffineTransRegion(ho_i_MatchReg, out ho__MatchReg, hv_i_HomMatMod2Img,
                    "nearest_neighbor");
                //
                //-----IC检测
                //************* Ic 有无检测 *************
                if ((int)(new HTuple(hv_ExistEnable.TupleEqual(1))) != 0)
                {
                    //
                    //-----选择图像
                    ho_i_Image.Dispose();
                    HOperatorSet.SelectObj(ho_i_Images, out ho_i_Image, hv_i_ImageIndex.TupleSelect(
                        2));
                    HTV_Ic_Exist(ho_i_Image, ho__InspectReg, hv_i_DilationSize, hv_i_ThreshGray,
                        hv_i_LightOrDark, hv_i_CloseSize, hv_i_IcSizeTh, out hv__ErrExistCode,
                        out hv__ErrExistStr);
                    //参数异常处理
                    if ((int)(new HTuple(hv__ErrExistCode.TupleLess(0))) != 0)
                    {
                        hv_o_ErrCode = -1;
                        hv_o_ErrStr = "fail to HTV_Ic_Exist" + hv__ErrExistStr;
                        ho__EmptyFailReg.Dispose();
                        ho__InspectReg.Dispose();
                        ho__MatchReg.Dispose();
                        ho_i_Image.Dispose();
                        ho__IcInspectReg.Dispose();
                        ho__Targets.Dispose();
                        ho_RegionUnion.Dispose();
                        ho__SubFailReg.Dispose();
                        ho_SubFailReg.Dispose();
                        ho_SubFailRegConnection.Dispose();
                        ho__ChippingFailReg.Dispose();
                        ho_ChippingFailReg.Dispose();
                        ho_ChippingFailRegConnection.Dispose();

                        return;
                    }
                    //不存在返回
                    if ((int)(new HTuple(hv__ErrExistCode.TupleGreater(0))) != 0)
                    {
                        hv_o_DefectType = hv_o_DefectType.TupleConcat(1);
                        hv_o_DefectImgIdx = hv_o_DefectImgIdx.TupleConcat(hv_i_ImageIndex.TupleSelect(
                            2));
                        hvec_o_DefectValue[0] = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(-1))));
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(ho_o_FailRegs, ho__InspectReg, out ExpTmpOutVar_0
                                );
                            ho_o_FailRegs.Dispose();
                            ho_o_FailRegs = ExpTmpOutVar_0;
                        }
                        hv_o_ErrCode = 1;
                        hv_o_ErrStr = hv__ErrExistStr.Clone();
                        ho__EmptyFailReg.Dispose();
                        ho__InspectReg.Dispose();
                        ho__MatchReg.Dispose();
                        ho_i_Image.Dispose();
                        ho__IcInspectReg.Dispose();
                        ho__Targets.Dispose();
                        ho_RegionUnion.Dispose();
                        ho__SubFailReg.Dispose();
                        ho_SubFailReg.Dispose();
                        ho_SubFailRegConnection.Dispose();
                        ho__ChippingFailReg.Dispose();
                        ho_ChippingFailReg.Dispose();
                        ho_ChippingFailRegConnection.Dispose();

                        return;
                    }
                }
                else
                {
                    //若无该检测项，默认存在
                    hv__ErrExistCode = 0;
                    hv__ErrExistStr = "ic exist";
                }

                //************* Ic 定位 *************
                if ((int)((new HTuple(hv_LocEnable.TupleEqual(1))).TupleAnd(new HTuple(hv__ErrExistCode.TupleEqual(
                    0)))) != 0)
                {
                    //Ic定位
                    //-----选择图像
                    ho_i_Image.Dispose();
                    HOperatorSet.SelectObj(ho_i_Images, out ho_i_Image, hv_i_ImageIndex.TupleSelect(
                        0));
                    HTV_Ic_Location(ho_i_Image, ho__MatchReg, hv_i_DilationSize, hv_i_ModelType,
                        hv_i_ModelID, hv_i_MinScore, hv_i_AngleStart, hv_i_AngleExt, hv_i_MatchNum,
                        out hv__LocPara, out hv__Score, out hv__ErrLocCode, out hv__ErrLocStr);

                    if ((int)(new HTuple(hv__ErrLocCode.TupleLess(0))) != 0)
                    {
                        //参数异常
                        hv_o_ErrCode = -1;
                        hv_o_ErrStr = "fail to HTV_Ic_Location" + hv__ErrExistStr;
                        ho__EmptyFailReg.Dispose();
                        ho__InspectReg.Dispose();
                        ho__MatchReg.Dispose();
                        ho_i_Image.Dispose();
                        ho__IcInspectReg.Dispose();
                        ho__Targets.Dispose();
                        ho_RegionUnion.Dispose();
                        ho__SubFailReg.Dispose();
                        ho_SubFailReg.Dispose();
                        ho_SubFailRegConnection.Dispose();
                        ho__ChippingFailReg.Dispose();
                        ho_ChippingFailReg.Dispose();
                        ho_ChippingFailRegConnection.Dispose();

                        return;
                    }
                    else if ((int)(new HTuple(hv__ErrLocCode.TupleGreater(0))) != 0)
                    {
                        //定位失败进行反向检测
                        //Ic反向检测
                        HTV_Ic_Error(ho_i_Image, ho__InspectReg, ho__MatchReg, hv_i_HomMatMod2Img,
                            hv_i_DilationSize, hv_i_ModelType, hv_i_ModelID, hv_i_MinScore, hv_i_AngleStart,
                            hv_i_AngleExt, hv_i_MatchNum, out hv__ReverseLocPara, out hv__ErrErrorCode,
                            out hv__ErrErrorStr);

                        if ((int)(new HTuple(hv__ErrErrorCode.TupleLess(0))) != 0)
                        {
                            //参数异常
                            hv_o_ErrCode = -1;
                            hv_o_ErrStr = "fail to HTV_Ic_Error" + hv__ErrErrorStr;
                            ho__EmptyFailReg.Dispose();
                            ho__InspectReg.Dispose();
                            ho__MatchReg.Dispose();
                            ho_i_Image.Dispose();
                            ho__IcInspectReg.Dispose();
                            ho__Targets.Dispose();
                            ho_RegionUnion.Dispose();
                            ho__SubFailReg.Dispose();
                            ho_SubFailReg.Dispose();
                            ho_SubFailRegConnection.Dispose();
                            ho__ChippingFailReg.Dispose();
                            ho_ChippingFailReg.Dispose();
                            ho_ChippingFailRegConnection.Dispose();

                            return;
                        }
                        else if ((int)(new HTuple(hv__ErrErrorCode.TupleGreater(0))) != 0)
                        {
                            //反向也未找到
                            hv_o_DefectType = hv_o_DefectType.TupleConcat(5);
                            hv_o_DefectImgIdx = hv_o_DefectImgIdx.TupleConcat(hv_i_ImageIndex.TupleSelect(
                                0));
                            hvec_o_DefectValue[0] = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(-1))));
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.ConcatObj(ho_o_FailRegs, ho__InspectReg, out ExpTmpOutVar_0
                                    );
                                ho_o_FailRegs.Dispose();
                                ho_o_FailRegs = ExpTmpOutVar_0;
                            }
                            hv_o_ErrCode = 1;
                            hv_o_ErrStr = hv__ErrErrorStr.Clone();
                            ho__EmptyFailReg.Dispose();
                            ho__InspectReg.Dispose();
                            ho__MatchReg.Dispose();
                            ho_i_Image.Dispose();
                            ho__IcInspectReg.Dispose();
                            ho__Targets.Dispose();
                            ho_RegionUnion.Dispose();
                            ho__SubFailReg.Dispose();
                            ho_SubFailReg.Dispose();
                            ho_SubFailRegConnection.Dispose();
                            ho__ChippingFailReg.Dispose();
                            ho_ChippingFailReg.Dispose();
                            ho_ChippingFailRegConnection.Dispose();

                            return;
                        }
                        else
                        {
                            //反向找到也返回
                            hv_o_DefectType = hv_o_DefectType.TupleConcat(4);
                            hv_o_DefectImgIdx = hv_o_DefectImgIdx.TupleConcat(hv_i_ImageIndex.TupleSelect(
                                0));
                            hvec_o_DefectValue[0] = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(-1))));
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.ConcatObj(ho_o_FailRegs, ho__InspectReg, out ExpTmpOutVar_0
                                    );
                                ho_o_FailRegs.Dispose();
                                ho_o_FailRegs = ExpTmpOutVar_0;
                            }
                            hv_o_ErrCode = 1;
                            hv_o_ErrStr = hv__ErrErrorStr.Clone();
                            ho__EmptyFailReg.Dispose();
                            ho__InspectReg.Dispose();
                            ho__MatchReg.Dispose();
                            ho_i_Image.Dispose();
                            ho__IcInspectReg.Dispose();
                            ho__Targets.Dispose();
                            ho_RegionUnion.Dispose();
                            ho__SubFailReg.Dispose();
                            ho_SubFailReg.Dispose();
                            ho_SubFailRegConnection.Dispose();
                            ho__ChippingFailReg.Dispose();
                            ho_ChippingFailReg.Dispose();
                            ho_ChippingFailRegConnection.Dispose();

                            return;
                        }
                    }
                    else
                    {
                        //定位成功，输出位置
                        hv_o_LocPara = hv__LocPara.Clone();
                        //定位成功，输出匹配分数
                        hvec_o_DefectValue[0][0] = new HTupleVector(hv__Score).Clone();
                        //定位成功，输出映射矩阵
                        HOperatorSet.VectorAngleToRigid(0, 0, 0, hv__LocPara.TupleSelect(0), hv__LocPara.TupleSelect(
                            1), hv__LocPara.TupleSelect(2), out hv_o_HomMatMod2Img);
                        //获取使用Ic映射矩阵映射的Ic检测区域
                        ho_o_IcReg.Dispose();
                        HOperatorSet.AffineTransRegion(ho_i_InspectReg, out ho_o_IcReg, hv_o_HomMatMod2Img,
                            "nearest_neighbor");
                    }
                }

                //************* Ic 偏移、转角检测 *************
                if ((int)((new HTuple(hv_ShiftEnable.TupleEqual(1))).TupleAnd(new HTuple(hv__ErrLocCode.TupleEqual(
                    0)))) != 0)
                {
                    //
                    //IC旋转、偏移检测
                    HOperatorSet.SmallestRectangle2(ho__InspectReg, out hv_IcRow, out hv_IcCol,
                        out hv_IcPhi, out hv_Len1, out hv_Len2);
                    if ((int)((new HTuple((new HTuple(((hv_i_refLocPara_COPY_INP_TMP.TupleSelect(
                        0))).TupleEqual(0))).TupleAnd(new HTuple(((hv_i_refLocPara_COPY_INP_TMP.TupleSelect(
                        1))).TupleEqual(0))))).TupleAnd(new HTuple(((hv_i_refLocPara_COPY_INP_TMP.TupleSelect(
                        2))).TupleEqual(0)))) != 0)
                    {
                        //参考位置为芯片中心
                        if (hv_i_refLocPara_COPY_INP_TMP == null)
                            hv_i_refLocPara_COPY_INP_TMP = new HTuple();
                        hv_i_refLocPara_COPY_INP_TMP[0] = hv_IcRow;
                        if (hv_i_refLocPara_COPY_INP_TMP == null)
                            hv_i_refLocPara_COPY_INP_TMP = new HTuple();
                        hv_i_refLocPara_COPY_INP_TMP[1] = hv_IcCol;
                        if (hv_i_refLocPara_COPY_INP_TMP == null)
                            hv_i_refLocPara_COPY_INP_TMP = new HTuple();
                        hv_i_refLocPara_COPY_INP_TMP[2] = hv_IcPhi;
                    }

                    HTV_Ic_Shift_Inspect(ho_o_IcReg, hv_i_refLocPara_COPY_INP_TMP, hv_i_RowDiffTh,
                        hv_i_ColDiffTh, hv_i_AngleDiffTh, out hv__DiffPara, out hv__IcShiftFlag,
                        out hv__ShiftErrCode, out hv__ShiftErrStr);

                    if ((int)(new HTuple(hv__ShiftErrCode.TupleLess(0))) != 0)
                    {
                        //参数异常
                        hv_o_ErrCode = -1;
                        hv_o_ErrStr = "fail to HTV_Ic_Shift_Inspect" + hv__ShiftErrStr;
                        ho__EmptyFailReg.Dispose();
                        ho__InspectReg.Dispose();
                        ho__MatchReg.Dispose();
                        ho_i_Image.Dispose();
                        ho__IcInspectReg.Dispose();
                        ho__Targets.Dispose();
                        ho_RegionUnion.Dispose();
                        ho__SubFailReg.Dispose();
                        ho_SubFailReg.Dispose();
                        ho_SubFailRegConnection.Dispose();
                        ho__ChippingFailReg.Dispose();
                        ho_ChippingFailReg.Dispose();
                        ho_ChippingFailRegConnection.Dispose();

                        return;
                    }
                    if ((int)(new HTuple(hv__ShiftErrCode.TupleGreater(0))) != 0)
                    {
                        //
                        //变换偏移或旋转的Ic检测区域
                        ho__IcInspectReg.Dispose();
                        HOperatorSet.AffineTransRegion(ho_i_InspectReg, out ho__IcInspectReg, hv_o_HomMatMod2Img,
                            "nearest_neighbor");

                        //芯片偏移 or 旋转
                        if ((int)(new HTuple(((hv__IcShiftFlag.TupleSelect(0))).TupleEqual(1))) != 0)
                        {
                            //Ic偏移
                            hv_o_DefectType = hv_o_DefectType.TupleConcat(2);
                            hv_o_DefectImgIdx = hv_o_DefectImgIdx.TupleConcat(hv_i_ImageIndex.TupleSelect(
                                0));
                            hvec_o_DefectValue[1] = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(((hv__DiffPara.TupleSelect(
                                0))).TupleConcat(hv__DiffPara.TupleSelect(1))))));
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.ConcatObj(ho_o_FailRegs, ho__IcInspectReg, out ExpTmpOutVar_0
                                    );
                                ho_o_FailRegs.Dispose();
                                ho_o_FailRegs = ExpTmpOutVar_0;
                            }
                        }
                        else
                        {
                            hvec_o_DefectValue[1] = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(((hv__DiffPara.TupleSelect(
                                0))).TupleConcat(hv__DiffPara.TupleSelect(1))))));
                        }
                        //
                        if ((int)(new HTuple(((hv__IcShiftFlag.TupleSelect(1))).TupleEqual(1))) != 0)
                        {
                            //Ic旋转
                            hv_o_DefectType = hv_o_DefectType.TupleConcat(3);
                            hv_o_DefectImgIdx = hv_o_DefectImgIdx.TupleConcat(hv_i_ImageIndex.TupleSelect(
                                0));
                            hvec_o_DefectValue[2] = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(hv__DiffPara.TupleSelect(
                                2)))));
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.ConcatObj(ho_o_FailRegs, ho__IcInspectReg, out ExpTmpOutVar_0
                                    );
                                ho_o_FailRegs.Dispose();
                                ho_o_FailRegs = ExpTmpOutVar_0;
                            }
                        }
                        else
                        {
                            hvec_o_DefectValue[2] = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(hv__DiffPara.TupleSelect(
                                2)))));
                        }
                    }
                    else
                    {
                        hvec_o_DefectValue[1] = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(((hv__DiffPara.TupleSelect(
                            0))).TupleConcat(hv__DiffPara.TupleSelect(1))))));
                        hvec_o_DefectValue[2] = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(hv__DiffPara.TupleSelect(
                            2)))));
                    }
                }

                //************* Ic 表面检测 *************
                if ((int)((new HTuple(hv_SurfaceEnable.TupleEqual(1))).TupleAnd(new HTuple(hv__ErrLocCode.TupleEqual(
                    0)))) != 0)
                {
                    //
                    //Ic表面检测
                    ho_i_Image.Dispose();
                    HOperatorSet.SelectObj(ho_i_Images, out ho_i_Image, hv_i_ImageIndex.TupleSelect(
                        1));
                    ho__Targets.Dispose();
                    HTV_Ic_Surface_GoldenModel(ho_i_Image, ho_i_InspectReg, ho_i_RejectRegs,
                        ho_i_SubReg, ho_i_LightImg, ho_i_DarkImg, ho_i_MeanImg, out ho__Targets,
                        hv_o_HomMatMod2Img, hv_i_GrayContrast, hv_i_CloseSize, hv_i_MinLength,
                        hv_i_MinWidth, hv_i_MinArea, hv_i_SelOperation, hv_i_isChromatismProcess,
                        hv_i_isGlobalChromatism, out hv__ErrSurfaceCode, out hv__ErrSurfaceStr);

                    if ((int)(new HTuple(hv__ErrSurfaceCode.TupleLess(0))) != 0)
                    {
                        //参数异常
                        hv_o_ErrCode = -1;
                        hv_o_ErrStr = "fail to HTV_Ic_Surface_Threshold" + hv__ErrSurfaceStr;
                        ho__EmptyFailReg.Dispose();
                        ho__InspectReg.Dispose();
                        ho__MatchReg.Dispose();
                        ho_i_Image.Dispose();
                        ho__IcInspectReg.Dispose();
                        ho__Targets.Dispose();
                        ho_RegionUnion.Dispose();
                        ho__SubFailReg.Dispose();
                        ho_SubFailReg.Dispose();
                        ho_SubFailRegConnection.Dispose();
                        ho__ChippingFailReg.Dispose();
                        ho_ChippingFailReg.Dispose();
                        ho_ChippingFailRegConnection.Dispose();

                        return;
                    }
                    if ((int)(new HTuple(hv__ErrSurfaceCode.TupleGreater(0))) != 0)
                    {
                        //表面有异物
                        ho_RegionUnion.Dispose();
                        HOperatorSet.Union1(ho__Targets, out ho_RegionUnion);
                        //Ic区
                        ho__SubFailReg.Dispose();
                        HOperatorSet.Intersection(ho_RegionUnion, ho_i_SubReg, out ho__SubFailReg
                            );
                        HOperatorSet.AreaCenter(ho__SubFailReg, out hv_Area, out hv_Row, out hv_Column);
                        if ((int)(new HTuple(hv_Area.TupleGreater(0))) != 0)
                        {
                            hv_o_DefectType = hv_o_DefectType.TupleConcat(7);
                            hv_o_DefectImgIdx = hv_o_DefectImgIdx.TupleConcat(hv_i_ImageIndex.TupleSelect(
                                1));
                            //异物信息独立统计 lw
                            ho_SubFailReg.Dispose();
                            HOperatorSet.AffineTransRegion(ho__SubFailReg, out ho_SubFailReg, hv_o_HomMatMod2Img,
                                "nearest_neighbor");
                            ho_SubFailRegConnection.Dispose();
                            HOperatorSet.Connection(ho_SubFailReg, out ho_SubFailRegConnection);
                            HOperatorSet.AreaCenter(ho_SubFailRegConnection, out hv_AreaSub, out hv_RowSub,
                                out hv_ColumnSub);
                            hvec_o_DefectValue[3] = (((new HTupleVector(1).Insert(0, new HTupleVector(hv_AreaSub))).Insert(
                                1, new HTupleVector(hv_RowSub))).Insert(2, new HTupleVector(hv_ColumnSub)));
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.ConcatObj(ho_o_FailRegs, ho_SubFailReg, out ExpTmpOutVar_0
                                    );
                                ho_o_FailRegs.Dispose();
                                ho_o_FailRegs = ExpTmpOutVar_0;
                            }
                        }
                        else
                        {
                            hvec_o_DefectValue[3] = (((new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(0)))).Insert(
                                1, new HTupleVector(new HTuple(0)))).Insert(2, new HTupleVector(new HTuple(0))));
                        }
                        //崩边区
                        ho__ChippingFailReg.Dispose();
                        HOperatorSet.Difference(ho_RegionUnion, ho__SubFailReg, out ho__ChippingFailReg
                            );
                        HOperatorSet.AreaCenter(ho__ChippingFailReg, out hv_Area1, out hv_Row1,
                            out hv_Column1);
                        if ((int)(hv_Area1) != 0)
                        {
                            hv_o_DefectType = hv_o_DefectType.TupleConcat(8);
                            hv_o_DefectImgIdx = hv_o_DefectImgIdx.TupleConcat(hv_i_ImageIndex.TupleSelect(
                                1));
                            //异物信息独立统计 lw
                            ho_ChippingFailReg.Dispose();
                            HOperatorSet.AffineTransRegion(ho__ChippingFailReg, out ho_ChippingFailReg,
                                hv_o_HomMatMod2Img, "nearest_neighbor");
                            ho_ChippingFailRegConnection.Dispose();
                            HOperatorSet.Connection(ho_ChippingFailReg, out ho_ChippingFailRegConnection
                                );
                            HOperatorSet.AreaCenter(ho_ChippingFailRegConnection, out hv_AreaChipping,
                                out hv_RowChipping, out hv_ColumnChipping);
                            hvec_o_DefectValue[4] = (((new HTupleVector(1).Insert(0, new HTupleVector(hv_AreaChipping))).Insert(
                                1, new HTupleVector(hv_RowChipping))).Insert(2, new HTupleVector(hv_ColumnChipping)));
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.ConcatObj(ho_o_FailRegs, ho_ChippingFailReg, out ExpTmpOutVar_0
                                    );
                                ho_o_FailRegs.Dispose();
                                ho_o_FailRegs = ExpTmpOutVar_0;
                            }
                        }
                        else
                        {
                            hvec_o_DefectValue[4] = (((new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(0)))).Insert(
                                1, new HTupleVector(new HTuple(0)))).Insert(2, new HTupleVector(new HTuple(0))));
                        }
                    }
                    else
                    {
                        //输出缺陷值
                        hvec_o_DefectValue[3] = (((new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(0)))).Insert(
                            1, new HTupleVector(new HTuple(0)))).Insert(2, new HTupleVector(new HTuple(0))));
                        hvec_o_DefectValue[4] = (((new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(0)))).Insert(
                            1, new HTupleVector(new HTuple(0)))).Insert(2, new HTupleVector(new HTuple(0))));
                    }
                }

                //结果判断
                if ((int)(new HTuple((new HTuple(hv_o_DefectType.TupleLength())).TupleGreater(
                    0))) != 0)
                {
                    hv_o_ErrCode = 1;
                    hv_o_ErrStr = "ic has defect";
                    ho__EmptyFailReg.Dispose();
                    ho__InspectReg.Dispose();
                    ho__MatchReg.Dispose();
                    ho_i_Image.Dispose();
                    ho__IcInspectReg.Dispose();
                    ho__Targets.Dispose();
                    ho_RegionUnion.Dispose();
                    ho__SubFailReg.Dispose();
                    ho_SubFailReg.Dispose();
                    ho_SubFailRegConnection.Dispose();
                    ho__ChippingFailReg.Dispose();
                    ho_ChippingFailReg.Dispose();
                    ho_ChippingFailRegConnection.Dispose();

                    return;
                }
                else
                {
                    //正常项输出0错误码和ResultReg
                    hv_o_DefectType = hv_o_DefectType.TupleConcat(0);
                    hv_o_DefectImgIdx = hv_o_DefectImgIdx.TupleConcat(hv_i_ImageIndex.TupleSelect(
                        0));

                    ho__IcInspectReg.Dispose();
                    HOperatorSet.AffineTransRegion(ho_i_InspectReg, out ho__IcInspectReg, hv_o_HomMatMod2Img,
                        "nearest_neighbor");
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_o_FailRegs, ho__IcInspectReg, out ExpTmpOutVar_0
                            );
                        ho_o_FailRegs.Dispose();
                        ho_o_FailRegs = ExpTmpOutVar_0;
                    }

                    hv_o_ErrCode = 0;
                    hv_o_ErrStr = "ic is OK";
                    ho__EmptyFailReg.Dispose();
                    ho__InspectReg.Dispose();
                    ho__MatchReg.Dispose();
                    ho_i_Image.Dispose();
                    ho__IcInspectReg.Dispose();
                    ho__Targets.Dispose();
                    ho_RegionUnion.Dispose();
                    ho__SubFailReg.Dispose();
                    ho_SubFailReg.Dispose();
                    ho_SubFailRegConnection.Dispose();
                    ho__ChippingFailReg.Dispose();
                    ho_ChippingFailReg.Dispose();
                    ho_ChippingFailRegConnection.Dispose();

                    return;
                }


            }
            catch (HalconException HDevExpDefaultException)
            {
                ho__EmptyFailReg.Dispose();
                ho__InspectReg.Dispose();
                ho__MatchReg.Dispose();
                ho_i_Image.Dispose();
                ho__IcInspectReg.Dispose();
                ho__Targets.Dispose();
                ho_RegionUnion.Dispose();
                ho__SubFailReg.Dispose();
                ho_SubFailReg.Dispose();
                ho_SubFailRegConnection.Dispose();
                ho__ChippingFailReg.Dispose();
                ho_ChippingFailReg.Dispose();
                ho_ChippingFailRegConnection.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public static void HTV_Ic_Exist(HObject ho_i_Image, HObject ho_i_InspectReg, HTuple hv_i_DilationSize,
    		HTuple hv_i_ThreshGray, HTuple hv_i_LightOrDark, HTuple hv_i_ClosingSize, HTuple hv_i_IcSizeTh,
    		out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {




            // Local iconic variables 

            HObject ho__InspectReg, ho_InspectImg, ho_Region;
            HObject ho_RegionOpening1, ho_RegionOpening, ho_ConnectedRegions;
            HObject ho__IcReg;

            // Local control variables 

            HTuple hv_imgNum = null, hv_regNum = null;
            HTuple hv_IsString = null, hv_threshNum = null, hv_lowThresh = new HTuple();
            HTuple hv_highThresh = new HTuple(), hv_minSize = null;
            HTuple hv_maxSize = new HTuple(), hv_Width = new HTuple();
            HTuple hv_Height = new HTuple(), hv__ErrCode = null, hv__ErrStr = null;
            HTuple hv_IcNum = null;
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho__InspectReg);
            HOperatorSet.GenEmptyObj(out ho_InspectImg);
            HOperatorSet.GenEmptyObj(out ho_Region);
            HOperatorSet.GenEmptyObj(out ho_RegionOpening1);
            HOperatorSet.GenEmptyObj(out ho_RegionOpening);
            HOperatorSet.GenEmptyObj(out ho_ConnectedRegions);
            HOperatorSet.GenEmptyObj(out ho__IcReg);
            //***********************************采用阈值分割的方式进行IC检测区域有无IC进行存在检测
            //i_Image：输入图像
            //i_InspectReg：矩形搜索区域
            //i_DilationSize：区域膨胀因子
            //i_ThreshGray: 阈值分割的灰度阈值，可以为1个参数（灰度上限或下限）或2个参数（灰度上下限）
            //i_LightOrDark：IC为亮目标或暗目标
            //i_ClosingSize: 为去除孔洞干扰进行闭运算的尺寸
            //i_EpoxySizeTh: 银胶目标的面积阈值，可以为1个参数（面积下限）或2个参数（面积上下限）
            //o_ErrCode: 错误码，代表该算子执行过程中产生的错误，0-代表正常执行，自然数-代表错误类型，-1-代表异常，-2-代表未执行
            //o_ErrStr: 错误信息，对各种错误的具体描述


            //初始化
            hv_o_ErrCode = -2;
            hv_o_ErrStr = "initializing";
            //输入有效性测试
            HOperatorSet.CountObj(ho_i_Image, out hv_imgNum);
            if ((int)(new HTuple(hv_imgNum.TupleEqual(0))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "input image is null";
                ho__InspectReg.Dispose();
                ho_InspectImg.Dispose();
                ho_Region.Dispose();
                ho_RegionOpening1.Dispose();
                ho_RegionOpening.Dispose();
                ho_ConnectedRegions.Dispose();
                ho__IcReg.Dispose();

                return;
            }
            if ((int)(new HTuple((new HTuple(hv_i_ThreshGray.TupleLength())).TupleLess(1))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "paras illegal";
                ho__InspectReg.Dispose();
                ho_InspectImg.Dispose();
                ho_Region.Dispose();
                ho_RegionOpening1.Dispose();
                ho_RegionOpening.Dispose();
                ho_ConnectedRegions.Dispose();
                ho__IcReg.Dispose();

                return;
            }
            HOperatorSet.CountObj(ho_i_InspectReg, out hv_regNum);
            if ((int)(new HTuple(hv_regNum.TupleLess(1))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "Epoxy inspect region empty";
                ho__InspectReg.Dispose();
                ho_InspectImg.Dispose();
                ho_Region.Dispose();
                ho_RegionOpening1.Dispose();
                ho_RegionOpening.Dispose();
                ho_ConnectedRegions.Dispose();
                ho__IcReg.Dispose();

                return;
            }
            HOperatorSet.TupleIsString(hv_i_LightOrDark, out hv_IsString);
            if ((int)(new HTuple(hv_IsString.TupleEqual("false"))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "the para i_LightOrDark must be a string";
                ho__InspectReg.Dispose();
                ho_InspectImg.Dispose();
                ho_Region.Dispose();
                ho_RegionOpening1.Dispose();
                ho_RegionOpening.Dispose();
                ho_ConnectedRegions.Dispose();
                ho__IcReg.Dispose();

                return;
            }
            if ((int)((new HTuple((new HTuple(hv_i_ClosingSize.TupleLength())).TupleLess(
                1))).TupleOr(new HTuple(hv_i_ClosingSize.TupleLess(1)))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "the para i_OpeningSize must greater than 0";
                ho__InspectReg.Dispose();
                ho_InspectImg.Dispose();
                ho_Region.Dispose();
                ho_RegionOpening1.Dispose();
                ho_RegionOpening.Dispose();
                ho_ConnectedRegions.Dispose();
                ho__IcReg.Dispose();

                return;
            }
            if ((int)((new HTuple((new HTuple(hv_i_IcSizeTh.TupleLength())).TupleLess(1))).TupleOr(
                new HTuple(((hv_i_IcSizeTh.TupleSelect(0))).TupleLess(1)))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "the para i_EpoxySizeTh must be one integer greater than 0 at least";
                ho__InspectReg.Dispose();
                ho_InspectImg.Dispose();
                ho_Region.Dispose();
                ho_RegionOpening1.Dispose();
                ho_RegionOpening.Dispose();
                ho_ConnectedRegions.Dispose();
                ho__IcReg.Dispose();

                return;
            }
            //阈值分割上下限参数
            hv_threshNum = new HTuple(hv_i_ThreshGray.TupleLength());
            if ((int)(new HTuple(hv_threshNum.TupleEqual(1))) != 0)
            {
                if ((int)(new HTuple(hv_i_LightOrDark.TupleEqual("light"))) != 0)
                {
                    hv_lowThresh = hv_i_ThreshGray.Clone();
                    hv_highThresh = 255;
                }
                else
                {
                    hv_lowThresh = 0;
                    hv_highThresh = hv_i_ThreshGray.Clone();
                }
            }
            else if ((int)(new HTuple(hv_threshNum.TupleEqual(2))) != 0)
            {
                hv_lowThresh = hv_i_ThreshGray[0];
                hv_highThresh = hv_i_ThreshGray[1];
            }
            //目标区域面积上下限
            hv_minSize = hv_i_IcSizeTh[0];
            if ((int)(new HTuple((new HTuple(hv_i_IcSizeTh.TupleLength())).TupleGreater(1))) != 0)
            {
                hv_maxSize = hv_i_IcSizeTh[1];
            }
            else
            {
                HOperatorSet.GetImageSize(ho_i_Image, out hv_Width, out hv_Height);
                hv_maxSize = hv_Width * hv_Height;
            }
            //对区域进行膨胀
            ho__InspectReg.Dispose();
            HTV_region_dilation(ho_i_InspectReg, out ho__InspectReg, hv_i_DilationSize, out hv__ErrCode,
                out hv__ErrStr);
            //异常处理
            if ((int)(new HTuple(hv__ErrCode.TupleLess(0))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = hv__ErrStr.Clone();
                ho__InspectReg.Dispose();
                ho_InspectImg.Dispose();
                ho_Region.Dispose();
                ho_RegionOpening1.Dispose();
                ho_RegionOpening.Dispose();
                ho_ConnectedRegions.Dispose();
                ho__IcReg.Dispose();

                return;
            }
            //对Ic检测区域进行阈值分割
            ho_InspectImg.Dispose();
            HOperatorSet.ReduceDomain(ho_i_Image, ho__InspectReg, out ho_InspectImg);
            ho_Region.Dispose();
            HOperatorSet.Threshold(ho_InspectImg, out ho_Region, hv_lowThresh, hv_highThresh);
            //形态学处理：去除金线、孔洞干扰
            ho_RegionOpening1.Dispose();
            HOperatorSet.OpeningCircle(ho_Region, out ho_RegionOpening1, hv_i_ClosingSize);
            ho_RegionOpening.Dispose();
            HOperatorSet.ClosingCircle(ho_RegionOpening1, out ho_RegionOpening, hv_i_ClosingSize);
            ho_ConnectedRegions.Dispose();
            HOperatorSet.Connection(ho_RegionOpening, out ho_ConnectedRegions);
            ho__IcReg.Dispose();
            HOperatorSet.SelectShape(ho_ConnectedRegions, out ho__IcReg, "area", "and", hv_minSize,
                hv_maxSize);

            //判断IC检测区域有无IC
            HOperatorSet.CountObj(ho__IcReg, out hv_IcNum);
            if ((int)(hv_IcNum) != 0)
            {
                hv_o_ErrCode = 0;
                hv_o_ErrStr = "ic exist";
                ho__InspectReg.Dispose();
                ho_InspectImg.Dispose();
                ho_Region.Dispose();
                ho_RegionOpening1.Dispose();
                ho_RegionOpening.Dispose();
                ho_ConnectedRegions.Dispose();
                ho__IcReg.Dispose();

                return;
            }
            else
            {
                hv_o_ErrCode = 1;
                hv_o_ErrStr = "ic does not exist!";
                ho__InspectReg.Dispose();
                ho_InspectImg.Dispose();
                ho_Region.Dispose();
                ho_RegionOpening1.Dispose();
                ho_RegionOpening.Dispose();
                ho_ConnectedRegions.Dispose();
                ho__IcReg.Dispose();

                return;
            }
        }

        public static void HTV_Ic_Error(HObject ho_i_Image, HObject ho_i_InspectReg, HObject ho_i_MatchReg,
            HTuple hv_i_HomMatMod2Img, HTuple hv_i_DilationSize, HTuple hv_i_ModelType,
            HTuple hv_i_ModelID, HTuple hv_i_Score, HTuple hv_i_AngleStart, HTuple hv_i_AngleExt,
            HTuple hv_i_MatchNum, out HTuple hv_o_LocPara, out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {




            // Local iconic variables 

            HObject ho__InspectReg, ho__IcMatchImage, ho_ImageAffinTrans;
            HObject ho__SearchReg;

            // Local control variables 

            HTuple hv_Area = null, hv_Row = null, hv_Column = null;
            HTuple hv_HomMat2D = null, hv_HomMat2DRotate = null, hv__ErrInspectRegDilCode = null;
            HTuple hv__ErrInspectRegDilStr = null, hv__ErrDilCode = null;
            HTuple hv__ErrDilStr = null, hv_o_Score = null, hv__ErrLocCode = null;
            HTuple hv__ErrLocStr = null;
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho__InspectReg);
            HOperatorSet.GenEmptyObj(out ho__IcMatchImage);
            HOperatorSet.GenEmptyObj(out ho_ImageAffinTrans);
            HOperatorSet.GenEmptyObj(out ho__SearchReg);
            try
            {
                //*************测试IC是否反向：使用旋转图像，再次进行匹配的定位的方法
                // i_Image：输入图像，在图像中寻找匹配对象
                // i_InspectReg：Ic检测区域
                // i_MatchReg: Ic匹配区域
                // i_HomMatMod2Img: Frame模板到图像的映射矩阵--从模板到检测图像的映射关系
                // i_DilationSize：膨胀匹配区域获取搜索区域所需要的膨胀尺寸
                // i_ModelType: 模板类型，一般使用ncc和shape定位模板，该参数为整型类型，0-ncc，1-shape
                // i_ModelID: 模板ID号，创建匹配模板时返回值，通常由模板文件读入
                // i_Score: 最小匹配分数
                // i_AngleStart: 匹配定位起始角度
                // i_AngleExt: 匹配定位角度范围
                // i_MatchNum: 需要匹配的目标个数
                // o_LocPara：Ic反向定位结果
                // o_ErrCode: 错误码，代表该算子执行过程中产生的错误，0-代表正常执行，正整数-代表错误类型，-1-代表异常，-2-代表未执行
                // o_ErrStr: 错误信息，对各种错误的具体描述
                //***************************************************************
                //初始化
                hv_o_ErrCode = -2;
                hv_o_ErrStr = "initializing";
                hv_o_LocPara = new HTuple();
                //计算芯片中心,应该传入芯片外接矩形框
                HOperatorSet.AreaCenter(ho_i_InspectReg, out hv_Area, out hv_Row, out hv_Column);
                HOperatorSet.HomMat2dIdentity(out hv_HomMat2D);
                HOperatorSet.HomMat2dRotate(hv_HomMat2D, (new HTuple(180)).TupleRad(), hv_Row,
                    hv_Column, out hv_HomMat2DRotate);
                //检测图像区域膨胀
                ho__InspectReg.Dispose();
                HTV_region_dilation(ho_i_InspectReg, out ho__InspectReg, hv_i_DilationSize,
                    out hv__ErrInspectRegDilCode, out hv__ErrInspectRegDilStr);
                //异常处理
                if ((int)(new HTuple(hv__ErrInspectRegDilCode.TupleLess(0))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "fail to dilation ic inspect region dilation";
                    ho__InspectReg.Dispose();
                    ho__IcMatchImage.Dispose();
                    ho_ImageAffinTrans.Dispose();
                    ho__SearchReg.Dispose();

                    return;
                }

                //获取区域图像
                ho__IcMatchImage.Dispose();
                HOperatorSet.ReduceDomain(ho_i_Image, ho__InspectReg, out ho__IcMatchImage);
                //反转匹配图像
                ho_ImageAffinTrans.Dispose();
                HOperatorSet.AffineTransImage(ho__IcMatchImage, out ho_ImageAffinTrans, hv_HomMat2DRotate,
                    "constant", "false");
                //IC搜索区域获取
                ho__SearchReg.Dispose();
                HTV_region_dilation(ho_i_MatchReg, out ho__SearchReg, hv_i_DilationSize, out hv__ErrDilCode,
                    out hv__ErrDilStr);
                //异常处理
                if ((int)(new HTuple(hv__ErrDilCode.TupleLess(0))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "fail to dilation ic match region dilation";
                    ho__InspectReg.Dispose();
                    ho__IcMatchImage.Dispose();
                    ho_ImageAffinTrans.Dispose();
                    ho__SearchReg.Dispose();

                    return;
                }
                HTV_Loc_Match(ho_ImageAffinTrans, ho__SearchReg, hv_i_ModelType, hv_i_ModelID,
                    hv_i_Score, hv_i_AngleStart, hv_i_AngleExt, hv_i_MatchNum, out hv_o_LocPara,
                    out hv_o_Score, out hv__ErrLocCode, out hv__ErrLocStr);
                //出现异常
                if ((int)(new HTuple(hv__ErrLocCode.TupleLess(0))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = hv__ErrLocStr.Clone();
                    ho__InspectReg.Dispose();
                    ho__IcMatchImage.Dispose();
                    ho_ImageAffinTrans.Dispose();
                    ho__SearchReg.Dispose();

                    return;
                }
                if ((int)(new HTuple(hv__ErrLocCode.TupleGreater(0))) != 0)
                {
                    hv_o_ErrCode = 1;
                    hv_o_ErrStr = "fail to reverse locate Ic !";
                    ho__InspectReg.Dispose();
                    ho__IcMatchImage.Dispose();
                    ho_ImageAffinTrans.Dispose();
                    ho__SearchReg.Dispose();

                    return;
                }
                else
                {
                    hv_o_ErrCode = 0;
                    hv_o_ErrStr = "succeed to reverse locate Ic";
                    ho__InspectReg.Dispose();
                    ho__IcMatchImage.Dispose();
                    ho_ImageAffinTrans.Dispose();
                    ho__SearchReg.Dispose();

                    return;
                }









            }
            catch (HalconException HDevExpDefaultException)
            {
                ho__InspectReg.Dispose();
                ho__IcMatchImage.Dispose();
                ho_ImageAffinTrans.Dispose();
                ho__SearchReg.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public static void HTV_Ic_Shift_Inspect(HObject ho_i_IcInspectReg, HTuple hv_i_RefLocPara,
            HTuple hv_i_RowDiffTh, HTuple hv_i_ColDiffTh, HTuple hv_i_AngleDiffTh, out HTuple hv_o_DiffPara,
            out HTuple hv_o_IcShiftFlag, out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {




            // Local iconic variables 

            // Local control variables 

            HTuple hv__IcRow = null, hv__IcColumn = null;
            HTuple hv__IcPhi = null, hv_Length1 = null, hv_Length2 = null;
            HTuple hv__RefRow = null, hv__RefColumn = null, hv__RefPhi = null;
            HTuple hv__RowDiff = null, hv__ColDiff = null, hv__AngleDiff = null;
            HTuple hv_Index = null;
            // Initialize local and output iconic variables 
            //****************************************
            //---图标输入参数
            // i_RefMatchReg：使用Frame映射矩阵映射后的Ic匹配区域
            // i_MatchReg：模板中画的Ic匹配区域
            //----控制参数
            // i_HomMatMod2Img：IC定位后的映射矩阵
            // i_RowDiffTh: 行方向偏移阈值
            // i_ColDiffTh: 列方向偏移阈值
            // i_AngleDiffTh: 角度偏移阈值
            // o_DiffPara：Ic实际偏移量
            // o_ErrCode: 错误码，代表该算子执行过程中产生的错误，0-代表正常执行，正整数-代表错误类型，-1-代表异常，-2-代表未执行
            // o_ErrStr: 错误信息，对各种错误的具体描述
            //*****************************************
            //初始化
            hv_o_ErrCode = -2;
            hv_o_ErrStr = "initializing";
            hv_o_DiffPara = new HTuple();
            hv_o_IcShiftFlag = new HTuple();
            //
            //输入参数合理性判断
            if ((int)((new HTuple((new HTuple(hv_i_RowDiffTh.TupleLength())).TupleEqual(0))).TupleOr(
                new HTuple(hv_i_RowDiffTh.TupleLess(0)))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "i_RowDiffTh is illegal";

                return;
            }
            if ((int)((new HTuple((new HTuple(hv_i_ColDiffTh.TupleLength())).TupleEqual(0))).TupleOr(
                new HTuple(hv_i_ColDiffTh.TupleLess(0)))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "i_ColDiffTh is illegal";

                return;
            }
            if ((int)((new HTuple((new HTuple(hv_i_AngleDiffTh.TupleLength())).TupleEqual(
                0))).TupleOr(new HTuple(hv_i_AngleDiffTh.TupleLess(0)))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "i_AngleDiffTh is illegal";

                return;
            }
            //
            //-------进行Ic偏移、旋转检测
            //
            //获取Ic检测区域真实位置及角度
            HOperatorSet.SmallestRectangle2(ho_i_IcInspectReg, out hv__IcRow, out hv__IcColumn,
                out hv__IcPhi, out hv_Length1, out hv_Length2);
            //获取框架参考位置及角度
            hv__RefRow = hv_i_RefLocPara[0];
            hv__RefColumn = hv_i_RefLocPara[1];
            hv__RefPhi = hv_i_RefLocPara[2];
            //计算偏移量
            hv__RowDiff = ((hv__RefRow - hv__IcRow)).TupleAbs();
            hv__ColDiff = ((hv__RefColumn - hv__IcColumn)).TupleAbs();
            hv__AngleDiff = ((hv__RefPhi - hv__IcPhi)).TupleAbs();

            //转换角度Angle
            if ((int)(new HTuple(((hv__AngleDiff.TupleAbs())).TupleGreater(1.5))) != 0)
            {
                if ((int)(new HTuple(hv__AngleDiff.TupleGreater(0))) != 0)
                {
                    hv__AngleDiff = ((new HTuple(180)).TupleRad()) - hv__AngleDiff;
                }
                else
                {
                    hv__AngleDiff = ((new HTuple(180)).TupleRad()) + hv__AngleDiff;
                }
            }
            hv_o_DiffPara = ((((hv_o_DiffPara.TupleConcat(hv__RowDiff))).TupleConcat(hv__ColDiff))).TupleConcat(
                hv__AngleDiff);
            //判断IC是否偏移或旋转
            if ((int)((new HTuple(hv__RowDiff.TupleGreater(hv_i_RowDiffTh))).TupleOr(new HTuple(hv__ColDiff.TupleGreater(
                hv_i_ColDiffTh)))) != 0)
            {
                if (hv_o_IcShiftFlag == null)
                    hv_o_IcShiftFlag = new HTuple();
                hv_o_IcShiftFlag[0] = 1;
            }
            else
            {
                if (hv_o_IcShiftFlag == null)
                    hv_o_IcShiftFlag = new HTuple();
                hv_o_IcShiftFlag[0] = 0;
            }
            if ((int)(new HTuple(hv__AngleDiff.TupleGreater(hv_i_AngleDiffTh))) != 0)
            {
                if (hv_o_IcShiftFlag == null)
                    hv_o_IcShiftFlag = new HTuple();
                hv_o_IcShiftFlag[1] = 1;
            }
            else
            {
                if (hv_o_IcShiftFlag == null)
                    hv_o_IcShiftFlag = new HTuple();
                hv_o_IcShiftFlag[1] = 0;
            }

            //
            HOperatorSet.TupleFindFirst(hv_o_IcShiftFlag, 1, out hv_Index);
            if ((int)(new HTuple(hv_Index.TupleGreaterEqual(0))) != 0)
            {
                hv_o_ErrCode = 1;
                hv_o_ErrStr = "ic is shift!";

                return;
            }
            else
            {
                hv_o_ErrCode = 0;
                hv_o_ErrStr = "ic is Ok!";

                return;
            }
        }

        public static void HTV_Ic_Surface_GoldenModel(HObject ho_i_Image, HObject ho_i_InspectReg,
            HObject ho_i_RejectRegs, HObject ho_i_SubReg, HObject ho_i_LightImg, HObject ho_i_DarkImg,
            HObject ho_i_MeanImg, out HObject ho_o_Targets, HTuple hv_i_HomMatMod2Img, HTuple hv_i_GrayContrast,
            HTuple hv_i_CloseSize, HTuple hv_i_MinLength, HTuple hv_i_MinWidth, HTuple hv_i_MinArea,
            HTuple hv_i_SelOperation, HTuple hv_i_isChromatismProcess, HTuple hv_i_isGlobalChromatism,
            out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {




            // Local iconic variables 

            HObject ho_RegionUnion, ho__InspectReg, ho_ImageAffinTrans;
            HObject ho__IcSurfaceImg, ho__SegImage, ho__IcSurfaceImg0 = null;
            HObject ho__MeanImg0 = null, ho__SubImg = null, ho__SegImageDilation = null;
            HObject ho__ImgZero = null, ho_i_LightImgNew = null, ho_i_DarkImgNew = null;
            HObject ho__IcSurfaceImgNew = null;

            // Local control variables 

            HTuple hv_HomMatImg2Model = null, hv__ThresholdErrCode = null;
            HTuple hv__ThresholdErrStr = null, hv_RegArea = null, hv_RegRow = null;
            HTuple hv_RegCol = null, hv_MinArea = null, hv_BinNum = new HTuple();
            HTuple hv_Histo = new HTuple(), hv_BinSize = new HTuple();
            HTuple hv_PeakGray = new HTuple(), hv_GrayDiff = new HTuple();
            HTuple hv_Width = new HTuple(), hv_Height = new HTuple();
            HTuple hv__BlobErrCode = new HTuple(), hv__BlobErrStr = new HTuple();
            HTuple hv_Number = new HTuple(), hv_dilation_size = new HTuple(); 
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_Targets);
            HOperatorSet.GenEmptyObj(out ho_RegionUnion);
            HOperatorSet.GenEmptyObj(out ho__InspectReg);
            HOperatorSet.GenEmptyObj(out ho_ImageAffinTrans);
            HOperatorSet.GenEmptyObj(out ho__IcSurfaceImg);
            HOperatorSet.GenEmptyObj(out ho__SegImage);
            HOperatorSet.GenEmptyObj(out ho__IcSurfaceImg0);
            HOperatorSet.GenEmptyObj(out ho__MeanImg0);
            HOperatorSet.GenEmptyObj(out ho__SubImg);
            HOperatorSet.GenEmptyObj(out ho__SegImageDilation);
            HOperatorSet.GenEmptyObj(out ho__ImgZero);
            HOperatorSet.GenEmptyObj(out ho_i_LightImgNew);
            HOperatorSet.GenEmptyObj(out ho_i_DarkImgNew);
            HOperatorSet.GenEmptyObj(out ho__IcSurfaceImgNew);
            try
            {
                //***************************使用亮暗图像进行IC动态阈值分割提取IC表面被污染的区域，并进行符合要求的缺陷目标进行提取
                //i_Image: 输入图像
                //i_InspectReg：检测区域，在该区域中进行表面污染检测
                //i_RejectRegs: 拒绝区域，即免检区域，一般在检测区域内部容易造成干扰的区域或不感兴趣的区域
                //i_SubReg：重点检测区域，在IC表面检测中需要进行检测，需要输入
                //i_LightImg：Ic检测的亮图
                //i_DarkImg：Ic检测的暗图
                //o_Targets：符合要求的IC缺陷目标
                //i_HomMatMod2Img: Ic模板到图像的映射矩阵--从模板到检测图像的映射关系
                //i_GrayContrast: 灰度对比度，即超过阈值多大的范围视为感兴趣的目标
                //i_CloseSize: 闭运算尺寸，对图像分割的原始结果进行形态学处理，消除内部的干扰成分
                //i_MinLength：缺陷最小外接矩形半长,为一个向量，针对各重点检测区和非重点检测区分别设置不同参数
                //i_MinWidth：缺陷最小外接矩形半宽,为一个向量，针对各重点检测区和非重点检测区分别设置不同参数
                //i_MinArea：缺陷最小面积,为一个向量，针对各重点检测区和非重点检测区分别设置不同参数
                //i_SelOperation：形状选择算子and或or等
                //o_ErrCode: 错误码，代表该算子执行过程中产生的错误，0-代表正常执行，正整数-代表错误类型，-1-代表异常，-2-代表未执行
                //o_ErrStr: 错误信息，对各种错误的具体描述

                //初始化

                ho_o_Targets.Dispose();
                HOperatorSet.GenEmptyObj(out ho_o_Targets);
                hv_o_ErrCode = -2;
                hv_o_ErrStr = "initializing";

                //获取检测区域、图像
                ho_RegionUnion.Dispose();
                HOperatorSet.Union1(ho_i_RejectRegs, out ho_RegionUnion);
                ho__InspectReg.Dispose();
                HOperatorSet.Difference(ho_i_InspectReg, ho_RegionUnion, out ho__InspectReg
                    );
                //align image(affine trans image to model)
                HOperatorSet.HomMat2dInvert(hv_i_HomMatMod2Img, out hv_HomMatImg2Model);
                //将检测区域图像映射到model
                ho_ImageAffinTrans.Dispose();
                HOperatorSet.AffineTransImage(ho_i_Image, out ho_ImageAffinTrans, hv_HomMatImg2Model,
                    "constant", "false");
                //获取检测区域图像
                ho__IcSurfaceImg.Dispose();
                HOperatorSet.ReduceDomain(ho_ImageAffinTrans, ho__InspectReg, out ho__IcSurfaceImg
                    );

                ho__SegImage.Dispose();
                HTV_GlodenModel_Threshold(ho__IcSurfaceImg, ho_i_LightImg, ho_i_DarkImg, out ho__SegImage,
                    hv_i_GrayContrast, hv_i_CloseSize, out hv__ThresholdErrCode, out hv__ThresholdErrStr);

                //异常处理
                if ((int)(new HTuple(hv__ThresholdErrCode.TupleLess(0))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = hv__ThresholdErrStr.Clone();
                    ho_RegionUnion.Dispose();
                    ho__InspectReg.Dispose();
                    ho_ImageAffinTrans.Dispose();
                    ho__IcSurfaceImg.Dispose();
                    ho__SegImage.Dispose();
                    ho__IcSurfaceImg0.Dispose();
                    ho__MeanImg0.Dispose();
                    ho__SubImg.Dispose();
                    ho__SegImageDilation.Dispose();
                    ho__ImgZero.Dispose();
                    ho_i_LightImgNew.Dispose();
                    ho_i_DarkImgNew.Dispose();
                    ho__IcSurfaceImgNew.Dispose();

                    return;
                }
                //
                //针对色差图处理优化-add by lw 20201020
                HOperatorSet.AreaCenter(ho__SegImage, out hv_RegArea, out hv_RegRow, out hv_RegCol);
                hv_MinArea = ((hv_i_MinArea.TupleSelect(0))).TupleMin2(hv_i_MinArea.TupleSelect(
                    1));
                if ((int)(hv_i_isChromatismProcess.TupleAnd(new HTuple(hv_RegArea.TupleGreater(
                    hv_MinArea)))) != 0)
                {
                    //计算色差
                    ho__IcSurfaceImg0.Dispose();
                    HOperatorSet.ConvertImageType(ho__IcSurfaceImg, out ho__IcSurfaceImg0, "int2");
                    ho__MeanImg0.Dispose();
                    HOperatorSet.ConvertImageType(ho_i_MeanImg, out ho__MeanImg0, "int2");
                    ho__SubImg.Dispose();
                    HOperatorSet.SubImage(ho__IcSurfaceImg0, ho__MeanImg0, out ho__SubImg, 1.0,
                        0);
                    hv_BinNum = 128;
                    if ((int)(hv_i_isGlobalChromatism) != 0)
                    {
                        //整体色差
                        HOperatorSet.GrayHistoRange(ho__InspectReg, ho__SubImg, -256, 255, hv_BinNum,
                            out hv_Histo, out hv_BinSize);
                    }
                    else
                    {
                        //局部色差
                        hv_dilation_size = (((2 * hv_RegArea)).TupleSqrt()) - (hv_RegArea.TupleSqrt());
                        hv_dilation_size = hv_dilation_size.TupleMax2(5);
                        ho__SegImageDilation.Dispose();
                        HOperatorSet.DilationCircle(ho__SegImage, out ho__SegImageDilation, hv_dilation_size);
                        HOperatorSet.GrayHistoRange(ho__SegImageDilation, ho__SubImg, -256, 255,
                            hv_BinNum, out hv_Histo, out hv_BinSize);
                    }
                    hv_PeakGray = ((hv_Histo.TupleSortIndex())).TupleSelect(hv_BinNum - 1);
                    hv_GrayDiff = (hv_PeakGray - (hv_BinNum / 2)) * hv_BinSize;
                    if ((int)(new HTuple(((hv_GrayDiff.TupleAbs())).TupleGreater(hv_BinSize))) != 0)
                    {
                        //整图偏移
                        HOperatorSet.GetImageSize(ho_i_MeanImg, out hv_Width, out hv_Height);
                        ho__ImgZero.Dispose();
                        HOperatorSet.GenImageConst(out ho__ImgZero, "byte", hv_Width, hv_Height);
                        ho_i_LightImgNew.Dispose();
                        HOperatorSet.AddImage(ho_i_LightImg, ho__ImgZero, out ho_i_LightImgNew,
                            1.0, hv_GrayDiff);
                        ho_i_DarkImgNew.Dispose();
                        HOperatorSet.AddImage(ho_i_DarkImg, ho__ImgZero, out ho_i_DarkImgNew, 1.0,
                            hv_GrayDiff);
                        //二次分割
                        ho__IcSurfaceImgNew.Dispose();
                        HOperatorSet.ReduceDomain(ho__IcSurfaceImg, ho__SegImage, out ho__IcSurfaceImgNew
                            );
                        ho__SegImage.Dispose();
                        HTV_GlodenModel_Threshold(ho__IcSurfaceImgNew, ho_i_LightImgNew, ho_i_DarkImgNew,
                            out ho__SegImage, hv_i_GrayContrast, hv_i_CloseSize, out hv__ThresholdErrCode,
                            out hv__ThresholdErrStr);

                        //若仍存在大面积分割区域再次分割
                        HOperatorSet.AreaCenter(ho__SegImage, out hv_RegArea, out hv_RegRow, out hv_RegCol);
                        if ((int)(new HTuple(hv_RegArea.TupleGreater(100 * hv_MinArea))) != 0)
                        {
                            ho__SegImageDilation.Dispose();
                            HOperatorSet.DilationCircle(ho__SegImage, out ho__SegImageDilation, 5);
                            HOperatorSet.GrayHistoRange(ho__SegImageDilation, ho__SubImg, -256, 255,
                                hv_BinNum, out hv_Histo, out hv_BinSize);
                            hv_PeakGray = ((hv_Histo.TupleSortIndex())).TupleSelect(hv_BinNum - 1);
                            hv_GrayDiff = (hv_PeakGray - (hv_BinNum / 2)) * hv_BinSize;

                            if ((int)(new HTuple(((hv_GrayDiff.TupleAbs())).TupleGreater(hv_BinSize))) != 0)
                            {
                                //整图偏移
                                HOperatorSet.GetImageSize(ho_i_MeanImg, out hv_Width, out hv_Height);
                                ho__ImgZero.Dispose();
                                HOperatorSet.GenImageConst(out ho__ImgZero, "byte", hv_Width, hv_Height);
                                ho_i_LightImgNew.Dispose();
                                HOperatorSet.AddImage(ho_i_LightImg, ho__ImgZero, out ho_i_LightImgNew,
                                    1.0, hv_GrayDiff);
                                ho_i_DarkImgNew.Dispose();
                                HOperatorSet.AddImage(ho_i_DarkImg, ho__ImgZero, out ho_i_DarkImgNew,
                                    1.0, hv_GrayDiff);
                                //三次分割
                                ho__IcSurfaceImgNew.Dispose();
                                HOperatorSet.ReduceDomain(ho__IcSurfaceImg, ho__SegImage, out ho__IcSurfaceImgNew
                                    );
                                ho__SegImage.Dispose();
                                HTV_GlodenModel_Threshold(ho__IcSurfaceImgNew, ho_i_LightImgNew, ho_i_DarkImgNew,
                                    out ho__SegImage, hv_i_GrayContrast, hv_i_CloseSize, out hv__ThresholdErrCode,
                                    out hv__ThresholdErrStr);
                            }
                        }

                        //异常处理
                        if ((int)(new HTuple(hv__ThresholdErrCode.TupleLess(0))) != 0)
                        {
                            hv_o_ErrCode = -1;
                            hv_o_ErrStr = hv__ThresholdErrStr.Clone();
                            ho_RegionUnion.Dispose();
                            ho__InspectReg.Dispose();
                            ho_ImageAffinTrans.Dispose();
                            ho__IcSurfaceImg.Dispose();
                            ho__SegImage.Dispose();
                            ho__IcSurfaceImg0.Dispose();
                            ho__MeanImg0.Dispose();
                            ho__SubImg.Dispose();
                            ho__SegImageDilation.Dispose();
                            ho__ImgZero.Dispose();
                            ho_i_LightImgNew.Dispose();
                            ho_i_DarkImgNew.Dispose();
                            ho__IcSurfaceImgNew.Dispose();

                            return;
                        }
                    }
                }
                //
                if ((int)(new HTuple(hv__ThresholdErrCode.TupleEqual(0))) != 0)
                {
                    //对阈值分割后的目标区域图像进行BLOB分析
                    ho_o_Targets.Dispose();
                    HTV_BLOB_Extract(ho__SegImage, ho__InspectReg, ho_i_SubReg, out ho_o_Targets,
                        hv_i_CloseSize, hv_i_MinLength, hv_i_MinWidth, hv_i_MinArea, hv_i_SelOperation,
                        out hv__BlobErrCode, out hv__BlobErrStr);
                    //异常
                    if ((int)(new HTuple(hv__BlobErrCode.TupleLess(0))) != 0)
                    {
                        hv_o_ErrCode = -1;
                        hv_o_ErrStr = hv__BlobErrStr.Clone();
                        ho_RegionUnion.Dispose();
                        ho__InspectReg.Dispose();
                        ho_ImageAffinTrans.Dispose();
                        ho__IcSurfaceImg.Dispose();
                        ho__SegImage.Dispose();
                        ho__IcSurfaceImg0.Dispose();
                        ho__MeanImg0.Dispose();
                        ho__SubImg.Dispose();
                        ho__SegImageDilation.Dispose();
                        ho__ImgZero.Dispose();
                        ho_i_LightImgNew.Dispose();
                        ho_i_DarkImgNew.Dispose();
                        ho__IcSurfaceImgNew.Dispose();

                        return;
                    }

                    //对Blob分析后的结果进行缺陷判断
                    HOperatorSet.CountObj(ho_o_Targets, out hv_Number);
                    if ((int)(new HTuple(hv_Number.TupleEqual(0))) != 0)
                    {
                        hv_o_ErrCode = 0;
                        hv_o_ErrStr = "ic-Surface is clear";
                        ho_RegionUnion.Dispose();
                        ho__InspectReg.Dispose();
                        ho_ImageAffinTrans.Dispose();
                        ho__IcSurfaceImg.Dispose();
                        ho__SegImage.Dispose();
                        ho__IcSurfaceImg0.Dispose();
                        ho__MeanImg0.Dispose();
                        ho__SubImg.Dispose();
                        ho__SegImageDilation.Dispose();
                        ho__ImgZero.Dispose();
                        ho_i_LightImgNew.Dispose();
                        ho_i_DarkImgNew.Dispose();
                        ho__IcSurfaceImgNew.Dispose();

                        return;
                    }
                    else
                    {
                        hv_o_ErrCode = 1;
                        hv_o_ErrStr = "ic-Surface is dirty";
                        ho_RegionUnion.Dispose();
                        ho__InspectReg.Dispose();
                        ho_ImageAffinTrans.Dispose();
                        ho__IcSurfaceImg.Dispose();
                        ho__SegImage.Dispose();
                        ho__IcSurfaceImg0.Dispose();
                        ho__MeanImg0.Dispose();
                        ho__SubImg.Dispose();
                        ho__SegImageDilation.Dispose();
                        ho__ImgZero.Dispose();
                        ho_i_LightImgNew.Dispose();
                        ho_i_DarkImgNew.Dispose();
                        ho__IcSurfaceImgNew.Dispose();

                        return;
                    }
                }


            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_RegionUnion.Dispose();
                ho__InspectReg.Dispose();
                ho_ImageAffinTrans.Dispose();
                ho__IcSurfaceImg.Dispose();
                ho__SegImage.Dispose();
                ho__IcSurfaceImg0.Dispose();
                ho__MeanImg0.Dispose();
                ho__SubImg.Dispose();
                ho__SegImageDilation.Dispose();
                ho__ImgZero.Dispose();
                ho_i_LightImgNew.Dispose();
                ho_i_DarkImgNew.Dispose();
                ho__IcSurfaceImgNew.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public static void HTV_region_dilation(HObject ho_i_MatchReg, out HObject ho_o_MatchReDilation,
            HTuple hv_i_DilationSize, out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {




            // Local iconic variables 

            HObject ho_RegionUnion, ho_RegionTrans;
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_MatchReDilation);
            HOperatorSet.GenEmptyObj(out ho_RegionUnion);
            HOperatorSet.GenEmptyObj(out ho_RegionTrans);
            //****  对匹配区域进行膨胀
            //i_MatchReg输入的区域变量，即待膨胀区域；
            //o_MatchRegDilation输出的膨胀结果的区域；
            //i_DilationSize控制膨胀大小的输入控制参数；
            //o_ErrCode输出的错误信号码；
            //o_ErrString输出的错误信息；

            //初始化
            hv_o_ErrCode = 0;
            hv_o_ErrStr = "initializing";
            //输入参数有效性判断
            if ((int)((new HTuple((new HTuple(hv_i_DilationSize.TupleLength())).TupleEqual(
                0))).TupleOr(new HTuple(hv_i_DilationSize.TupleLess(0)))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "i_DilationSize is illegal";
                ho_RegionUnion.Dispose();
                ho_RegionTrans.Dispose();

                return;
            }

            //对输入的匹配区域进行膨胀处理

            ho_RegionUnion.Dispose();
            HOperatorSet.Union1(ho_i_MatchReg, out ho_RegionUnion);
            ho_RegionTrans.Dispose();
            HOperatorSet.ShapeTrans(ho_RegionUnion, out ho_RegionTrans, "rectangle1");
            if ((int)(new HTuple(hv_i_DilationSize.TupleNotEqual(0))) != 0)
            {
                ho_o_MatchReDilation.Dispose();
                HOperatorSet.DilationRectangle1(ho_RegionTrans, out ho_o_MatchReDilation, hv_i_DilationSize,
                    hv_i_DilationSize);
            }
            else
            {
                ho_o_MatchReDilation.Dispose();
                ho_o_MatchReDilation = ho_RegionTrans.CopyObj(1, -1);
            }

            hv_o_ErrCode = 0;
            hv_o_ErrStr = "match region dilation successful";
            ho_RegionUnion.Dispose();
            ho_RegionTrans.Dispose();

            return;
        }

        public static void HTV_GlodenModel_Threshold(HObject ho_i_Image, HObject ho_i_ImageLight,
            HObject ho_i_ImageDark, out HObject ho_o_SegImage, HTuple hv_i_GrayContrast,
            HTuple hv_i_ClosingSize, out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho__darkRegion, ho__lightRegion;

            // Local control variables 

            HTuple hv_imgNum = null, hv_lightNum = null;
            HTuple hv_darkNum = null;
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_SegImage);
            HOperatorSet.GenEmptyObj(out ho__darkRegion);
            HOperatorSet.GenEmptyObj(out ho__lightRegion);
            //**********    基于黄金模板图像进行动态阈值分割
            //i_Image: 待处理图像，要求时reduce_domain之后的目标区域图像
            //i_ImageLight: 亮图像，黄金模板比对阈值分割的阈值上限图像
            //i_ImageDark: 暗图像，黄金模板比对阈值分割的阈值下限图像
            //i_RejectRegs: 拒绝区域，即免检区域，一般在检测区域内部容易造成干扰的区域或不感兴趣的区域
            //o_SegImage: 阈值分割后的目标区域图像，常用于接下来的BLOB分析
            //i_GrayContrast: 灰度对比度，即超过阈值多大的范围视为感兴趣的目标
            //i_ClosingSize: 闭运算尺寸，对图像分割的原始结果进行形态学处理，消除内部的干扰成分
            //o_ErrCode: 错误码，代表该算子执行过程中产生的错误，0-代表正常执行，自然数-代表错误类型，-1-代表异常，-2-代表未执行
            //o_ErrStr: 错误信息，对各种错误的具体描述

            //初始化
            ho_o_SegImage.Dispose();
            HOperatorSet.GenEmptyObj(out ho_o_SegImage);
            hv_o_ErrCode = -2;
            hv_o_ErrStr = "initializing";

            //输入合法性分析
            //输入图像
            HOperatorSet.CountObj(ho_i_Image, out hv_imgNum);
            if ((int)(new HTuple(hv_imgNum.TupleEqual(0))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "input image is null";
                ho__darkRegion.Dispose();
                ho__lightRegion.Dispose();

                return;
            }
            //亮图像
            HOperatorSet.CountObj(ho_i_ImageLight, out hv_lightNum);
            if ((int)(new HTuple(hv_lightNum.TupleEqual(0))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "Light image is null";
                ho__darkRegion.Dispose();
                ho__lightRegion.Dispose();

                return;
            }
            //暗图像
            HOperatorSet.CountObj(ho_i_ImageDark, out hv_darkNum);
            if ((int)(new HTuple(hv_darkNum.TupleEqual(0))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "dark image is null";
                ho__darkRegion.Dispose();
                ho__lightRegion.Dispose();

                return;
            }
            //其他参数
            if ((int)((new HTuple((new HTuple(hv_i_GrayContrast.TupleLength())).TupleEqual(
                0))).TupleOr(new HTuple(hv_i_GrayContrast.TupleLess(0)))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "i_GrayContrast must be greater than 0";
                ho__darkRegion.Dispose();
                ho__lightRegion.Dispose();

                return;
            }
            if ((int)((new HTuple((new HTuple(hv_i_ClosingSize.TupleLength())).TupleEqual(
                0))).TupleOr(new HTuple(hv_i_ClosingSize.TupleLess(0)))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "i_ClosingSize must be greater than 0";
                ho__darkRegion.Dispose();
                ho__lightRegion.Dispose();

                return;
            }

            //算法主体
            //逐像素进行比较，保留亮暗图像限定的图像区域
            ho__darkRegion.Dispose();
            HOperatorSet.DynThreshold(ho_i_Image, ho_i_ImageDark, out ho__darkRegion, hv_i_GrayContrast.TupleSelect(
                0), "dark");
            ho__lightRegion.Dispose();
            HOperatorSet.DynThreshold(ho_i_Image, ho_i_ImageLight, out ho__lightRegion, hv_i_GrayContrast.TupleSelect(
                1), "light");
            ho_o_SegImage.Dispose();
            HOperatorSet.Union2(ho__darkRegion, ho__lightRegion, out ho_o_SegImage);
            //形态学处理：闭运算
            {
                HObject ExpTmpOutVar_0;
                HOperatorSet.ClosingCircle(ho_o_SegImage, out ExpTmpOutVar_0, hv_i_ClosingSize.TupleMin()
                    );
                ho_o_SegImage.Dispose();
                ho_o_SegImage = ExpTmpOutVar_0;
            }

            hv_o_ErrCode = 0;
            hv_o_ErrStr = "Golden Model threshold successful";

            ho__darkRegion.Dispose();
            ho__lightRegion.Dispose();

            return;
        }

        public static void HTV_Ic_Location(HObject ho_i_Image, HObject ho_i_MatchReg, HTuple hv_i_DilationSize,
            HTuple hv_i_ModelType, HTuple hv_i_ModelID, HTuple hv_i_Score, HTuple hv_i_AngleStart,
            HTuple hv_i_AngleExt, HTuple hv_i_MatchNum, out HTuple hv_o_LocPara, out HTuple hv_o_Score,
            out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {




            // Local iconic variables 

            HObject ho__SearchReg;

            // Local control variables 

            HTuple hv__ErrDilCode = null, hv__ErrDilStr = null;
            HTuple hv__ErrLocCode = null, hv__ErrLocStr = null;
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho__SearchReg);
            hv_o_Score = new HTuple();
            try
            {
                //**********     通过模板匹配的方式定位目标
                // i_Image: 输入图像，在图像中寻找匹配对象
                // i_MatchReg: 搜索区域，在区域内匹配目标对象
                // i_DilationSize：膨胀匹配区域获取搜索区域所需要的膨胀尺寸
                // i_ModelType: 模板类型，一般使用ncc和shape定位模板，该参数为整型类型，0-ncc，1-shape
                // i_ModelID: 模板ID号，创建匹配模板时返回值，通常由模板文件读入
                // i_Score: 最小匹配分数
                // i_AngleStart: 匹配定位起始角度
                // i_AngleExt: 匹配定位角度范围
                // i_MatchNum: 需要匹配的目标个数
                // o_LocPara：Ic实际定位结果
                // o_ErrCode: 错误码，代表该算子执行过程中产生的错误，0-代表正常执行，正整数-代表错误类型，-1-代表异常，-2-代表未执行
                // o_ErrStr: 错误信息，对各种错误的具体描述

                //初始化
                hv_o_ErrCode = -2;
                hv_o_ErrStr = "initializing";
                hv_o_LocPara = new HTuple();
                //
                //----------进行IC定位、偏移、旋转检测
                //IC搜索区域获取
                ho__SearchReg.Dispose();
                HTV_region_dilation(ho_i_MatchReg, out ho__SearchReg, hv_i_DilationSize, out hv__ErrDilCode,
                    out hv__ErrDilStr);
                //异常处理
                if ((int)(new HTuple(hv__ErrDilCode.TupleLess(0))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = hv__ErrDilStr.Clone();
                    ho__SearchReg.Dispose();

                    return;
                }
                //
                //IC定位
                HTV_Loc_Match(ho_i_Image, ho__SearchReg, hv_i_ModelType, hv_i_ModelID, hv_i_Score,
                    hv_i_AngleStart, hv_i_AngleExt, hv_i_MatchNum, out hv_o_LocPara, out hv_o_Score,
                    out hv__ErrLocCode, out hv__ErrLocStr);
                //出现异常
                if ((int)(new HTuple(hv__ErrLocCode.TupleLess(0))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = hv__ErrLocStr.Clone();
                    ho__SearchReg.Dispose();

                    return;
                }
                //
                if ((int)(new HTuple(hv__ErrLocCode.TupleGreater(0))) != 0)
                {
                    hv_o_ErrCode = 1;
                    hv_o_ErrStr = "fail to locate Ic !";
                    ho__SearchReg.Dispose();

                    return;
                }
                else
                {
                    hv_o_ErrCode = 0;
                    hv_o_ErrStr = "ic location successful";
                    ho__SearchReg.Dispose();

                    return;
                }
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho__SearchReg.Dispose();

                throw HDevExpDefaultException;
            }
        }
        #endregion


        #region  //更新 20200709

        public static void HTV_confirm_mapping_matrix(HObject ho_i_Imgs, HObject ho_i_SearchReg,
            HTuple hv_i_ModelPath, HTuple hv_i_RecipePath, HTuple hv_i_PosTo, out HTuple hv_o_HomMat2D,
            out HTuple hv_o_frameLocPara, out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {




            // Local iconic variables 

            HObject ho_Frame_matchReg = null, ho_FrameRegion = null;
            HObject ho_i_Image = null, ho_icMatch_Region = null, ho__MatchReg = null;
            HObject ho__SearchReg = null;

            // Local control variables 

            HTuple hv_IsString = null, hv_FrameNumMatches = null;
            HTuple hv_IcNumMatches = null, hv__Path = null, hv__filePath = new HTuple();
            HTuple hv_FileExists = new HTuple(), hv_frameImage_Index = new HTuple();
            HTuple hv_frameModelType = new HTuple(), hv_ItemFiles = new HTuple();
            HTuple hv__PosModelItem = new HTuple(), hv_framePosModel = new HTuple();
            HTuple hv_idx = new HTuple(), hv__PosModel = new HTuple();
            HTuple hv__xmlPath = new HTuple(), hv_frameMinMatchScore = new HTuple();
            HTuple hv_frameMatchStartAngle = new HTuple(), hv_frameMatchAngleExt = new HTuple();
            HTuple hv_frameMatchNum = new HTuple(), hv_frameDilationSize = new HTuple();
            HTuple hv_o_Scores = new HTuple(), hv__frameErrCode = new HTuple();
            HTuple hv__frameErrStr = new HTuple(), hv_icImage_Index = new HTuple();
            HTuple hv_icModelType = new HTuple(), hv_icPosModel = new HTuple();
            HTuple hv_icOnWhat = new HTuple(), hv_icDilationSize = new HTuple();
            HTuple hv_icMinMatchScore = new HTuple(), hv_icMatchStartAngle = new HTuple();
            HTuple hv_icMatchAngleExt = new HTuple(), hv_icMatchNum = new HTuple();
            HTuple hv__PosHomMat2D = new HTuple(), hv__ErrDilCode = new HTuple();
            HTuple hv__ErrDilStr = new HTuple(), hv__icLocPara = new HTuple();
            HTuple hv__icScore = new HTuple(), hv__icLocErrCode = new HTuple();
            HTuple hv__icLocErrStr = new HTuple();

            HTupleVector hvec_LoadedElements = new HTupleVector(2);
            HTupleVector hvec_ParameterVector = new HTupleVector(3), hvec_subParameterVector = new HTupleVector(2);
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_Frame_matchReg);
            HOperatorSet.GenEmptyObj(out ho_FrameRegion);
            HOperatorSet.GenEmptyObj(out ho_i_Image);
            HOperatorSet.GenEmptyObj(out ho_icMatch_Region);
            HOperatorSet.GenEmptyObj(out ho__MatchReg);
            HOperatorSet.GenEmptyObj(out ho__SearchReg);
            try
            {
                //*******************************************
                //---输入图标参数
                //i_Image：匹配定位的图像
                //i_SearchReg：Die搜索区域
                //---输入控制参数
                //i_ModelPath ：存放模板的路径，一般指Moldes下的文件
                //i_PosTo：位置归属标志
                //---输出控制参数
                //o_HomMat2D：活得的映射矩阵
                //o_ErrCode：错误码，代表该算子在执行过程中产生的错误，0-代表执行正常，-1-代表执行异常，-2-代表未执行
                //o_ErrStr: 错误信息，对各种错误的具体描述
                //*********************************************
                //初始化
                //
                hv_o_ErrCode = -2;
                hv_o_ErrStr = "initializing!";
                //
                hv_o_HomMat2D = new HTuple();
                hv_o_HomMat2D[0] = -2;
                hv_o_HomMat2D[1] = -2;
                hv_o_HomMat2D[2] = -2;
                hv_o_HomMat2D[3] = -2;
                hv_o_HomMat2D[4] = -2;
                hv_o_HomMat2D[5] = -2;

                hv_o_frameLocPara = new HTuple();
                hv_o_frameLocPara[0] = -2;
                hv_o_frameLocPara[1] = -2;
                hv_o_frameLocPara[2] = -2;
                //
                //传入有效性测试
                HOperatorSet.TupleIsString(hv_i_ModelPath, out hv_IsString);
                if ((int)((new HTuple(hv_IsString.TupleEqual("false"))).TupleOr(new HTuple((new HTuple(hv_i_ModelPath.TupleLength()
                    )).TupleEqual(0)))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "the para i_ModelPath must be a string and the para |i_ModelPath| must greater than 0";
                    ho_Frame_matchReg.Dispose();
                    ho_FrameRegion.Dispose();
                    ho_i_Image.Dispose();
                    ho_icMatch_Region.Dispose();
                    ho__MatchReg.Dispose();
                    ho__SearchReg.Dispose();

                    return;
                }
                HOperatorSet.TupleIsString(hv_i_PosTo, out hv_IsString);
                if ((int)((new HTuple(hv_IsString.TupleEqual("false"))).TupleOr(new HTuple((new HTuple(hv_i_PosTo.TupleLength()
                    )).TupleEqual(0)))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "the para i_PosTo must be a string and the para |i_PosTo| must greater than 0";
                    ho_Frame_matchReg.Dispose();
                    ho_FrameRegion.Dispose();
                    ho_i_Image.Dispose();
                    ho_icMatch_Region.Dispose();
                    ho__MatchReg.Dispose();
                    ho__SearchReg.Dispose();

                    return;
                }
                //
                //*************************************获取映射矩阵***************************
                //-------确定检测区域检测项隶属于哪个大区域
                //属于Frame*，属于FrameNumMatches>0,否FrameNumMatches = 0
                HOperatorSet.TupleRegexpTest(hv_i_PosTo, "Frame*", out hv_FrameNumMatches);
                //属于IC*，属于IcNumMatches>0,否IcNumMatches = 0
                HOperatorSet.TupleRegexpTest(hv_i_PosTo, "IC*", out hv_IcNumMatches);
                //
                hv__Path = (hv_i_ModelPath + hv_i_PosTo) + "/";
                //
                if ((int)(hv_FrameNumMatches) != 0)
                {
                    //
                    //1-------读取Frame定位相关模板文件
                    //框架定位匹配区域
                    hv__filePath = hv__Path + "Match_Region.reg";
                    HOperatorSet.FileExists(hv__filePath, out hv_FileExists);
                    if ((int)(hv_FileExists) != 0)
                    {
                        ho_Frame_matchReg.Dispose();
                        HOperatorSet.ReadRegion(out ho_Frame_matchReg, hv__filePath);
                    }
                    else
                    {
                        ho_Frame_matchReg.Dispose();
                        HOperatorSet.GenEmptyObj(out ho_Frame_matchReg);
                    }
                    //框架所在区域
                    hv__filePath = hv__Path + "FrameRegion.reg";
                    HOperatorSet.FileExists(hv__filePath, out hv_FileExists);
                    if ((int)(hv_FileExists) != 0)
                    {
                        ho_FrameRegion.Dispose();
                        HOperatorSet.ReadRegion(out ho_FrameRegion, hv__filePath);
                    }
                    else
                    {
                        ho_FrameRegion.Dispose();
                        HOperatorSet.GenEmptyObj(out ho_FrameRegion);
                    }
                    //读取制作模板所用图序
                    hv__filePath = hv__Path + "Image_Index.tup";
                    HOperatorSet.ReadTuple(hv__filePath, out hv_frameImage_Index);
                    //
                    hv__filePath = hv__Path + "Model_Type.tup";
                    HOperatorSet.ReadTuple(hv__filePath, out hv_frameModelType);
                    //
                    //确定posmodel的个数
                    HOperatorSet.ListFiles(hv__Path, "files", out hv_ItemFiles);
                    HOperatorSet.TupleRegexpSelect(hv_ItemFiles, "PosModel.*", out hv__PosModelItem);
                    hv_framePosModel = new HTuple();
                    for (hv_idx = 0; (int)hv_idx <= (int)((new HTuple(hv__PosModelItem.TupleLength()
                        )) - 1); hv_idx = (int)hv_idx + 1)
                    {
                        //
                        hv__filePath = hv__PosModelItem.TupleSelect(hv_idx);
                        //
                        if ((int)(new HTuple(hv_frameModelType.TupleEqual("ncc"))) != 0)
                        {
                            HOperatorSet.ReadNccModel(hv__filePath, out hv__PosModel);
                            hv_framePosModel = hv_framePosModel.TupleConcat(hv__PosModel);
                        }
                        else if ((int)(new HTuple(hv_frameModelType.TupleEqual("shape"))) != 0)
                        {
                            HOperatorSet.ReadShapeModel(hv__filePath, out hv__PosModel);
                            hv_framePosModel = hv_framePosModel.TupleConcat(hv__PosModel);
                        }
                    }
                    //
                    //2-------读取Frame定位相关参数
                    hv__xmlPath = (hv_i_RecipePath + hv_i_PosTo) + "/FrameRecipe.xml";
                    //遍历Frame定位、检测所有参数
                    fread_xml_to_vector(hv__xmlPath, out hvec_LoadedElements);
                    //Frame检测参数
                    get_subvector_param(hvec_LoadedElements, "FrameLocateParameter", "/FrameLocateParameter",
                        out hvec_ParameterVector);
                    //
                    //选取参数
                    hvec_subParameterVector = hvec_ParameterVector[0];
                    //定位参数
                    get_vector_param_value(hvec_subParameterVector, "MinMatchScore", out hv_frameMinMatchScore);
                    get_vector_param_value(hvec_subParameterVector, "AngleStart", out hv_frameMatchStartAngle);
                    get_vector_param_value(hvec_subParameterVector, "AngleExt", out hv_frameMatchAngleExt);
                    get_vector_param_value(hvec_subParameterVector, "MatchNum", out hv_frameMatchNum);
                    get_vector_param_value(hvec_subParameterVector, "DilationSize", out hv_frameDilationSize);

                    //多匹配区域进行框架定位
                    ho_i_Image.Dispose();
                    HOperatorSet.SelectObj(ho_i_Imgs, out ho_i_Image, hv_frameImage_Index.TupleSelect(
                        0));
                    //
                    HTV_multi_match_region_location_frame(ho_i_Image, ho_i_SearchReg, ho_Frame_matchReg,
                        ho_FrameRegion, hv_frameModelType, hv_framePosModel, hv_frameDilationSize,
                        hv_frameMinMatchScore, hv_frameMatchStartAngle, hv_frameMatchAngleExt,
                        hv_frameMatchNum, out hv_o_frameLocPara, out hv_o_HomMat2D, out hv_o_Scores,
                        out hv__frameErrCode, out hv__frameErrStr);
                    if ((int)(new HTuple(hv__frameErrCode.TupleNotEqual(0))) != 0)
                    {
                        //
                        hv_o_ErrCode = 1;
                        hv_o_ErrStr = "Pos location is fail!";
                        ho_Frame_matchReg.Dispose();
                        ho_FrameRegion.Dispose();
                        ho_i_Image.Dispose();
                        ho_icMatch_Region.Dispose();
                        ho__MatchReg.Dispose();
                        ho__SearchReg.Dispose();

                        return;
                    }
                    else
                    {
                        //清除模板
                        HTV_clear_model(hv_framePosModel, hv_frameModelType);
                        //
                    }


                }
                else if ((int)(hv_IcNumMatches) != 0)
                {
                    //
                    //1------读取Ic定位相关模板文件
                    //IC匹配区域
                    hv__filePath = hv__Path + "Match_Region.reg";
                    ho_icMatch_Region.Dispose();
                    HOperatorSet.ReadRegion(out ho_icMatch_Region, hv__filePath);
                    //读取制作模板所用图序
                    hv__filePath = hv__Path + "Image_Index.tup";
                    HOperatorSet.ReadTuple(hv__filePath, out hv_icImage_Index);
                    //读取IC定位模板参数
                    hv__filePath = hv__Path + "Model_Type.tup";
                    HOperatorSet.ReadTuple(hv__filePath, out hv_icModelType);
                    //
                    hv__filePath = hv__Path + "PosModel.dat";
                    if ((int)(new HTuple(hv_icModelType.TupleEqual("ncc"))) != 0)
                    {
                        HOperatorSet.ReadNccModel(hv__filePath, out hv_icPosModel);
                    }
                    else if ((int)(new HTuple(hv_icModelType.TupleEqual("shape"))) != 0)
                    {
                        HOperatorSet.ReadShapeModel(hv__filePath, out hv_icPosModel);
                    }
                    //读取Ic位置信息
                    hv__filePath = hv__Path + "OnWhat.tup";
                    HOperatorSet.ReadTuple(hv__filePath, out hv_icOnWhat);
                    //2-----读取Ic定位参数
                    hv__xmlPath = (hv_i_RecipePath + hv_i_PosTo) + "/IcRecipe.xml";
                    fread_xml_to_vector(hv__xmlPath, out hvec_LoadedElements);
                    //GoldenModelInspectParameter
                    get_subvector_param(hvec_LoadedElements, "GoldenModelInspectParameter", "/GoldenModelInspectParameter",
                        out hvec_ParameterVector);
                    //
                    hvec_subParameterVector = hvec_ParameterVector[0];
                    //匹配定位参数
                    get_vector_param_value(hvec_subParameterVector, "DilationSize", out hv_icDilationSize);
                    get_vector_param_value(hvec_subParameterVector, "MinMatchScore", out hv_icMinMatchScore);
                    get_vector_param_value(hvec_subParameterVector, "AngleStart", out hv_icMatchStartAngle);
                    get_vector_param_value(hvec_subParameterVector, "AngleExt", out hv_icMatchAngleExt);
                    get_vector_param_value(hvec_subParameterVector, "MatchNum", out hv_icMatchNum);
                    //
                    //3------读取Ic所属位置定位模板文件
                    //读取制作模板所用图序
                    hv__Path = (hv_i_ModelPath + hv_icOnWhat) + "/";
                    //
                    //框架定位匹配区域
                    hv__filePath = hv__Path + "Match_Region.reg";
                    HOperatorSet.FileExists(hv__filePath, out hv_FileExists);
                    if ((int)(hv_FileExists) != 0)
                    {
                        ho_Frame_matchReg.Dispose();
                        HOperatorSet.ReadRegion(out ho_Frame_matchReg, hv__filePath);
                    }
                    else
                    {
                        ho_Frame_matchReg.Dispose();
                        HOperatorSet.GenEmptyObj(out ho_Frame_matchReg);
                    }
                    //框架所在区域
                    hv__filePath = hv__Path + "FrameRegion.reg";
                    HOperatorSet.FileExists(hv__filePath, out hv_FileExists);
                    if ((int)(hv_FileExists) != 0)
                    {
                        ho_FrameRegion.Dispose();
                        HOperatorSet.ReadRegion(out ho_FrameRegion, hv__filePath);
                    }
                    else
                    {
                        ho_FrameRegion.Dispose();
                        HOperatorSet.GenEmptyObj(out ho_FrameRegion);
                    }
                    //
                    hv__filePath = hv__Path + "Image_Index.tup";
                    HOperatorSet.ReadTuple(hv__filePath, out hv_frameImage_Index);
                    //
                    hv__filePath = hv__Path + "Model_Type.tup";
                    HOperatorSet.ReadTuple(hv__filePath, out hv_frameModelType);
                    //
                    //确定posmodel的个数
                    HOperatorSet.ListFiles(hv__Path, "files", out hv_ItemFiles);
                    HOperatorSet.TupleRegexpSelect(hv_ItemFiles, "PosModel.*", out hv__PosModelItem);
                    hv_framePosModel = new HTuple();
                    for (hv_idx = 0; (int)hv_idx <= (int)((new HTuple(hv__PosModelItem.TupleLength()
                        )) - 1); hv_idx = (int)hv_idx + 1)
                    {
                        //
                        hv__filePath = hv__PosModelItem.TupleSelect(hv_idx);
                        //
                        if ((int)(new HTuple(hv_frameModelType.TupleEqual("ncc"))) != 0)
                        {
                            HOperatorSet.ReadNccModel(hv__filePath, out hv__PosModel);
                            hv_framePosModel = hv_framePosModel.TupleConcat(hv__PosModel);
                        }
                        else if ((int)(new HTuple(hv_frameModelType.TupleEqual("shape"))) != 0)
                        {
                            HOperatorSet.ReadShapeModel(hv__filePath, out hv__PosModel);
                            hv_framePosModel = hv_framePosModel.TupleConcat(hv__PosModel);
                        }
                    }
                    //
                    //4-------读取Frame定位相关参数
                    hv__xmlPath = (hv_i_RecipePath + hv_icOnWhat) + "/FrameRecipe.xml";
                    //遍历Frame定位、检测所有参数
                    fread_xml_to_vector(hv__xmlPath, out hvec_LoadedElements);
                    //Frame检测参数
                    get_subvector_param(hvec_LoadedElements, "FrameLocateParameter", "/FrameLocateParameter",
                        out hvec_ParameterVector);
                    //
                    //选取参数
                    hvec_subParameterVector = hvec_ParameterVector[0];
                    //定位参数
                    get_vector_param_value(hvec_subParameterVector, "MinMatchScore", out hv_frameMinMatchScore);
                    get_vector_param_value(hvec_subParameterVector, "AngleStart", out hv_frameMatchStartAngle);
                    get_vector_param_value(hvec_subParameterVector, "AngleExt", out hv_frameMatchAngleExt);
                    get_vector_param_value(hvec_subParameterVector, "MatchNum", out hv_frameMatchNum);
                    get_vector_param_value(hvec_subParameterVector, "DilationSize", out hv_frameDilationSize);
                    //
                    //5--------获取i_PosTo定位映射矩阵
                    //获取定位的图像
                    //多匹配区域进行框架定位
                    ho_i_Image.Dispose();
                    HOperatorSet.SelectObj(ho_i_Imgs, out ho_i_Image, hv_frameImage_Index.TupleSelect(
                        0));
                    //
                    HTV_multi_match_region_location_frame(ho_i_Image, ho_i_SearchReg, ho_Frame_matchReg,
                        ho_FrameRegion, hv_frameModelType, hv_framePosModel, hv_frameDilationSize,
                        hv_frameMinMatchScore, hv_frameMatchStartAngle, hv_frameMatchAngleExt,
                        hv_frameMatchNum, out hv_o_frameLocPara, out hv__PosHomMat2D, out hv_o_Scores,
                        out hv__frameErrCode, out hv__frameErrStr);

                    if ((int)(new HTuple(hv__frameErrCode.TupleEqual(0))) != 0)
                    {
                        //Ic定位
                        //-----------IC定位
                        //映射IC匹配区域
                        ho__MatchReg.Dispose();
                        HOperatorSet.AffineTransRegion(ho_icMatch_Region, out ho__MatchReg, hv__PosHomMat2D,
                            "nearest_neighbor");
                        //IC搜索区域获取
                        ho__SearchReg.Dispose();
                        HTV_region_dilation(ho__MatchReg, out ho__SearchReg, hv_icDilationSize,
                            out hv__ErrDilCode, out hv__ErrDilStr);
                        //Ic定位
                        //获取定位的图像
                        ho_i_Image.Dispose();
                        HOperatorSet.SelectObj(ho_i_Imgs, out ho_i_Image, hv_icImage_Index.TupleSelect(
                            0));
                        HTV_Loc_Match(ho_i_Image, ho__SearchReg, hv_icModelType, hv_icPosModel,
                            hv_icMinMatchScore, hv_icMatchStartAngle, hv_icMatchAngleExt, hv_icMatchNum,
                            out hv__icLocPara, out hv__icScore, out hv__icLocErrCode, out hv__icLocErrStr);
                        if ((int)(new HTuple(hv__icLocErrCode.TupleEqual(0))) != 0)
                        {
                            HOperatorSet.VectorAngleToRigid(0, 0, 0, hv__icLocPara.TupleSelect(0),
                                hv__icLocPara.TupleSelect(1), hv__icLocPara.TupleSelect(2), out hv_o_HomMat2D);
                        }
                        else
                        {
                            hv_o_ErrCode = 1;
                            hv_o_ErrStr = "Pos location is fail!";
                            ho_Frame_matchReg.Dispose();
                            ho_FrameRegion.Dispose();
                            ho_i_Image.Dispose();
                            ho_icMatch_Region.Dispose();
                            ho__MatchReg.Dispose();
                            ho__SearchReg.Dispose();

                            return;
                        }
                    }
                    else
                    {
                        hv_o_ErrCode = 1;
                        hv_o_ErrStr = "Pos location is fail!";
                        ho_Frame_matchReg.Dispose();
                        ho_FrameRegion.Dispose();
                        ho_i_Image.Dispose();
                        ho_icMatch_Region.Dispose();
                        ho__MatchReg.Dispose();
                        ho__SearchReg.Dispose();

                        return;
                    }
                    //清除模板
                    //
                    HTV_clear_model(hv_framePosModel, hv_frameModelType);
                    //
                    HTV_clear_model(hv_icPosModel, hv_icModelType);
                }
                else
                {
                    //
                    hv_o_ErrCode = 1;
                    hv_o_ErrStr = "i_PosTo is not illegal!";
                    ho_Frame_matchReg.Dispose();
                    ho_FrameRegion.Dispose();
                    ho_i_Image.Dispose();
                    ho_icMatch_Region.Dispose();
                    ho__MatchReg.Dispose();
                    ho__SearchReg.Dispose();

                    return;
                }
                //
                hv_o_ErrCode = 0;
                hv_o_ErrStr = "get mapping matrix successful!";
                ho_Frame_matchReg.Dispose();
                ho_FrameRegion.Dispose();
                ho_i_Image.Dispose();
                ho_icMatch_Region.Dispose();
                ho__MatchReg.Dispose();
                ho__SearchReg.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Frame_matchReg.Dispose();
                ho_FrameRegion.Dispose();
                ho_i_Image.Dispose();
                ho_icMatch_Region.Dispose();
                ho__MatchReg.Dispose();
                ho__SearchReg.Dispose();

                throw HDevExpDefaultException;
            }
        }
        #endregion


        #region Epoxy检测验证
        public static void HTV_Epoxy_Inspect_Threshold(HObject ho_i_Image, HObject ho_i_InspectReg,
            HObject ho_i_RefReg, out HObject ho_o_EpoxyRegs, out HObjectVector/*{eObjectVector,Dim=1}*/ hvec_o_FailReg,
            HTuple hv_i_HomMatMod2Img, HTupleVector/*{eTupleVector,Dim=1}*/ hvec_i_ThreshGray,
            HTuple hv_i_LightOrDark, HTuple hv_i_OpeningSize, HTuple hv_i_EpoxyLenTh, HTuple hv_i_EpoxyHeiTh,
            HTupleVector/*{eTupleVector,Dim=3}*/ hvec_i_DefectValue, HTuple hv_i_DefectImgIdx,
            out HTupleVector/*{eTupleVector,Dim=1}*/ hvec_o_DefectType, out HTupleVector/*{eTupleVector,Dim=1}*/ hvec_o_DefectImgIdx,
            out HTupleVector/*{eTupleVector,Dim=3}*/ hvec_o_DefectValue, out HTuple hv_o_ErrCode,
            out HTuple hv_o_ErrStr)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_EmptyObject, ho__InspectReg, ho__RefReg;
            HObject ho_ObjectSelected = null, ho__EpoxyReg = null;

            HObjectVector hvec__EpoxyRegs = new HObjectVector(1);

            // Local control variables 

            HTuple hv_regNum = null, hv_Idx = null, hv_HomMatSum = null;
            HTuple hv__RefRow = null, hv__RefColumn = null, hv__RefPhi = null;
            HTuple hv_RefLen1 = null, hv_RefLen2 = null, hv_o_EpoxyExtractResult = null;
            HTuple hv__ErrCode = null, hv__ErrStr = null, hv_ResultSum = null;
            HTuple hv__EpoxyLen = new HTuple(), hv__EpoxyHei = new HTuple();
            HTuple hv_regIdx = new HTuple(), hv_Row1 = new HTuple();
            HTuple hv_Column1 = new HTuple(), hv_Phi1 = new HTuple();
            HTuple hv_Len1 = new HTuple(), hv_Len2 = new HTuple();
            HTuple hv_Row = new HTuple(), hv_Column = new HTuple();
            HTuple hv_Phi = new HTuple(), hv_EpoxyLen = new HTuple();
            HTuple hv_GreaterLen = new HTuple(), hv_GreaterHei = new HTuple();
            HTuple hv_EpoxyIsOK = new HTuple(), hv_IsOKSum = null;
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_EpoxyRegs);
            HOperatorSet.GenEmptyObj(out ho_EmptyObject);
            HOperatorSet.GenEmptyObj(out ho__InspectReg);
            HOperatorSet.GenEmptyObj(out ho__RefReg);
            HOperatorSet.GenEmptyObj(out ho_ObjectSelected);
            HOperatorSet.GenEmptyObj(out ho__EpoxyReg);
            hvec_o_FailReg = new HObjectVector(1);
            try
            {
                //**********阈值分割方法提取银胶区域并分析银胶胶测结果是否满足检测要求
                //----------图标参数
                //i_Image: 待处理图像
                //i_InspectReg: 芯片各边对应的银胶检测区域，一般以上、下、左、右的顺序来排列
                //o_EpoxyReg: 通过阈值分割提取出来的银胶区域，上、下、左、右各对应一个区域
                //o_FailRegs：银胶出现缺陷的显示区域
                //----------控制参数
                //i_HomMatMod2Img：Ic定位后模板到图像的映射矩阵
                //i_ThreshGray: 阈值分割的灰度阈值，可以为1个参数（灰度上限或下限）或2个参数（灰度上下限）
                //i_LightOrDark: 银胶为亮目标或暗目标
                //i_OpeningSize: 为去除金线干扰进行开运算的尺寸
                //i_EpoxyLenTh：银胶长度阈值：0-1之间，银胶长度与芯片长度的比值：上下左右
                //i_EpoxyHeiTh：银胶最高度距离芯片边缘的高度 ：上下左右的高度  单位像素
                //o_DefectValue：输出检测到银胶长度比值o_DefectValue.at[0]，银胶高度o_DefectValue.at[1]
                //o_DefectType：输出缺陷类型
                //o_ErrCode: 错误码，代表该算子执行过程中产生的错误，0-代表正常执行，自然数-代表错误类型，-1-代表异常，-2-代表未执行
                //o_ErrStr: 错误信息，对各种错误的具体描述

                //初始化
                hv_o_ErrCode = -2;
                hv_o_ErrStr = "Initializing";
                ho_o_EpoxyRegs.Dispose();
                HOperatorSet.GenEmptyObj(out ho_o_EpoxyRegs);
                ho_EmptyObject.Dispose();
                HOperatorSet.GenEmptyObj(out ho_EmptyObject);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hvec_o_FailReg = dh.Take((
                        dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho_EmptyObject)))));
                }
                hvec_o_DefectType = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())));
                hvec_o_DefectImgIdx = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())));
                hvec_o_DefectValue = hvec_i_DefectValue.Clone();
                HOperatorSet.CountObj(ho_i_InspectReg, out hv_regNum);
                HTuple end_val28 = hv_regNum - 1;
                HTuple step_val28 = 1;
                for (hv_Idx = 0; hv_Idx.Continue(end_val28, step_val28); hv_Idx = hv_Idx.TupleAdd(step_val28))
                {
                    hvec_o_DefectValue[hv_Idx] = ((new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(-2)))))).Insert(
                        1, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(-2))))));
                }
                //传入映射矩阵有效性测试
                HOperatorSet.TupleSum(hv_i_HomMatMod2Img, out hv_HomMatSum);
                if ((int)(new HTuple(hv_HomMatSum.TupleEqual(-12))) != 0)
                {
                    hv_o_ErrCode = 1;
                    hv_o_ErrStr = "mapping matrix is invalid!";
                    ho_EmptyObject.Dispose();
                    ho__InspectReg.Dispose();
                    ho__RefReg.Dispose();
                    ho_ObjectSelected.Dispose();
                    ho__EpoxyReg.Dispose();
                    hvec__EpoxyRegs.Dispose();

                    return;
                }

                //---------银胶检测
                //银胶检测区域映射
                ho__InspectReg.Dispose();
                HOperatorSet.AffineTransRegion(ho_i_InspectReg, out ho__InspectReg, hv_i_HomMatMod2Img,
                    "nearest_neighbor");
                //映射参考区域
                ho__RefReg.Dispose();
                HOperatorSet.AffineTransRegion(ho_i_RefReg, out ho__RefReg, hv_i_HomMatMod2Img,
                    "nearest_neighbor");
                //参考区域中心位置
                HOperatorSet.SmallestRectangle2(ho__RefReg, out hv__RefRow, out hv__RefColumn,
                    out hv__RefPhi, out hv_RefLen1, out hv_RefLen2);

                //采用阈值分割方式进行银胶检测
                hvec__EpoxyRegs.Dispose();
                HTV_Epoxy_Threshold(ho_i_Image, ho__InspectReg, out hvec__EpoxyRegs, hvec_i_ThreshGray,
                    hv_i_LightOrDark, hv_i_OpeningSize, hv__RefRow, hv__RefColumn, out hv_o_EpoxyExtractResult,
                    out hv__ErrCode, out hv__ErrStr);
                //发生异常
                if ((int)(new HTuple(hv__ErrCode.TupleLess(0))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = hv__ErrStr.Clone();
                    ho_EmptyObject.Dispose();
                    ho__InspectReg.Dispose();
                    ho__RefReg.Dispose();
                    ho_ObjectSelected.Dispose();
                    ho__EpoxyReg.Dispose();
                    hvec__EpoxyRegs.Dispose();

                    return;
                }
                //银胶检测结果输出
                HOperatorSet.TupleSum(hv_o_EpoxyExtractResult, out hv_ResultSum);
                HOperatorSet.CountObj(ho__InspectReg, out hv_regNum);
                if ((int)(new HTuple(hv_ResultSum.TupleEqual(hv_regNum))) != 0)
                {
                    //全部提取失败
                    //一个检测区一个检测项ID
                    HTuple end_val61 = hv_regNum - 1;
                    HTuple step_val61 = 1;
                    for (hv_Idx = 0; hv_Idx.Continue(end_val61, step_val61); hv_Idx = hv_Idx.TupleAdd(step_val61))
                    {
                        hvec_o_DefectType[hv_Idx] = new HTupleVector(new HTuple(9));
                        hvec_o_DefectImgIdx[hv_Idx] = new HTupleVector(hv_i_DefectImgIdx).Clone();
                        hvec_o_DefectValue[hv_Idx] = ((new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(-1)))))).Insert(
                            1, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(-1))))));
                        ho_ObjectSelected.Dispose();
                        HOperatorSet.SelectObj(ho__InspectReg, out ho_ObjectSelected, hv_Idx + 1);
                        hvec_o_FailReg[hv_Idx] = new HObjectVector(ho_ObjectSelected.CopyObj(1, -1));
                    }
                    //输出结果
                    hv_o_ErrCode = 1;
                    hv_o_ErrStr = "Epoxy is too little!";
                    ho_EmptyObject.Dispose();
                    ho__InspectReg.Dispose();
                    ho__RefReg.Dispose();
                    ho_ObjectSelected.Dispose();
                    ho__EpoxyReg.Dispose();
                    hvec__EpoxyRegs.Dispose();

                    return;
                }
                else
                {
                    hv__EpoxyLen = new HTuple();
                    hv__EpoxyHei = new HTuple();
                    HTuple end_val75 = hv_regNum - 1;
                    HTuple step_val75 = 1;
                    for (hv_regIdx = 0; hv_regIdx.Continue(end_val75, step_val75); hv_regIdx = hv_regIdx.TupleAdd(step_val75))
                    {
                        ho__EpoxyReg.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho__EpoxyReg = hvec__EpoxyRegs[hv_regIdx].O.CopyObj(1, -1);
                        }
                        ho_ObjectSelected.Dispose();
                        HOperatorSet.SelectObj(ho__InspectReg, out ho_ObjectSelected, hv_regIdx + 1);
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(ho_o_EpoxyRegs, ho__EpoxyReg, out ExpTmpOutVar_0
                                );
                            ho_o_EpoxyRegs.Dispose();
                            ho_o_EpoxyRegs = ExpTmpOutVar_0;
                        }
                        if ((int)(new HTuple(((hv_o_EpoxyExtractResult.TupleSelect(hv_regIdx))).TupleEqual(
                            0))) != 0)
                        {
                            //确定银胶长、宽
                            HOperatorSet.SmallestRectangle2(ho__EpoxyReg, out hv_Row1, out hv_Column1,
                                out hv_Phi1, out hv_Len1, out hv_Len2);
                            //确定提取银胶检测区域长宽
                            HOperatorSet.SmallestRectangle2(ho_ObjectSelected, out hv_Row, out hv_Column,
                                out hv_Phi, out hv_RefLen1, out hv_RefLen2);
                            //银胶高度
                            hv__EpoxyHei = hv__EpoxyHei.TupleConcat(2 * hv_Len2);
                            //上下银胶长度比值
                            hv_EpoxyLen = hv_Len1 / hv_RefLen1;
                            hv__EpoxyLen = hv__EpoxyLen.TupleConcat(hv_EpoxyLen);
                        }
                        else
                        {
                            hv__EpoxyHei = hv__EpoxyHei.TupleConcat(0);
                            hv__EpoxyLen = hv__EpoxyLen.TupleConcat(0);
                        }
                    }
                    //银胶长度比值阈值比较结果
                    HOperatorSet.TupleGreaterElem(hv__EpoxyLen, hv_i_EpoxyLenTh, out hv_GreaterLen);
                    //银胶高度阈值比较结果
                    HOperatorSet.TupleGreaterElem(hv__EpoxyHei, hv_i_EpoxyHeiTh, out hv_GreaterHei);
                    //逻辑判断银胶区域长宽是否同时满足
                    hv_EpoxyIsOK = new HTuple();
                    HTuple end_val100 = hv_regNum - 1;
                    HTuple step_val100 = 1;
                    for (hv_Idx = 0; hv_Idx.Continue(end_val100, step_val100); hv_Idx = hv_Idx.TupleAdd(step_val100))
                    {
                        if ((int)(new HTuple((((hv_GreaterLen.TupleSelect(hv_Idx)) + (hv_GreaterHei.TupleSelect(
                            hv_Idx)))).TupleEqual(2))) != 0)
                        {
                            //提取的银胶区域满足要求
                            hv_EpoxyIsOK = hv_EpoxyIsOK.TupleConcat(0);

                            hvec_o_DefectType[hv_Idx] = new HTupleVector(new HTuple(0));
                            hvec_o_DefectImgIdx[hv_Idx] = new HTupleVector(hv_i_DefectImgIdx).Clone();
                            //检测正常输出ResultReg
                            ho__EpoxyReg.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                ho__EpoxyReg = hvec__EpoxyRegs[hv_Idx].O.CopyObj(1, -1);
                            }
                            hvec_o_FailReg[hv_Idx] = new HObjectVector(ho__EpoxyReg.CopyObj(1, -1));
                        }
                        else
                        {
                            //提取的银胶区域不满足要求
                            hv_EpoxyIsOK = hv_EpoxyIsOK.TupleConcat(1);

                            hvec_o_DefectType[hv_Idx] = new HTupleVector(new HTuple(9));
                            hvec_o_DefectImgIdx[hv_Idx] = new HTupleVector(hv_i_DefectImgIdx).Clone();

                            ho_ObjectSelected.Dispose();
                            HOperatorSet.SelectObj(ho__InspectReg, out ho_ObjectSelected, hv_Idx + 1);
                            hvec_o_FailReg[hv_Idx] = new HObjectVector(ho_ObjectSelected.CopyObj(1, -1));
                        }

                        hvec_o_DefectValue[hv_Idx][0] = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(hv__EpoxyLen.TupleSelect(
                            hv_Idx)))));
                        hvec_o_DefectValue[hv_Idx][1] = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(hv__EpoxyHei.TupleSelect(
                            hv_Idx)))));
                    }
                }
                //
                HOperatorSet.TupleSum(hv_EpoxyIsOK, out hv_IsOKSum);
                if ((int)(new HTuple(hv_IsOKSum.TupleGreater(0))) != 0)
                {
                    hv_o_ErrCode = 1;
                    hv_o_ErrStr = "epoxy has defect";
                    ho_EmptyObject.Dispose();
                    ho__InspectReg.Dispose();
                    ho__RefReg.Dispose();
                    ho_ObjectSelected.Dispose();
                    ho__EpoxyReg.Dispose();
                    hvec__EpoxyRegs.Dispose();

                    return;
                }
                else
                {
                    hv_o_ErrCode = 0;
                    hv_o_ErrStr = "epoxy is OK";
                    ho_EmptyObject.Dispose();
                    ho__InspectReg.Dispose();
                    ho__RefReg.Dispose();
                    ho_ObjectSelected.Dispose();
                    ho__EpoxyReg.Dispose();
                    hvec__EpoxyRegs.Dispose();

                    return;
                }


            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_EmptyObject.Dispose();
                ho__InspectReg.Dispose();
                ho__RefReg.Dispose();
                ho_ObjectSelected.Dispose();
                ho__EpoxyReg.Dispose();
                hvec__EpoxyRegs.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public static void HTV_Epoxy_Threshold(HObject ho_i_Image, HObject ho_i_InspectReg, out HObjectVector/*{eObjectVector,Dim=1}*/ hvec_o_EpoxyReg,
            HTupleVector/*{eTupleVector,Dim=1}*/ hvec_i_ThreshGray, HTuple hv_i_LightOrDark,
            HTuple hv_i_OpeningSize, HTuple hv_i_RefRow, HTuple hv_i_RefCol, out HTuple hv_o_EpoxyExtractResult,
            out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_EmptyObject, ho_curReg = null, ho_InspectImage = null;
            HObject ho_Region = null, ho_RegionOpening1 = null, ho_ConnectedRegions = null;
            HObject ho__EpoxyReg = null, ho_RegSel = null, ho_RegionUnion = null;
            HObject ho_RegEpoxy = null;

            // Local control variables 

            HTuple hv_imgNum = null, hv_regNum = null;
            HTuple hv_regIdx = null, hv_Row = new HTuple(), hv_Column = new HTuple();
            HTuple hv_Phi = new HTuple(), hv_Len1 = new HTuple(), hv_Len2 = new HTuple();
            HTuple hv_Area = new HTuple(), hv_RefRow = new HTuple();
            HTuple hv_RegColumn = new HTuple(), hv_startPtRow = new HTuple();
            HTuple hv_startPtCol = new HTuple(), hv_endPtRow = new HTuple();
            HTuple hv_endPtCol = new HTuple(), hv_DistThresh = new HTuple();
            HTuple hv__ThreshGray = new HTuple(), hv_lowThresh = new HTuple();
            HTuple hv_highThresh = new HTuple(), hv_EpoxyNum = new HTuple();
            HTuple hv_IdxEpoxy = new HTuple(), hv_AreaReg = new HTuple();
            HTuple hv_RowReg = new HTuple(), hv_ColumnReg = new HTuple();
            HTuple hv_DistPL = new HTuple(), hv_Number = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_EmptyObject);
            HOperatorSet.GenEmptyObj(out ho_curReg);
            HOperatorSet.GenEmptyObj(out ho_InspectImage);
            HOperatorSet.GenEmptyObj(out ho_Region);
            HOperatorSet.GenEmptyObj(out ho_RegionOpening1);
            HOperatorSet.GenEmptyObj(out ho_ConnectedRegions);
            HOperatorSet.GenEmptyObj(out ho__EpoxyReg);
            HOperatorSet.GenEmptyObj(out ho_RegSel);
            HOperatorSet.GenEmptyObj(out ho_RegionUnion);
            HOperatorSet.GenEmptyObj(out ho_RegEpoxy);
            hvec_o_EpoxyReg = new HObjectVector(1);
            try
            {
                //**********     阈值分割方法提取银胶区域
                //i_Image: 待处理图像
                //i_InspectReg: 芯片各边对应的银胶检测区域，一般以上、下、左、右的顺序来排列
                //o_EpoxyReg: 通过阈值分割提取出来的银胶区域，上、下、左、右各对应一个区域
                //i_ThreshGray: 阈值分割的灰度阈值，可以为1个参数（灰度上限或下限）或2个参数（灰度上下限）
                //i_LightOrDark: 银胶为亮目标或暗目标
                //i_OpeningSize: 为去除金线干扰进行开运算的尺寸
                //i_RefRow：银胶区域参考IC中心行坐标
                //i_RefCol：银胶区域参考Ic中心列坐标
                //o_EpoxyExtractResult：银胶提取结果Flag
                //o_ErrCode: 错误码，代表该算子执行过程中产生的错误，0-代表正常执行，自然数-代表错误类型，-1-代表异常，-2-代表未执行
                //o_ErrStr: 错误信息，对各种错误的具体描述

                //初始化
                hv_o_ErrCode = -2;
                hv_o_ErrStr = "Initializing";
                ho_EmptyObject.Dispose();
                HOperatorSet.GenEmptyObj(out ho_EmptyObject);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hvec_o_EpoxyReg = dh.Take((
                        dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho_EmptyObject)))));
                }
                hv_o_EpoxyExtractResult = new HTuple();
                //输入有效性测试
                HOperatorSet.CountObj(ho_i_Image, out hv_imgNum);
                if ((int)(new HTuple(hv_imgNum.TupleEqual(0))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "input image is null";
                    ho_EmptyObject.Dispose();
                    ho_curReg.Dispose();
                    ho_InspectImage.Dispose();
                    ho_Region.Dispose();
                    ho_RegionOpening1.Dispose();
                    ho_ConnectedRegions.Dispose();
                    ho__EpoxyReg.Dispose();
                    ho_RegSel.Dispose();
                    ho_RegionUnion.Dispose();
                    ho_RegEpoxy.Dispose();

                    return;
                }
                HOperatorSet.CountObj(ho_i_InspectReg, out hv_regNum);
                if ((int)(new HTuple(hv_regNum.TupleLess(1))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "Epoxy inspect region empty";
                    ho_EmptyObject.Dispose();
                    ho_curReg.Dispose();
                    ho_InspectImage.Dispose();
                    ho_Region.Dispose();
                    ho_RegionOpening1.Dispose();
                    ho_ConnectedRegions.Dispose();
                    ho__EpoxyReg.Dispose();
                    ho_RegSel.Dispose();
                    ho_RegionUnion.Dispose();
                    ho_RegEpoxy.Dispose();

                    return;
                }
                if ((int)((new HTuple((new HTuple(hv_i_OpeningSize.TupleLength())).TupleLess(
                    1))).TupleOr(new HTuple(hv_i_OpeningSize.TupleLess(1)))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "the para i_OpeningSize must greater than 0";
                    ho_EmptyObject.Dispose();
                    ho_curReg.Dispose();
                    ho_InspectImage.Dispose();
                    ho_Region.Dispose();
                    ho_RegionOpening1.Dispose();
                    ho_ConnectedRegions.Dispose();
                    ho__EpoxyReg.Dispose();
                    ho_RegSel.Dispose();
                    ho_RegionUnion.Dispose();
                    ho_RegEpoxy.Dispose();

                    return;
                }

                //分别对各边区域进行阈值分割
                HTuple end_val39 = hv_regNum - 1;
                HTuple step_val39 = 1;
                for (hv_regIdx = 0; hv_regIdx.Continue(end_val39, step_val39); hv_regIdx = hv_regIdx.TupleAdd(step_val39))
                {
                    ho_curReg.Dispose();
                    HOperatorSet.SelectObj(ho_i_InspectReg, out ho_curReg, hv_regIdx + 1);
                    HOperatorSet.SmallestRectangle2(ho_curReg, out hv_Row, out hv_Column, out hv_Phi,
                        out hv_Len1, out hv_Len2);
                    HOperatorSet.AreaCenter(ho_curReg, out hv_Area, out hv_RefRow, out hv_RegColumn);

                    //直线两端点
                    hv_startPtRow = hv_i_RefRow + (hv_Len1 * (hv_Phi.TupleSin()));
                    hv_startPtCol = hv_i_RefCol - (hv_Len1 * (hv_Phi.TupleCos()));
                    hv_endPtRow = hv_i_RefRow - (hv_Len1 * (hv_Phi.TupleSin()));
                    hv_endPtCol = hv_i_RefCol + (hv_Len1 * (hv_Phi.TupleCos()));

                    HOperatorSet.DistancePp(hv_i_RefRow, hv_i_RefCol, hv_RefRow, hv_RegColumn,
                        out hv_DistThresh);

                    //阈值分割上下限参数
                    hv__ThreshGray = hvec_i_ThreshGray[hv_regIdx].T.Clone();
                    hv_lowThresh = hv__ThreshGray[0];
                    hv_highThresh = hv__ThreshGray[1];

                    ho_InspectImage.Dispose();
                    HOperatorSet.ReduceDomain(ho_i_Image, ho_curReg, out ho_InspectImage);
                    ho_Region.Dispose();
                    HOperatorSet.Threshold(ho_InspectImage, out ho_Region, hv_lowThresh, hv_highThresh);

                    //形态学处理: 去金线干扰
                    ho_RegionOpening1.Dispose();
                    HOperatorSet.OpeningCircle(ho_Region, out ho_RegionOpening1, hv_i_OpeningSize.TupleSelect(
                        hv_regIdx));

                    ho_ConnectedRegions.Dispose();
                    HOperatorSet.Connection(ho_RegionOpening1, out ho_ConnectedRegions);
                    HOperatorSet.CountObj(ho_ConnectedRegions, out hv_EpoxyNum);
                    //提取合格的银胶区域
                    ho__EpoxyReg.Dispose();
                    HOperatorSet.GenEmptyObj(out ho__EpoxyReg);
                    HTuple end_val67 = hv_EpoxyNum;
                    HTuple step_val67 = 1;
                    for (hv_IdxEpoxy = 1; hv_IdxEpoxy.Continue(end_val67, step_val67); hv_IdxEpoxy = hv_IdxEpoxy.TupleAdd(step_val67))
                    {
                        ho_RegSel.Dispose();
                        HOperatorSet.SelectObj(ho_ConnectedRegions, out ho_RegSel, hv_IdxEpoxy);
                        HOperatorSet.AreaCenter(ho_RegSel, out hv_AreaReg, out hv_RowReg, out hv_ColumnReg);
                        //改为点到直线的距离
                        HOperatorSet.DistancePl(hv_RowReg, hv_ColumnReg, hv_startPtRow, hv_startPtCol,
                            hv_endPtRow, hv_endPtCol, out hv_DistPL);

                        //根据银胶区域中心距离IC中心距离判断是否为银胶区域
                        if ((int)(new HTuple(hv_DistPL.TupleLess(hv_DistThresh))) != 0)
                        {
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.ConcatObj(ho__EpoxyReg, ho_RegSel, out ExpTmpOutVar_0);
                                ho__EpoxyReg.Dispose();
                                ho__EpoxyReg = ExpTmpOutVar_0;
                            }
                        }
                    }
                    //每个检测区域内的银胶作为一个整体存入输出对象中
                    ho_RegionUnion.Dispose();
                    HOperatorSet.Union1(ho__EpoxyReg, out ho_RegionUnion);
                    //去除银胶区域内孔洞
                    ho_RegEpoxy.Dispose();
                    HOperatorSet.ClosingCircle(ho_RegionUnion, out ho_RegEpoxy, hv_i_OpeningSize.TupleSelect(
                        hv_regIdx));
                    HOperatorSet.CountObj(ho_RegionUnion, out hv_Number);
                    if ((int)(hv_Number) != 0)
                    {
                        //提取成功
                        hv_o_EpoxyExtractResult = hv_o_EpoxyExtractResult.TupleConcat(0);
                    }
                    else
                    {
                        //提取失败
                        hv_o_EpoxyExtractResult = hv_o_EpoxyExtractResult.TupleConcat(1);
                    }
                    hvec_o_EpoxyReg[hv_regIdx] = new HObjectVector(ho_RegEpoxy.CopyObj(1, -1));
                }

                hv_o_ErrCode = 0;
                hv_o_ErrStr = "Epoxy extract successful";

                ho_EmptyObject.Dispose();
                ho_curReg.Dispose();
                ho_InspectImage.Dispose();
                ho_Region.Dispose();
                ho_RegionOpening1.Dispose();
                ho_ConnectedRegions.Dispose();
                ho__EpoxyReg.Dispose();
                ho_RegSel.Dispose();
                ho_RegionUnion.Dispose();
                ho_RegEpoxy.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_EmptyObject.Dispose();
                ho_curReg.Dispose();
                ho_InspectImage.Dispose();
                ho_Region.Dispose();
                ho_RegionOpening1.Dispose();
                ho_ConnectedRegions.Dispose();
                ho__EpoxyReg.Dispose();
                ho_RegSel.Dispose();
                ho_RegionUnion.Dispose();
                ho_RegEpoxy.Dispose();

                throw HDevExpDefaultException;
            }
        }
        #endregion


        #region  bond检测验证 模板匹配
        //
        public static void HTV_GenBond2Model_Recipe(HObject ho_i_Image, HObject ho_i_Bond2RotateImages,
            HObject ho_i_Bond2InitModelReg, HObject ho_i_Bond2RefineRegs, HTuple hv_i_ModelType,
            HTuple hv_i_Bond2ModelNum, HTuple hv_i_IsPreProcess, HTuple hv_i_Gamma, out HTuple hv_o_ModelID)
        {

            // Local iconic variables 

            HObject ho_ROISelected = null, ho_ImgSelected = null;
            HObject ho_PowImage = null, ho__gamaImg = null;

            // Local control variables 

            HTuple hv__TotRefineNum = null, hv_RefineNum = null;
            HTuple hv_Index = null, hv_Min = new HTuple(), hv_Max = new HTuple();
            HTuple hv_Range = new HTuple(), hv__ModelID = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_ROISelected);
            HOperatorSet.GenEmptyObj(out ho_ImgSelected);
            HOperatorSet.GenEmptyObj(out ho_PowImage);
            HOperatorSet.GenEmptyObj(out ho__gamaImg);
            //****************************************************************
            //生成第二焊点定位匹配模板
            //i_Image: 第二焊点检测图像
            //i_Bond2RotateImages: 用于创建第二焊点初始模板的旋转后图像
            //i_Bond2InitModelReg: 创建第二焊点初始模板的区域（旋转图像中）
            //i_Bond2RefineRegs: 用于第二焊点模板精炼的区域（检测图像中）
            //i_ModelType: 第二焊点模板类型
            //i_Bond2ModelNum: 第二焊点模板个数
            //i_IsPreProcess: 创建模板之前图像是否需要预处理
            //i_Gamma: 预处理时使用的Gamma变换系数
            //o_ModelID: 模板ID
            //****************************************************************

            hv_o_ModelID = new HTuple();
            HOperatorSet.CountObj(ho_i_Bond2RefineRegs, out hv__TotRefineNum);
            hv_RefineNum = 0;
            if ((int)(new HTuple(hv_i_Bond2ModelNum.TupleGreater(0))) != 0)
            {
                hv_RefineNum = hv__TotRefineNum / hv_i_Bond2ModelNum;
            }
            HTuple end_val19 = hv_i_Bond2ModelNum;
            HTuple step_val19 = 1;
            for (hv_Index = 1; hv_Index.Continue(end_val19, step_val19); hv_Index = hv_Index.TupleAdd(step_val19))
            {
                ho_ROISelected.Dispose();
                HOperatorSet.SelectObj(ho_i_Bond2InitModelReg, out ho_ROISelected, hv_Index);
                ho_ImgSelected.Dispose();
                HOperatorSet.SelectObj(ho_i_Bond2RotateImages, out ho_ImgSelected, hv_Index);
                //生成初始模板
                if ((int)(hv_i_IsPreProcess) != 0)
                {
                    ho_PowImage.Dispose();
                    HOperatorSet.PowImage(ho_ImgSelected, out ho_PowImage, hv_i_Gamma);
                    HOperatorSet.MinMaxGray(ho_ROISelected, ho_PowImage, 0, out hv_Min, out hv_Max,
                        out hv_Range);
                    ho__gamaImg.Dispose();
                    HOperatorSet.ScaleImage(ho_PowImage, out ho__gamaImg, 255 / hv_Max, 0);
                    ho_ImgSelected.Dispose();
                    HOperatorSet.ConvertImageType(ho__gamaImg, out ho_ImgSelected, "byte");
                }


                //更新接口
                HTV_create_model_recipe(ho_ImgSelected, ho_ROISelected, hv_i_ModelType, (new HTuple(-180)).TupleRad()
                    , (new HTuple(360)).TupleRad(), out hv__ModelID);


                //更新接口
                //Refine提炼模板
                HTV_Refine_Bond2_Model_Recipe(ho_i_Image, ho_i_Bond2RefineRegs, ho_ROISelected,
                  hv__ModelID, hv_i_ModelType, (hv_Index - 1) * hv_RefineNum, hv_RefineNum, hv_i_IsPreProcess,
                  hv_i_Gamma, out hv__ModelID);

                hv_o_ModelID = hv_o_ModelID.TupleConcat(hv__ModelID);



            }
            ho_ROISelected.Dispose();
            ho_ImgSelected.Dispose();
            ho_PowImage.Dispose();
            ho__gamaImg.Dispose();

            return;
        }

        public static void HTV_Refine_Bond2_Model_Recipe(HObject ho_i_Image, HObject ho_i_RefineRegs,
            HObject ho_i_ModelROI, HTuple hv_i_ModelID, HTuple hv_i_ModelType, HTuple hv_i_IndexStart,
            HTuple hv_i_RegsNum, HTuple hv_i_IsPreProcess, HTuple hv_i_Gamma, out HTuple hv_o_ModelID)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_curReg = null, ho_PowImage = null, ho__gamaImg = null;
            HObject ho_ImageReduced = null, ho_ImageAffinTrans = null, ho_ImageConverted1 = null;
            HObject ho_ImageCleared, ho_ImageScaled = null, ho_ImageConverted2 = null;
            HObject ho_ImageReduced5 = null;

            // Local copy input parameter variables 
            HObject ho_i_Image_COPY_INP_TMP;
            ho_i_Image_COPY_INP_TMP = ho_i_Image.CopyObj(1, -1);



            // Local control variables 

            HTuple hv_matchNum = null, hv_Index = null;
            HTuple hv_Min = new HTuple(), hv_Max = new HTuple(), hv_Range = new HTuple();
            HTuple hv_Row = new HTuple(), hv_Column = new HTuple();
            HTuple hv_Angle = new HTuple(), hv_Score = new HTuple();
            HTuple hv_HomMat2D = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_curReg);
            HOperatorSet.GenEmptyObj(out ho_PowImage);
            HOperatorSet.GenEmptyObj(out ho__gamaImg);
            HOperatorSet.GenEmptyObj(out ho_ImageReduced);
            HOperatorSet.GenEmptyObj(out ho_ImageAffinTrans);
            HOperatorSet.GenEmptyObj(out ho_ImageConverted1);
            HOperatorSet.GenEmptyObj(out ho_ImageCleared);
            HOperatorSet.GenEmptyObj(out ho_ImageScaled);
            HOperatorSet.GenEmptyObj(out ho_ImageConverted2);
            HOperatorSet.GenEmptyObj(out ho_ImageReduced5);
            hv_o_ModelID = new HTuple();

            ho_ImageCleared.Dispose();
            HTV_gen_image_type_recipe(ho_i_Image_COPY_INP_TMP, out ho_ImageCleared, "real");
            hv_matchNum = 0;
            HTuple end_val3 = hv_i_RegsNum;
            HTuple step_val3 = 1;
            for (hv_Index = 1; hv_Index.Continue(end_val3, step_val3); hv_Index = hv_Index.TupleAdd(step_val3))
            {
                ho_curReg.Dispose();
                HOperatorSet.SelectObj(ho_i_RefineRegs, out ho_curReg, hv_Index + hv_i_IndexStart);// 
                if ((int)(hv_i_IsPreProcess) != 0)
                {
                    ho_PowImage.Dispose();
                    HOperatorSet.PowImage(ho_i_Image_COPY_INP_TMP, out ho_PowImage, hv_i_Gamma);
                    HOperatorSet.MinMaxGray(ho_curReg, ho_PowImage, 0, out hv_Min, out hv_Max,
                        out hv_Range);
                    ho__gamaImg.Dispose();
                    HOperatorSet.ScaleImage(ho_PowImage, out ho__gamaImg, 255 / hv_Max, 0);
                    ho_i_Image_COPY_INP_TMP.Dispose();
                    HOperatorSet.ConvertImageType(ho__gamaImg, out ho_i_Image_COPY_INP_TMP, "byte");
                }
                ho_ImageReduced.Dispose();
                HOperatorSet.ReduceDomain(ho_i_Image_COPY_INP_TMP, ho_curReg, out ho_ImageReduced
                    );
                if ((int)(new HTuple(hv_i_ModelType.TupleEqual(0))) != 0)
                {
                    HOperatorSet.FindNccModel(ho_ImageReduced, hv_i_ModelID, (new HTuple(-180)).TupleRad()
                        , (new HTuple(360)).TupleRad(), 0.6, 1, 0.5, "true", 0, out hv_Row, out hv_Column,
                        out hv_Angle, out hv_Score);
                }
                else
                {
                    HOperatorSet.FindShapeModel(ho_ImageReduced, hv_i_ModelID, (new HTuple(-180)).TupleRad()
                        , (new HTuple(360)).TupleRad(), 0.6, 1, 0.5, "least_squares", 0, 0.9,
                        out hv_Row, out hv_Column, out hv_Angle, out hv_Score);
                }
                if ((int)(new HTuple((new HTuple(hv_Score.TupleLength())).TupleGreater(0))) != 0)
                {
                    hv_matchNum = hv_matchNum + 1;
                    //焊点区域图像求和
                    HOperatorSet.VectorAngleToRigid(hv_Row, hv_Column, hv_Angle, 0, 0, 0, out hv_HomMat2D);
                    ho_ImageAffinTrans.Dispose();
                    HOperatorSet.AffineTransImage(ho_i_Image_COPY_INP_TMP, out ho_ImageAffinTrans,
                        hv_HomMat2D, "bilinear", "false");
                    ho_ImageConverted1.Dispose();
                    HOperatorSet.ConvertImageType(ho_ImageAffinTrans, out ho_ImageConverted1,
                        "real");
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.AddImage(ho_ImageCleared, ho_ImageConverted1, out ExpTmpOutVar_0,
                            1, 0);
                        ho_ImageCleared.Dispose();
                        ho_ImageCleared = ExpTmpOutVar_0;
                    }
                }
            }
            if ((int)(new HTuple(hv_matchNum.TupleGreater(0))) != 0)
            {
                ho_ImageScaled.Dispose();
                HOperatorSet.ScaleImage(ho_ImageCleared, out ho_ImageScaled, 1.0 / hv_matchNum,
                    0);
                ho_ImageConverted2.Dispose();
                HOperatorSet.ConvertImageType(ho_ImageScaled, out ho_ImageConverted2, "byte");
                ho_ImageReduced5.Dispose();
                HOperatorSet.ReduceDomain(ho_ImageConverted2, ho_i_ModelROI, out ho_ImageReduced5
                    );
                HTV_clear_model_recipe(hv_i_ModelID, hv_i_ModelType);
                HTV_create_model_recipe(ho_ImageReduced5, ho_i_ModelROI, hv_i_ModelType, (new HTuple(-180)).TupleRad()
                    , (new HTuple(360)).TupleRad(), out hv_o_ModelID);
            }
            else
            {
                hv_o_ModelID = hv_i_ModelID.Clone();
            }

            ho_i_Image_COPY_INP_TMP.Dispose();
            ho_curReg.Dispose();
            ho_PowImage.Dispose();
            ho__gamaImg.Dispose();
            ho_ImageReduced.Dispose();
            ho_ImageAffinTrans.Dispose();
            ho_ImageConverted1.Dispose();
            ho_ImageCleared.Dispose();
            ho_ImageScaled.Dispose();
            ho_ImageConverted2.Dispose();
            ho_ImageReduced5.Dispose();

            return;
        }

        public static void HTV_Bond_Inspect_model(HObject ho_i_Imgs, HObject ho_i_ModelImg, HObject ho_i_InspectReg,
            out HObject ho_o_BondContour, out HObject ho_o_FailReg, HTuple hv_i_ImgIdx,
            HTuple hv_i_BondNum, HTuple hv_i_ModelType, HTuple hv_i_ModelID, HTuple hv_i_Score,
            HTuple hv_i_AngleStart, HTuple hv_i_AngleExt, HTuple hv_i_BondSize, HTuple hv_i_IsBondRegRefine,
            HTuple hv_i_AddNum, HTuple hv_i_OverLap, HTuple hv_i_MinHistScore, out HTuple hv_o_DefectType,
            out HTuple hv_o_DefectImgIdx, out HTupleVector/*{eTupleVector,Dim=1}*/ hvec_o_DefectValue,
            out HTupleVector/*{eTupleVector,Dim=1}*/ hvec_o_RefValue, out HTuple hv_o_ErrCode,
            out HTuple hv_o_ErrStr)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_EmptyObject, ho_i_Image, ho_EmptyRegion;
            HObject ho__BondRegUnion = null;

            // Local control variables 

            HTuple hv_idx = null, hv__BondRegNum = null;
            HTuple hv__BondRows = new HTuple(), hv__BondCols = new HTuple();
            HTuple hv__ErrCode = new HTuple(), hv__ErrStr = new HTuple();
            HTuple hv__MatchScore = new HTuple(), hv_bondIdx = null;
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_BondContour);
            HOperatorSet.GenEmptyObj(out ho_o_FailReg);
            HOperatorSet.GenEmptyObj(out ho_EmptyObject);
            HOperatorSet.GenEmptyObj(out ho_i_Image);
            HOperatorSet.GenEmptyObj(out ho_EmptyRegion);
            HOperatorSet.GenEmptyObj(out ho__BondRegUnion);
            hvec_o_DefectValue = new HTupleVector(1);
            hvec_o_RefValue = new HTupleVector(1);
            try
            {
                //****使用阈值分割的方法进行Bond1检测：1.先判断Bond1是否存在，2.再阈值分割判定Bond1的检测结果
                //----------图标参数
                //i_Image：输入图像
                //i_BondRegs：Bond检测区域
                //o_BondContours：检测到的Bond轮廓
                //o_FailRegs：未检测到Bond的缺陷区域
                //-----------控制参数
                //i_HomMatMod2Img: 检测区域的映射矩阵
                //i_BondNum：定位区域内Bond的数量
                //i_ModelType: 模板类型，一般使用ncc和shape定位模板，该参数为整型类型，0-ncc，1-shape
                //i_ModelID: 模板ID号，创建匹配模板时返回值，通常由模板文件读入
                //i_Score: 最小匹配分数
                //i_AngleStart: 匹配定位起始角度
                //i_AngleExt: 匹配定位角度范围
                //i_BondSize：焊点半径大小
                //o_BondParas：bond位置信息
                //o_DefectValue：输出的实际检测得到的检测值
                //o_DefectType：输出的检测得到缺陷类型
                //o_RefValue:缺陷参考值
                //o_ErrCode: 错误码，代表该算子执行过程中产生的错误，0-代表正常执行，正整数-代表错误类型(1-未检测到焊点，2-焊点太小，3-焊点太大，4-焊点偏出焊盘)，-1-代表异常，-2-代表未执行
                //o_ErrStr: 错误信息，对各种错误的具体描述
                //*****

                //初始化
                ho_EmptyObject.Dispose();
                HOperatorSet.GenEmptyObj(out ho_EmptyObject);
                //
                ho_o_FailReg.Dispose();
                ho_o_FailReg = ho_EmptyObject.CopyObj(1, -1);
                ho_o_BondContour.Dispose();
                ho_o_BondContour = ho_EmptyObject.CopyObj(1, -1);
                //
                hv_o_DefectType = new HTuple();
                hv_o_DefectImgIdx = new HTuple();
                //
                HTuple end_val32 = hv_i_BondNum - 1;
                HTuple step_val32 = 1;
                for (hv_idx = 0; hv_idx.Continue(end_val32, step_val32); hv_idx = hv_idx.TupleAdd(step_val32))
                {
                    hvec_o_DefectValue[hv_idx] = new HTupleVector(new HTuple(-2));
                    hvec_o_RefValue[hv_idx] = new HTupleVector((new HTuple(-2)).TupleConcat(-2));
                }

                //
                hv_o_ErrCode = -2;
                hv_o_ErrStr = "Initializing";

                //输入有效性测试
                HOperatorSet.CountObj(ho_i_InspectReg, out hv__BondRegNum);
                if ((int)(new HTuple(hv__BondRegNum.TupleEqual(0))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "bond region is empty";
                    ho_EmptyObject.Dispose();
                    ho_i_Image.Dispose();
                    ho_EmptyRegion.Dispose();
                    ho__BondRegUnion.Dispose();

                    return;
                }

                //区域内检测
                //区域内检测图层获取
                ho_i_Image.Dispose();
                HOperatorSet.SelectObj(ho_i_Imgs, out ho_i_Image, hv_i_ImgIdx);

                if ((int)(hv_i_IsBondRegRefine) != 0)
                {
                    //通过直方图相似性择优选择检测结果
                    ho_o_BondContour.Dispose();
                    HTV_Bond_Location_Refine(ho_i_Image, ho_i_ModelImg, ho_i_InspectReg, out ho_o_BondContour,
                        hv_i_BondNum, hv_i_ModelType, hv_i_ModelID, hv_i_Score, hv_i_OverLap,
                        hv_i_AngleStart, hv_i_AngleExt, hv_i_BondSize, hv_i_AddNum, hv_i_MinHistScore,
                        out hv__BondRows, out hv__BondCols, out hv__ErrCode, out hv__ErrStr);
                }
                else
                {
                    //根据预设匹配数目检测
                    ho_o_BondContour.Dispose();
                    HTV_Bond_Location(ho_i_Image, ho_i_InspectReg, out ho_o_BondContour, hv_i_BondNum,
                        hv_i_ModelType, hv_i_ModelID, hv_i_Score, hv_i_AngleStart, hv_i_AngleExt,
                        hv_i_BondSize, out hv__MatchScore, out hv__BondRows, out hv__BondCols,
                        out hv__ErrCode, out hv__ErrStr);
                }
                //出现异常
                if ((int)(new HTuple(hv__ErrCode.TupleLess(0))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = hv__ErrStr.Clone();
                    ho_EmptyObject.Dispose();
                    ho_i_Image.Dispose();
                    ho_EmptyRegion.Dispose();
                    ho__BondRegUnion.Dispose();

                    return;
                }
                //
                //分配defectvalue
                HTuple end_val68 = hv_i_BondNum - 1;
                HTuple step_val68 = 1;
                for (hv_bondIdx = 0; hv_bondIdx.Continue(end_val68, step_val68); hv_bondIdx = hv_bondIdx.TupleAdd(step_val68))
                {
                    //
                    hvec_o_DefectValue[hv_bondIdx] = new HTupleVector(hv_i_BondSize).Clone();
                    //参数参考值
                    if ((int)(new HTuple((new HTuple(hv_i_BondSize.TupleLength())).TupleGreater(
                        1))) != 0)
                    {
                        hvec_o_RefValue[hv_bondIdx] = new HTupleVector(hv_i_BondSize).Clone();
                    }
                    else
                    {
                        hvec_o_RefValue[hv_bondIdx] = new HTupleVector(hv_i_BondSize.TupleConcat(
                            hv_i_BondSize));
                    }
                }
                //
                ho_EmptyRegion.Dispose();
                HOperatorSet.GenEmptyRegion(out ho_EmptyRegion);
                //
                if ((int)(new HTuple(hv__ErrCode.TupleGreater(0))) != 0)
                {
                    HTuple end_val82 = hv_i_BondNum - 1;
                    HTuple step_val82 = 1;
                    for (hv_bondIdx = 0; hv_bondIdx.Continue(end_val82, step_val82); hv_bondIdx = hv_bondIdx.TupleAdd(step_val82))
                    {
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(ho_o_FailReg, ho_i_InspectReg, out ExpTmpOutVar_0
                                );
                            ho_o_FailReg.Dispose();
                            ho_o_FailReg = ExpTmpOutVar_0;
                        }
                        //
                        if (hv_o_DefectType == null)
                            hv_o_DefectType = new HTuple();
                        hv_o_DefectType[hv_bondIdx] = 14;
                        if (hv_o_DefectImgIdx == null)
                            hv_o_DefectImgIdx = new HTuple();
                        hv_o_DefectImgIdx[hv_bondIdx] = hv_i_ImgIdx;
                    }
                }
                else
                {
                    HTuple end_val89 = hv_i_BondNum - 1;
                    HTuple step_val89 = 1;
                    for (hv_bondIdx = 0; hv_bondIdx.Continue(end_val89, step_val89); hv_bondIdx = hv_bondIdx.TupleAdd(step_val89))
                    {
                        //检测正常输出ResultReg
                        ho__BondRegUnion.Dispose();
                        HOperatorSet.Union1(ho_o_BondContour, out ho__BondRegUnion);
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(ho_o_FailReg, ho__BondRegUnion, out ExpTmpOutVar_0
                                );
                            ho_o_FailReg.Dispose();
                            ho_o_FailReg = ExpTmpOutVar_0;
                        }
                        //
                        if (hv_o_DefectType == null)
                            hv_o_DefectType = new HTuple();
                        hv_o_DefectType[hv_bondIdx] = 0;
                        if (hv_o_DefectImgIdx == null)
                            hv_o_DefectImgIdx = new HTuple();
                        hv_o_DefectImgIdx[hv_bondIdx] = hv_i_ImgIdx;
                    }
                }
                //
                if ((int)(new HTuple(hv_o_DefectType.TupleGreater(0))) != 0)
                {
                    hv_o_ErrCode = 1;
                    hv_o_ErrStr = hv__ErrStr.Clone();
                    ho_EmptyObject.Dispose();
                    ho_i_Image.Dispose();
                    ho_EmptyRegion.Dispose();
                    ho__BondRegUnion.Dispose();

                    return;
                }
                else
                {
                    hv_o_ErrCode = 0;
                    hv_o_ErrStr = hv__ErrStr.Clone();
                    ho_EmptyObject.Dispose();
                    ho_i_Image.Dispose();
                    ho_EmptyRegion.Dispose();
                    ho__BondRegUnion.Dispose();

                    return;
                }

            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_EmptyObject.Dispose();
                ho_i_Image.Dispose();
                ho_EmptyRegion.Dispose();
                ho__BondRegUnion.Dispose();

                throw HDevExpDefaultException;
            }
        }

        //2020-09-05 更新
        /*
        public static void HTV_Bond_Location(HObject ho_i_Image, HObject ho_i_BondRegs, out HObject ho_o_BondContours,
            HTuple hv_i_BondNum, HTuple hv_i_ModelType, HTuple hv_i_ModelID, HTuple hv_i_Score,
            HTuple hv_i_AngleStart, HTuple hv_i_AngleExt, HTuple hv_i_BondSize, out HTuple hv_o_BondLocFlags,
            out HTuple hv_o_BondRows, out HTuple hv_o_BondCols, out HTuple hv_o_ErrCode,
            out HTuple hv_o_ErrStr)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho__BondReg = null, ho__BondContours = null;

            // Local control variables 

            HTuple hv_RegNumber = null, hv_RegIdx = null;
            HTuple hv__BondNum = new HTuple(), hv__ErrCode = new HTuple();
            HTuple hv__ErrStr = new HTuple(), hv__BondRows = new HTuple();
            HTuple hv__BondCols = new HTuple(), hv__BondAngles = new HTuple();
            HTuple hv_idx = new HTuple(), hv__LocPara = new HTuple();
            HTuple hv__BondRow = new HTuple(), hv__BondCol = new HTuple();
            HTuple hv__BondAngle = new HTuple(), hv_BondSum = null;
            HTuple hv_IdxBond = null, hv_Index = null;
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_BondContours);
            HOperatorSet.GenEmptyObj(out ho__BondReg);
            HOperatorSet.GenEmptyObj(out ho__BondContours);
            //**********     通过模板匹配的方式定位目标
            // i_Image: 输入图像，在图像中寻找匹配对象
            // i_BondRegs：Bond所有的定位区域
            // o_BondContours：定位到Bond轮廓
            // i_HomMatMod2Img: 检测区域的映射矩阵
            // i_BondNum：定位区域内Bond的数量
            // i_ModelType: 模板类型，一般使用ncc和shape定位模板，该参数为整型类型，0-ncc，1-shape
            // i_ModelID: 模板ID号，创建匹配模板时返回值，通常由模板文件读入
            // i_Score: 最小匹配分数
            // i_AngleStart: 匹配定位起始角度
            // i_AngleExt: 匹配定位角度范围
            // o_BondRows: 匹配对象的横坐标：位置信息
            // o_BondCols: 匹配对象的纵坐标：位置信息
            // o_BondLocFlags：bond定位区域内定位结果
            // o_ErrCode: 错误码，代表该算子执行过程中产生的错误，0-代表正常执行，自然数-代表错误类型，-1-代表异常，-2-代表未执行
            // o_ErrStr: 错误信息，对各种错误的具体描述

            //初始化
            ho_o_BondContours.Dispose();
            HOperatorSet.GenEmptyObj(out ho_o_BondContours);
            hv_o_ErrCode = -2;
            hv_o_ErrStr = "initializing";
            hv_o_BondRows = new HTuple();
            hv_o_BondCols = new HTuple();
            hv_o_BondLocFlags = new HTuple();

            //定位Bond
            //映射检测区域

            //
            HOperatorSet.CountObj(ho_i_BondRegs, out hv_RegNumber);
            HTuple end_val30 = hv_RegNumber - 1;
            HTuple step_val30 = 1;
            for (hv_RegIdx = 0; hv_RegIdx.Continue(end_val30, step_val30); hv_RegIdx = hv_RegIdx.TupleAdd(step_val30))
            {
                ho__BondReg.Dispose();
                HOperatorSet.SelectObj(ho_i_BondRegs, out ho__BondReg, hv_RegIdx + 1);
                hv__BondNum = hv_i_BondNum.TupleSelect(hv_RegIdx);
                HTV_Loc_Match(ho_i_Image, ho__BondReg, hv_i_ModelType, hv_i_ModelID, hv_i_Score,
                    hv_i_AngleStart.TupleSelect(hv_RegIdx), hv_i_AngleExt, hv__BondNum, out hv__LocPara,
                    out hv__ErrCode, out hv__ErrStr);
                //判断异常
                if ((int)(new HTuple(hv__ErrCode.TupleLess(0))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = hv__ErrStr.Clone();
                    ho__BondReg.Dispose();
                    ho__BondContours.Dispose();

                    return;
                }
                //*对一个检测区域内多个Bond位置进行排序
                hv__BondRows = new HTuple();
                hv__BondCols = new HTuple();
                hv__BondAngles = new HTuple();
                if ((int)(new HTuple(hv__ErrCode.TupleGreater(0))) != 0)
                {
                    hv_o_BondLocFlags = hv_o_BondLocFlags.TupleConcat(1);
                    for (hv_idx = 0; (int)hv_idx <= (int)(((new HTuple(hv__LocPara.TupleLength())) / 3) - 1); hv_idx = (int)hv_idx + 1)
                    {
                        hv__BondRow = hv__LocPara.TupleSelect(3 * hv_idx);
                        hv__BondCol = hv__LocPara.TupleSelect((3 * hv_idx) + 1);
                        hv__BondAngle = hv__LocPara.TupleSelect((3 * hv_idx) + 2);
                        hv__BondRows = hv__BondRows.TupleConcat(hv__BondRow);
                        hv__BondCols = hv__BondCols.TupleConcat(hv__BondCol);
                        hv__BondAngles = hv__BondAngles.TupleConcat(hv__BondAngle);
                    }
                    //找到焊点进行焊点位置从模板位置映射到图像位置
                    HTV_Arrange_Pos(hv_i_ModelID, hv_i_ModelType, hv__BondRows, hv__BondCols, hv__BondAngles,
                        out hv__BondRows, out hv__BondCols);
                    hv_o_BondRows = hv_o_BondRows.TupleConcat(hv__BondRows);
                    hv_o_BondCols = hv_o_BondCols.TupleConcat(hv__BondCols);
                    //-------------------------------------------------------
                }
                else
                {
                    hv_o_BondLocFlags = hv_o_BondLocFlags.TupleConcat(0);
                    for (hv_idx = 0; (int)hv_idx <= (int)(((new HTuple(hv__LocPara.TupleLength())) / 3) - 1); hv_idx = (int)hv_idx + 1)
                    {
                        hv__BondRow = hv__LocPara.TupleSelect(3 * hv_idx);
                        hv__BondCol = hv__LocPara.TupleSelect((3 * hv_idx) + 1);
                        hv__BondAngle = hv__LocPara.TupleSelect((3 * hv_idx) + 2);
                        hv__BondRows = hv__BondRows.TupleConcat(hv__BondRow);
                        hv__BondCols = hv__BondCols.TupleConcat(hv__BondCol);
                        hv__BondAngles = hv__BondAngles.TupleConcat(hv__BondAngle);
                    }
                    //找到焊点进行焊点位置从模板位置映射到图像位置
                    HTV_Arrange_Pos(hv_i_ModelID, hv_i_ModelType, hv__BondRows, hv__BondCols, hv__BondAngles,
                        out hv__BondRows, out hv__BondCols);
                    hv_o_BondRows = hv_o_BondRows.TupleConcat(hv__BondRows);
                    hv_o_BondCols = hv_o_BondCols.TupleConcat(hv__BondCols);
                }
            }
            //定位焊点区域轮廓生成
            HOperatorSet.TupleSum(hv_i_BondNum, out hv_BondSum);
            HTuple end_val77 = hv_BondSum - 1;
            HTuple step_val77 = 1;
            for (hv_IdxBond = 0; hv_IdxBond.Continue(end_val77, step_val77); hv_IdxBond = hv_IdxBond.TupleAdd(step_val77))
            {
                ho__BondContours.Dispose();
                HOperatorSet.GenCircle(out ho__BondContours, hv_o_BondRows.TupleSelect(hv_IdxBond),
                    hv_o_BondCols.TupleSelect(hv_IdxBond), hv_i_BondSize);
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.ConcatObj(ho_o_BondContours, ho__BondContours, out ExpTmpOutVar_0
                        );
                    ho_o_BondContours.Dispose();
                    ho_o_BondContours = ExpTmpOutVar_0;
                }
            }
            //整合定位结果
            HOperatorSet.TupleFindFirst(hv_o_BondLocFlags, 1, out hv_Index);
            if ((int)(new HTuple(hv_Index.TupleGreaterEqual(0))) != 0)
            {
                hv_o_ErrCode = 1;
                hv_o_ErrStr = "Fail to Locate one or more bond";
                ho__BondReg.Dispose();
                ho__BondContours.Dispose();

                return;
            }
            else
            {
                hv_o_ErrCode = 0;
                hv_o_ErrStr = "Bond Location success";
                ho__BondReg.Dispose();
                ho__BondContours.Dispose();

                return;
            }
        }
        */

        public static void HTV_Bond_Location_Refine(HObject ho_i_Image, HObject ho_i_ModelImage,
            HObject ho_i_BondInspectReg, out HObject ho_o_BondContour, HTuple hv_i_BondNum,
            HTuple hv_i_ModelType, HTuple hv_i_ModelID, HTuple hv_i_Score, HTuple hv_i_OverLap,
            HTuple hv_i_AngleStart, HTuple hv_i_AngleExt, HTuple hv_i_BondSize, HTuple hv_i_AddNum,
            HTuple hv_i_MinHistScore, out HTuple hv_o_BondRows, out HTuple hv_o_BondCols,
            out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_Oricircle = null, ho_BondRegs, ho_BondReg = null;
            HObject ho_SortRegs, ho__BestRegs = null, ho__BestReg = null;
            HObject ho__NewRegs = null, ho_Circle0 = null, ho_EmptyRegion;
            HObject ho__BondContour = null;

            // Local control variables 

            HTuple hv_OriRow = null, hv_OriColumn = null;
            HTuple hv__BondSize = new HTuple(), hv_BinNum = null, hv_AbsoluteHisto = null;
            HTuple hv_BinSize = null, hv_Area = null, hv__Row = null;
            HTuple hv__Col = null, hv__MatchNum = new HTuple(), hv__LocPara = null;
            HTuple hv__MatchScore = null, hv__ErrCode = null, hv__ErrStr = null;
            HTuple hv__BondRows = null, hv__BondCols = null, hv__BondAngles = null;
            HTuple hv_idx = null, hv__BondRow = new HTuple(), hv__BondCol = new HTuple();
            HTuple hv__BondAngle = new HTuple(), hv_HistScore = null;
            HTuple hv_AbsoluteHisto0 = new HTuple(), hv_BinSize0 = new HTuple();
            HTuple hv_AbsoluteHisto00 = new HTuple(), hv_BC = new HTuple();
            HTuple hv__BcScore = new HTuple(), hv_SortIndex = null;
            HTuple hv_SortHistScore = null, hv_SortBondRows = null;
            HTuple hv_SortBondCols = null, hv_SortBondAngles = null;
            HTuple hv_RegNum = null, hv_RefineBondRows = new HTuple();
            HTuple hv_RefineBondCols = new HTuple(), hv_RefineBondAngs = new HTuple();
            HTuple hv__BestBondLocPara = new HTuple(), hv__OtherHistScore = new HTuple();
            HTuple hv__OtherBondRows = new HTuple(), hv__OtherBondCols = new HTuple();
            HTuple hv__OtherBondAngles = new HTuple(), hv_BondSuccNum = null;
            HTuple hv__BondLocFlags = new HTuple(), hv__AngleBase = new HTuple();
            HTuple hv_HomMat2DIdentity = new HTuple(), hv_HomMat2DRotate = new HTuple();
            HTuple hv__NewRow = new HTuple(), hv__NewCol = new HTuple();
            HTuple hv_Indices = new HTuple(), hv_SortIndices = new HTuple();
            HTuple hv_o_BondAngles = new HTuple(), hv_BondSum = null;
            HTuple hv_IdxBond = null, hv_tmp_row = new HTuple(), hv_tmp_col = new HTuple();
            HTuple hv_tmp_r = new HTuple(), hv_tmp_r1 = new HTuple();
            HTuple hv_tmp_r2 = new HTuple(), hv_Row = new HTuple();
            HTuple hv_Column = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_BondContour);
            HOperatorSet.GenEmptyObj(out ho_Oricircle);
            HOperatorSet.GenEmptyObj(out ho_BondRegs);
            HOperatorSet.GenEmptyObj(out ho_BondReg);
            HOperatorSet.GenEmptyObj(out ho_SortRegs);
            HOperatorSet.GenEmptyObj(out ho__BestRegs);
            HOperatorSet.GenEmptyObj(out ho__BestReg);
            HOperatorSet.GenEmptyObj(out ho__NewRegs);
            HOperatorSet.GenEmptyObj(out ho_Circle0);
            HOperatorSet.GenEmptyObj(out ho_EmptyRegion);
            HOperatorSet.GenEmptyObj(out ho__BondContour);
            try
            {
                //*************通过模板匹配的方式定位目标
                // i_Image: 输入图像，在图像中寻找匹配对象
                // i_BondRegs：Bond所有的定位区域
                // o_BondContours：定位到Bond轮廓
                // i_HomMatMod2Img: 检测区域的映射矩阵
                // i_BondNum：定位区域内Bond的数量
                // i_ModelType: 模板类型，一般使用ncc和shape定位模板，该参数为整型类型，0-ncc，1-shape
                // i_ModelID: 模板ID号，创建匹配模板时返回值，通常由模板文件读入
                // i_Score: 最小匹配分数
                // i_AngleStart: 匹配定位起始角度
                // i_AngleExt: 匹配定位角度范围
                // o_BondRows: 匹配对象的横坐标：位置信息
                // o_BondCols: 匹配对象的纵坐标：位置信息
                // o_BondLocFlags：bond定位区域内定位结果
                // o_ErrCode: 错误码，代表该算子执行过程中产生的错误，0-代表正常执行，自然数-代表错误类型，-1-代表异常，-2-代表未执行
                // o_ErrStr: 错误信息，对各种错误的具体描述
                //********************************************************************************************************************
                //初始化
                ho_o_BondContour.Dispose();
                HOperatorSet.GenEmptyObj(out ho_o_BondContour);
                hv_o_ErrCode = -2;
                hv_o_ErrStr = "initializing";
                hv_o_BondRows = new HTuple();
                hv_o_BondCols = new HTuple();
                //*****************************************
                //
                //模板图bond区域直方图概率分布
                HOperatorSet.GetNccModelOrigin(hv_i_ModelID, out hv_OriRow, out hv_OriColumn);
                if ((int)(new HTuple((new HTuple(hv_i_BondSize.TupleLength())).TupleLess(2))) != 0)
                {
                    hv__BondSize = hv_i_BondSize[0];
                    ho_Oricircle.Dispose();
                    HOperatorSet.GenCircle(out ho_Oricircle, -hv_OriRow, -hv_OriColumn, hv__BondSize);
                }
                else
                {
                    hv__BondSize = (hv_i_BondSize.TupleSelect(0)) + (hv_i_BondSize.TupleSelect(
                        1));
                    ho_Oricircle.Dispose();
                    HOperatorSet.GenEllipse(out ho_Oricircle, -hv_OriRow, -hv_OriColumn, 0, hv_i_BondSize.TupleSelect(
                        0), hv_i_BondSize.TupleSelect(1));
                }
                hv_BinNum = 64;
                HOperatorSet.GrayHistoRange(ho_Oricircle, ho_i_ModelImage, 0, 255, hv_BinNum,
                    out hv_AbsoluteHisto, out hv_BinSize);
                HOperatorSet.AreaCenter(ho_Oricircle, out hv_Area, out hv__Row, out hv__Col);
                hv_Area = hv_Area * 1.0;
                HOperatorSet.TupleDiv(hv_AbsoluteHisto, hv_Area, out hv_AbsoluteHisto);

                //**********************************检测区域内开始匹配*****************************************************
                //*-比实际多输出n个候选区
                if ((int)(new HTuple(hv_i_AddNum.TupleLess(0))) != 0)
                {
                    hv__MatchNum = 0;
                }
                else
                {
                    hv__MatchNum = hv_i_BondNum + hv_i_AddNum;
                }
                //
                HTV_Loc_Match_All(ho_i_Image, ho_i_BondInspectReg, hv_i_ModelType, hv_i_ModelID,
                    hv_i_Score, hv_i_AngleStart, hv_i_AngleExt, hv__MatchNum, hv_i_OverLap,
                    out hv__LocPara, out hv__MatchScore, out hv__ErrCode, out hv__ErrStr);
                //
                //判断异常
                if ((int)(new HTuple(hv__ErrCode.TupleLess(0))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = hv__ErrStr.Clone();
                    ho_Oricircle.Dispose();
                    ho_BondRegs.Dispose();
                    ho_BondReg.Dispose();
                    ho_SortRegs.Dispose();
                    ho__BestRegs.Dispose();
                    ho__BestReg.Dispose();
                    ho__NewRegs.Dispose();
                    ho_Circle0.Dispose();
                    ho_EmptyRegion.Dispose();
                    ho__BondContour.Dispose();

                    return;
                }
                //对候选匹配区域进行挑选
                hv__BondRows = new HTuple();
                hv__BondCols = new HTuple();
                hv__BondAngles = new HTuple();
                //映射实际坐标
                for (hv_idx = 0; (int)hv_idx <= (int)(((new HTuple(hv__LocPara.TupleLength())) / 3) - 1); hv_idx = (int)hv_idx + 1)
                {
                    hv__BondRow = hv__LocPara.TupleSelect(3 * hv_idx);
                    hv__BondCol = hv__LocPara.TupleSelect((3 * hv_idx) + 1);
                    hv__BondAngle = hv__LocPara.TupleSelect((3 * hv_idx) + 2);
                    hv__BondRows = hv__BondRows.TupleConcat(hv__BondRow);
                    hv__BondCols = hv__BondCols.TupleConcat(hv__BondCol);
                    hv__BondAngles = hv__BondAngles.TupleConcat(hv__BondAngle);
                }
                HTV_Arrange_Pos(hv_i_ModelID, hv_i_ModelType, hv__BondRows, hv__BondCols, hv__BondAngles,
                    out hv__BondRows, out hv__BondCols);

                hv_HistScore = new HTuple();
                ho_BondRegs.Dispose();
                HOperatorSet.GenEmptyObj(out ho_BondRegs);
                for (hv_idx = 0; (int)hv_idx <= (int)((new HTuple(hv__MatchScore.TupleLength())) - 1); hv_idx = (int)hv_idx + 1)
                {
                    if ((int)(new HTuple((new HTuple(hv_i_BondSize.TupleLength())).TupleLess(
                        2))) != 0)
                    {
                        ho_BondReg.Dispose();
                        HOperatorSet.GenCircle(out ho_BondReg, hv__BondRows.TupleSelect(hv_idx),
                            hv__BondCols.TupleSelect(hv_idx), hv__BondSize);
                    }
                    else
                    {
                        ho_BondReg.Dispose();
                        HOperatorSet.GenEllipse(out ho_BondReg, hv__BondRows.TupleSelect(hv_idx),
                            hv__BondCols.TupleSelect(hv_idx), hv__BondAngles.TupleSelect(hv_idx),
                            hv_i_BondSize.TupleSelect(0), hv_i_BondSize.TupleSelect(1));
                    }
                    //为了减小边缘不全区域分数
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.Intersection(ho_BondReg, ho_i_BondInspectReg, out ExpTmpOutVar_0
                            );
                        ho_BondReg.Dispose();
                        ho_BondReg = ExpTmpOutVar_0;
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_BondRegs, ho_BondReg, out ExpTmpOutVar_0);
                        ho_BondRegs.Dispose();
                        ho_BondRegs = ExpTmpOutVar_0;
                    }
                    //计算直方图相似度
                    HOperatorSet.GrayHistoRange(ho_BondReg, ho_i_Image, 0, 255, hv_BinNum, out hv_AbsoluteHisto0,
                        out hv_BinSize0);
                    HOperatorSet.TupleDiv(hv_AbsoluteHisto0, hv_Area, out hv_AbsoluteHisto00);
                    hv_BC = ((hv_AbsoluteHisto * hv_AbsoluteHisto00)).TupleSqrt();
                    HOperatorSet.TupleSum(hv_BC, out hv__BcScore);
                    //排除相似性很差的结果
                    if ((int)(new HTuple(hv__BcScore.TupleGreater(hv_i_MinHistScore))) != 0)
                    {
                        hv_HistScore = hv_HistScore.TupleConcat(hv__BcScore);
                    }
                }

                HOperatorSet.TupleSortIndex(hv_HistScore, out hv_SortIndex);
                HOperatorSet.TupleInverse(hv_SortIndex, out hv_SortIndex);
                ho_SortRegs.Dispose();
                HOperatorSet.SelectObj(ho_BondRegs, out ho_SortRegs, hv_SortIndex + 1);
                HOperatorSet.TupleSelect(hv_HistScore, hv_SortIndex, out hv_SortHistScore);
                HOperatorSet.TupleSelect(hv__BondRows, hv_SortIndex, out hv_SortBondRows);
                HOperatorSet.TupleSelect(hv__BondCols, hv_SortIndex, out hv_SortBondCols);
                HOperatorSet.TupleSelect(hv__BondAngles, hv_SortIndex, out hv_SortBondAngles);
                hv_RegNum = new HTuple(hv_SortIndex.TupleLength());

                if ((int)(new HTuple(hv_RegNum.TupleGreater(1))) != 0)
                {
                    ho__BestRegs.Dispose();
                    HOperatorSet.GenEmptyObj(out ho__BestRegs);
                    hv_RefineBondRows = new HTuple();
                    hv_RefineBondCols = new HTuple();
                    hv_RefineBondAngs = new HTuple();
                    HTuple end_val107 = hv_i_BondNum - 1;
                    HTuple step_val107 = 1;
                    for (hv_idx = 0; hv_idx.Continue(end_val107, step_val107); hv_idx = hv_idx.TupleAdd(step_val107))
                    {
                        //通过交集分类输出最优结果
                        ho__BestReg.Dispose(); ho__NewRegs.Dispose();
                        HTV_Select_BestReg(ho_SortRegs, out ho__BestReg, out ho__NewRegs, hv_RegNum,
                            hv_SortHistScore, hv_SortBondRows, hv_SortBondCols, hv_SortBondAngles,
                            out hv__BestBondLocPara, out hv__OtherHistScore, out hv__OtherBondRows,
                            out hv__OtherBondCols, out hv__OtherBondAngles);
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(ho__BestRegs, ho__BestReg, out ExpTmpOutVar_0);
                            ho__BestRegs.Dispose();
                            ho__BestRegs = ExpTmpOutVar_0;
                        }
                        hv_RefineBondRows = hv_RefineBondRows.TupleConcat(hv__BestBondLocPara.TupleSelect(
                            0));
                        hv_RefineBondCols = hv_RefineBondCols.TupleConcat(hv__BestBondLocPara.TupleSelect(
                            1));
                        hv_RefineBondAngs = hv_RefineBondAngs.TupleConcat(hv__BestBondLocPara.TupleSelect(
                            2));
                        ho_Circle0.Dispose();
                        HOperatorSet.GenCircle(out ho_Circle0, hv__BestBondLocPara.TupleSelect(
                            0), hv__BestBondLocPara.TupleSelect(1), hv__BondSize);
                        ho_SortRegs.Dispose();
                        ho_SortRegs = ho__NewRegs.CopyObj(1, -1);
                        hv_SortBondRows = hv__OtherBondRows.Clone();
                        hv_SortBondCols = hv__OtherBondCols.Clone();
                        hv_SortBondAngles = hv__OtherBondAngles.Clone();
                        hv_SortHistScore = hv__OtherHistScore.Clone();
                        hv_RegNum = new HTuple(hv__OtherHistScore.TupleLength());
                    }
                }
                else
                {
                    ho__BestRegs.Dispose();
                    ho__BestRegs = ho_SortRegs.CopyObj(1, -1);
                    hv_RefineBondRows = hv_SortBondRows.Clone();
                    hv_RefineBondCols = hv_SortBondCols.Clone();
                    hv_RefineBondAngs = hv_SortBondAngles.Clone();
                }

                HOperatorSet.CountObj(ho__BestRegs, out hv_BondSuccNum);
                if ((int)(new HTuple(hv_BondSuccNum.TupleLess(hv_i_BondNum))) != 0)
                {
                    hv__BondLocFlags = 1;
                    //顺时针排序
                    hv__BondRows = hv_RefineBondRows.Clone();
                    hv__BondCols = hv_RefineBondCols.Clone();
                    hv__BondAngles = hv_RefineBondAngs.Clone();
                    if ((int)(new HTuple((new HTuple(hv__BondRows.TupleLength())).TupleGreater(
                        1))) != 0)
                    {
                        hv__AngleBase = hv_i_AngleStart.Clone();
                        HOperatorSet.HomMat2dIdentity(out hv_HomMat2DIdentity);
                        HOperatorSet.HomMat2dRotate(hv_HomMat2DIdentity, -hv__AngleBase, 0, 0,
                            out hv_HomMat2DRotate);
                        HOperatorSet.AffineTransPoint2d(hv_HomMat2DRotate, hv__BondRows, hv__BondCols,
                            out hv__NewRow, out hv__NewCol);
                        HOperatorSet.TupleSortIndex(hv__NewRow, out hv_Indices);
                        HOperatorSet.TupleInverse(hv_Indices, out hv_SortIndices);
                        hv__BondRows = hv__BondRows.TupleSelect(hv_SortIndices);
                        hv__BondCols = hv__BondCols.TupleSelect(hv_SortIndices);
                    }

                    hv_o_BondRows = hv_o_BondRows.TupleConcat(hv__BondRows);
                    hv_o_BondCols = hv_o_BondCols.TupleConcat(hv__BondCols);
                    hv_o_BondAngles = hv_o_BondAngles.TupleConcat(hv__BondAngles);

                }
                else
                {
                    hv__BondLocFlags = 0;
                    //顺时针排序
                    hv__BondRows = hv_RefineBondRows.Clone();
                    hv__BondCols = hv_RefineBondCols.Clone();
                    hv__BondAngles = hv_RefineBondAngs.Clone();
                    if ((int)(new HTuple((new HTuple(hv__BondRows.TupleLength())).TupleGreater(
                        1))) != 0)
                    {
                        hv__AngleBase = hv_i_AngleStart.Clone();
                        HOperatorSet.HomMat2dIdentity(out hv_HomMat2DIdentity);
                        HOperatorSet.HomMat2dRotate(hv_HomMat2DIdentity, -hv__AngleBase, 0, 0,
                            out hv_HomMat2DRotate);
                        HOperatorSet.AffineTransPoint2d(hv_HomMat2DRotate, hv__BondRows, hv__BondCols,
                            out hv__NewRow, out hv__NewCol);
                        HOperatorSet.TupleSortIndex(hv__NewRow, out hv_Indices);
                        HOperatorSet.TupleInverse(hv_Indices, out hv_SortIndices);
                        hv__BondRows = hv__BondRows.TupleSelect(hv_SortIndices);
                        hv__BondCols = hv__BondCols.TupleSelect(hv_SortIndices);
                    }

                    hv_o_BondRows = hv_o_BondRows.TupleConcat(hv__BondRows);
                    hv_o_BondCols = hv_o_BondCols.TupleConcat(hv__BondCols);
                    hv_o_BondAngles = hv_o_BondAngles.TupleConcat(hv__BondAngles);
                }
                //
                //定位焊点区域轮廓生成
                hv_BondSum = new HTuple(hv_o_BondRows.TupleLength());
                ho_EmptyRegion.Dispose();
                HOperatorSet.GenEmptyRegion(out ho_EmptyRegion);
                //
                HTuple end_val177 = hv_BondSum - 1;
                HTuple step_val177 = 1;
                for (hv_IdxBond = 0; hv_IdxBond.Continue(end_val177, step_val177); hv_IdxBond = hv_IdxBond.TupleAdd(step_val177))
                {

                    hv_tmp_row = hv_o_BondRows.TupleSelect(hv_IdxBond);
                    hv_tmp_col = hv_o_BondCols.TupleSelect(hv_IdxBond);
                    //
                    if ((int)(new HTuple((new HTuple(hv_i_BondSize.TupleLength())).TupleLess(
                        2))) != 0)
                    {
                        //生成圆
                        if ((int)((new HTuple(hv_tmp_row.TupleLess(0))).TupleOr(new HTuple(hv_tmp_col.TupleLess(
                            0)))) != 0)
                        {
                            hv_tmp_r = 0;
                        }
                        else
                        {
                            hv_tmp_r = hv_i_BondSize[0];
                        }
                        ho__BondContour.Dispose();
                        HOperatorSet.GenCircle(out ho__BondContour, hv_o_BondRows.TupleSelect(hv_IdxBond),
                            hv_o_BondCols.TupleSelect(hv_IdxBond), hv_tmp_r);
                    }
                    else
                    {
                        //生成椭圆
                        if ((int)((new HTuple(hv_tmp_row.TupleLess(0))).TupleOr(new HTuple(hv_tmp_col.TupleLess(
                            0)))) != 0)
                        {
                            hv_tmp_r1 = 0;
                            hv_tmp_r2 = 0;
                        }
                        else
                        {
                            if ((int)(new HTuple(((hv_i_BondSize.TupleSelect(0))).TupleGreater(hv_i_BondSize.TupleSelect(
                                1)))) != 0)
                            {
                                hv_tmp_r1 = hv_i_BondSize[0];
                                hv_tmp_r2 = hv_i_BondSize[1];
                            }
                            else
                            {
                                hv_tmp_r1 = hv_i_BondSize[1];
                                hv_tmp_r2 = hv_i_BondSize[0];
                            }
                        }
                        ho__BondContour.Dispose();
                        HOperatorSet.GenEllipse(out ho__BondContour, hv_o_BondRows.TupleSelect(
                            hv_IdxBond), hv_o_BondCols.TupleSelect(hv_IdxBond), hv_o_BondAngles.TupleSelect(
                            hv_IdxBond), hv_tmp_r1, hv_tmp_r2);
                    }
                    //
                    HOperatorSet.AreaCenter(ho__BondContour, out hv_Area, out hv_Row, out hv_Column);
                    if ((int)(new HTuple(hv_Area.TupleEqual(0))) != 0)
                    {
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(ho_o_BondContour, ho_EmptyRegion, out ExpTmpOutVar_0
                                );
                            ho_o_BondContour.Dispose();
                            ho_o_BondContour = ExpTmpOutVar_0;
                        }
                    }
                    else
                    {
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(ho_o_BondContour, ho__BondContour, out ExpTmpOutVar_0
                                );
                            ho_o_BondContour.Dispose();
                            ho_o_BondContour = ExpTmpOutVar_0;
                        }
                    }
                }

                //整合定位结果
                if ((int)(new HTuple(hv__BondLocFlags.TupleGreater(0))) != 0)
                {
                    hv_o_ErrCode = 1;
                    hv_o_ErrStr = "Fail to Locate one or more bond";
                    ho_Oricircle.Dispose();
                    ho_BondRegs.Dispose();
                    ho_BondReg.Dispose();
                    ho_SortRegs.Dispose();
                    ho__BestRegs.Dispose();
                    ho__BestReg.Dispose();
                    ho__NewRegs.Dispose();
                    ho_Circle0.Dispose();
                    ho_EmptyRegion.Dispose();
                    ho__BondContour.Dispose();

                    return;
                }
                else
                {
                    hv_o_ErrCode = 0;
                    hv_o_ErrStr = "Bond Location success";
                    ho_Oricircle.Dispose();
                    ho_BondRegs.Dispose();
                    ho_BondReg.Dispose();
                    ho_SortRegs.Dispose();
                    ho__BestRegs.Dispose();
                    ho__BestReg.Dispose();
                    ho__NewRegs.Dispose();
                    ho_Circle0.Dispose();
                    ho_EmptyRegion.Dispose();
                    ho__BondContour.Dispose();

                    return;
                }
                //
                //
                //焊点去重用 add_lw 1104
                //if (|i_BondSize| < 2)
                //DistTh := i_BondSize[0]
                //else
                //DistTh := i_BondSize[1]
                //endif
                //dilation_circle (i_BondInspectReg, BondDilateRegs, DistTh)
                //
                //焊点去重 add_lw 1104
                //if (IdxBond > 1)
                //前两个焊点
                //tmp_row0 := o_BondRows[IdxBond-2]
                //tmp_col0 := o_BondCols[IdxBond-2]
                //前一个焊点
                //tmp_row1 := o_BondRows[IdxBond-1]
                //tmp_col1 := o_BondCols[IdxBond-1]
                //距离小于BondSize认为重合
                //distance_pp (tmp_row, tmp_col, tmp_row0, tmp_col0, dist0)
                //distance_pp (tmp_row, tmp_col, tmp_row1, tmp_col1, dist1)
                //if (dist0 < DistTh or dist1 < DistTh)
                //根据焊点中点所在区域找到对应检测框，通过距离比较找出FailReg
                //get_region_index (BondDilateRegs, int(tmp_row), int(tmp_col), RegIndex)
                //select_obj (i_BondInspectReg, _SeclectBondReg, RegIndex)
                //area_center (_SeclectBondReg, RegArea, RegRow, RegCol)
                //tuple_gen_const (|RegRow|, tmp_row, CurRow)
                //tuple_gen_const (|RegCol|, tmp_col, CurCol)
                //distance_pp (CurRow, CurCol, RegRow, RegCol, DistTuple)
                //tuple_max (DistTuple, MaxDist)
                //tuple_find (DistTuple, MaxDist, FailIdx)
                //RegFailIndex := RegIndex[FailIdx]
                //重合结果更改
                //o_BondLocFlags[RegFailIndex-1] := 1
                //tmp_row := -1
                //tmp_col := -1
                //endif
                //elseif (IdxBond > 0)
                //前一个焊点
                //tmp_row1 := o_BondRows[IdxBond-1]
                //tmp_col1 := o_BondCols[IdxBond-1]
                //距离小于BondSize认为重合
                //distance_pp (tmp_row, tmp_col, tmp_row1, tmp_col1, dist1)
                //if (dist1 < DistTh)
                //根据焊点中点所在区域找到对应检测框，通过距离比较找出FailReg
                //get_region_index (BondDilateRegs, int(tmp_row), int(tmp_col), RegIndex)
                //select_obj (i_BondInspectReg, _SeclectBondReg, RegIndex)
                //area_center (_SeclectBondReg, RegArea, RegRow, RegCol)
                //tuple_gen_const (|RegRow|, tmp_row, CurRow)
                //tuple_gen_const (|RegCol|, tmp_col, CurCol)
                //distance_pp (CurRow, CurCol, RegRow, RegCol, DistTuple)
                //tuple_max (DistTuple, MaxDist)
                //tuple_find (DistTuple, MaxDist, FailIdx)
                //RegFailIndex := RegIndex[FailIdx]
                //重合结果更改
                //o_BondLocFlags[RegFailIndex-1] := 1
                //tmp_row := -1
                //tmp_col := -1
                //endif
                //endif


            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Oricircle.Dispose();
                ho_BondRegs.Dispose();
                ho_BondReg.Dispose();
                ho_SortRegs.Dispose();
                ho__BestRegs.Dispose();
                ho__BestReg.Dispose();
                ho__NewRegs.Dispose();
                ho_Circle0.Dispose();
                ho_EmptyRegion.Dispose();
                ho__BondContour.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public static void HTV_Loc_Match_All(HObject ho_i_Image, HObject ho_i_SearchReg, HTuple hv_i_ModelType,
            HTuple hv_i_ModelID, HTuple hv_i_MinScore, HTuple hv_i_AngleStart, HTuple hv_i_AngleExt,
            HTuple hv_i_MatchNum, HTuple hv_i_MaxOverlap, out HTuple hv_o_LocPara, out HTuple hv_o_Score,
            out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {




            // Local iconic variables 

            HObject ho_searchImage;

            // Local control variables 

            HTuple hv_imgNum = null, hv_regNum = null;
            HTuple hv_Row = new HTuple(), hv_Column = new HTuple();
            HTuple hv_Angle = new HTuple(), hv_idx = null;
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_searchImage);
            hv_o_LocPara = new HTuple();
            hv_o_Score = new HTuple();
            try
            {
                //**********     通过模板匹配的方式定位目标
                // i_Image: 输入图像，在图像中寻找匹配对象
                // i_SearchReg: 搜索区域，在区域内匹配目标对象
                // i_ModelType: 模板类型，一般使用ncc和shape定位模板，该参数为整型类型，0-ncc，1-shape
                // i_ModelID: 模板ID号，创建匹配模板时返回值，通常由模板文件读入
                // i_Score: 最小匹配分数
                // i_AngleStart: 匹配定位起始角度
                // i_AngleExt: 匹配定位角度范围
                // i_MatchNum: 需要匹配的目标个数
                // o_LocPara: 匹配对象的位置信息
                // o_ErrCode: 错误码，代表该算子执行过程中产生的错误，0-代表正常执行，自然数-代表错误类型，-1-代表异常，-2-代表未执行
                // o_ErrStr: 错误信息，对各种错误的具体描述

                //初始化
                hv_o_ErrCode = -2;
                hv_o_ErrStr = "initializing";

                //输入有效性测试
                HOperatorSet.CountObj(ho_i_Image, out hv_imgNum);
                if ((int)(new HTuple(hv_imgNum.TupleEqual(0))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "input image is null";
                    ho_searchImage.Dispose();

                    return;
                }
                HOperatorSet.CountObj(ho_i_SearchReg, out hv_regNum);
                if ((int)(new HTuple(hv_regNum.TupleLess(1))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "search region is empty";
                    ho_searchImage.Dispose();

                    return;
                }
                if ((int)(new HTuple((new HTuple(hv_i_ModelType.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "para i_ModelType is illegal";
                    ho_searchImage.Dispose();

                    return;
                }
                if ((int)((new HTuple((new HTuple(hv_i_ModelID.TupleLength())).TupleEqual(0))).TupleOr(
                    new HTuple(hv_i_ModelID.TupleLess(0)))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "para i_ModelID is illegal";
                    ho_searchImage.Dispose();

                    return;
                }
                if ((int)((new HTuple((new HTuple((new HTuple(hv_i_MinScore.TupleLength())).TupleEqual(
                    0))).TupleOr(new HTuple(hv_i_MinScore.TupleLess(0))))).TupleOr(new HTuple(hv_i_MinScore.TupleGreater(
                    1)))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "para i_MinScore is illegal";
                    ho_searchImage.Dispose();

                    return;
                }
                if ((int)((new HTuple((new HTuple((new HTuple(hv_i_MaxOverlap.TupleLength()
                    )).TupleEqual(0))).TupleOr(new HTuple(hv_i_MaxOverlap.TupleLess(0))))).TupleOr(
                    new HTuple(hv_i_MaxOverlap.TupleGreater(1)))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "para i_MaxOverlap is illegal";
                    ho_searchImage.Dispose();

                    return;
                }
                if ((int)(new HTuple((new HTuple(hv_i_AngleStart.TupleLength())).TupleEqual(
                    0))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "para i_AngleStart is illegal";
                    ho_searchImage.Dispose();

                    return;
                }
                if ((int)(new HTuple((new HTuple(hv_i_AngleExt.TupleLength())).TupleEqual(0))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "para i_AngleExt is illegal";
                    ho_searchImage.Dispose();

                    return;
                }
                if ((int)((new HTuple((new HTuple(hv_i_MatchNum.TupleLength())).TupleEqual(
                    0))).TupleOr(new HTuple(hv_i_MatchNum.TupleLess(0)))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "para i_MatchNum is illegal";
                    ho_searchImage.Dispose();

                    return;
                }

                //根据匹配类型选择算法进行模板匹配
                ho_searchImage.Dispose();
                HOperatorSet.ReduceDomain(ho_i_Image, ho_i_SearchReg, out ho_searchImage);
                if ((int)(new HTuple(hv_i_ModelType.TupleEqual("ncc"))) != 0)
                {
                    HOperatorSet.FindNccModel(ho_searchImage, hv_i_ModelID, hv_i_AngleStart,
                        hv_i_AngleExt, hv_i_MinScore, hv_i_MatchNum, hv_i_MaxOverlap, "true",
                        0, out hv_Row, out hv_Column, out hv_Angle, out hv_o_Score);
                }
                else if ((int)(new HTuple(hv_i_ModelType.TupleEqual("shape"))) != 0)
                {
                    HOperatorSet.FindShapeModel(ho_searchImage, hv_i_ModelID, hv_i_AngleStart,
                        hv_i_AngleExt, hv_i_MinScore, hv_i_MatchNum, hv_i_MaxOverlap, "least_squares",
                        0, 0.9, out hv_Row, out hv_Column, out hv_Angle, out hv_o_Score);
                }
                else
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "unsupported model type!";
                    ho_searchImage.Dispose();

                    return;
                }

                //将匹配到的对象位置信息保存到输出参数数组中
                for (hv_idx = 0; (int)hv_idx <= (int)((new HTuple(hv_o_Score.TupleLength())) - 1); hv_idx = (int)hv_idx + 1)
                {
                    if (hv_o_LocPara == null)
                        hv_o_LocPara = new HTuple();
                    hv_o_LocPara[hv_idx * 3] = hv_Row.TupleSelect(hv_idx);
                    if (hv_o_LocPara == null)
                        hv_o_LocPara = new HTuple();
                    hv_o_LocPara[(hv_idx * 3) + 1] = hv_Column.TupleSelect(hv_idx);
                    if (hv_o_LocPara == null)
                        hv_o_LocPara = new HTuple();
                    hv_o_LocPara[(hv_idx * 3) + 2] = hv_Angle.TupleSelect(hv_idx);
                }

                hv_o_ErrCode = 0;
                hv_o_ErrStr = "model match successful";

                ho_searchImage.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_searchImage.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public static void HTV_Select_BestReg(HObject ho_i_SortRegs, out HObject ho_o_BestReg,
            out HObject ho_o_OtherRegs, HTuple hv_i_RegNum, HTuple hv_i_Scores, HTuple hv_i_Rows,
            HTuple hv_i_Cols, HTuple hv_i_Angles, out HTuple hv_o_BestLocPara, out HTuple hv_o_OtherScores,
            out HTuple hv_o_OtherRows, out HTuple hv_o_OtherCols, out HTuple hv_o_OtherAngles)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_EmptyReg, ho_CurReg = null, ho_InterseReg = null;

            // Local control variables 

            HTuple hv_idx = null, hv_IsEqual = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_BestReg);
            HOperatorSet.GenEmptyObj(out ho_o_OtherRegs);
            HOperatorSet.GenEmptyObj(out ho_EmptyReg);
            HOperatorSet.GenEmptyObj(out ho_CurReg);
            HOperatorSet.GenEmptyObj(out ho_InterseReg);
            try
            {
                //**************************************************************************************************
                //---函数：HTV_Select_BestReg
                //---作用：根据得分选择最佳区域
                //===图标参数
                //  i_SortRegs：源候选区域
                //  o_BestReg：最优区
                //  o_OtherRegs：剩余区域
                //===控制参数
                //  i_RegNum：候选区数目
                //  i_Scores：候选区得分
                //  i_Rows：候选区域坐标
                //  i_Cols：候选区域坐标
                //  i_Angless：候选区角度
                //  o_BestLocPara：最优区定位参数
                //  o_OtherScores：剩余区域得分
                //  o_OtherRows：剩余区坐标
                //  o_OtherCols：剩余区坐标
                //  o_OtherAngles：剩余区角度
                //**************************************************************************************************


                hv_o_OtherScores = new HTuple();
                hv_o_OtherRows = new HTuple();
                hv_o_OtherCols = new HTuple();
                hv_o_OtherAngles = new HTuple();
                ho_o_OtherRegs.Dispose();
                HOperatorSet.GenEmptyObj(out ho_o_OtherRegs);
                ho_EmptyReg.Dispose();
                HOperatorSet.GenEmptyRegion(out ho_EmptyReg);

                ho_o_BestReg.Dispose();
                HOperatorSet.SelectObj(ho_i_SortRegs, out ho_o_BestReg, 1);
                hv_o_BestLocPara = new HTuple();
                hv_o_BestLocPara = hv_o_BestLocPara.TupleConcat(hv_i_Rows.TupleSelect(
                    0));
                hv_o_BestLocPara = hv_o_BestLocPara.TupleConcat(hv_i_Cols.TupleSelect(
                    0));
                hv_o_BestLocPara = hv_o_BestLocPara.TupleConcat(hv_i_Angles.TupleSelect(
                    0));
                HTuple end_val30 = hv_i_RegNum - 1;
                HTuple step_val30 = 1;
                for (hv_idx = 1; hv_idx.Continue(end_val30, step_val30); hv_idx = hv_idx.TupleAdd(step_val30))
                {
                    ho_CurReg.Dispose();
                    HOperatorSet.SelectObj(ho_i_SortRegs, out ho_CurReg, hv_idx + 1);
                    //此处可用IoU判定，简化为交集
                    ho_InterseReg.Dispose();
                    HOperatorSet.Intersection(ho_o_BestReg, ho_CurReg, out ho_InterseReg);
                    HOperatorSet.TestEqualObj(ho_InterseReg, ho_EmptyReg, out hv_IsEqual);
                    if ((int)(new HTuple(hv_IsEqual.TupleEqual(1))) != 0)
                    {
                        hv_o_OtherScores = hv_o_OtherScores.TupleConcat(hv_i_Scores.TupleSelect(
                            hv_idx));
                        hv_o_OtherRows = hv_o_OtherRows.TupleConcat(hv_i_Rows.TupleSelect(hv_idx));
                        hv_o_OtherCols = hv_o_OtherCols.TupleConcat(hv_i_Cols.TupleSelect(hv_idx));
                        hv_o_OtherAngles = hv_o_OtherAngles.TupleConcat(hv_i_Angles.TupleSelect(
                            hv_idx));
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(ho_o_OtherRegs, ho_CurReg, out ExpTmpOutVar_0);
                            ho_o_OtherRegs.Dispose();
                            ho_o_OtherRegs = ExpTmpOutVar_0;
                        }
                    }
                }

                ho_EmptyReg.Dispose();
                ho_CurReg.Dispose();
                ho_InterseReg.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_EmptyReg.Dispose();
                ho_CurReg.Dispose();
                ho_InterseReg.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public static void HTV_Bond_Location(HObject ho_i_Image, HObject ho_i_BondInspectReg,
            out HObject ho_o_BondContour, HTuple hv_i_BondNum, HTuple hv_i_ModelType, HTuple hv_i_ModelID,
            HTuple hv_i_Score, HTuple hv_i_AngleStart, HTuple hv_i_AngleExt, HTuple hv_i_BondSize,
            out HTuple hv_o_MatchScore, out HTuple hv_o_BondRows, out HTuple hv_o_BondCols,
            out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_EmptyRegion, ho__BondContour = null;

            // Local control variables 

            HTuple hv_o_BondAngles = null, hv__LocPara = null;
            HTuple hv__Score = null, hv__ErrCode = null, hv__ErrStr = null;
            HTuple hv__BondRows = null, hv__BondCols = null, hv__BondAngles = null;
            HTuple hv__BondLocFlags = new HTuple(), hv_idx = new HTuple();
            HTuple hv__BondRow = new HTuple(), hv__BondCol = new HTuple();
            HTuple hv__BondAngle = new HTuple(), hv__AngleBase = new HTuple();
            HTuple hv_HomMat2DIdentity = new HTuple(), hv_HomMat2DRotate = new HTuple();
            HTuple hv__NewRow = new HTuple(), hv__NewCol = new HTuple();
            HTuple hv_Indices = new HTuple(), hv_SortIndices = new HTuple();
            HTuple hv_BondSum = null, hv_IdxBond = null, hv_tmp_row = new HTuple();
            HTuple hv_tmp_col = new HTuple(), hv_tmp_r = new HTuple();
            HTuple hv_tmp_r1 = new HTuple(), hv_tmp_r2 = new HTuple();
            HTuple hv_Area = new HTuple(), hv_Row = new HTuple(), hv_Column = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_BondContour);
            HOperatorSet.GenEmptyObj(out ho_EmptyRegion);
            HOperatorSet.GenEmptyObj(out ho__BondContour);
            try
            {
                //**********     通过模板匹配的方式定位目标
                // i_Image: 输入图像，在图像中寻找匹配对象
                // i_BondRegs：Bond所有的定位区域
                // o_BondContours：定位到Bond轮廓
                // i_HomMatMod2Img: 检测区域的映射矩阵
                // i_BondNum：定位区域内Bond的数量
                // i_ModelType: 模板类型，一般使用ncc和shape定位模板，该参数为整型类型，0-ncc，1-shape
                // i_ModelID: 模板ID号，创建匹配模板时返回值，通常由模板文件读入
                // i_Score: 最小匹配分数
                // i_AngleStart: 匹配定位起始角度
                // i_AngleExt: 匹配定位角度范围
                // o_BondRows: 匹配对象的横坐标：位置信息
                // o_BondCols: 匹配对象的纵坐标：位置信息
                // o_BondLocFlags：bond定位区域内定位结果
                // o_ErrCode: 错误码，代表该算子执行过程中产生的错误，0-代表正常执行，自然数-代表错误类型，-1-代表异常，-2-代表未执行
                // o_ErrStr: 错误信息，对各种错误的具体描述

                //初始化
                ho_o_BondContour.Dispose();
                HOperatorSet.GenEmptyObj(out ho_o_BondContour);
                hv_o_ErrCode = -2;
                hv_o_ErrStr = "initializing";
                hv_o_BondRows = new HTuple();
                hv_o_BondCols = new HTuple();
                hv_o_BondAngles = new HTuple();
                //
                hv_o_MatchScore = new HTuple();
                //
                //***************************************检测区域内开始匹配*****************************************************
                //
                HTV_Loc_Match(ho_i_Image, ho_i_BondInspectReg, hv_i_ModelType, hv_i_ModelID,
                    hv_i_Score, hv_i_AngleStart, hv_i_AngleExt, hv_i_BondNum, out hv__LocPara,
                    out hv__Score, out hv__ErrCode, out hv__ErrStr);

                hv_o_MatchScore = hv_o_MatchScore.TupleConcat(hv__Score);
                //判断异常
                if ((int)(new HTuple(hv__ErrCode.TupleLess(0))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = hv__ErrStr.Clone();
                    ho_EmptyRegion.Dispose();
                    ho__BondContour.Dispose();

                    return;
                }
                //*对一个检测区域内多个Bond位置进行排序
                hv__BondRows = new HTuple();
                hv__BondCols = new HTuple();
                hv__BondAngles = new HTuple();
                if ((int)(new HTuple(hv__ErrCode.TupleGreater(0))) != 0)
                {
                    hv__BondLocFlags = 1;
                    for (hv_idx = 0; (int)hv_idx <= (int)(((new HTuple(hv__LocPara.TupleLength())) / 3) - 1); hv_idx = (int)hv_idx + 1)
                    {
                        hv__BondRow = hv__LocPara.TupleSelect(3 * hv_idx);
                        hv__BondCol = hv__LocPara.TupleSelect((3 * hv_idx) + 1);
                        hv__BondAngle = hv__LocPara.TupleSelect((3 * hv_idx) + 2);
                        hv__BondRows = hv__BondRows.TupleConcat(hv__BondRow);
                        hv__BondCols = hv__BondCols.TupleConcat(hv__BondCol);
                        hv__BondAngles = hv__BondAngles.TupleConcat(hv__BondAngle);
                    }
                    //找到焊点进行焊点位置从模板位置映射到图像位置
                    HTV_Arrange_Pos(hv_i_ModelID, hv_i_ModelType, hv__BondRows, hv__BondCols,
                        hv__BondAngles, out hv__BondRows, out hv__BondCols);
                    //顺时针排序
                    if ((int)(new HTuple((new HTuple(hv__BondRows.TupleLength())).TupleGreater(
                        1))) != 0)
                    {
                        hv__AngleBase = hv_i_AngleStart.Clone();
                        HOperatorSet.HomMat2dIdentity(out hv_HomMat2DIdentity);
                        HOperatorSet.HomMat2dRotate(hv_HomMat2DIdentity, -hv__AngleBase, 0, 0,
                            out hv_HomMat2DRotate);
                        HOperatorSet.AffineTransPoint2d(hv_HomMat2DRotate, hv__BondRows, hv__BondCols,
                            out hv__NewRow, out hv__NewCol);
                        HOperatorSet.TupleSortIndex(hv__NewRow, out hv_Indices);
                        HOperatorSet.TupleInverse(hv_Indices, out hv_SortIndices);
                        hv__BondRows = hv__BondRows.TupleSelect(hv_SortIndices);
                        hv__BondCols = hv__BondCols.TupleSelect(hv_SortIndices);
                    }

                    hv_o_BondRows = hv_o_BondRows.TupleConcat(hv__BondRows);
                    hv_o_BondCols = hv_o_BondCols.TupleConcat(hv__BondCols);
                    hv_o_BondAngles = hv_o_BondAngles.TupleConcat(hv__BondAngles);
                    //-------------------------------------------------------
                }
                else
                {
                    hv__BondLocFlags = 0;
                    for (hv_idx = 0; (int)hv_idx <= (int)(((new HTuple(hv__LocPara.TupleLength())) / 3) - 1); hv_idx = (int)hv_idx + 1)
                    {
                        hv__BondRow = hv__LocPara.TupleSelect(3 * hv_idx);
                        hv__BondCol = hv__LocPara.TupleSelect((3 * hv_idx) + 1);
                        hv__BondAngle = hv__LocPara.TupleSelect((3 * hv_idx) + 2);
                        hv__BondRows = hv__BondRows.TupleConcat(hv__BondRow);
                        hv__BondCols = hv__BondCols.TupleConcat(hv__BondCol);
                        hv__BondAngles = hv__BondAngles.TupleConcat(hv__BondAngle);
                    }
                    //找到焊点进行焊点位置从模板位置映射到图像位置
                    HTV_Arrange_Pos(hv_i_ModelID, hv_i_ModelType, hv__BondRows, hv__BondCols,
                        hv__BondAngles, out hv__BondRows, out hv__BondCols);
                    //顺时针排序
                    if ((int)(new HTuple((new HTuple(hv__BondRows.TupleLength())).TupleGreater(
                        1))) != 0)
                    {
                        hv__AngleBase = hv_i_AngleStart.Clone();
                        HOperatorSet.HomMat2dIdentity(out hv_HomMat2DIdentity);
                        HOperatorSet.HomMat2dRotate(hv_HomMat2DIdentity, -hv__AngleBase, 0, 0,
                            out hv_HomMat2DRotate);
                        HOperatorSet.AffineTransPoint2d(hv_HomMat2DRotate, hv__BondRows, hv__BondCols,
                            out hv__NewRow, out hv__NewCol);
                        HOperatorSet.TupleSortIndex(hv__NewRow, out hv_Indices);
                        HOperatorSet.TupleInverse(hv_Indices, out hv_SortIndices);
                        hv__BondRows = hv__BondRows.TupleSelect(hv_SortIndices);
                        hv__BondCols = hv__BondCols.TupleSelect(hv_SortIndices);
                    }

                    hv_o_BondRows = hv_o_BondRows.TupleConcat(hv__BondRows);
                    hv_o_BondCols = hv_o_BondCols.TupleConcat(hv__BondCols);
                    hv_o_BondAngles = hv_o_BondAngles.TupleConcat(hv__BondAngles);
                }

                //
                //定位焊点区域轮廓生成
                hv_BondSum = new HTuple(hv_o_BondRows.TupleLength());
                ho_EmptyRegion.Dispose();
                HOperatorSet.GenEmptyRegion(out ho_EmptyRegion);
                //
                //焊点去重用 add_lw 1104
                //if (|i_BondSize| < 2)
                //DistTh := i_BondSize[0]
                //else
                //DistTh := i_BondSize[1]
                //endif
                //dilation_circle (i_BondInspectReg, BondDilateRegs, DistTh)
                //
                HTuple end_val112 = hv_BondSum - 1;
                HTuple step_val112 = 1;
                for (hv_IdxBond = 0; hv_IdxBond.Continue(end_val112, step_val112); hv_IdxBond = hv_IdxBond.TupleAdd(step_val112))
                {

                    hv_tmp_row = hv_o_BondRows.TupleSelect(hv_IdxBond);
                    hv_tmp_col = hv_o_BondCols.TupleSelect(hv_IdxBond);

                    //焊点去重 add_lw 1104
                    //if (IdxBond > 1)
                    //前两个焊点
                    //tmp_row0 := o_BondRows[IdxBond-2]
                    //tmp_col0 := o_BondCols[IdxBond-2]
                    //前一个焊点
                    //tmp_row1 := o_BondRows[IdxBond-1]
                    //tmp_col1 := o_BondCols[IdxBond-1]
                    //距离小于BondSize认为重合
                    //distance_pp (tmp_row, tmp_col, tmp_row0, tmp_col0, dist0)
                    //distance_pp (tmp_row, tmp_col, tmp_row1, tmp_col1, dist1)
                    //if (dist0 < -DistTh or dist1 < -DistTh)
                    //根据焊点中点所在区域找到对应检测框，通过距离比较找出FailReg
                    //get_region_index (BondDilateRegs, int(tmp_row), int(tmp_col), RegIndex)
                    //select_obj (i_BondInspectReg, _SeclectBondReg, RegIndex)
                    //area_center (_SeclectBondReg, RegArea, RegRow, RegCol)
                    //tuple_gen_const (|RegRow|, tmp_row, CurRow)
                    //tuple_gen_const (|RegCol|, tmp_col, CurCol)
                    //distance_pp (CurRow, CurCol, RegRow, RegCol, DistTuple)
                    //tuple_max (DistTuple, MaxDist)
                    //tuple_find (DistTuple, MaxDist, FailIdx)
                    //RegFailIndex := RegIndex[FailIdx]
                    //重合结果更改
                    //o_BondLocFlags[RegFailIndex-1] := 1
                    //tmp_row := -1
                    //tmp_col := -1
                    //endif
                    //elseif (IdxBond > 0)
                    //前一个焊点
                    //tmp_row1 := o_BondRows[IdxBond-1]
                    //tmp_col1 := o_BondCols[IdxBond-1]
                    //距离小于BondSize认为重合
                    //distance_pp (tmp_row, tmp_col, tmp_row1, tmp_col1, dist1)
                    //if (dist1 < -DistTh)
                    //根据焊点中点所在区域找到对应检测框，通过距离比较找出FailReg
                    //get_region_index (BondDilateRegs, int(tmp_row), int(tmp_col), RegIndex)
                    //select_obj (i_BondInspectReg, _SeclectBondReg, RegIndex)
                    //area_center (_SeclectBondReg, RegArea, RegRow, RegCol)
                    //tuple_gen_const (|RegRow|, tmp_row, CurRow)
                    //tuple_gen_const (|RegCol|, tmp_col, CurCol)
                    //distance_pp (CurRow, CurCol, RegRow, RegCol, DistTuple)
                    //tuple_max (DistTuple, MaxDist)
                    //tuple_find (DistTuple, MaxDist, FailIdx)
                    //RegFailIndex := RegIndex[FailIdx]
                    //重合结果更改
                    //o_BondLocFlags[RegFailIndex-1] := 1
                    //tmp_row := -1
                    //tmp_col := -1
                    //endif
                    //endif

                    if ((int)(new HTuple((new HTuple(hv_i_BondSize.TupleLength())).TupleLess(
                        2))) != 0)
                    {
                        //生成圆
                        if ((int)((new HTuple(hv_tmp_row.TupleLess(0))).TupleOr(new HTuple(hv_tmp_col.TupleLess(
                            0)))) != 0)
                        {
                            hv_tmp_r = 0;
                        }
                        else
                        {
                            hv_tmp_r = hv_i_BondSize[0];
                        }
                        ho__BondContour.Dispose();
                        HOperatorSet.GenCircle(out ho__BondContour, hv_o_BondRows.TupleSelect(hv_IdxBond),
                            hv_o_BondCols.TupleSelect(hv_IdxBond), hv_tmp_r);
                    }
                    else
                    {
                        //生成椭圆
                        if ((int)((new HTuple(hv_tmp_row.TupleLess(0))).TupleOr(new HTuple(hv_tmp_col.TupleLess(
                            0)))) != 0)
                        {
                            hv_tmp_r1 = 0;
                            hv_tmp_r2 = 0;
                        }
                        else
                        {
                            if ((int)(new HTuple(((hv_i_BondSize.TupleSelect(0))).TupleGreater(hv_i_BondSize.TupleSelect(
                                1)))) != 0)
                            {
                                hv_tmp_r1 = hv_i_BondSize[0];
                                hv_tmp_r2 = hv_i_BondSize[1];
                            }
                            else
                            {
                                hv_tmp_r1 = hv_i_BondSize[1];
                                hv_tmp_r2 = hv_i_BondSize[0];
                            }
                        }
                        ho__BondContour.Dispose();
                        HOperatorSet.GenEllipse(out ho__BondContour, hv_o_BondRows.TupleSelect(
                            hv_IdxBond), hv_o_BondCols.TupleSelect(hv_IdxBond), hv_o_BondAngles.TupleSelect(
                            hv_IdxBond), hv_tmp_r1, hv_tmp_r2);
                    }
                    //
                    HOperatorSet.AreaCenter(ho__BondContour, out hv_Area, out hv_Row, out hv_Column);
                    if ((int)(new HTuple(hv_Area.TupleEqual(0))) != 0)
                    {
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(ho_o_BondContour, ho_EmptyRegion, out ExpTmpOutVar_0
                                );
                            ho_o_BondContour.Dispose();
                            ho_o_BondContour = ExpTmpOutVar_0;
                        }
                    }
                    else
                    {
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(ho_o_BondContour, ho__BondContour, out ExpTmpOutVar_0
                                );
                            ho_o_BondContour.Dispose();
                            ho_o_BondContour = ExpTmpOutVar_0;
                        }
                    }
                }

                //整合定位结果
                if ((int)(new HTuple(hv__BondLocFlags.TupleGreater(0))) != 0)
                {
                    hv_o_ErrCode = 1;
                    hv_o_ErrStr = "Fail to Locate one or more bond";
                    ho_EmptyRegion.Dispose();
                    ho__BondContour.Dispose();

                    return;
                }
                else
                {
                    hv_o_ErrCode = 0;
                    hv_o_ErrStr = "Bond Location success";
                    ho_EmptyRegion.Dispose();
                    ho__BondContour.Dispose();

                    return;
                }
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_EmptyRegion.Dispose();
                ho__BondContour.Dispose();

                throw HDevExpDefaultException;
            }
        }
        #endregion


        #region Bond检测 阈值分割方法
        public static void HTV_Bond_Inspect_threshold(HObject ho_i_Imgs, HObject ho_i_BondInspectReg,
            out HObject ho_o_BondContour, out HObject ho_o_FailReg, HTuple hv_i_ImgIdx,
            HTuple hv_i_BallSize, HTuple hv_i_ThreshGray, HTuple hv_i_ClosingSize, HTuple hv_i_BondOverSizeFactor,
            HTuple hv_i_BondUnderSizeFactor, out HTuple hv_o_DefectType, out HTuple hv_o_DefectImgIdx,
            out HTupleVector/*{eTupleVector,Dim=1}*/ hvec_o_DefectValue, out HTupleVector/*{eTupleVector,Dim=1}*/ hvec_o_RefValue,
            out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {




            // Local iconic variables 

            HObject ho_EmptyReg, ho_i_Image, ho__BondContour;
            HObject ho_EmptyRegion, ho_RegionDilation = null, ho_Circle = null;
            HObject ho_RegionErosion = null, ho_Rectangle = null;

            // Local control variables 

            HTuple hv_imgNum = null, hv_regNum = null;
            HTuple hv__ThreErrCode = null, hv__ThreErrStr = null, hv_Row = new HTuple();
            HTuple hv_Column = new HTuple(), hv_Radius = new HTuple();
            HTuple hv_BondRadius = new HTuple(), hv_RefRadius = new HTuple();
            HTuple hv_Row1 = new HTuple(), hv_Column1 = new HTuple();
            HTuple hv_Phi = new HTuple(), hv_Length1 = new HTuple();
            HTuple hv_Length2 = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_BondContour);
            HOperatorSet.GenEmptyObj(out ho_o_FailReg);
            HOperatorSet.GenEmptyObj(out ho_EmptyReg);
            HOperatorSet.GenEmptyObj(out ho_i_Image);
            HOperatorSet.GenEmptyObj(out ho__BondContour);
            HOperatorSet.GenEmptyObj(out ho_EmptyRegion);
            HOperatorSet.GenEmptyObj(out ho_RegionDilation);
            HOperatorSet.GenEmptyObj(out ho_Circle);
            HOperatorSet.GenEmptyObj(out ho_RegionErosion);
            HOperatorSet.GenEmptyObj(out ho_Rectangle);
            try
            {
                //********************************************************************************************************
                //--函数：HTV_Bond_Inspect_threshold
                //--作用：检测区域内使用阈值分割方法检测焊点
                //--参数：
                //==图标参数：
                // i_Imgs:输入检测需要的图像集
                // i_BondInspectReg:检测区域
                // o_BondContour:区域内检测到的焊点区域
                // o_FailReg:未检测到焊点返回的缺陷区域
                //==控制参数：
                // i_ImgIdx:j检测区域内检测需要图集的图像索引号
                // i_BallType:焊点类别：一般为circle或ellipse
                // i_ThreshGray:检测区域内需要的检测阈值
                // i_ClosingSize:分割区域内闭运算尺寸
                // i_BondOverSizeFactor:检测到的焊点区域过大尺度阈值
                // i_BondUnderSizeFactor:检测到的焊点区域过小尺度阈值
                // o_DefectType:检测到的缺陷的类别
                // o_DefectImgIdx:缺陷区域图像索引号
                // o_DefectValue:缺陷返回值
                // o_RefValue:缺陷参考值
                // o_ErrCode:错误码
                // o_ErrStr:错误信息
                //*******************************************************************************************************
                //初始化
                //
                hv_o_DefectType = new HTuple();
                hv_o_DefectImgIdx = new HTuple();
                hvec_o_DefectValue = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(-2))));
                hvec_o_RefValue = (new HTupleVector(1).Insert(0, new HTupleVector((new HTuple(-2)).TupleConcat(
                    -2))));
                //
                ho_EmptyReg.Dispose();
                HOperatorSet.GenEmptyRegion(out ho_EmptyReg);
                ho_o_FailReg.Dispose();
                ho_o_FailReg = ho_EmptyReg.CopyObj(1, -1);
                ho_o_BondContour.Dispose();
                ho_o_BondContour = ho_EmptyReg.CopyObj(1, -1);
                //
                hv_o_ErrCode = -2;
                hv_o_ErrStr = "Initializing";
                //
                //输入有效性测试
                HOperatorSet.CountObj(ho_i_Imgs, out hv_imgNum);
                if ((int)(new HTuple(hv_imgNum.TupleEqual(0))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "input image is null";
                    ho_EmptyReg.Dispose();
                    ho_i_Image.Dispose();
                    ho__BondContour.Dispose();
                    ho_EmptyRegion.Dispose();
                    ho_RegionDilation.Dispose();
                    ho_Circle.Dispose();
                    ho_RegionErosion.Dispose();
                    ho_Rectangle.Dispose();

                    return;
                }
                HOperatorSet.CountObj(ho_i_BondInspectReg, out hv_regNum);
                if ((int)(new HTuple(hv_regNum.TupleLess(1))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "Bond inspect region empty";
                    ho_EmptyReg.Dispose();
                    ho_i_Image.Dispose();
                    ho__BondContour.Dispose();
                    ho_EmptyRegion.Dispose();
                    ho_RegionDilation.Dispose();
                    ho_Circle.Dispose();
                    ho_RegionErosion.Dispose();
                    ho_Rectangle.Dispose();

                    return;
                }
                if ((int)((new HTuple((new HTuple(hv_i_BallSize.TupleLength())).TupleLess(1))).TupleOr(
                    new HTuple(((hv_i_BallSize.TupleSelect(0))).TupleLess(0)))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "the para i_BallSize must greater than 0";
                    ho_EmptyReg.Dispose();
                    ho_i_Image.Dispose();
                    ho__BondContour.Dispose();
                    ho_EmptyRegion.Dispose();
                    ho_RegionDilation.Dispose();
                    ho_Circle.Dispose();
                    ho_RegionErosion.Dispose();
                    ho_Rectangle.Dispose();

                    return;
                }
                if ((int)((new HTuple((new HTuple(hv_i_BondOverSizeFactor.TupleLength())).TupleLess(
                    1))).TupleOr(new HTuple(hv_i_BondOverSizeFactor.TupleLess(0)))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "the para i_BondOverSizeFactor must greater than 0";
                    ho_EmptyReg.Dispose();
                    ho_i_Image.Dispose();
                    ho__BondContour.Dispose();
                    ho_EmptyRegion.Dispose();
                    ho_RegionDilation.Dispose();
                    ho_Circle.Dispose();
                    ho_RegionErosion.Dispose();
                    ho_Rectangle.Dispose();

                    return;
                }
                if ((int)((new HTuple((new HTuple(hv_i_BondUnderSizeFactor.TupleLength())).TupleLess(
                    1))).TupleOr(new HTuple(hv_i_BondUnderSizeFactor.TupleLess(0)))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "the para i_BondUnderSizeFactor must greater than 0";
                    ho_EmptyReg.Dispose();
                    ho_i_Image.Dispose();
                    ho__BondContour.Dispose();
                    ho_EmptyRegion.Dispose();
                    ho_RegionDilation.Dispose();
                    ho_Circle.Dispose();
                    ho_RegionErosion.Dispose();
                    ho_Rectangle.Dispose();

                    return;
                }
                //------------------应用阈值分割进行Bond检测
                //阈值图像选择
                ho_i_Image.Dispose();
                HOperatorSet.SelectObj(ho_i_Imgs, out ho_i_Image, hv_i_ImgIdx);

                ho__BondContour.Dispose();
                HTV_Bond_Threshold(ho_i_Image, ho_i_BondInspectReg, out ho__BondContour, hv_i_ThreshGray,
                    hv_i_ClosingSize, out hv__ThreErrCode, out hv__ThreErrStr);
                //函数异常
                if ((int)(new HTuple(hv__ThreErrCode.TupleLess(0))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = hv__ThreErrStr.Clone();
                    ho_EmptyReg.Dispose();
                    ho_i_Image.Dispose();
                    ho__BondContour.Dispose();
                    ho_EmptyRegion.Dispose();
                    ho_RegionDilation.Dispose();
                    ho_Circle.Dispose();
                    ho_RegionErosion.Dispose();
                    ho_Rectangle.Dispose();

                    return;
                }
                //
                //获取真实焊点区域
                ho_EmptyRegion.Dispose();
                HOperatorSet.GenEmptyRegion(out ho_EmptyRegion);
                //------确定焊点类型
                //根据焊点类型获取焊点半径
                if ((int)(new HTuple((new HTuple(hv_i_BallSize.TupleLength())).TupleEqual(1))) != 0)
                {
                    ho_RegionDilation.Dispose();
                    HOperatorSet.DilationCircle(ho__BondContour, out ho_RegionDilation, 3.5);
                    //
                    HOperatorSet.InnerCircle(ho_RegionDilation, out hv_Row, out hv_Column, out hv_Radius);
                    ho_Circle.Dispose();
                    HOperatorSet.GenCircle(out ho_Circle, hv_Row, hv_Column, hv_Radius);
                    hv_BondRadius = hv_Radius.Clone();
                    hv_RefRadius = hv_i_BallSize.Clone();
                }
                else
                {
                    ho_RegionErosion.Dispose();
                    HOperatorSet.ErosionCircle(ho__BondContour, out ho_RegionErosion, 1.5);
                    //
                    HOperatorSet.SmallestRectangle2(ho_RegionErosion, out hv_Row1, out hv_Column1,
                        out hv_Phi, out hv_Length1, out hv_Length2);
                    ho_Rectangle.Dispose();
                    HOperatorSet.GenRectangle2(out ho_Rectangle, hv_Row1, hv_Column1, hv_Phi,
                        hv_Length1, hv_Length2);
                    hv_BondRadius = hv_Length2.Clone();
                    hv_RefRadius = hv_i_BallSize[1];
                }
                //参数参考值, 焊点大小上下限
                hvec_o_RefValue = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(((hv_RefRadius * hv_i_BondUnderSizeFactor)).TupleConcat(
                    hv_RefRadius * hv_i_BondOverSizeFactor)))));
                //
                if ((int)(new HTuple(hv__ThreErrCode.TupleGreater(0))) != 0)
                {
                    //焊点脱落
                    hv_o_DefectType = 22;
                    hv_o_DefectImgIdx = hv_i_ImgIdx.Clone();
                    hvec_o_DefectValue = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(-1))));
                    //
                    ho_o_FailReg.Dispose();
                    ho_o_FailReg = ho_i_BondInspectReg.CopyObj(1, -1);
                    ho_o_BondContour.Dispose();
                    ho_o_BondContour = ho_EmptyRegion.CopyObj(1, -1);
                }
                else if ((int)(new HTuple(hv__ThreErrCode.TupleEqual(0))) != 0)
                {
                    //
                    if ((int)(new HTuple(hv_BondRadius.TupleGreater(hv_RefRadius * hv_i_BondOverSizeFactor))) != 0)
                    {
                        //焊点过大
                        hv_o_DefectType = 10;
                        hv_o_DefectImgIdx = hv_i_ImgIdx.Clone();
                        hvec_o_DefectValue = (new HTupleVector(1).Insert(0, new HTupleVector(hv_BondRadius)));
                        //
                        ho_o_FailReg.Dispose();
                        ho_o_FailReg = ho_i_BondInspectReg.CopyObj(1, -1);
                        ho_o_BondContour.Dispose();
                        ho_o_BondContour = ho_EmptyRegion.CopyObj(1, -1);
                        //
                    }
                    else if ((int)(new HTuple(hv_BondRadius.TupleLess(hv_RefRadius * hv_i_BondUnderSizeFactor))) != 0)
                    {
                        //焊点过小
                        hv_o_DefectType = 10;
                        hv_o_DefectImgIdx = hv_i_ImgIdx.Clone();
                        hvec_o_DefectValue = (new HTupleVector(1).Insert(0, new HTupleVector(hv_BondRadius)));
                        //
                        ho_o_FailReg.Dispose();
                        ho_o_FailReg = ho_i_BondInspectReg.CopyObj(1, -1);
                        ho_o_BondContour.Dispose();
                        ho_o_BondContour = ho_EmptyRegion.CopyObj(1, -1);
                    }
                    else
                    {
                        hv_o_DefectType = 0;
                        hv_o_DefectImgIdx = hv_i_ImgIdx.Clone();
                        hvec_o_DefectValue = (new HTupleVector(1).Insert(0, new HTupleVector(hv_BondRadius)));
                        //检测正常输出ResultReg
                        ho_o_FailReg.Dispose();
                        ho_o_FailReg = ho__BondContour.CopyObj(1, -1);
                        ho_o_BondContour.Dispose();
                        ho_o_BondContour = ho__BondContour.CopyObj(1, -1);
                        //
                    }
                }
                //
                //输出执行结果
                if ((int)(new HTuple(hv_o_DefectType.TupleGreater(0))) != 0)
                {
                    hv_o_ErrCode = 1;
                    hv_o_ErrStr = "Fail to one  Bond";
                    ho_EmptyReg.Dispose();
                    ho_i_Image.Dispose();
                    ho__BondContour.Dispose();
                    ho_EmptyRegion.Dispose();
                    ho_RegionDilation.Dispose();
                    ho_Circle.Dispose();
                    ho_RegionErosion.Dispose();
                    ho_Rectangle.Dispose();

                    return;
                }
                else
                {
                    hv_o_ErrCode = 0;
                    hv_o_ErrStr = "Bond Location is successful";
                    ho_EmptyReg.Dispose();
                    ho_i_Image.Dispose();
                    ho__BondContour.Dispose();
                    ho_EmptyRegion.Dispose();
                    ho_RegionDilation.Dispose();
                    ho_Circle.Dispose();
                    ho_RegionErosion.Dispose();
                    ho_Rectangle.Dispose();

                    return;
                }






            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_EmptyReg.Dispose();
                ho_i_Image.Dispose();
                ho__BondContour.Dispose();
                ho_EmptyRegion.Dispose();
                ho_RegionDilation.Dispose();
                ho_Circle.Dispose();
                ho_RegionErosion.Dispose();
                ho_Rectangle.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public static void HTV_Bond_Threshold(HObject ho_i_Image, HObject ho_i_InspectReg, out HObject ho_o_BondContour,
            HTuple hv_i_ThreshGray, HTuple hv_i_ClosingSize, out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {




            // Local iconic variables 

            HObject ho_BondImage, ho_Region, ho_RegionFillup;
            HObject ho_BondRegMorph, ho_ConnectedBondRegs, ho_MaxBondReg;

            // Local control variables 

            HTuple hv_o_MeasurePara = null, hv_o_MeasureFlag = null;
            HTuple hv_imgNum = null, hv_regNum = null, hv_BondRegArea = null;
            HTuple hv_BondRegRow = null, hv_SecBondCol = null, hv_MaxArea = null;
            HTuple hv_MaxIndice = null, hv_BondArea = null, hv_BondRow = null;
            HTuple hv_BondCol = null;
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_BondContour);
            HOperatorSet.GenEmptyObj(out ho_BondImage);
            HOperatorSet.GenEmptyObj(out ho_Region);
            HOperatorSet.GenEmptyObj(out ho_RegionFillup);
            HOperatorSet.GenEmptyObj(out ho_BondRegMorph);
            HOperatorSet.GenEmptyObj(out ho_ConnectedBondRegs);
            HOperatorSet.GenEmptyObj(out ho_MaxBondReg);
            try
            {
                //********************************************************************************************************
                //--函数：HTV_Bond_Threshold
                //--作用：检测区域内使用阈值分割方法检测焊点
                //--参数：
                //==图标参数：
                // i_Image:输入检测需要的图像
                // i_InspectReg:检测区域
                // o_BondContour:区域内检测到的焊点区域
                //==控制参数：
                // i_BallType:焊点类别：一般为circle或ellipse
                // i_ThreshGray:检测区域内需要的检测阈值
                // i_ClosingSize:分割区域内闭运算尺寸
                // o_ErrCode:错误码
                // o_ErrStr:错误信息
                //**********************************************************************************************************
                //初始化
                hv_o_ErrCode = -2;
                hv_o_ErrStr = "initializing";
                hv_o_MeasurePara = new HTuple();
                ho_o_BondContour.Dispose();
                HOperatorSet.GenEmptyRegion(out ho_o_BondContour);
                //测量结果Flag
                hv_o_MeasureFlag = new HTuple();
                //输入有效性测试
                HOperatorSet.CountObj(ho_i_Image, out hv_imgNum);
                if ((int)(new HTuple(hv_imgNum.TupleEqual(0))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "input image is null";
                    ho_BondImage.Dispose();
                    ho_Region.Dispose();
                    ho_RegionFillup.Dispose();
                    ho_BondRegMorph.Dispose();
                    ho_ConnectedBondRegs.Dispose();
                    ho_MaxBondReg.Dispose();

                    return;
                }
                HOperatorSet.CountObj(ho_i_InspectReg, out hv_regNum);
                if ((int)(new HTuple(hv_regNum.TupleLess(1))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "inspect region is empty";
                    ho_BondImage.Dispose();
                    ho_Region.Dispose();
                    ho_RegionFillup.Dispose();
                    ho_BondRegMorph.Dispose();
                    ho_ConnectedBondRegs.Dispose();
                    ho_MaxBondReg.Dispose();

                    return;
                }

                if ((int)((new HTuple((new HTuple(hv_i_ThreshGray.TupleLength())).TupleEqual(
                    0))).TupleOr(new HTuple(((hv_i_ThreshGray.TupleSelect(0))).TupleLess(0)))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "the para i_ThreshGray must be a integer greater than 3";
                    ho_BondImage.Dispose();
                    ho_Region.Dispose();
                    ho_RegionFillup.Dispose();
                    ho_BondRegMorph.Dispose();
                    ho_ConnectedBondRegs.Dispose();
                    ho_MaxBondReg.Dispose();

                    return;
                }

                if ((int)((new HTuple((new HTuple(hv_i_ClosingSize.TupleLength())).TupleEqual(
                    0))).TupleOr(new HTuple(hv_i_ClosingSize.TupleLess(0)))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "the para i_ClosingSize must be a integer greater than 3";
                    ho_BondImage.Dispose();
                    ho_Region.Dispose();
                    ho_RegionFillup.Dispose();
                    ho_BondRegMorph.Dispose();
                    ho_ConnectedBondRegs.Dispose();
                    ho_MaxBondReg.Dispose();

                    return;
                }
                //

                //**********************************
                ho_BondImage.Dispose();
                HOperatorSet.ReduceDomain(ho_i_Image, ho_i_InspectReg, out ho_BondImage);
                ho_Region.Dispose();
                HOperatorSet.Threshold(ho_BondImage, out ho_Region, hv_i_ThreshGray.TupleSelect(
                    0), hv_i_ThreshGray.TupleSelect(1));
                //
                //ho_RegionFillup.Dispose();
                //HOperatorSet.FillUp(ho_Region, out ho_RegionFillup);
                ho_BondRegMorph.Dispose();
                HOperatorSet.OpeningCircle(ho_Region, out ho_BondRegMorph, hv_i_ClosingSize);

                ho_ConnectedBondRegs.Dispose();
                HOperatorSet.Connection(ho_BondRegMorph, out ho_ConnectedBondRegs);
                HOperatorSet.AreaCenter(ho_ConnectedBondRegs, out hv_BondRegArea, out hv_BondRegRow,
                    out hv_SecBondCol);
                HOperatorSet.TupleMax(hv_BondRegArea, out hv_MaxArea);
                HOperatorSet.TupleFind(hv_BondRegArea, hv_MaxArea, out hv_MaxIndice);
                ho_MaxBondReg.Dispose();
                HOperatorSet.SelectObj(ho_ConnectedBondRegs, out ho_MaxBondReg, (hv_MaxIndice.TupleSelect(
                    0)) + 1);
                //
                HOperatorSet.AreaCenter(ho_MaxBondReg, out hv_BondArea, out hv_BondRow, out hv_BondCol);
                if ((int)(hv_BondArea) != 0)
                {
                    hv_o_ErrCode = 0;
                    hv_o_ErrStr = "succeed to get bond region ";
                    ho_o_BondContour.Dispose();
                    ho_o_BondContour = ho_MaxBondReg.CopyObj(1, -1);
                    ho_BondImage.Dispose();
                    ho_Region.Dispose();
                    ho_RegionFillup.Dispose();
                    ho_BondRegMorph.Dispose();
                    ho_ConnectedBondRegs.Dispose();
                    ho_MaxBondReg.Dispose();

                    return;
                }
                else
                {
                    hv_o_ErrCode = 1;
                    hv_o_ErrStr = "fail to get bond region ";
                    ho_BondImage.Dispose();
                    ho_Region.Dispose();
                    ho_RegionFillup.Dispose();
                    ho_BondRegMorph.Dispose();
                    ho_ConnectedBondRegs.Dispose();
                    ho_MaxBondReg.Dispose();

                    return;
                }



            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_BondImage.Dispose();
                ho_Region.Dispose();
                ho_RegionFillup.Dispose();
                ho_BondRegMorph.Dispose();
                ho_ConnectedBondRegs.Dispose();
                ho_MaxBondReg.Dispose();

                throw HDevExpDefaultException;
            }
        }
        #endregion

        #region bond 检测验证 测量

        //
        public static void HTV_Create_Metrology_Model(HTuple hv_i_MetrologyType, HTuple hv_i_MeasureContrast,
            HTuple hv_i_MeasureExpand, HTuple hv_i_MetrologyWideth, HTuple hv_i_MetrologyTransition,
            HTuple hv_i_MetrologyPara, HTuple hv_i_MetrologyDistTh, HTuple hv_i_MetrologySelect,
            out HTuple hv_o_MetrologyHandle, out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv__MeasureToolNum = null, hv_Greater = null;
            HTuple hv_Less = null, hv_sum1 = null, hv_sum2 = null;
            HTuple hv_paraIdx = null, hv_parasNum = null, hv_toolIdx = null;
            HTuple hv_Index = new HTuple();
            // Initialize local and output iconic variables 
            //*********     创建测量模板工具，返回测量句柄
            // i_MetrologyType: 测量工具类型，允许对同一句柄添加多个测量工具，并分别指定类型，支持4类测量工具————1-直线工具，2-矩形工具，3-圆工具，4-椭圆工具
            // i_MetrologyPara: 创建测量工具需要的参数，每一个测量工具对应一组参数，所有测量工具的参数均包含在该输入变量中
            // i_MeasureExpand: 在测量工具附近延伸多大范围进行测量，为一个距离值
            // i_MeasureContrast: 测量边界处的对比度，大于该值时才能测量出边界位置。
            // o_MetrologyHandle: 测量模板句柄，返回值为整数，创建模板成功时为整数，初始为-1。
            // o_ErrCode: 错误码，代表该算子执行过程中产生的错误，0-代表正常执行，自然数-代表错误类型，-1-代表异常，-2-代表未执行
            // o_ErrStr: 错误信息，对各种错误的具体描述

            //初始化
            hv_o_ErrCode = -2;
            hv_o_ErrStr = "Initializing!";
            hv_o_MetrologyHandle = -1;

            //输入合法性验证
            hv__MeasureToolNum = new HTuple(hv_i_MetrologyType.TupleLength());
            if ((int)(new HTuple(hv__MeasureToolNum.TupleLess(1))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "no measure tools input!";

                return;
            }
            //测量工具类型不属于支持的4类，异常退出
            HOperatorSet.TupleGreaterElem(hv_i_MetrologyType, 4, out hv_Greater);
            HOperatorSet.TupleLessElem(hv_i_MetrologyType, 1, out hv_Less);
            hv_sum1 = ((hv_Greater.TupleSum())).TupleAbs();
            hv_sum2 = ((hv_Less.TupleSum())).TupleAbs();
            if ((int)((new HTuple(hv_sum1.TupleGreater(0))).TupleOr(new HTuple(hv_sum2.TupleGreater(
                0)))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "measure tools unsupport!";

                return;
            }

            //创建测量模板
            HOperatorSet.CreateMetrologyModel(out hv_o_MetrologyHandle);
            //添加测量工具
            hv_paraIdx = 0;
            hv_parasNum = new HTuple(hv_i_MetrologyPara.TupleLength());
            HTuple end_val37 = hv__MeasureToolNum - 1;
            HTuple step_val37 = 1;
            for (hv_toolIdx = 0; hv_toolIdx.Continue(end_val37, step_val37); hv_toolIdx = hv_toolIdx.TupleAdd(step_val37))
            {
                switch ((hv_i_MetrologyType.TupleSelect(
                    hv_toolIdx)).I)
                {
                    case 1:
                        //添加直线测量工具，需要4个参数，分别为端点1横坐标和纵坐标，端点2横坐标和纵坐标
                        if ((int)(new HTuple(((hv_paraIdx + 4)).TupleGreater(hv_parasNum))) != 0)
                        {
                            hv_o_ErrCode = -1;
                            hv_o_ErrStr = "paras not enough!";

                            return;
                        }
                        HOperatorSet.AddMetrologyObjectLineMeasure(hv_o_MetrologyHandle, hv_i_MetrologyPara.TupleSelect(
                            hv_paraIdx), hv_i_MetrologyPara.TupleSelect(hv_paraIdx + 1), hv_i_MetrologyPara.TupleSelect(
                            hv_paraIdx + 2), hv_i_MetrologyPara.TupleSelect(hv_paraIdx + 3), hv_i_MeasureExpand.TupleSelect(
                            hv_toolIdx), hv_i_MetrologyWideth.TupleSelect(hv_toolIdx), 1, hv_i_MeasureContrast.TupleSelect(
                            hv_toolIdx), ((new HTuple("measure_transition")).TupleConcat("measure_distance")).TupleConcat(
                            "min_score"), ((((hv_i_MetrologyTransition.TupleSelect(hv_toolIdx))).TupleConcat(
                            hv_i_MetrologyWideth.TupleSelect(hv_toolIdx)))).TupleConcat(0.5), out hv_Index);

                        //设置边缘点选择和距离阈值
                        HOperatorSet.SetMetrologyObjectParam(hv_o_MetrologyHandle, hv_Index, "measure_select",
                            hv_i_MetrologySelect.TupleSelect(hv_toolIdx));
                        HOperatorSet.SetMetrologyObjectParam(hv_o_MetrologyHandle, hv_Index, "distance_threshold",
                            hv_i_MetrologyDistTh.TupleSelect(hv_toolIdx));

                        hv_paraIdx = hv_paraIdx + 4;
                        break;
                    case 2:
                        //添加矩形测量工具，需要5个参数，分别为矩形中心点横坐标、纵坐标、半长、半宽、长边方向
                        if ((int)(new HTuple(((hv_paraIdx + 5)).TupleGreater(hv_parasNum))) != 0)
                        {
                            hv_o_ErrCode = -1;
                            hv_o_ErrStr = "paras not enough!";

                            return;
                        }
                        HOperatorSet.AddMetrologyObjectRectangle2Measure(hv_o_MetrologyHandle, hv_i_MetrologyPara.TupleSelect(
                            hv_paraIdx), hv_i_MetrologyPara.TupleSelect(hv_paraIdx + 1), hv_i_MetrologyPara.TupleSelect(
                            hv_paraIdx + 2), hv_i_MetrologyPara.TupleSelect(hv_paraIdx + 3), hv_i_MetrologyPara.TupleSelect(
                            hv_paraIdx + 4), hv_i_MeasureExpand.TupleSelect(hv_toolIdx), hv_i_MetrologyWideth.TupleSelect(
                            hv_toolIdx), 1, hv_i_MeasureContrast.TupleSelect(hv_toolIdx), ((new HTuple("measure_transition")).TupleConcat(
                            "measure_distance")).TupleConcat("min_score"), ((((hv_i_MetrologyTransition.TupleSelect(
                            hv_toolIdx))).TupleConcat(hv_i_MetrologyWideth.TupleSelect(hv_toolIdx)))).TupleConcat(
                            0.5), out hv_Index);

                        //设置边缘点选择和距离阈值
                        HOperatorSet.SetMetrologyObjectParam(hv_o_MetrologyHandle, hv_Index, "measure_select",
                            hv_i_MetrologySelect.TupleSelect(hv_toolIdx));
                        HOperatorSet.SetMetrologyObjectParam(hv_o_MetrologyHandle, hv_Index, "distance_threshold",
                            hv_i_MetrologyDistTh.TupleSelect(hv_toolIdx));

                        hv_paraIdx = hv_paraIdx + 5;
                        break;
                    case 3:
                        //添加圆形测量工具，需要3个参数，分别为圆心横坐标、纵坐标、半径
                        if ((int)(new HTuple(((hv_paraIdx + 3)).TupleGreater(hv_parasNum))) != 0)
                        {
                            hv_o_ErrCode = -1;
                            hv_o_ErrStr = "paras not enough!";

                            return;
                        }
                        HOperatorSet.AddMetrologyObjectCircleMeasure(hv_o_MetrologyHandle, hv_i_MetrologyPara.TupleSelect(
                            hv_paraIdx), hv_i_MetrologyPara.TupleSelect(hv_paraIdx + 1), hv_i_MetrologyPara.TupleSelect(
                            hv_paraIdx + 2), hv_i_MeasureExpand.TupleSelect(hv_toolIdx), hv_i_MetrologyWideth.TupleSelect(
                            hv_toolIdx), 1, hv_i_MeasureContrast.TupleSelect(hv_toolIdx), ((new HTuple("measure_transition")).TupleConcat(
                            "measure_distance")).TupleConcat("min_score"), ((((hv_i_MetrologyTransition.TupleSelect(
                            hv_toolIdx))).TupleConcat(hv_i_MetrologyWideth.TupleSelect(hv_toolIdx)))).TupleConcat(
                            0.5), out hv_Index);

                        //设置边缘点选择和距离阈值
                        HOperatorSet.SetMetrologyObjectParam(hv_o_MetrologyHandle, hv_Index, "measure_select",
                            hv_i_MetrologySelect.TupleSelect(hv_toolIdx));
                        HOperatorSet.SetMetrologyObjectParam(hv_o_MetrologyHandle, hv_Index, "distance_threshold",
                            hv_i_MetrologyDistTh.TupleSelect(hv_toolIdx));

                        hv_paraIdx = hv_paraIdx + 3;
                        break;
                    case 4:
                        //添加椭圆测量工具，需要5个参数，分别为椭圆中心横坐标、纵坐标、半长轴长、半短轴长、长轴方向
                        if ((int)(new HTuple(((hv_paraIdx + 5)).TupleGreater(hv_parasNum))) != 0)
                        {
                            hv_o_ErrCode = -1;
                            hv_o_ErrStr = "paras not enough!";

                            return;
                        }
                        HOperatorSet.AddMetrologyObjectEllipseMeasure(hv_o_MetrologyHandle, hv_i_MetrologyPara.TupleSelect(
                            hv_paraIdx), hv_i_MetrologyPara.TupleSelect(hv_paraIdx + 1), hv_i_MetrologyPara.TupleSelect(
                            hv_paraIdx + 2), hv_i_MetrologyPara.TupleSelect(hv_paraIdx + 3), hv_i_MetrologyPara.TupleSelect(
                            hv_paraIdx + 4), hv_i_MeasureExpand.TupleSelect(hv_toolIdx), hv_i_MetrologyWideth.TupleSelect(
                            hv_toolIdx), 1, hv_i_MeasureContrast.TupleSelect(hv_toolIdx), ((new HTuple("measure_transition")).TupleConcat(
                            "measure_distance")).TupleConcat("min_score"), ((((hv_i_MetrologyTransition.TupleSelect(
                            hv_toolIdx))).TupleConcat(1.5*(hv_i_MetrologyWideth.TupleSelect(hv_toolIdx))))).TupleConcat(
                            0.5), out hv_Index); //add_lw 修改卡尺间距

                        //设置边缘点选择和距离阈值
                        HOperatorSet.SetMetrologyObjectParam(hv_o_MetrologyHandle, hv_Index, "measure_select",
                            hv_i_MetrologySelect.TupleSelect(hv_toolIdx));
                        HOperatorSet.SetMetrologyObjectParam(hv_o_MetrologyHandle, hv_Index, "distance_threshold",
                            hv_i_MetrologyDistTh.TupleSelect(hv_toolIdx));

                        hv_paraIdx = hv_paraIdx + 5;
                        break;
                }
            }
            //设置模板的参考坐标系
            HOperatorSet.SetMetrologyModelParam(hv_o_MetrologyHandle, "reference_system",
                ((new HTuple(0)).TupleConcat(0)).TupleConcat(0));

            hv_o_ErrCode = 0;
            hv_o_ErrStr = "Create Metrology Handle successful!";

            return;
        }

        public static void HTV_Bond_Inspect_measure(HObject ho_i_Imgs, HObject ho_i_BondInspectReg,
            out HObject ho_o_BondContour, out HObject ho_o_FailReg, HTuple hv_i_HomMatMod2Img,
            HTuple hv_i_MeasureIndex, HTuple hv_i_ImgIdx, HTuple hv_i_MeasureType, HTuple hv_i_MetrologyHandle,
            HTuple hv_i_BondOverSizeFactor, HTuple hv_i_BondUnderSizeFactor, HTuple hv_i_isPreJudge,
            HTuple hv_i_ThreshGray, HTuple hv_i_SegRegAreaFactor, out HTuple hv_o_DefectType,
            out HTuple hv_o_DefectImgIdx, out HTupleVector/*{eTupleVector,Dim=1}*/ hvec_o_DefectValue,
            out HTupleVector/*{eTupleVector,Dim=1}*/ hvec_o_RefValue, out HTuple hv_o_ErrCode,
            out HTuple hv_o_ErrStr)
        {




            // Local iconic variables 

            HObject ho_EmptyReg, ho_i_Image, ho__BondContour;
            HObject ho_EmptyRegion, ho_RefBondCircle = null, ho__BondImage = null;
            HObject ho_SegReg = null, ho_SegReg0 = null, ho_RegDilation = null;
            HObject ho_RegDiff = null, ho_InspectRegUnion = null, ho_inspectImage = null;
            HObject ho_RefBondEllipse = null;

            // Local control variables 

            HTuple hv_HomMatSum = null, hv_Indices = null;
            HTuple hv__BondRegNum = null, hv__RefBondPara = null, hv__MeasureResult = null;
            HTuple hv__BondParas = null, hv__ErrMeasureCode = null;
            HTuple hv__ErrMeasureStr = null, hv_MetrologyType = null;
            HTuple hv__RefRow = new HTuple(), hv__RefCol = new HTuple();
            HTuple hv_RefRadius = new HTuple(), hv_RefBondRow = new HTuple();
            HTuple hv_RefBondCol = new HTuple(), hv_BondRow = new HTuple();
            HTuple hv_BondCol = new HTuple(), hv_BondRadius = new HTuple();
            HTuple hv_lowThresh = new HTuple(), hv_highThresh = new HTuple();
            HTuple hv_BondAreaAll = new HTuple(), hv_Row0 = new HTuple();
            HTuple hv_Col0 = new HTuple(), hv_BondAreaSeg = new HTuple();
            HTuple hv_Row1 = new HTuple(), hv_Col1 = new HTuple();
            HTuple hv_AreaFactor = new HTuple(), hv_BondAreaSeg0 = new HTuple();
            HTuple hv_DilateSize = new HTuple(), hv_RowIn = new HTuple();
            HTuple hv_ColIn = new HTuple(), hv_RadiusIn = new HTuple();
            HTuple hv_MetrologyHandle1 = new HTuple(), hv_RefLen1 = new HTuple();
            HTuple hv_RefLen2 = new HTuple(), hv_RefTransition = new HTuple();
            HTuple hv_RefThreshold = new HTuple(), hv__RefRadius = new HTuple();
            HTuple hv_MeasureSelect = new HTuple(), hv_DistanceThreshold = new HTuple();
            HTuple hv_AgainIndex = new HTuple(), hv_Parameter = new HTuple();
            HTuple hv_Exception = new HTuple(), hv_RefPhi = new HTuple();
            HTuple hv_RefRadius1 = new HTuple(), hv_RefRadius2 = new HTuple();
            HTuple hv_BondPhi = new HTuple(), hv_BondRadius1 = new HTuple();
            HTuple hv_BondRadius2 = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_BondContour);
            HOperatorSet.GenEmptyObj(out ho_o_FailReg);
            HOperatorSet.GenEmptyObj(out ho_EmptyReg);
            HOperatorSet.GenEmptyObj(out ho_i_Image);
            HOperatorSet.GenEmptyObj(out ho__BondContour);
            HOperatorSet.GenEmptyObj(out ho_EmptyRegion);
            HOperatorSet.GenEmptyObj(out ho_RefBondCircle);
            HOperatorSet.GenEmptyObj(out ho__BondImage);
            HOperatorSet.GenEmptyObj(out ho_SegReg);
            HOperatorSet.GenEmptyObj(out ho_SegReg0);
            HOperatorSet.GenEmptyObj(out ho_RegDilation);
            HOperatorSet.GenEmptyObj(out ho_RegDiff);
            HOperatorSet.GenEmptyObj(out ho_InspectRegUnion);
            HOperatorSet.GenEmptyObj(out ho_inspectImage);
            HOperatorSet.GenEmptyObj(out ho_RefBondEllipse);
            try
            {
                //****使用阈值分割的方法进行Bond1检测：1.先判断Bond1是否存在，2.再阈值分割判定Bond1的检测结果
                //----------图标参数
                //i_Image：输入图像
                //i_BondRegs：焊点检测区域（焊盘区域）
                //o_BondContours：检测到的Bond轮廓
                //o_FailRegs：未检测到Bond的缺陷区域
                //-----------控制参数
                //i_MetrologyHandle: 测量模板句柄
                //i_HomMatMod2Img: 测量区域的映射矩阵
                //i_MeasureType: 测量工具类型，允许对同一句柄添加多个测量工具，并分别指定类型，支持4类测量工具————1-直线工具，2-矩形工具，3-圆工具，4-椭圆工具
                //i_BondOffsetFactor: 焊点偏出参考点比例阈值
                //o_BondParas：检测到的Bond位置及半径信息
                //o_DefectValue：输出的实际检测得到的检测值
                //o_DefectType：输出的检测得到缺陷类型
                //o_RefValue:缺陷参考值
                //o_ErrCode: 错误码，代表该算子执行过程中产生的错误，0-代表正常执行，正整数-代表错误类型(1-未检测到焊点，2-焊点太小，3-焊点太大，4-焊点偏出焊盘)，-1-代表异常，-2-代表未执行
                //o_ErrStr: 错误信息，对各种错误的具体描述
                //*****

                //初始化
                //
                hv_o_DefectType = new HTuple();
                hv_o_DefectImgIdx = new HTuple();
                hvec_o_DefectValue = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(-2))));
                hvec_o_RefValue = (new HTupleVector(1).Insert(0, new HTupleVector((new HTuple(-2)).TupleConcat(
                    -2))));
                //
                ho_EmptyReg.Dispose();
                HOperatorSet.GenEmptyRegion(out ho_EmptyReg);
                ho_o_FailReg.Dispose();
                ho_o_FailReg = ho_EmptyReg.CopyObj(1, -1);
                ho_o_BondContour.Dispose();
                ho_o_BondContour = ho_EmptyReg.CopyObj(1, -1);
                //
                hv_o_ErrCode = -2;
                hv_o_ErrStr = "Initializing";
                //
                //传入映射矩阵有效性测试
                HOperatorSet.TupleSum(hv_i_HomMatMod2Img, out hv_HomMatSum);
                if ((int)(new HTuple(hv_HomMatSum.TupleEqual(-12))) != 0)
                {
                    hv_o_ErrCode = 1;
                    hv_o_ErrStr = "mapping matrix is invalid!";
                    ho_EmptyReg.Dispose();
                    ho_i_Image.Dispose();
                    ho__BondContour.Dispose();
                    ho_EmptyRegion.Dispose();
                    ho_RefBondCircle.Dispose();
                    ho__BondImage.Dispose();
                    ho_SegReg.Dispose();
                    ho_SegReg0.Dispose();
                    ho_RegDilation.Dispose();
                    ho_RegDiff.Dispose();
                    ho_InspectRegUnion.Dispose();
                    ho_inspectImage.Dispose();
                    ho_RefBondEllipse.Dispose();

                    return;
                }
                //
                //输入有效性测试
                HOperatorSet.GetMetrologyObjectIndices(hv_i_MetrologyHandle, out hv_Indices);
                hv__BondRegNum = new HTuple(hv_Indices.TupleLength());
                if ((int)(new HTuple(hv__BondRegNum.TupleEqual(0))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "bond region is empty";
                    ho_EmptyReg.Dispose();
                    ho_i_Image.Dispose();
                    ho__BondContour.Dispose();
                    ho_EmptyRegion.Dispose();
                    ho_RefBondCircle.Dispose();
                    ho__BondImage.Dispose();
                    ho_SegReg.Dispose();
                    ho_SegReg0.Dispose();
                    ho_RegDilation.Dispose();
                    ho_RegDiff.Dispose();
                    ho_InspectRegUnion.Dispose();
                    ho_inspectImage.Dispose();
                    ho_RefBondEllipse.Dispose();

                    return;
                }
                //
                //Bond参考信息获取
                HOperatorSet.GetMetrologyObjectParam(hv_i_MetrologyHandle, hv_i_MeasureIndex,
                    "object_params", out hv__RefBondPara);
                //
                //------应用测量工具方式进行Bond检测
                //测量图像选择
                ho_i_Image.Dispose();
                HOperatorSet.SelectObj(ho_i_Imgs, out ho_i_Image, hv_i_ImgIdx);
                ho__BondContour.Dispose();
                HTV_Apply_Measurement(ho_i_Image, ho_i_BondInspectReg, out ho__BondContour,
                    hv_i_MetrologyHandle, hv_i_HomMatMod2Img, hv_i_MeasureIndex, hv_i_MeasureType,
                    out hv__MeasureResult, out hv__BondParas, out hv__ErrMeasureCode, out hv__ErrMeasureStr);

                //HTV_Bond_Measure (i_Imgs, i_BondInspectReg, _BondContours, i_MetrologyHandle, i_HomMatMod2Img, i_MeasureType, _RefBondParas, _MeasureResult, _BondParas, _ErrBondMeasureCode, _ErrBondMeasureStr)

                //函数异常
                if ((int)(new HTuple(hv__ErrMeasureCode.TupleLess(0))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = hv__ErrMeasureStr.Clone();
                    ho_EmptyReg.Dispose();
                    ho_i_Image.Dispose();
                    ho__BondContour.Dispose();
                    ho_EmptyRegion.Dispose();
                    ho_RefBondCircle.Dispose();
                    ho__BondImage.Dispose();
                    ho_SegReg.Dispose();
                    ho_SegReg0.Dispose();
                    ho_RegDilation.Dispose();
                    ho_RegDiff.Dispose();
                    ho_InspectRegUnion.Dispose();
                    ho_inspectImage.Dispose();
                    ho_RefBondEllipse.Dispose();

                    return;
                }
                //
                //获取真实焊点区域
                ho_EmptyRegion.Dispose();
                HOperatorSet.GenEmptyRegion(out ho_EmptyRegion);
                //确定测量类型
                hv_MetrologyType = hv_i_MeasureType.TupleSelect(hv_i_MeasureIndex);
                switch (hv_MetrologyType.I)
                {
                    case 1:
                        //直线参数对角端点  4个参数Row, Column, Row, Column
                        break;
                    case 2:
                        //带方向的矩形  5个参数 Row, Column, Phi, Length1, Length2
                        break;
                    case 3:
                        //圆 3个参数 Row1, Column1, Radius1
                        //
                        //Bond参考位置及半径
                        hv__RefRow = hv__RefBondPara[0];
                        hv__RefCol = hv__RefBondPara[1];
                        hv_RefRadius = hv__RefBondPara[2];
                        HOperatorSet.AffineTransPoint2d(hv_i_HomMatMod2Img, hv__RefRow, hv__RefCol,
                            out hv_RefBondRow, out hv_RefBondCol);
                        //
                        //Bond实际测量
                        hv_BondRow = hv__BondParas[0];
                        hv_BondCol = hv__BondParas[1];
                        hv_BondRadius = hv__BondParas[2];
                        //
                        //***************************************************************
                        //焊点内部阈值分割复判
                        if ((int)(hv_i_isPreJudge) != 0)
                        {
                            //为了避免检测的空心焊盘当做焊球
                            if ((int)(new HTuple(hv__MeasureResult.TupleEqual(0))) != 0)
                            {
                                hv_lowThresh = hv_i_ThreshGray[0];
                                hv_highThresh = hv_i_ThreshGray[1];
                                ho_RefBondCircle.Dispose();
                                HOperatorSet.GenCircle(out ho_RefBondCircle, hv_RefBondRow, hv_RefBondCol,
                                    hv_RefRadius);
                                ho__BondImage.Dispose();
                                HOperatorSet.ReduceDomain(ho_i_Imgs, ho_RefBondCircle, out ho__BondImage
                                    );
                                ho_SegReg.Dispose();
                                HOperatorSet.Threshold(ho__BondImage, out ho_SegReg, hv_lowThresh, hv_highThresh);
                                HOperatorSet.AreaCenter(ho_RefBondCircle, out hv_BondAreaAll, out hv_Row0,
                                    out hv_Col0);
                                HOperatorSet.AreaCenter(ho_SegReg, out hv_BondAreaSeg, out hv_Row1, out hv_Col1);
                                hv_AreaFactor = (hv_BondAreaSeg * 1.0) / hv_BondAreaAll;
                                //
                                if ((int)(new HTuple(hv_AreaFactor.TupleGreater(hv_i_SegRegAreaFactor))) != 0)
                                {
                                    //若分割区域面积过大，则判定焊点检测失败
                                    hv__MeasureResult = 1;
                                }
                                else if ((int)(new HTuple(hv_AreaFactor.TupleGreater(hv_i_SegRegAreaFactor / 2))) != 0)
                                {
                                    //若分割区域面积一般，则偏移模板中心重新测量
                                    ho__BondImage.Dispose();
                                    HOperatorSet.ReduceDomain(ho_i_Imgs, ho__BondContour, out ho__BondImage
                                        );
                                    ho_SegReg0.Dispose();
                                    HOperatorSet.Threshold(ho__BondImage, out ho_SegReg0, hv_lowThresh,
                                        hv_highThresh);
                                    HOperatorSet.AreaCenter(ho_SegReg0, out hv_BondAreaSeg0, out hv_Row1,
                                        out hv_Col1);

                                    if ((int)(new HTuple(hv_BondAreaSeg0.TupleGreater(hv_BondAreaSeg / 2))) != 0)
                                    {
                                        //测量中心为分割后剩余区域中心
                                        hv_DilateSize = hv_RefRadius / 2;
                                        ho_RegDilation.Dispose();
                                        HOperatorSet.DilationCircle(ho_SegReg, out ho_RegDilation, hv_DilateSize);
                                        ho_RegDiff.Dispose();
                                        HOperatorSet.Difference(ho_RefBondCircle, ho_RegDilation, out ho_RegDiff
                                            );
                                        if ((int)(new HTuple(ho_RegDiff.TestEqualObj(ho_EmptyRegion))) != 0)
                                        {
                                            ho_RegDiff.Dispose();
                                            HOperatorSet.Difference(ho_RefBondCircle, ho_SegReg, out ho_RegDiff
                                                );
                                            HOperatorSet.InnerCircle(ho_RegDiff, out hv_RowIn, out hv_ColIn,
                                                out hv_RadiusIn);
                                        }
                                        else
                                        {
                                            HOperatorSet.InnerCircle(ho_RegDiff, out hv_RowIn, out hv_ColIn,
                                                out hv_RadiusIn);
                                        }
                                        //gen_cross_contour_xld (cross, RowIn, ColIn, 4, 0)

                                        //偏移测量卡尺再次测量
                                        HOperatorSet.CreateMetrologyModel(out hv_MetrologyHandle1);
                                        //模板参数
                                        HOperatorSet.GetMetrologyObjectParam(hv_i_MetrologyHandle, hv_i_MeasureIndex,
                                            "measure_length1", out hv_RefLen1);
                                        HOperatorSet.GetMetrologyObjectParam(hv_i_MetrologyHandle, hv_i_MeasureIndex,
                                            "measure_length2", out hv_RefLen2);
                                        HOperatorSet.GetMetrologyObjectParam(hv_i_MetrologyHandle, hv_i_MeasureIndex,
                                            "measure_transition", out hv_RefTransition);
                                        HOperatorSet.GetMetrologyObjectParam(hv_i_MetrologyHandle, hv_i_MeasureIndex,
                                            "measure_threshold", out hv_RefThreshold);
                                        HOperatorSet.GetMetrologyObjectParam(hv_i_MetrologyHandle, hv_i_MeasureIndex,
                                            "radius", out hv__RefRadius);
                                        HOperatorSet.GetMetrologyObjectParam(hv_i_MetrologyHandle, hv_i_MeasureIndex,
                                            "measure_select", out hv_MeasureSelect);
                                        HOperatorSet.GetMetrologyObjectParam(hv_i_MetrologyHandle, hv_i_MeasureIndex,
                                            "distance_threshold", out hv_DistanceThreshold);
                                        //
                                        HOperatorSet.AddMetrologyObjectCircleMeasure(hv_MetrologyHandle1,
                                            hv_RowIn, hv_ColIn, hv__RefRadius, hv_RefLen1, hv_RefLen2, 1,
                                            hv_RefThreshold, ((new HTuple("measure_transition")).TupleConcat(
                                            "measure_distance")).TupleConcat("min_score"), ((hv_RefTransition.TupleConcat(
                                            1.5 * hv_RefLen2))).TupleConcat(0.5), out hv_AgainIndex);

                                        HOperatorSet.SetMetrologyObjectParam(hv_MetrologyHandle1, hv_AgainIndex,
                                            "measure_select", hv_MeasureSelect);
                                        HOperatorSet.SetMetrologyObjectParam(hv_MetrologyHandle1, hv_AgainIndex,
                                            "distance_threshold", hv_DistanceThreshold);

                                        ho_InspectRegUnion.Dispose();
                                        HOperatorSet.Union1(ho_i_BondInspectReg, out ho_InspectRegUnion);
                                        ho_inspectImage.Dispose();
                                        HOperatorSet.ReduceDomain(ho_i_Imgs, ho_InspectRegUnion, out ho_inspectImage
                                            );
                                        try
                                        {
                                            HOperatorSet.ApplyMetrologyModel(ho_inspectImage, hv_MetrologyHandle1);
                                            HOperatorSet.GetMetrologyObjectResult(hv_MetrologyHandle1, hv_AgainIndex,
                                                "all", "result_type", "all_param", out hv_Parameter);

                                            //get_metrology_object_measures (Contours1, MetrologyHandle1, 'all', 'all', Row1, Column1)
                                            //gen_cross_contour_xld (Cross, Row1, Column1, 3, 0.785398)
                                        }
                                        // catch (Exception) 
                                        catch (HalconException HDevExpDefaultException1)
                                        {
                                            HDevExpDefaultException1.ToHTuple(out hv_Exception);
                                            hv_Parameter = new HTuple();
                                        }
                                        HOperatorSet.ClearMetrologyModel(hv_MetrologyHandle1);

                                        if ((int)(new HTuple((new HTuple(hv_Parameter.TupleLength())).TupleLess(
                                            3))) != 0)
                                        {
                                            hv__MeasureResult = 1;
                                        }
                                        else
                                        {
                                            hv__MeasureResult = 0;
                                            ho__BondContour.Dispose();
                                            HOperatorSet.GenCircle(out ho__BondContour, hv_Parameter.TupleSelect(
                                                0), hv_Parameter.TupleSelect(1), hv_Parameter.TupleSelect(2));

                                            //更新Bond实际测量
                                            hv_BondRow = hv_Parameter[0];
                                            hv_BondCol = hv_Parameter[1];
                                            hv_BondRadius = hv_Parameter[2];
                                        }
                                    }
                                }
                            }
                        }
                        //***************************************************************
                        //
                        break;
                    case 4:
                        //椭圆 5个参数 Row, Column, Phi, Radius1, Radius2
                        hv__RefRow = hv__RefBondPara[0];
                        hv__RefCol = hv__RefBondPara[1];
                        hv_RefPhi = hv__RefBondPara[2];
                        hv_RefRadius1 = hv__RefBondPara[3];
                        hv_RefRadius2 = hv__RefBondPara[4];
                        hv_RefRadius = (hv_RefRadius1 + hv_RefRadius2) / 2;
                        HOperatorSet.AffineTransPoint2d(hv_i_HomMatMod2Img, hv__RefRow, hv__RefCol,
                            out hv_RefBondRow, out hv_RefBondCol);
                        //
                        //bond实际测量
                        hv_BondRow = hv__BondParas[0];
                        hv_BondCol = hv__BondParas[1];
                        hv_BondPhi = hv__BondParas[2];
                        hv_BondRadius1 = hv__BondParas[3];
                        hv_BondRadius2 = hv__BondParas[4];
                        //与阈值分割方法保持一致，使用椭圆的短半径作为过大过小判断标准
                        hv_BondRadius = hv_BondRadius2.Clone();
                        //
                        //***************************************************************
                        //焊点内部阈值分割复判
                        if ((int)(hv_i_isPreJudge) != 0)
                        {
                            //为了避免检测的空心焊盘当做焊球
                            if ((int)(new HTuple(hv__MeasureResult.TupleEqual(0))) != 0)
                            {
                                hv_lowThresh = hv_i_ThreshGray[0];
                                hv_highThresh = hv_i_ThreshGray[1];
                                ho_RefBondEllipse.Dispose();
                                HOperatorSet.GenEllipse(out ho_RefBondEllipse, hv_RefBondRow, hv_RefBondCol,
                                    hv_RefPhi, hv_RefRadius1, hv_RefRadius2);
                                ho__BondImage.Dispose();
                                HOperatorSet.ReduceDomain(ho_i_Imgs, ho_RefBondEllipse, out ho__BondImage
                                    );
                                ho_SegReg.Dispose();
                                HOperatorSet.Threshold(ho__BondImage, out ho_SegReg, hv_lowThresh, hv_highThresh);
                                HOperatorSet.AreaCenter(ho_RefBondEllipse, out hv_BondAreaAll, out hv_Row0,
                                    out hv_Col0);
                                HOperatorSet.AreaCenter(ho_SegReg, out hv_BondAreaSeg, out hv_Row1, out hv_Col1);
                                hv_AreaFactor = (hv_BondAreaSeg * 1.0) / hv_BondAreaAll;
                                //
                                if ((int)(new HTuple(hv_AreaFactor.TupleGreater(hv_i_SegRegAreaFactor))) != 0)
                                {
                                    hv__MeasureResult = 1;
                                }
                            }
                        }
                        //***************************************************************
                        //
                        break;
                }
                //参数参考值, 焊点大小上下限
                hvec_o_RefValue = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(((hv_RefRadius * hv_i_BondUnderSizeFactor)).TupleConcat(
                    hv_RefRadius * hv_i_BondOverSizeFactor)))));
                //
                //分析焊点
                if ((int)(new HTuple(hv__MeasureResult.TupleGreater(0))) != 0)
                {
                    hv_o_DefectType = 22;
                    hv_o_DefectImgIdx = hv_i_ImgIdx.Clone();
                    hvec_o_DefectValue = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(-1))));
                    //
                    ho_o_FailReg.Dispose();
                    ho_o_FailReg = ho_i_BondInspectReg.CopyObj(1, -1);
                    ho_o_BondContour.Dispose();
                    ho_o_BondContour = ho_EmptyRegion.CopyObj(1, -1);
                }
                else if ((int)(new HTuple(hv__MeasureResult.TupleEqual(0))) != 0)
                {
                    //
                    if ((int)(new HTuple(hv_BondRadius.TupleGreater(hv_RefRadius * hv_i_BondOverSizeFactor))) != 0)
                    {
                        //焊点过大
                        hv_o_DefectType = 10;
                        hv_o_DefectImgIdx = hv_i_ImgIdx.Clone();
                        hvec_o_DefectValue = (new HTupleVector(1).Insert(0, new HTupleVector(hv_BondRadius)));
                        //
                        ho_o_FailReg.Dispose();
                        ho_o_FailReg = ho_i_BondInspectReg.CopyObj(1, -1);
                        ho_o_BondContour.Dispose();
                        ho_o_BondContour = ho_EmptyRegion.CopyObj(1, -1);
                        //
                    }
                    else if ((int)(new HTuple(hv_BondRadius.TupleLess(hv_RefRadius * hv_i_BondUnderSizeFactor))) != 0)
                    {
                        //焊点过小
                        hv_o_DefectType = 10;
                        hv_o_DefectImgIdx = hv_i_ImgIdx.Clone();
                        hvec_o_DefectValue = (new HTupleVector(1).Insert(0, new HTupleVector(hv_BondRadius)));
                        //
                        ho_o_FailReg.Dispose();
                        ho_o_FailReg = ho_i_BondInspectReg.CopyObj(1, -1);
                        ho_o_BondContour.Dispose();
                        ho_o_BondContour = ho_EmptyRegion.CopyObj(1, -1);
                    }
                    else
                    {
                        hv_o_DefectType = 0;
                        hv_o_DefectImgIdx = hv_i_ImgIdx.Clone();
                        hvec_o_DefectValue = (new HTupleVector(1).Insert(0, new HTupleVector(hv_BondRadius)));
                        //检测正常输出ResultReg
                        ho_o_FailReg.Dispose();
                        ho_o_FailReg = ho__BondContour.CopyObj(1, -1);
                        ho_o_BondContour.Dispose();
                        ho_o_BondContour = ho__BondContour.CopyObj(1, -1);
                        //
                    }
                }

                //输出执行结果
                if ((int)(new HTuple(hv_o_DefectType.TupleGreater(0))) != 0)
                {
                    hv_o_ErrCode = 1;
                    hv_o_ErrStr = "Fail to one  Bond";
                    ho_EmptyReg.Dispose();
                    ho_i_Image.Dispose();
                    ho__BondContour.Dispose();
                    ho_EmptyRegion.Dispose();
                    ho_RefBondCircle.Dispose();
                    ho__BondImage.Dispose();
                    ho_SegReg.Dispose();
                    ho_SegReg0.Dispose();
                    ho_RegDilation.Dispose();
                    ho_RegDiff.Dispose();
                    ho_InspectRegUnion.Dispose();
                    ho_inspectImage.Dispose();
                    ho_RefBondEllipse.Dispose();

                    return;
                }
                else
                {
                    hv_o_ErrCode = 0;
                    hv_o_ErrStr = "Bond Location is successful";
                    ho_EmptyReg.Dispose();
                    ho_i_Image.Dispose();
                    ho__BondContour.Dispose();
                    ho_EmptyRegion.Dispose();
                    ho_RefBondCircle.Dispose();
                    ho__BondImage.Dispose();
                    ho_SegReg.Dispose();
                    ho_SegReg0.Dispose();
                    ho_RegDilation.Dispose();
                    ho_RegDiff.Dispose();
                    ho_InspectRegUnion.Dispose();
                    ho_inspectImage.Dispose();
                    ho_RefBondEllipse.Dispose();

                    return;
                }

            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_EmptyReg.Dispose();
                ho_i_Image.Dispose();
                ho__BondContour.Dispose();
                ho_EmptyRegion.Dispose();
                ho_RefBondCircle.Dispose();
                ho__BondImage.Dispose();
                ho_SegReg.Dispose();
                ho_SegReg0.Dispose();
                ho_RegDilation.Dispose();
                ho_RegDiff.Dispose();
                ho_InspectRegUnion.Dispose();
                ho_inspectImage.Dispose();
                ho_RefBondEllipse.Dispose();

                throw HDevExpDefaultException;
            }
        }

        //public static void HTV_Bond_Inspect_measure(HObject ho_i_Image, HObject ho_i_BondRegs,
        //    out HObject ho_o_BondContours, out HObject ho_o_FailRegs, HTuple hv_i_HomMatMod2Img,
        //    HTuple hv_i_MetrologyHandle, HTuple hv_i_MeasureType, HTuple hv_i_BondOffsetFactor,
        //    out HTuple hv_o_DefectType, out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        //{
        //    // Stack for temporary objects 
        //    HObject[] OTemp = new HObject[20];

        //    // Local iconic variables 

        //    HObject ho_EmptyFailReg, ho__BondRegs, ho_failReg = null;
        //    HObject ho__BondContours, ho__BondContour = null;

        //    // Local control variables 

        //    HTuple hv_HomMatSum = null, hv_Indices = null;
        //    HTuple hv__BondRegNum = null, hv__RefBondParas = null;
        //    HTuple hv__ErrBondMeasureCode = null, hv__ErrBondMeasureStr = null;
        //    HTuple hv_paraIdx = null, hv_idx = null, hv_MetrologyType = new HTuple();
        //    HTuple hv__RefRow = new HTuple(), hv__RefCol = new HTuple();
        //    HTuple hv_RefRadius = new HTuple(), hv_BondRow = new HTuple();
        //    HTuple hv__BondParas = null, hv_BondCol = new HTuple();
        //    HTuple hv_BondRadius = new HTuple(), hv_RefRadius1 = new HTuple();
        //    HTuple hv_RefRadius2 = new HTuple(), hv_BondRadius1 = new HTuple();
        //    HTuple hv_BondRadius2 = new HTuple(), hv_RefBondRow = new HTuple();
        //    HTuple hv_RefBondCol = new HTuple(), hv__MeasureResult = null;
        //    HTuple hv__DiffRow = new HTuple(), hv__DiffCol = new HTuple();

        //    HTupleVector hvec_o_DefectValue = new HTupleVector(1);
        //    // Initialize local and output iconic variables 
        //    HOperatorSet.GenEmptyObj(out ho_o_BondContours);
        //    HOperatorSet.GenEmptyObj(out ho_o_FailRegs);
        //    HOperatorSet.GenEmptyObj(out ho_EmptyFailReg);
        //    HOperatorSet.GenEmptyObj(out ho__BondRegs);
        //    HOperatorSet.GenEmptyObj(out ho_failReg);
        //    HOperatorSet.GenEmptyObj(out ho__BondContours);
        //    HOperatorSet.GenEmptyObj(out ho__BondContour);
        //    //****使用阈值分割的方法进行Bond1检测：1.先判断Bond1是否存在，2.再阈值分割判定Bond1的检测结果
        //    //----------图标参数
        //    //i_Image：输入图像
        //    //i_BondRegs：焊点检测区域（焊盘区域）
        //    //o_BondContours：检测到的Bond轮廓
        //    //o_FailRegs：未检测到Bond的缺陷区域
        //    //-----------控制参数
        //    //i_MetrologyHandle: 测量模板句柄
        //    //i_HomMatMod2Img: 测量区域的映射矩阵
        //    //i_MeasureType: 测量工具类型，允许对同一句柄添加多个测量工具，并分别指定类型，支持4类测量工具————1-直线工具，2-矩形工具，3-圆工具，4-椭圆工具
        //    //i_BondOffsetFactor: 焊点偏出参考点比例阈值
        //    //o_BondParas：检测到的Bond位置及半径信息
        //    //o_DefectValue：输出的实际检测得到的检测值
        //    //o_DefectType：输出的检测得到缺陷类型
        //    //o_ErrCode: 错误码，代表该算子执行过程中产生的错误，0-代表正常执行，正整数-代表错误类型(1-未检测到焊点，2-焊点太小，3-焊点太大，4-焊点偏出焊盘)，-1-代表异常，-2-代表未执行
        //    //o_ErrStr: 错误信息，对各种错误的具体描述
        //    //*****

        //    //初始化
        //    //
        //    ho_EmptyFailReg.Dispose();
        //    HOperatorSet.GenEmptyObj(out ho_EmptyFailReg);
        //    hv_o_DefectType = new HTuple();
        //    ho_o_FailRegs.Dispose();
        //    ho_o_FailRegs = ho_EmptyFailReg.CopyObj(1, -1);
        //    ho_o_BondContours.Dispose();
        //    ho_o_BondContours = ho_EmptyFailReg.CopyObj(1, -1);
        //    hv_o_ErrCode = -2;
        //    hv_o_ErrStr = "Initializing";

        //    //传入映射矩阵有效性测试
        //    HOperatorSet.TupleSum(hv_i_HomMatMod2Img, out hv_HomMatSum);
        //    if ((int)(new HTuple(hv_HomMatSum.TupleEqual(-12))) != 0)
        //    {
        //        hv_o_ErrCode = 1;
        //        hv_o_ErrStr = "mapping matrix is invalid!";
        //        ho_EmptyFailReg.Dispose();
        //        ho__BondRegs.Dispose();
        //        ho_failReg.Dispose();
        //        ho__BondContours.Dispose();
        //        ho__BondContour.Dispose();

        //        return;
        //    }
        //    //输入有效性测试
        //    HOperatorSet.GetMetrologyObjectIndices(hv_i_MetrologyHandle, out hv_Indices);
        //    hv__BondRegNum = new HTuple(hv_Indices.TupleLength());
        //    if ((int)(new HTuple(hv__BondRegNum.TupleEqual(0))) != 0)
        //    {
        //        hv_o_ErrCode = -1;
        //        hv_o_ErrStr = "bond region is empty";
        //        ho_EmptyFailReg.Dispose();
        //        ho__BondRegs.Dispose();
        //        ho_failReg.Dispose();
        //        ho__BondContours.Dispose();
        //        ho__BondContour.Dispose();

        //        return;
        //    }
        //    //检测区域映射
        //    ho__BondRegs.Dispose();
        //    HOperatorSet.AffineTransRegion(ho_i_BondRegs, out ho__BondRegs, hv_i_HomMatMod2Img,
        //        "nearest_neighbor");
        //    //Bond参考信息获取
        //    HOperatorSet.GetMetrologyObjectParam(hv_i_MetrologyHandle, "all", "object_params",
        //        out hv__RefBondParas);

        //    //------应用测量工具方式进行Bond1检测
        //    ho__BondContours.Dispose();
        //    HTV_Bond_Measure(ho_i_Image, ho_i_BondRegs, out ho__BondContours, hv_i_MetrologyHandle,
        //        hv_i_HomMatMod2Img, hv_i_MeasureType, hv__RefBondParas, out hv__MeasureResult,
        //        out hv__BondParas, out hv__ErrBondMeasureCode, out hv__ErrBondMeasureStr);

        //    //参数异常
        //    if ((int)(new HTuple(hv__ErrBondMeasureCode.TupleLess(0))) != 0)
        //    {
        //        hv_o_ErrCode = -1;
        //        hv_o_ErrStr = hv__ErrBondMeasureStr.Clone();
        //        ho_EmptyFailReg.Dispose();
        //        ho__BondRegs.Dispose();
        //        ho_failReg.Dispose();
        //        ho__BondContours.Dispose();
        //        ho__BondContour.Dispose();

        //        return;
        //    }

        //    //
        //    hv_paraIdx = 0;
        //    //

        //    HTuple end_val61 = hv__BondRegNum - 1;
        //    HTuple step_val61 = 1;
        //    for (hv_idx = 0; hv_idx.Continue(end_val61, step_val61); hv_idx = hv_idx.TupleAdd(step_val61))
        //    {
        //        //确定测量类型
        //        hv_MetrologyType = hv_i_MeasureType.TupleSelect(hv_idx);
        //        switch (hv_MetrologyType.I)
        //        {
        //            case 1:
        //                //直线参数对角端点  4个参数Row, Column, Row, Column
        //                goto case 2;
        //            case 2:
        //                //带方向的矩形  5个参数 Row, Column, Phi, Length1, Length2
        //                goto case 3;
        //            case 3:
        //                //圆 3个参数 Row1, Column1, Radius1
        //                //
        //                //Bond参考位置及半径
        //                hv__RefRow = hv__RefBondParas.TupleSelect(hv_paraIdx + 0);
        //                hv__RefCol = hv__RefBondParas.TupleSelect(hv_paraIdx + 1);
        //                hv_RefRadius = hv__RefBondParas.TupleSelect(hv_paraIdx + 2);
        //                //
        //                //Bond实际测量
        //                hv_BondRow = hv__BondParas.TupleSelect(hv_paraIdx + 0);
        //                hv_BondCol = hv__BondParas.TupleSelect(hv_paraIdx + 1);
        //                hv_BondRadius = hv__BondParas.TupleSelect(hv_paraIdx + 2);
        //                //
        //                hv_paraIdx = hv_paraIdx + 3;
        //                break;
        //            case 4:
        //                //椭圆 5个参数 Row, Column, Phi, Radius, Radius
        //                hv__RefRow = hv__RefBondParas.TupleSelect(hv_paraIdx + 0);
        //                hv__RefCol = hv__RefBondParas.TupleSelect(hv_paraIdx + 1);
        //                hv_RefRadius1 = hv__RefBondParas.TupleSelect(hv_paraIdx + 3);
        //                hv_RefRadius2 = hv__RefBondParas.TupleSelect(hv_paraIdx + 4);
        //                hv_RefRadius = (hv_RefRadius1 + hv_RefRadius2) / 2;
        //                //
        //                //bond实际测量
        //                hv_BondRow = hv__BondParas.TupleSelect(hv_paraIdx + 0);
        //                hv_BondCol = hv__BondParas.TupleSelect(hv_paraIdx + 1);
        //                hv_BondRadius1 = hv__BondParas.TupleSelect(hv_paraIdx + 3);
        //                hv_BondRadius2 = hv__BondParas.TupleSelect(hv_paraIdx + 4);
        //                hv_BondRadius = (hv_BondRadius1 + hv_BondRadius2) / 2;
        //                //
        //                hv_paraIdx = hv_paraIdx + 5;
        //                break;
        //        }
        //        //Bond参考区域映射
        //        HOperatorSet.AffineTransPoint2d(hv_i_HomMatMod2Img, hv__RefRow, hv__RefCol,
        //            out hv_RefBondRow, out hv_RefBondCol);
        //        ho_failReg.Dispose();
        //        HOperatorSet.GenRectangle2(out ho_failReg, hv_RefBondRow, hv_RefBondCol, 0,
        //            hv_RefRadius * 2, hv_RefRadius * 2);
        //        //分析每个焊点
        //        ho__BondContour.Dispose();
        //        HOperatorSet.SelectObj(ho__BondContours, out ho__BondContour, hv_idx + 1);
        //        if ((int)(new HTuple(((hv__MeasureResult.TupleSelect(hv_idx))).TupleGreater(
        //            0))) != 0)
        //        {
        //            hv_o_DefectType = hv_o_DefectType.TupleConcat(22);
        //            hvec_o_DefectValue[hv__BondRegNum + hv_idx] = new HTupleVector(((new HTuple(-1)).TupleConcat(
        //                -1)).TupleConcat(-1));
        //            {
        //                HObject ExpTmpOutVar_0;
        //                HOperatorSet.ConcatObj(ho_o_FailRegs, ho_failReg, out ExpTmpOutVar_0);
        //                ho_o_FailRegs.Dispose();
        //                ho_o_FailRegs = ExpTmpOutVar_0;
        //            }
        //            //
        //        }
        //        else if ((int)(new HTuple(((hv__MeasureResult.TupleSelect(hv_idx))).TupleEqual(
        //            0))) != 0)
        //        {
        //            //焊点位置偏移
        //            hv__DiffRow = ((hv_RefBondRow - hv_BondRow)).TupleAbs();
        //            hv__DiffCol = ((hv_RefBondCol - hv_BondCol)).TupleAbs();
        //            //
        //            if ((int)(new HTuple(hv_BondRadius.TupleGreater(hv_RefRadius * 1.5))) != 0)
        //            {
        //                //焊点过大
        //                hv_o_DefectType = hv_o_DefectType.TupleConcat(10);
        //                hvec_o_DefectValue[hv__BondRegNum + hv_idx] = new HTupleVector(((hv_BondRow.TupleConcat(
        //                    hv_BondCol))).TupleConcat(hv_BondRadius));
        //                //
        //                {
        //                    HObject ExpTmpOutVar_0;
        //                    HOperatorSet.ConcatObj(ho_o_FailRegs, ho_failReg, out ExpTmpOutVar_0);
        //                    ho_o_FailRegs.Dispose();
        //                    ho_o_FailRegs = ExpTmpOutVar_0;
        //                }
        //                //输出位置、焊点轮廓
        //                {
        //                    HObject ExpTmpOutVar_0;
        //                    HOperatorSet.ConcatObj(ho_o_BondContours, ho_EmptyFailReg, out ExpTmpOutVar_0
        //                        );
        //                    ho_o_BondContours.Dispose();
        //                    ho_o_BondContours = ExpTmpOutVar_0;
        //                }
        //                //
        //            }
        //            else if ((int)(new HTuple(hv_BondRadius.TupleLess(hv_RefRadius * 0.5))) != 0)
        //            {
        //                //焊点过小
        //                hv_o_DefectType = hv_o_DefectType.TupleConcat(10);
        //                hvec_o_DefectValue[hv__BondRegNum + hv_idx] = new HTupleVector(((hv_BondRow.TupleConcat(
        //                    hv_BondCol))).TupleConcat(hv_BondRadius));
        //                //
        //                {
        //                    HObject ExpTmpOutVar_0;
        //                    HOperatorSet.ConcatObj(ho_o_FailRegs, ho_failReg, out ExpTmpOutVar_0);
        //                    ho_o_FailRegs.Dispose();
        //                    ho_o_FailRegs = ExpTmpOutVar_0;
        //                }
        //                //输出位置、焊点轮廓
        //                {
        //                    HObject ExpTmpOutVar_0;
        //                    HOperatorSet.ConcatObj(ho_o_BondContours, ho_EmptyFailReg, out ExpTmpOutVar_0
        //                        );
        //                    ho_o_BondContours.Dispose();
        //                    ho_o_BondContours = ExpTmpOutVar_0;
        //                }
        //                //
        //            }
        //            else if ((int)((new HTuple(((hv__DiffRow / hv_RefRadius)).TupleGreater(
        //                hv_i_BondOffsetFactor))).TupleOr(new HTuple(((hv__DiffCol / hv_RefRadius)).TupleGreater(
        //                hv_i_BondOffsetFactor)))) != 0)
        //            {
        //                //焊点偏移
        //                hv_o_DefectType = hv_o_DefectType.TupleConcat(11);
        //                hvec_o_DefectValue[hv__BondRegNum + hv_idx] = new HTupleVector(((hv_BondRow.TupleConcat(
        //                    hv_BondCol))).TupleConcat(hv_BondRadius));
        //                //
        //                {
        //                    HObject ExpTmpOutVar_0;
        //                    HOperatorSet.ConcatObj(ho_o_FailRegs, ho_failReg, out ExpTmpOutVar_0);
        //                    ho_o_FailRegs.Dispose();
        //                    ho_o_FailRegs = ExpTmpOutVar_0;
        //                }
        //                //输出位置、焊点轮廓
        //                {
        //                    HObject ExpTmpOutVar_0;
        //                    HOperatorSet.ConcatObj(ho_o_BondContours, ho_EmptyFailReg, out ExpTmpOutVar_0
        //                        );
        //                    ho_o_BondContours.Dispose();
        //                    ho_o_BondContours = ExpTmpOutVar_0;
        //                }
        //            }
        //            else
        //            {
        //                hvec_o_DefectValue[hv__BondRegNum + hv_idx] = new HTupleVector(((hv_BondRow.TupleConcat(
        //                    hv_BondCol))).TupleConcat(hv_BondRadius));
        //                //焊点正常，输出焊点轮廓
        //                {
        //                    HObject ExpTmpOutVar_0;
        //                    HOperatorSet.ConcatObj(ho_o_BondContours, ho__BondContour, out ExpTmpOutVar_0
        //                        );
        //                    ho_o_BondContours.Dispose();
        //                    ho_o_BondContours = ExpTmpOutVar_0;
        //                }
        //                //
        //            }
        //        }
        //    }

        //    //输出执行结果
        //    if ((int)(new HTuple((new HTuple(hv_o_DefectType.TupleLength())).TupleGreater(
        //        0))) != 0)
        //    {
        //        hv_o_ErrCode = 1;
        //        hv_o_ErrStr = "Fail to one or more Bond";
        //        ho_EmptyFailReg.Dispose();
        //        ho__BondRegs.Dispose();
        //        ho_failReg.Dispose();
        //        ho__BondContours.Dispose();
        //        ho__BondContour.Dispose();

        //        return;
        //    }
        //    else
        //    {
        //        hv_o_ErrCode = 0;
        //        hv_o_ErrStr = "Bond Location is successful";
        //        ho_EmptyFailReg.Dispose();
        //        ho__BondRegs.Dispose();
        //        ho_failReg.Dispose();
        //        ho__BondContours.Dispose();
        //        ho__BondContour.Dispose();

        //        return;
        //    }

        //}

        public static void HTV_Bond_Measure(HObject ho_i_Image, HObject ho_i_BondRegs, out HObject ho_o_BondContours,
            HTuple hv_i_MetrologyHandle, HTuple hv_i_HomMatMod2Img, HTuple hv_i_MeasureType,
            HTuple hv_i_RefBondParas, out HTuple hv_o_MeasureResult, out HTuple hv_o_BondParas,
            out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {




            // Local iconic variables 

            // Local control variables 

            HTuple hv__ErrMeasureCode = null, hv__ErrMeasureStr = null;
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_BondContours);
            //***********   基于应用测量测方法定位焊点
            // i_Image：待处理图像
            // i_BondRegs：焊点检测区域（焊盘区域）
            // o_BondContours：检测到的焊点轮廓
            // i_MetrologyHandle: 测量模板句柄
            // i_HomMatMod2Img: 测量区域的映射矩阵
            // i_MeasureType: 测量工具类型，允许对同一句柄添加多个测量工具，并分别指定类型，支持4类测量工具————1-直线工具，2-矩形工具，3-圆工具，4-椭圆工具
            // o_MeasureResult：应用测量测量的结果
            // o_BondParas: 测量结果，每一个测量工具对应一组结果参数，所有测量工具的参数均包含在该变量中
            // o_ErrCode: 错误码，代表该算子执行过程中产生的错误，0-代表正常执行，正整数-代表错误类型，-1-代表异常，-2-代表未执行
            // o_ErrStr: 错误信息，对各种错误的具体描述
            //************************************************

            //初始化
            ho_o_BondContours.Dispose();
            HOperatorSet.GenEmptyObj(out ho_o_BondContours);
            hv_o_MeasureResult = new HTuple();
            hv_o_BondParas = new HTuple();
            hv_o_ErrCode = -2;
            hv_o_ErrStr = "initializing";

            //应用测量
            ho_o_BondContours.Dispose();
            HTV_Apply_Measurement(ho_i_Image, ho_i_BondRegs, out ho_o_BondContours, hv_i_MetrologyHandle,
                hv_i_HomMatMod2Img, hv_i_MeasureType, hv_i_RefBondParas, out hv_o_MeasureResult,
                out hv_o_BondParas, out hv__ErrMeasureCode, out hv__ErrMeasureStr);

            //对测量结果进行判断
            if ((int)(new HTuple(hv__ErrMeasureCode.TupleGreater(0))) != 0)
            {
                hv_o_ErrCode = 1;
                hv_o_ErrStr = "Fail to measure one bondreg" + hv__ErrMeasureStr;

                return;
            }
            else if ((int)(new HTuple(hv__ErrMeasureCode.TupleEqual(0))) != 0)
            {
                hv_o_ErrCode = 0;
                hv_o_ErrStr = "Success to measure bondreg" + hv__ErrMeasureStr;

                return;
            }
            else
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "Fail to apply measurement" + hv__ErrMeasureStr;

                return;
            }

        }

        public static void HTV_Apply_Measurement(HObject ho_i_Image, HObject ho_i_InspectReg,
            out HObject ho_o_MeasureContour, HTuple hv_i_MetrologyHandle, HTuple hv_i_HomMatMod2Img,
            HTuple hv_i_MeasureIndex, HTuple hv_i_MeasureType, out HTuple hv_o_MeasureFlag,
            out HTuple hv_o_MeasurePara, out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {




            // Local iconic variables 

            HObject ho_InspectRegUnion, ho_inspectImage;
            HObject ho_EmptyReg, ho_Contour = null;

            // Local control variables 

            HTuple hv_imgNum = null, hv_regNum = null;
            HTuple hv_Greater = null, hv_Less = null, hv_sum1 = null;
            HTuple hv_sum2 = null, hv_MetrologyHandle = null, hv_Sx = null;
            HTuple hv_Sy = null, hv_PhiAffine = null, hv_Theta = null;
            HTuple hv_TxAffine = null, hv_TyAffine = null, hv_AgainFlag = null;
            HTuple hv_Exception = null, hv_RefLen1 = new HTuple();
            HTuple hv_RefLen2 = new HTuple(), hv_RefTransition = new HTuple();
            HTuple hv_RefThreshold = new HTuple(), hv__MetrologyParas = new HTuple();
            HTuple hv_MeasureSelect = new HTuple(), hv_DistanceThreshold = new HTuple();
            HTuple hv_MetrologyHandle0 = new HTuple(), hv_NewIndex = new HTuple();
            HTuple hv_paraIdx = new HTuple(), hv_Exception0 = new HTuple();
            HTuple hv__RefRow = new HTuple(), hv__RefCol = new HTuple();
            HTuple hv__RefPhi = new HTuple(), hv__RefR1 = new HTuple();
            HTuple hv__RefR2 = new HTuple(), hv_Parameter = null, hv_MetrologyHandle1 = new HTuple();
            HTuple hv_AgainIndex = new HTuple(), hv_Exception1 = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_MeasureContour);
            HOperatorSet.GenEmptyObj(out ho_InspectRegUnion);
            HOperatorSet.GenEmptyObj(out ho_inspectImage);
            HOperatorSet.GenEmptyObj(out ho_EmptyReg);
            HOperatorSet.GenEmptyObj(out ho_Contour);
            try
            {
                //***********   运用测量模板检测区域内的目标
                // i_Image: 待处理图像
                // i_InspectRegs: 测量所在区域
                // o_MeasureContours：测量结果显示
                // i_MetrologyHandle: 测量模板句柄
                // i_HomMatMod2Img: 测量区域的映射矩阵
                // i_MeasureType: 测量工具类型，允许对同一句柄添加多个测量工具，并分别指定类型，支持4类测量工具————1-直线工具，2-矩形工具，3-圆工具，4-椭圆工具
                // o_MeasureFlag：测量结果标志
                // o_MeasureParas: 测量结果，每一个测量工具对应一组结果参数，所有测量工具的参数均包含在该变量中
                // o_ErrCode: 错误码，代表该算子执行过程中产生的错误，0-代表正常执行，自然数-代表错误类型，-1-代表异常，-2-代表未执行
                // o_ErrStr: 错误信息，对各种错误的具体描述

                //初始化
                hv_o_ErrCode = -2;
                hv_o_ErrStr = "initializing";
                hv_o_MeasurePara = new HTuple();
                ho_o_MeasureContour.Dispose();
                HOperatorSet.GenEmptyObj(out ho_o_MeasureContour);
                //测量结果Flag
                hv_o_MeasureFlag = new HTuple();
                //输入有效性测试
                HOperatorSet.CountObj(ho_i_Image, out hv_imgNum);
                if ((int)(new HTuple(hv_imgNum.TupleEqual(0))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "input image is null";
                    ho_InspectRegUnion.Dispose();
                    ho_inspectImage.Dispose();
                    ho_EmptyReg.Dispose();
                    ho_Contour.Dispose();

                    return;
                }
                HOperatorSet.CountObj(ho_i_InspectReg, out hv_regNum);
                if ((int)(new HTuple(hv_regNum.TupleLess(1))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "inspect region is empty";
                    ho_InspectRegUnion.Dispose();
                    ho_inspectImage.Dispose();
                    ho_EmptyReg.Dispose();
                    ho_Contour.Dispose();

                    return;
                }
                if ((int)((new HTuple((new HTuple(hv_i_MetrologyHandle.TupleLength())).TupleEqual(
                    0))).TupleOr(new HTuple(hv_i_MetrologyHandle.TupleLess(0)))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "para i_MetrologyHandle is illegal";
                    ho_InspectRegUnion.Dispose();
                    ho_inspectImage.Dispose();
                    ho_EmptyReg.Dispose();
                    ho_Contour.Dispose();

                    return;
                }
                if ((int)(new HTuple((new HTuple(hv_i_HomMatMod2Img.TupleLength())).TupleLess(
                    6))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "para i_HomMatMod2Img is illegal";
                    ho_InspectRegUnion.Dispose();
                    ho_inspectImage.Dispose();
                    ho_EmptyReg.Dispose();
                    ho_Contour.Dispose();

                    return;
                }

                //测量工具类型不属于支持的4类，异常退出
                HOperatorSet.TupleGreaterElem(hv_i_MeasureType, 4, out hv_Greater);
                HOperatorSet.TupleLessElem(hv_i_MeasureType, 1, out hv_Less);
                hv_sum1 = hv_Greater.TupleSum();
                hv_sum2 = hv_Less.TupleSum();
                if ((int)((new HTuple(hv_sum1.TupleGreater(0))).TupleOr(new HTuple(hv_sum2.TupleGreater(
                    0)))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "measure tools unsupport!";
                    ho_InspectRegUnion.Dispose();
                    ho_inspectImage.Dispose();
                    ho_EmptyReg.Dispose();
                    ho_Contour.Dispose();

                    return;
                }

                //复制测量模板，并映射到当前图像中
                HOperatorSet.CopyMetrologyModel(hv_i_MetrologyHandle, hv_i_MeasureIndex, out hv_MetrologyHandle);
                //测量模板映射
                HOperatorSet.HomMat2dToAffinePar(hv_i_HomMatMod2Img, out hv_Sx, out hv_Sy,
                    out hv_PhiAffine, out hv_Theta, out hv_TxAffine, out hv_TyAffine);
                HOperatorSet.AlignMetrologyModel(hv_MetrologyHandle, hv_TxAffine, hv_TyAffine,
                    hv_PhiAffine);
                //应用测量工具
                ho_InspectRegUnion.Dispose();
                HOperatorSet.Union1(ho_i_InspectReg, out ho_InspectRegUnion);
                ho_inspectImage.Dispose();
                HOperatorSet.ReduceDomain(ho_i_Image, ho_InspectRegUnion, out ho_inspectImage
                    );

                //针对apply_metrology_model出现9101报错，微调参数再试一次，add_lw_20200928
                hv_AgainFlag = 0;
                try
                {
                    HOperatorSet.ApplyMetrologyModel(ho_inspectImage, hv_MetrologyHandle);
                    //get_metrology_object_measures (Contours0, MetrologyHandle, 'all', 'all', Row0, Column0)
                    //gen_cross_contour_xld (Cross, Row0, Column0, 3, 0.785398)
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    if ((int)(new HTuple(((hv_Exception.TupleSelect(0))).TupleEqual(9101))) != 0)
                    {
                        //获取创建模板参数
                        HOperatorSet.GetMetrologyObjectParam(hv_MetrologyHandle, "all", "measure_length1",
                            out hv_RefLen1);
                        HOperatorSet.GetMetrologyObjectParam(hv_MetrologyHandle, "all", "measure_length2",
                            out hv_RefLen2);
                        HOperatorSet.GetMetrologyObjectParam(hv_MetrologyHandle, "all", "measure_transition",
                            out hv_RefTransition);
                        HOperatorSet.GetMetrologyObjectParam(hv_MetrologyHandle, "all", "measure_threshold",
                            out hv_RefThreshold);
                        HOperatorSet.GetMetrologyObjectParam(hv_MetrologyHandle, "all", "object_params",
                            out hv__MetrologyParas);
                        HOperatorSet.GetMetrologyObjectParam(hv_MetrologyHandle, "all", "measure_select",
                            out hv_MeasureSelect);
                        HOperatorSet.GetMetrologyObjectParam(hv_MetrologyHandle, "all", "distance_threshold",
                            out hv_DistanceThreshold);
                        //创建测量模板
                        HOperatorSet.CreateMetrologyModel(out hv_MetrologyHandle0);
                        //分类型进行创建模板
                        switch ((hv_i_MeasureType.TupleSelect(
                            hv_i_MeasureIndex)).I)
                        {
                            case 1:
                                break;
                            case 2:
                                break;
                            case 3:
                                //添加圆形测量工具，需要3个参数，分别为圆心横坐标、纵坐标、半径
                                //修改参数'measure_distance'
                                HOperatorSet.AddMetrologyObjectCircleMeasure(hv_MetrologyHandle0, hv__MetrologyParas,
                                    hv__MetrologyParas, hv__MetrologyParas, hv_RefLen1, hv_RefLen2, 1,
                                    hv_RefThreshold, ((new HTuple("measure_transition")).TupleConcat(
                                    "measure_distance")).TupleConcat("min_score"), ((hv_RefTransition.TupleConcat(
                                    2 * hv_RefLen2))).TupleConcat(0.5), out hv_NewIndex);
                                //设置边缘点参数
                                HOperatorSet.SetMetrologyObjectParam(hv_MetrologyHandle0, hv_NewIndex,
                                    "distance_threshold", hv_DistanceThreshold);
                                HOperatorSet.SetMetrologyObjectParam(hv_MetrologyHandle0, hv_NewIndex,
                                    "measure_select", hv_MeasureSelect);
                                hv_paraIdx = hv_paraIdx + 3;
                                break;
                            case 4:
                                //添加椭圆测量工具，需要5个参数，分别为椭圆中心横坐标、纵坐标、半长轴长、半短轴长、长轴方向
                                //修改参数'measure_distance'
                                HOperatorSet.AddMetrologyObjectEllipseMeasure(hv_MetrologyHandle0, hv__MetrologyParas,
                                    hv__MetrologyParas, hv__MetrologyParas, hv__MetrologyParas, hv__MetrologyParas,
                                    hv_RefLen1, hv_RefLen2, 1, hv_RefThreshold, ((new HTuple("measure_transition")).TupleConcat(
                                    "measure_distance")).TupleConcat("min_score"), ((hv_RefTransition.TupleConcat(
                                    2 * hv_RefLen2))).TupleConcat(0.5), out hv_NewIndex);
                                //设置边缘点参数
                                HOperatorSet.SetMetrologyObjectParam(hv_MetrologyHandle0, hv_NewIndex,
                                    "distance_threshold", hv_DistanceThreshold);
                                HOperatorSet.SetMetrologyObjectParam(hv_MetrologyHandle0, hv_NewIndex,
                                    "measure_select", hv_MeasureSelect);
                                hv_paraIdx = hv_paraIdx + 5;
                                break;
                        }
                        //应用
                        try
                        {
                            HOperatorSet.ApplyMetrologyModel(ho_inspectImage, hv_MetrologyHandle0);
                        }
                        // catch (Exception0) 
                        catch (HalconException HDevExpDefaultException2)
                        {
                            HDevExpDefaultException2.ToHTuple(out hv_Exception0);
                            if ((int)((new HTuple(((hv_Exception0.TupleSelect(0))).TupleEqual(9101))).TupleAnd(
                                new HTuple(((hv_i_MeasureType.TupleSelect(hv_i_MeasureIndex))).TupleEqual(
                                4)))) != 0)
                            {
                                HOperatorSet.GetMetrologyObjectParam(hv_MetrologyHandle, "all", "row",
                                    out hv__RefRow);
                                HOperatorSet.GetMetrologyObjectParam(hv_MetrologyHandle, "all", "column",
                                    out hv__RefCol);
                                HOperatorSet.GetMetrologyObjectParam(hv_MetrologyHandle, "all", "phi",
                                    out hv__RefPhi);
                                HOperatorSet.GetMetrologyObjectParam(hv_MetrologyHandle, "all", "radius1",
                                    out hv__RefR1);
                                HOperatorSet.GetMetrologyObjectParam(hv_MetrologyHandle, "all", "radius2",
                                    out hv__RefR2);
                                hv_AgainFlag = 1;
                            }
                        }
                        HOperatorSet.CopyMetrologyModel(hv_MetrologyHandle0, "all", out hv_MetrologyHandle);
                        HOperatorSet.ClearMetrologyModel(hv_MetrologyHandle0);
                    }
                }

                //根据测量工具索引及类型，获取测量结果
                ho_EmptyReg.Dispose();
                HOperatorSet.GenEmptyRegion(out ho_EmptyReg);
                HOperatorSet.GetMetrologyObjectResult(hv_MetrologyHandle, "all", "all", "result_type",
                    "all_param", out hv_Parameter);
                //
                switch ((hv_i_MeasureType.TupleSelect(
                    hv_i_MeasureIndex)).I)
                {
                    case 1:
                        //直线
                        if ((int)(new HTuple((new HTuple(hv_Parameter.TupleLength())).TupleLess(4))) != 0)
                        {
                            hv_o_MeasureFlag = 1;
                            hv_Parameter = new HTuple();
                            hv_Parameter[0] = -1;
                            hv_Parameter[1] = -1;
                            hv_Parameter[2] = -1;
                            hv_Parameter[3] = -1;
                            ho_Contour.Dispose();
                            ho_Contour = ho_EmptyReg.CopyObj(1, -1);
                        }
                        else
                        {
                            hv_o_MeasureFlag = 0;
                        }
                        hv_o_MeasurePara = hv_Parameter.Clone();
                        ho_o_MeasureContour.Dispose();
                        ho_o_MeasureContour = ho_Contour.CopyObj(1, -1);
                        //
                        break;
                    case 2:
                        //矩形
                        if ((int)(new HTuple((new HTuple(hv_Parameter.TupleLength())).TupleLess(5))) != 0)
                        {
                            hv_o_MeasureFlag = 1;
                            hv_Parameter = new HTuple();
                            hv_Parameter[0] = -1;
                            hv_Parameter[1] = -1;
                            hv_Parameter[2] = -1;
                            hv_Parameter[3] = -1;
                            hv_Parameter[4] = -1;
                            ho_Contour.Dispose();
                            ho_Contour = ho_EmptyReg.CopyObj(1, -1);
                        }
                        else
                        {
                            hv_o_MeasureFlag = 0;
                            ho_Contour.Dispose();
                            HOperatorSet.GenRectangle2(out ho_Contour, hv_Parameter.TupleSelect(0),
                                hv_Parameter.TupleSelect(1), hv_Parameter.TupleSelect(2), hv_Parameter.TupleSelect(
                                3), hv_Parameter.TupleSelect(4));
                        }
                        hv_o_MeasurePara = hv_Parameter.Clone();
                        ho_o_MeasureContour.Dispose();
                        ho_o_MeasureContour = ho_Contour.CopyObj(1, -1);
                        //
                        break;
                    case 3:
                        //圆
                        if ((int)(new HTuple((new HTuple(hv_Parameter.TupleLength())).TupleLess(3))) != 0)
                        {
                            hv_o_MeasureFlag = 1;
                            hv_Parameter = new HTuple();
                            hv_Parameter[0] = -1;
                            hv_Parameter[1] = -1;
                            hv_Parameter[2] = -1;
                            ho_Contour.Dispose();
                            ho_Contour = ho_EmptyReg.CopyObj(1, -1);
                            //增加卡尺尺寸，再试一次
                            //get_image_size (i_Image, Width, Height)
                            //get_metrology_object_param (MetrologyHandle, Indices[idx], ['row', 'column', 'radius'], RefBond0Paras)
                            //RefBond0Paras := i_RefBondPara[idx*3 : idx*3+2]
                            //affine_trans_point_2d (i_HomMatMod2Img, RefBond0Paras[0], RefBond0Paras[1], RefBondRow, RefBondCol)
                            //MeasureTransition := 'positive'
                            //i_MeasureLen1 := RefBond0Paras[2]/2
                            //i_MeasureLen2 := 2
                            //create_metrology_model (MetrologyHandle0)
                            //set_metrology_model_image_size (MetrologyHandle0, Width, Height)
                            //add_metrology_object_circle_measure (MetrologyHandle0, RefBondRow, RefBondCol, RefBond0Paras[2], i_MeasureLen1, i_MeasureLen2, 1, 5, ['measure_transition', 'measure_distance', 'min_score'], [MeasureTransition, 3, 0.6], NewIndex)
                            //apply_metrology_model (inspectImage, MetrologyHandle0)
                            //get_metrology_object_measures (Contours0, MetrologyHandle0, 'all', 'all', Row0, Column0)
                            //get_metrology_object_result (MetrologyHandle0, NewIndex, 'all', 'result_type', 'all_param', _circles)
                            //get_metrology_object_measures (Contours0, MetrologyHandle0, 'all', 'all', Row0, Column0)
                            //gen_cross_contour_xld (Cross, Row0, Column0, 6, 0.785398)
                            //clear_metrology_model (MetrologyHandle0)

                            //if (|_circles|#3)
                            //换成预处理图，再试一次
                            //select_obj (i_Images, _ImageS, i_BondImgIdx[1])
                            //reduce_domain (_ImageS, InspectRegUnion, inspectImageS)
                            //MeasureTransition := 'negative'
                            //MeasureTransition := i_MeasureTransition[1]
                            //create_metrology_model (MetrologyHandle1)
                            //set_metrology_model_image_size (MetrologyHandle1, Width, Height)
                            //add_metrology_object_circle_measure (MetrologyHandle1, RefBondRow, RefBondCol, RefBond0Paras[2], i_MeasureLen1, i_MeasureLen2, 1, i_MeasureThresh, ['measure_transition', 'measure_distance', 'min_score'], [MeasureTransition, 3, 0.6], NewIndex1)
                            //apply_metrology_model (inspectImageS, MetrologyHandle1)
                            //get_metrology_object_measures (Contours1, MetrologyHandle1, 'all', 'all', Row1, Column1)
                            //get_metrology_object_result (MetrologyHandle1, NewIndex1, 'all', 'result_type', 'all_param', _circles1)
                            //clear_metrology_model (MetrologyHandle1)

                            //if (|_circles1|#3)
                            //o_MeasureFlag := [o_MeasureFlag,1]
                            //Parameter := [-1,-1,-1]
                            //Contour := _InspectRegs
                            //else
                            //o_MeasureFlag := [o_MeasureFlag,0]
                            //Parameter := _circles1
                            //gen_circle (Contour, Parameter[0], Parameter[1], Parameter[2])
                            //endif
                            //else
                            //o_MeasureFlag := [o_MeasureFlag,0]
                            //Parameter := _circles
                            //gen_circle (Contour, Parameter[0], Parameter[1], Parameter[2])
                            //endif
                        }
                        else
                        {
                            hv_o_MeasureFlag = 0;
                            ho_Contour.Dispose();
                            HOperatorSet.GenCircle(out ho_Contour, hv_Parameter.TupleSelect(0), hv_Parameter.TupleSelect(
                                1), hv_Parameter.TupleSelect(2));
                        }
                        hv_o_MeasurePara = hv_Parameter.Clone();
                        ho_o_MeasureContour.Dispose();
                        ho_o_MeasureContour = ho_Contour.CopyObj(1, -1);
                        //
                        break;
                    case 4:
                        //椭圆
                        if ((int)((new HTuple(hv_AgainFlag.TupleEqual(1))).TupleAnd(new HTuple((new HTuple(hv_Parameter.TupleLength()
                            )).TupleLess(5)))) != 0)
                        {
                            //若9101再报错，再修改参数min_score循环创建模板测量，add_lw_20200928
                            HOperatorSet.CreateMetrologyModel(out hv_MetrologyHandle1);
                            HOperatorSet.AddMetrologyObjectEllipseMeasure(hv_MetrologyHandle1, hv__RefRow,
                                hv__RefCol, hv__RefPhi, hv__RefR1, hv__RefR2, hv_RefLen1, hv_RefLen2,
                                1, hv_RefThreshold, ((new HTuple("measure_transition")).TupleConcat(
                                "measure_distance")).TupleConcat("min_score"), ((hv_RefTransition.TupleConcat(
                                2 * hv_RefLen2))).TupleConcat(0.55), out hv_AgainIndex);

                            //get_metrology_object_measures (Contours1, MetrologyHandle1, 'all', 'all', Row1, Column1)
                            try
                            {
                                HOperatorSet.ApplyMetrologyModel(ho_inspectImage, hv_MetrologyHandle1);
                                HOperatorSet.GetMetrologyObjectResult(hv_MetrologyHandle1, hv_AgainIndex,
                                    "all", "result_type", "all_param", out hv_Parameter);
                            }
                            // catch (Exception1) 
                            catch (HalconException HDevExpDefaultException1)
                            {
                                HDevExpDefaultException1.ToHTuple(out hv_Exception1);
                                hv_Parameter = new HTuple();
                            }
                            HOperatorSet.ClearMetrologyModel(hv_MetrologyHandle1);
                        }
                        //
                        if ((int)(new HTuple((new HTuple(hv_Parameter.TupleLength())).TupleLess(5))) != 0)
                        {
                            hv_o_MeasureFlag = 1;
                            hv_Parameter = new HTuple();
                            hv_Parameter[0] = -1;
                            hv_Parameter[1] = -1;
                            hv_Parameter[2] = -1;
                            hv_Parameter[3] = -1;
                            hv_Parameter[4] = -1;
                            ho_Contour.Dispose();
                            ho_Contour = ho_EmptyReg.CopyObj(1, -1);
                        }
                        else
                        {
                            hv_o_MeasureFlag = 0;
                            ho_Contour.Dispose();
                            HOperatorSet.GenEllipse(out ho_Contour, hv_Parameter.TupleSelect(0), hv_Parameter.TupleSelect(
                                1), hv_Parameter.TupleSelect(2), hv_Parameter.TupleSelect(3), hv_Parameter.TupleSelect(
                                4));
                        }
                        hv_o_MeasurePara = hv_Parameter.Clone();
                        ho_o_MeasureContour.Dispose();
                        ho_o_MeasureContour = ho_Contour.CopyObj(1, -1);
                        //
                        break;
                }

                HOperatorSet.ClearMetrologyModel(hv_MetrologyHandle);
                //判断测量结果
                if ((int)(new HTuple(hv_o_MeasureFlag.TupleGreater(0))) != 0)
                {
                    hv_o_ErrCode = 1;
                    hv_o_ErrStr = " failed to one bond measure!";
                    ho_InspectRegUnion.Dispose();
                    ho_inspectImage.Dispose();
                    ho_EmptyReg.Dispose();
                    ho_Contour.Dispose();

                    return;
                }
                else
                {
                    hv_o_ErrCode = 0;
                    hv_o_ErrStr = "measure successful";
                    ho_InspectRegUnion.Dispose();
                    ho_inspectImage.Dispose();
                    ho_EmptyReg.Dispose();
                    ho_Contour.Dispose();

                    return;
                }


            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_InspectRegUnion.Dispose();
                ho_inspectImage.Dispose();
                ho_EmptyReg.Dispose();
                ho_Contour.Dispose();

                throw HDevExpDefaultException;
            }
        }

        #endregion


        #region 金线检测验证

        public static void HTV_affine_trans_bondreg(HObject ho_i_ModelStartRegs, HObject ho_i_ModelStopRegs,
            HObject ho_i_RealStartReg, HObject ho_i_RealStopReg, out HObject ho_o_LineStartRegs,
            out HObject ho_o_LineStopRegs, HTuple hv_i_HomMatMod2ImgStart, HTuple hv_i_HomMatMod2ImgStop,
            HTuple hv_i_IsUseStartReg, HTuple hv_i_IsUseStopReg, out HTuple hv_o_ErrCode,
            out HTuple hv_o_ErrStr)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho__LineStartRegs, ho__LineStopRegs;
            HObject ho_LineStartReg = null, ho_LineStopReg = null, ho_realStartReg = null;
            HObject ho_realStopReg = null;

            // Local control variables 

            HTuple hv_HomMatStartSum = null, hv_HomMatStopSum = null;
            HTuple hv_regNum = null, hv_regIdx = null, hv_StartRegArea = new HTuple();
            HTuple hv_Row = new HTuple(), hv_Column = new HTuple();
            HTuple hv_StopRegArea = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_LineStartRegs);
            HOperatorSet.GenEmptyObj(out ho_o_LineStopRegs);
            HOperatorSet.GenEmptyObj(out ho__LineStartRegs);
            HOperatorSet.GenEmptyObj(out ho__LineStopRegs);
            HOperatorSet.GenEmptyObj(out ho_LineStartReg);
            HOperatorSet.GenEmptyObj(out ho_LineStopReg);
            HOperatorSet.GenEmptyObj(out ho_realStartReg);
            HOperatorSet.GenEmptyObj(out ho_realStopReg);
            //***********************
            //确定检测金线的起始、结束点区域：1）真是焊点区域，or 2）模板中所画的虚拟焊点区域
            //i_ModelStartRegs:模板中画出的起始焊点区域
            //i_ModelStopRegs：模板中画出的结束焊点区域
            //i_RealStartRegs：实际得到的焊点起始区域
            //i_RealStopRegs：实际得到的焊点结束区域
            //o_LineStartRegs：输出的所确定的金线起始点区域
            //o_LineStopRegs：输出的所确定的金线结束点区域
            //i_HomMatMod2ImgStart：映射模板中画出的起始焊点区域的仿射变换矩阵
            //i_HomMatMod2ImgStop：映射模板中画出的结束焊点区域的仿射变换矩阵
            //i_IsUseStartReg:是否启用模板起始焊点区域
            //i_IsUseStopReg：是否启用模板结束焊点区域
            //o_ErrCode：错误码，代表该算子执行过程中产生的错误，0-代表执行正常，自然数-代表执行错误，-1-代表执行错误，-2-代表未执行
            //o_ErrStr：错误信息，对各种错误的具体描述
            //
            //************************
            //初始化
            ho_o_LineStartRegs.Dispose();
            HOperatorSet.GenEmptyObj(out ho_o_LineStartRegs);
            ho_o_LineStopRegs.Dispose();
            HOperatorSet.GenEmptyObj(out ho_o_LineStopRegs);
            //  初始化
            hv_o_ErrCode = -2;
            hv_o_ErrStr = "initializing";

            //传入映射矩阵有效性测试
            HOperatorSet.TupleSum(hv_i_HomMatMod2ImgStart, out hv_HomMatStartSum);
            HOperatorSet.TupleSum(hv_i_HomMatMod2ImgStop, out hv_HomMatStopSum);
            if ((int)((new HTuple(hv_HomMatStartSum.TupleEqual(-12))).TupleOr(new HTuple(hv_HomMatStopSum.TupleEqual(
                -12)))) != 0)
            {
                hv_o_ErrCode = 1;
                hv_o_ErrStr = "mapping matrix is invalid!";
                ho__LineStartRegs.Dispose();
                ho__LineStopRegs.Dispose();
                ho_LineStartReg.Dispose();
                ho_LineStopReg.Dispose();
                ho_realStartReg.Dispose();
                ho_realStopReg.Dispose();

                return;
            }

            //映射金线虚拟起始、结束焊点区域
            ho__LineStartRegs.Dispose();
            HOperatorSet.AffineTransRegion(ho_i_ModelStartRegs, out ho__LineStartRegs, hv_i_HomMatMod2ImgStart,
                "nearest_neighbor");
            ho__LineStopRegs.Dispose();
            HOperatorSet.AffineTransRegion(ho_i_ModelStopRegs, out ho__LineStopRegs, hv_i_HomMatMod2ImgStop,
                "nearest_neighbor");
            //
            //获取金线检测参考起始焊点区域
            HOperatorSet.CountObj(ho_i_ModelStartRegs, out hv_regNum);

            HTuple end_val39 = hv_regNum - 1;
            HTuple step_val39 = 1;
            for (hv_regIdx = 0; hv_regIdx.Continue(end_val39, step_val39); hv_regIdx = hv_regIdx.TupleAdd(step_val39))
            {
                //虚拟起始焊点
                ho_LineStartReg.Dispose();
                HOperatorSet.SelectObj(ho__LineStartRegs, out ho_LineStartReg, hv_regIdx + 1);
                //虚拟结束焊点
                ho_LineStopReg.Dispose();
                HOperatorSet.SelectObj(ho__LineStopRegs, out ho_LineStopReg, hv_regIdx + 1);
                //
                //***判断是否启用虚拟焊点
                //起始焊点区域
                if ((int)(hv_i_IsUseStartReg) != 0)
                {
                    //
                    ho_o_LineStartRegs.Dispose();
                    ho_o_LineStartRegs = ho__LineStartRegs.CopyObj(1, -1);
                }
                else
                {
                    //真实起始焊点
                    //ho_realStartReg.Dispose();
                    HOperatorSet.SelectObj(ho_i_RealStartReg, out ho_realStartReg, hv_regIdx + 1);
                    //********判断真实焊点是否存在：是-启用真实焊点，否-启用虚拟焊点
                    HOperatorSet.AreaCenter(ho_realStartReg, out hv_StartRegArea, out hv_Row,
                        out hv_Column);
                    if ((int)(new HTuple(hv_StartRegArea.TupleEqual(0))) != 0)
                    {
                        //启用虚拟焊点
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(ho_o_LineStartRegs, ho_LineStartReg, out ExpTmpOutVar_0
                                );
                            ho_o_LineStartRegs.Dispose();
                            ho_o_LineStartRegs = ExpTmpOutVar_0;
                        }
                    }
                    else
                    {
                        //启用真实焊点
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(ho_o_LineStartRegs, ho_realStartReg, out ExpTmpOutVar_0
                                );
                            ho_o_LineStartRegs.Dispose();
                            ho_o_LineStartRegs = ExpTmpOutVar_0;
                        }
                    }
                }
                //结束焊点区域
                if ((int)(hv_i_IsUseStopReg) != 0)
                {
                    ho_o_LineStopRegs.Dispose();
                    ho_o_LineStopRegs = ho__LineStopRegs.CopyObj(1, -1);
                }
                else
                {
                    //真实结束焊点
                    ho_realStopReg.Dispose();
                    HOperatorSet.SelectObj(ho_i_RealStopReg, out ho_realStopReg, hv_regIdx + 1);
                    //********判断真实焊点是否存在：是-启用真实焊点，否-启用虚拟焊点
                    HOperatorSet.AreaCenter(ho_realStopReg, out hv_StopRegArea, out hv_Row, out hv_Column);
                    if ((int)(new HTuple(hv_StopRegArea.TupleEqual(0))) != 0)
                    {
                        //启用虚拟焊点
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(ho_o_LineStopRegs, ho_LineStopReg, out ExpTmpOutVar_0
                                );
                            ho_o_LineStopRegs.Dispose();
                            ho_o_LineStopRegs = ExpTmpOutVar_0;
                        }
                    }
                    else
                    {
                        //启用真实焊点
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(ho_o_LineStopRegs, ho_realStopReg, out ExpTmpOutVar_0
                                );
                            ho_o_LineStopRegs.Dispose();
                            ho_o_LineStopRegs = ExpTmpOutVar_0;
                        }
                    }
                }
            }
            //
            hv_o_ErrCode = 0;
            hv_o_ErrStr = "confirm bondRegs successful!";
            ho__LineStartRegs.Dispose();
            ho__LineStopRegs.Dispose();
            ho_LineStartReg.Dispose();
            ho_LineStopReg.Dispose();
            ho_realStartReg.Dispose();
            ho_realStopReg.Dispose();

            return;
        }

        public static void HTV_Wire_Inspect_MVP(HObject ho_i_Imgs, HObject ho_i_StartRegs, HObject ho_i_StopRegs,
            HObject ho_i_RefStartRegs, HObject ho_i_RefStopRegs, HObject ho_i_WireRegs,
            out HObject ho_o_Wires, out HObjectVector/*{eObjectVector,Dim=1}*/ hvec_o_FailRegs,
            HTuple hv_i_InspectRegNum, HTupleVector/*{eTupleVector,Dim=2}*/ hvec_i_WireInspect_Paras,
            HTupleVector/*{eTupleVector,Dim=3}*/ hvec_i_DefectValue, out HTupleVector/*{eTupleVector,Dim=1}*/ hvec_o_DefectType,
            out HTupleVector/*{eTupleVector,Dim=1}*/ hvec_o_DefectImgIdx, out HTupleVector/*{eTupleVector,Dim=3}*/ hvec_o_DefectValue,
            out HTupleVector/*{eTupleVector,Dim=3}*/ hvec_o_RefValue, out HTuple hv_o_ErrCode,
            out HTuple hv_o_ErrStr)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_EmptyObj, ho_StartReg = null, ho_StopReg = null;
            HObject ho_RefStartReg = null, ho_RefStopReg = null, ho__Wires = null;
            HObject ho_WireInspectReg = null, ho__WireReg = null, ho__InspectReg = null;
            HObject ho__RefEdges = null, ho_i_Image = null, ho__WireSeg = null;
            HObject ho_StartLineReg = null, ho_StartContours = null, ho__WireLines = null;
            HObject ho_StopLineReg = null, ho_StopContours = null, ho_UnionContour = null;
            HObject ho__Wire = null, ho_WireDilateReg = null, ho_RegionUnion = null;

            // Local control variables 

            HTuple hv_inspectRegidx = null, hv_WireNum = null;
            HTuple hv_RegSum = null, hv_idxReg = null, hv__HomMat2D = new HTuple();
            HTuple hv__RefDirection = new HTuple(), hv_WireFlag = new HTuple();
            HTuple hv__RefEndRow = new HTuple(), hv__RefEndCol = new HTuple();
            HTuple hv_regNum = new HTuple(), hv_Regidx = new HTuple();
            HTuple hv__RegStartRow = new HTuple(), hv__RegStartCol = new HTuple();
            HTuple hv__regPhi = new HTuple(), hv__RegEndRow = new HTuple();
            HTuple hv__RegEndCol = new HTuple(), hv_WireInspectMethod = new HTuple();
            HTuple hv__ImgIdx = new HTuple(), hv__ThreshGray = new HTuple();
            HTuple hv__LightOrDark = new HTuple(), hv__ClosingSize = new HTuple();
            HTuple hv__WireWideth = new HTuple(), hv__WireLenth = new HTuple();
            HTuple hv__WireArea = new HTuple(), hv__DistTh = new HTuple();
            HTuple hv__StartDistTh = new HTuple(), hv__StopDistTh = new HTuple();
            HTuple hv__ErrCode = new HTuple(), hv__ErrStr = new HTuple();
            HTuple hv__WireWidth = new HTuple(), hv__WireContrast = new HTuple();
            HTuple hv__Transition = new HTuple(), hv__SelMetric = new HTuple();
            HTuple hv__SelMin = new HTuple(), hv__SelMax = new HTuple();
            HTuple hv__LinePhiDiff = new HTuple(), hv__MaxWireGap = new HTuple();
            HTuple hv__DoubleLinesFlag = new HTuple(), hv__DoubleLinesType = new HTuple();
            HTuple hv__MidLineWidth = new HTuple(), hv_FlagSum = new HTuple();
            HTuple hv_StartRow = new HTuple(), hv_StartColumn = new HTuple();
            HTuple hv_StopRow = new HTuple(), hv_StopColumn = new HTuple();
            HTuple hv_StartRadius = new HTuple(), hv_StopRadius = new HTuple();
            HTuple hv_Length = new HTuple(), hv_Pt1Row = new HTuple();
            HTuple hv_Pt1Col = new HTuple(), hv_Pt2Row = new HTuple();
            HTuple hv_Pt2Col = new HTuple(), hv_ContErrCode = new HTuple();
            HTuple hv_ContErrStr = new HTuple(), hv_RowBegin = new HTuple();
            HTuple hv_ColBegin = new HTuple(), hv_RowEnd = new HTuple();
            HTuple hv_ColEnd = new HTuple(), hv_Nr = new HTuple();
            HTuple hv_Nc = new HTuple(), hv_Dist = new HTuple(), hv_LineNum = new HTuple();
            HTuple hv_Dist0 = new HTuple(), hv_Dist1 = new HTuple();
            HTuple hv_TypeTup = null, hv_i = null, hv_TypeTmp = new HTuple();
            HTuple hv_TypeSum = null;

            HTupleVector hvec_WireRegPara = new HTupleVector(1);
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_Wires);
            HOperatorSet.GenEmptyObj(out ho_EmptyObj);
            HOperatorSet.GenEmptyObj(out ho_StartReg);
            HOperatorSet.GenEmptyObj(out ho_StopReg);
            HOperatorSet.GenEmptyObj(out ho_RefStartReg);
            HOperatorSet.GenEmptyObj(out ho_RefStopReg);
            HOperatorSet.GenEmptyObj(out ho__Wires);
            HOperatorSet.GenEmptyObj(out ho_WireInspectReg);
            HOperatorSet.GenEmptyObj(out ho__WireReg);
            HOperatorSet.GenEmptyObj(out ho__InspectReg);
            HOperatorSet.GenEmptyObj(out ho__RefEdges);
            HOperatorSet.GenEmptyObj(out ho_i_Image);
            HOperatorSet.GenEmptyObj(out ho__WireSeg);
            HOperatorSet.GenEmptyObj(out ho_StartLineReg);
            HOperatorSet.GenEmptyObj(out ho_StartContours);
            HOperatorSet.GenEmptyObj(out ho__WireLines);
            HOperatorSet.GenEmptyObj(out ho_StopLineReg);
            HOperatorSet.GenEmptyObj(out ho_StopContours);
            HOperatorSet.GenEmptyObj(out ho_UnionContour);
            HOperatorSet.GenEmptyObj(out ho__Wire);
            HOperatorSet.GenEmptyObj(out ho_WireDilateReg);
            HOperatorSet.GenEmptyObj(out ho_RegionUnion);
            hvec_o_FailRegs = new HObjectVector(1);
            try
            {
                //**************************************************************************************************
                //---函数：HTV_Wire_Inspect_MVP
                //---作用：多金线检测区域、多检测方法进行金线检测
                //---参数：
                //===图标参数
                //  i_Image: 输入图像，待处理图像
                //  i_StartRegs：金线实际起始焊点区域
                //  i_StopRegs：金线实际结束焊点区域
                //  i_RefStartRegs：金线参考起始焊点区域
                //  i_RefStopRegs：金线参考结束焊点区域
                //  i_WireRegs：金线检测区
                //  o_Wires：检出的金线区
                //  o_FailRegs：检测失败的区域
                //===控制参数
                //  i_InspectRegNum：金线检测区域数目
                //  i_IsTailInspect：是否检测尾丝
                //  i_WireInspect_Paras：金线检测参数
                //  o_DefectType：异常区域的缺陷类型
                //  o_ErrCode：错误码
                //  o_ErrStr：错误信息
                //**************************************************************************************************

                //初始化
                ho_o_Wires.Dispose();
                HOperatorSet.GenEmptyObj(out ho_o_Wires);
                ho_EmptyObj.Dispose();
                HOperatorSet.GenEmptyObj(out ho_EmptyObj);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hvec_o_FailRegs = dh.Take((
                        dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho_EmptyObj)))));
                }
                //
                hvec_o_DefectType = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())));
                hvec_o_DefectImgIdx = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())));
                hvec_o_DefectValue = hvec_i_DefectValue.Clone();
                hvec_o_RefValue = hvec_i_DefectValue.Clone();
                //
                hv_o_ErrCode = -2;
                hv_o_ErrStr = "Initializing";
                //
                //----------------------------------------------------------------------------------
                hv_inspectRegidx = 0;
                //金线数量
                HOperatorSet.CountObj(ho_i_StartRegs, out hv_WireNum);
                //检测区域数量
                HOperatorSet.TupleSum(hv_i_InspectRegNum, out hv_RegSum);
                HTuple end_val41 = hv_WireNum;
                HTuple step_val41 = 1;
                for (hv_idxReg = 1; hv_idxReg.Continue(end_val41, step_val41); hv_idxReg = hv_idxReg.TupleAdd(step_val41))
                {
                    //*******获取检测区域仿射变换矩阵
                    //实际焊点区域
                    ho_StartReg.Dispose();
                    HOperatorSet.SelectObj(ho_i_StartRegs, out ho_StartReg, hv_idxReg);
                    ho_StopReg.Dispose();
                    HOperatorSet.SelectObj(ho_i_StopRegs, out ho_StopReg, hv_idxReg);
                    //参考模板焊点区域
                    ho_RefStartReg.Dispose();
                    HOperatorSet.SelectObj(ho_i_RefStartRegs, out ho_RefStartReg, hv_idxReg);
                    ho_RefStopReg.Dispose();
                    HOperatorSet.SelectObj(ho_i_RefStopRegs, out ho_RefStopReg, hv_idxReg);
                    //
                    affine_transformation_matrix(ho_StartReg, ho_StopReg, ho_RefStartReg, ho_RefStopReg,
                        out hv__HomMat2D, out hv__RefDirection);
                    //
                    //分区域检测焊线
                    ho__Wires.Dispose();
                    HOperatorSet.GenEmptyObj(out ho__Wires);
                    ho_WireInspectReg.Dispose();
                    HOperatorSet.GenEmptyObj(out ho_WireInspectReg);
                    hv_WireFlag = new HTuple();
                    //
                    hv__RefEndRow = new HTuple();
                    hv__RefEndCol = new HTuple();
                    //
                    //选取金线检测区域数量
                    hv_regNum = hv_i_InspectRegNum.TupleSelect(hv_idxReg - 1);
                    //
                    HTuple end_val63 = hv_regNum;
                    HTuple step_val63 = 1;
                    for (hv_Regidx = 1; hv_Regidx.Continue(end_val63, step_val63); hv_Regidx = hv_Regidx.TupleAdd(step_val63))
                    {
                        //检测区域选取
                        ho__WireReg.Dispose();
                        HOperatorSet.SelectObj(ho_i_WireRegs, out ho__WireReg, hv_inspectRegidx + hv_Regidx);
                        ho__InspectReg.Dispose();
                        HOperatorSet.AffineTransRegion(ho__WireReg, out ho__InspectReg, hv__HomMat2D,
                            "nearest_neighbor");
                        //线检测区域集合
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(ho_WireInspectReg, ho__InspectReg, out ExpTmpOutVar_0
                                );
                            ho_WireInspectReg.Dispose();
                            ho_WireInspectReg = ExpTmpOutVar_0;
                        }
                        //
                        //获取金线检测区域参考端点/获取检测区域角度方向
                        //****************************************************************************
                        //WJ 20-20-07-06
                        ho__RefEdges.Dispose();
                        obtain_reference_point_direction(ho__InspectReg, ho_StartReg, out ho__RefEdges,
                            hv_Regidx, hv__RefEndRow, hv__RefEndCol, out hv__RefEndRow, out hv__RefEndCol,
                            out hv__RegStartRow, out hv__RegStartCol, out hv__regPhi);
                        //区域末端点
                        hv__RegEndRow = hv__RefEndRow.TupleSelect(hv_Regidx - 1);
                        hv__RegEndCol = hv__RefEndCol.TupleSelect(hv_Regidx - 1);
                        //

                        //********************************************************************************
                        //检测参数枚举
                        hvec_WireRegPara = hvec_i_WireInspect_Paras[(hv_inspectRegidx + hv_Regidx) - 1];
                        hv_WireInspectMethod = hvec_WireRegPara[0].T.Clone();
                        //0-threshold, 1-line_guass_sort, 2-line_guass_pro
                        if ((int)(new HTuple(hv_WireInspectMethod.TupleEqual(0))) != 0)
                        {
                            //获取金线区域检测图层
                            hv__ImgIdx = hvec_WireRegPara[1].T.Clone();
                            ho_i_Image.Dispose();
                            HOperatorSet.SelectObj(ho_i_Imgs, out ho_i_Image, hv__ImgIdx);
                            //threshold线提取、检测参数
                            hv__ThreshGray = hvec_WireRegPara[2].T.Clone();
                            //目标提取特点：'light','dark'
                            hv__LightOrDark = hvec_WireRegPara[3].T.Clone();
                            //金线检测判断参数
                            hv__ClosingSize = hvec_WireRegPara[4].T.Clone();
                            hv__WireWideth = hvec_WireRegPara[5].T.Clone();
                            hv__WireLenth = hvec_WireRegPara[6].T.Clone();
                            hv__WireArea = hvec_WireRegPara[7].T.Clone();
                            hv__DistTh = hvec_WireRegPara[8].T.Clone();
                            if ((int)(new HTuple(hv__DistTh.TupleEqual(0))) != 0)
                            {
                                hv__DistTh = 9999;
                            }
                            //离起止焊点最近的检测框作为当前参数
                            if ((int)(new HTuple(hv_Regidx.TupleEqual(1))) != 0)
                            {
                                hv__StartDistTh = hv__DistTh.Clone();
                            }
                            if ((int)(new HTuple(hv_Regidx.TupleEqual(hv_regNum))) != 0)
                            {
                                hv__StopDistTh = hv__DistTh.Clone();
                            }
                            //
                            //参考设置值
                            hvec_o_RefValue[hv_idxReg - 1][0] = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(hv__WireLenth.TupleSelect(
                                0)))));
                            //
                            //区域内金线检测
                            ho__WireSeg.Dispose();
                            HTV_WireSeg_Inspect_threshold(ho_i_Image, ho__InspectReg, out ho__WireSeg,
                                hv__ThreshGray, hv__LightOrDark, hv__ClosingSize, hv__WireLenth,
                                hv__WireWideth, hv__WireArea, out hv__ErrCode, out hv__ErrStr);
                        }
                        else if ((int)(new HTuple(hv_WireInspectMethod.TupleEqual(1))) != 0)
                        {
                            //line_gauss线提取、检测参数
                            //获取金线区域检测图层
                            hv__ImgIdx = hvec_WireRegPara[1].T.Clone();
                            ho_i_Image.Dispose();
                            HOperatorSet.SelectObj(ho_i_Imgs, out ho_i_Image, hv__ImgIdx);
                            //
                            hv__WireWidth = hvec_WireRegPara[2].T.Clone();
                            hv__WireContrast = hvec_WireRegPara[3].T.Clone();
                            hv__Transition = hvec_WireRegPara[4].T.Clone();
                            //金线检测判断参数
                            hv__SelMetric = hvec_WireRegPara[5].T.Clone();
                            hv__SelMin = hvec_WireRegPara[6].T.Clone();
                            hv__SelMax = hvec_WireRegPara[7].T.Clone();
                            hv__LinePhiDiff = hvec_WireRegPara[8].T.Clone();
                            hv__MaxWireGap = hvec_WireRegPara[9].T.Clone();
                            hv__DistTh = hvec_WireRegPara[10].T.Clone();
                            if ((int)(new HTuple(hv__DistTh.TupleEqual(0))) != 0)
                            {
                                hv__DistTh = 9999;
                            }
                            //离起止焊点最近的检测框作为当前参数
                            if ((int)(new HTuple(hv_Regidx.TupleEqual(1))) != 0)
                            {
                                hv__StartDistTh = hv__DistTh.Clone();
                            }
                            if ((int)(new HTuple(hv_Regidx.TupleEqual(hv_regNum))) != 0)
                            {
                                hv__StopDistTh = hv__DistTh.Clone();
                            }
                            //
                            //参考设置值
                            hvec_o_RefValue[hv_idxReg - 1][0] = (new HTupleVector(1).Insert(0, new HTupleVector(hv__MaxWireGap)));
                            //
                            //区域内金线检测
                            ho__WireSeg.Dispose();
                            HTV_WireSeg_Inspect_guass_sort(ho_i_Image, ho__InspectReg, ho_StartReg,
                                ho__RefEdges, out ho__WireSeg, hv__regPhi, hv__WireWidth, hv__WireContrast,
                                hv__Transition, hv__SelMetric, hv__SelMax, hv__SelMin, hv__RegStartRow,
                                hv__RegStartCol, hv__MaxWireGap, hv__RegEndRow, hv__RegEndCol, hv__LinePhiDiff,
                                out hv__ErrCode, out hv__ErrStr);
                        }
                        else if ((int)(new HTuple(hv_WireInspectMethod.TupleEqual(2))) != 0)
                        {
                            //line_gauss线提取、检测参数
                            //获取金线区域检测图层
                            hv__ImgIdx = hvec_WireRegPara[1].T.Clone();
                            ho_i_Image.Dispose();
                            HOperatorSet.SelectObj(ho_i_Imgs, out ho_i_Image, hv__ImgIdx);
                            //
                            hv__WireWidth = hvec_WireRegPara[2].T.Clone();
                            hv__WireContrast = hvec_WireRegPara[3].T.Clone();
                            hv__Transition = hvec_WireRegPara[4].T.Clone();
                            //金线检测判断参数
                            hv__SelMetric = hvec_WireRegPara[5].T.Clone();
                            hv__SelMin = hvec_WireRegPara[6].T.Clone();
                            hv__SelMax = hvec_WireRegPara[7].T.Clone();
                            hv__LinePhiDiff = hvec_WireRegPara[8].T.Clone();
                            hv__MaxWireGap = hvec_WireRegPara[9].T.Clone();
                            //双线预处理 add_lw 1120
                            hv__DoubleLinesFlag = hvec_WireRegPara[10].T.Clone();
                            hv__DoubleLinesType = hvec_WireRegPara[11].T.Clone();
                            hv__MidLineWidth = hvec_WireRegPara[12].T.Clone();
                            //焊点至金线距离阈值
                            hv__DistTh = hvec_WireRegPara[13].T.Clone();
                            if ((int)(new HTuple(hv__DistTh.TupleEqual(0))) != 0)
                            {
                                hv__DistTh = 9999;
                            }
                            //离起止焊点最近的检测框作为当前参数
                            if ((int)(new HTuple(hv_Regidx.TupleEqual(1))) != 0)
                            {
                                hv__StartDistTh = hv__DistTh.Clone();
                            }
                            if ((int)(new HTuple(hv_Regidx.TupleEqual(hv_regNum))) != 0)
                            {
                                hv__StopDistTh = hv__DistTh.Clone();
                            }
                            //
                            //参考设置值
                            hvec_o_RefValue[hv_idxReg - 1][0] = (new HTupleVector(1).Insert(0, new HTupleVector(hv__MaxWireGap)));
                            //
                            //区域内金线检测
                            ho__WireSeg.Dispose();
                            HTV_WireSeg_Inspect_guass_pro(ho_i_Image, ho__InspectReg, ho_StartReg,
                                ho__RefEdges, out ho__WireSeg, hv__regPhi, hv__WireWidth, hv__WireContrast,
                                hv__Transition, hv__SelMetric, hv__SelMax, hv__SelMin, hv__LinePhiDiff,
                                hv__MaxWireGap, hv__DoubleLinesFlag, hv__DoubleLinesType, hv__MidLineWidth,
                                hv__RegStartRow, hv__RegStartCol, hv__RegEndRow, hv__RegEndCol, out hv__ErrCode,
                                out hv__ErrStr);

                        }
                        else
                        {
                            //参数异常
                            hv_o_ErrCode = -1;
                            hv_o_ErrStr = "Parameter: WireInspectMethod is Error";
                            ho_EmptyObj.Dispose();
                            ho_StartReg.Dispose();
                            ho_StopReg.Dispose();
                            ho_RefStartReg.Dispose();
                            ho_RefStopReg.Dispose();
                            ho__Wires.Dispose();
                            ho_WireInspectReg.Dispose();
                            ho__WireReg.Dispose();
                            ho__InspectReg.Dispose();
                            ho__RefEdges.Dispose();
                            ho_i_Image.Dispose();
                            ho__WireSeg.Dispose();
                            ho_StartLineReg.Dispose();
                            ho_StartContours.Dispose();
                            ho__WireLines.Dispose();
                            ho_StopLineReg.Dispose();
                            ho_StopContours.Dispose();
                            ho_UnionContour.Dispose();
                            ho__Wire.Dispose();
                            ho_WireDilateReg.Dispose();
                            ho_RegionUnion.Dispose();

                            return;
                        }
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(ho__Wires, ho__WireSeg, out ExpTmpOutVar_0);
                            ho__Wires.Dispose();
                            ho__Wires = ExpTmpOutVar_0;
                        }
                        hv_WireFlag = hv_WireFlag.TupleConcat(hv__ErrCode);
                    }
                    //
                    //结果整合
                    HOperatorSet.TupleSum(hv_WireFlag, out hv_FlagSum);
                    if ((int)(new HTuple(hv_FlagSum.TupleEqual(0))) != 0)
                    {
                        //连接免检区
                        //area_center (StartReg, Area1, StartRow, StartColumn)
                        //area_center (StopReg, Area2, StopRow, StopColumn)
                        HOperatorSet.SmallestCircle(ho_StartReg, out hv_StartRow, out hv_StartColumn,
                            out hv_StartRadius);
                        HOperatorSet.SmallestCircle(ho_StopReg, out hv_StopRow, out hv_StopColumn,
                            out hv_StopRadius);
                        HOperatorSet.AngleLx(hv_StartRow, hv_StartColumn, hv_StopRow, hv_StopColumn,
                            out hv__RefDirection);
                        //起始参考线
                        hv_Length = hv_StartRadius + 1;
                        hv_Pt1Row = hv_StartRow - (hv_Length * (hv__RefDirection.TupleSin()));
                        hv_Pt1Col = hv_StartColumn + (hv_Length * (hv__RefDirection.TupleCos()));
                        hv_Length = hv_StartRadius - 1;
                        hv_Pt2Row = hv_StartRow - (hv_Length * (hv__RefDirection.TupleSin()));
                        hv_Pt2Col = hv_StartColumn + (hv_Length * (hv__RefDirection.TupleCos()));
                        ho_StartLineReg.Dispose();
                        HOperatorSet.GenRegionLine(out ho_StartLineReg, hv_Pt2Row, hv_Pt2Col, hv_Pt1Row,
                            hv_Pt1Col);
                        ho_StartContours.Dispose();
                        HOperatorSet.GenContoursSkeletonXld(ho_StartLineReg, out ho_StartContours,
                            1, "filter");
                        ho__WireLines.Dispose();
                        HOperatorSet.ConcatObj(ho__Wires, ho_StartContours, out ho__WireLines);
                        //结束参考线
                        hv_Length = hv_StopRadius + 1;
                        hv_Pt1Row = hv_StopRow - (hv_Length * (((hv__RefDirection + ((new HTuple(180)).TupleRad()
                            ))).TupleSin()));
                        hv_Pt1Col = hv_StopColumn + (hv_Length * (((hv__RefDirection + ((new HTuple(180)).TupleRad()
                            ))).TupleCos()));
                        hv_Length = hv_StopRadius - 1;
                        hv_Pt2Row = hv_StopRow - (hv_Length * (((hv__RefDirection + ((new HTuple(180)).TupleRad()
                            ))).TupleSin()));
                        hv_Pt2Col = hv_StopColumn + (hv_Length * (((hv__RefDirection + ((new HTuple(180)).TupleRad()
                            ))).TupleCos()));
                        ho_StopLineReg.Dispose();
                        HOperatorSet.GenRegionLine(out ho_StopLineReg, hv_Pt1Row, hv_Pt1Col, hv_Pt2Row,
                            hv_Pt2Col);
                        ho_StopContours.Dispose();
                        HOperatorSet.GenContoursSkeletonXld(ho_StopLineReg, out ho_StopContours,
                            1, "filter");
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(ho__WireLines, ho_StopContours, out ExpTmpOutVar_0
                                );
                            ho__WireLines.Dispose();
                            ho__WireLines = ExpTmpOutVar_0;
                        }

                        if ((int)((new HTuple(hv__StartDistTh.TupleEqual(9999))).TupleAnd(new HTuple(hv__StopDistTh.TupleEqual(
                            9999)))) != 0)
                        {
                            //最大条件连线
                            ho_UnionContour.Dispose();
                            HOperatorSet.UnionAdjacentContoursXld(ho__WireLines, out ho_UnionContour,
                                999, 999, "attr_keep");
                            ho__Wire.Dispose();
                            HOperatorSet.SmoothContoursXld(ho_UnionContour, out ho__Wire, 51);
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.ConcatObj(ho_o_Wires, ho__Wire, out ExpTmpOutVar_0);
                                ho_o_Wires.Dispose();
                                ho_o_Wires = ExpTmpOutVar_0;
                            }

                            //一根金线一个检测ID，断线距离值写死
                            hvec_o_DefectType[hv_idxReg - 1] = new HTupleVector(new HTuple(0));
                            hvec_o_DefectImgIdx[hv_idxReg - 1] = new HTupleVector(hv__ImgIdx).Clone();
                            hvec_o_DefectValue[hv_idxReg - 1][0] = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(10))));
                            //检测正常输出ResultReg
                            ho_WireDilateReg.Dispose();
                            HTV_contours_to_region(ho__Wire, out ho_WireDilateReg, 1, out hv_ContErrCode,
                                out hv_ContErrStr);
                            hvec_o_FailRegs[hv_idxReg - 1] = new HObjectVector(ho_WireDilateReg.CopyObj(1, -1));
                        }
                        else
                        {
                            //增加焊点周围金线异常判断
                            //1- 焊点至金线直线距离过大，认为异常
                            HOperatorSet.FitLineContourXld(ho__Wires, "huber", -1, 0, 5, 2, out hv_RowBegin,
                                out hv_ColBegin, out hv_RowEnd, out hv_ColEnd, out hv_Nr, out hv_Nc,
                                out hv_Dist);
                            HOperatorSet.CountObj(ho__Wires, out hv_LineNum);
                            //起始焊点
                            HOperatorSet.DistancePl(hv_StartRow, hv_StartColumn, hv_RowBegin.TupleSelect(
                                0), hv_ColBegin.TupleSelect(0), hv_RowEnd.TupleSelect(0), hv_ColEnd.TupleSelect(
                                0), out hv_Dist0);
                            //结束焊点
                            HOperatorSet.DistancePl(hv_StopRow, hv_StopColumn, hv_RowBegin.TupleSelect(
                                hv_LineNum - 1), hv_ColBegin.TupleSelect(hv_LineNum - 1), hv_RowEnd.TupleSelect(
                                hv_LineNum - 1), hv_ColEnd.TupleSelect(hv_LineNum - 1), out hv_Dist1);

                            if ((int)((new HTuple(hv_Dist0.TupleGreater(hv__StartDistTh))).TupleOr(
                                new HTuple(hv_Dist1.TupleGreater(hv__StopDistTh)))) != 0)
                            {
                                //引线检测有缺陷
                                {
                                    HObject ExpTmpOutVar_0;
                                    HOperatorSet.ConcatObj(ho_o_Wires, ho__Wires, out ExpTmpOutVar_0);
                                    ho_o_Wires.Dispose();
                                    ho_o_Wires = ExpTmpOutVar_0;
                                }
                                hvec_o_DefectType[hv_idxReg - 1] = new HTupleVector(new HTuple(12));
                                hvec_o_DefectImgIdx[hv_idxReg - 1] = new HTupleVector(hv__ImgIdx).Clone();
                                hvec_o_DefectValue[hv_idxReg - 1][0] = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(-1))));
                                ho_RegionUnion.Dispose();
                                HOperatorSet.Union1(ho_WireInspectReg, out ho_RegionUnion);
                                hvec_o_FailRegs[hv_idxReg - 1] = new HObjectVector(ho_RegionUnion.CopyObj(1, -1));
                            }
                            else
                            {
                                //最大条件连线
                                ho_UnionContour.Dispose();
                                HOperatorSet.UnionAdjacentContoursXld(ho__WireLines, out ho_UnionContour,
                                    999, 999, "attr_keep");
                                ho__Wire.Dispose();
                                HOperatorSet.SmoothContoursXld(ho_UnionContour, out ho__Wire, 51);
                                {
                                    HObject ExpTmpOutVar_0;
                                    HOperatorSet.ConcatObj(ho_o_Wires, ho__Wire, out ExpTmpOutVar_0);
                                    ho_o_Wires.Dispose();
                                    ho_o_Wires = ExpTmpOutVar_0;
                                }

                                //一根金线一个检测ID，断线距离值写死
                                hvec_o_DefectType[hv_idxReg - 1] = new HTupleVector(new HTuple(0));
                                hvec_o_DefectImgIdx[hv_idxReg - 1] = new HTupleVector(hv__ImgIdx).Clone();
                                hvec_o_DefectValue[hv_idxReg - 1][0] = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(10))));
                                //检测正常输出ResultReg
                                ho_WireDilateReg.Dispose();
                                HTV_contours_to_region(ho__Wire, out ho_WireDilateReg, 1, out hv_ContErrCode,
                                    out hv_ContErrStr);
                                hvec_o_FailRegs[hv_idxReg - 1] = new HObjectVector(ho_WireDilateReg.CopyObj(1, -1));
                            }
                        }
                        //
                    }
                    else
                    {
                        //引线检测有缺陷
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(ho_o_Wires, ho__Wires, out ExpTmpOutVar_0);
                            ho_o_Wires.Dispose();
                            ho_o_Wires = ExpTmpOutVar_0;
                        }
                        hvec_o_DefectType[hv_idxReg - 1] = new HTupleVector(new HTuple(12));
                        hvec_o_DefectImgIdx[hv_idxReg - 1] = new HTupleVector(hv__ImgIdx).Clone();
                        hvec_o_DefectValue[hv_idxReg - 1][0] = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(-1))));
                        ho_RegionUnion.Dispose();
                        HOperatorSet.Union1(ho_WireInspectReg, out ho_RegionUnion);
                        hvec_o_FailRegs[hv_idxReg - 1] = new HObjectVector(ho_RegionUnion.CopyObj(1, -1));
                    }
                    //
                    hv_inspectRegidx = hv_inspectRegidx + hv_regNum;
                }

                //
                hv_TypeTup = new HTuple();
                HTuple end_val286 = new HTuple(hvec_o_DefectType.Length) - 1;
                HTuple step_val286 = 1;
                for (hv_i = 0; hv_i.Continue(end_val286, step_val286); hv_i = hv_i.TupleAdd(step_val286))
                {
                    hv_TypeTmp = hvec_o_DefectType[hv_i].T.Clone();
                    hv_TypeTup = hv_TypeTup.TupleConcat(hv_TypeTmp);
                }
                HOperatorSet.TupleSum(hv_TypeTup, out hv_TypeSum);
                if ((int)(new HTuple(hv_TypeSum.TupleEqual(0))) != 0)
                {
                    hv_o_ErrCode = 0;
                    hv_o_ErrStr = "Wire is OK";
                    ho_EmptyObj.Dispose();
                    ho_StartReg.Dispose();
                    ho_StopReg.Dispose();
                    ho_RefStartReg.Dispose();
                    ho_RefStopReg.Dispose();
                    ho__Wires.Dispose();
                    ho_WireInspectReg.Dispose();
                    ho__WireReg.Dispose();
                    ho__InspectReg.Dispose();
                    ho__RefEdges.Dispose();
                    ho_i_Image.Dispose();
                    ho__WireSeg.Dispose();
                    ho_StartLineReg.Dispose();
                    ho_StartContours.Dispose();
                    ho__WireLines.Dispose();
                    ho_StopLineReg.Dispose();
                    ho_StopContours.Dispose();
                    ho_UnionContour.Dispose();
                    ho__Wire.Dispose();
                    ho_WireDilateReg.Dispose();
                    ho_RegionUnion.Dispose();

                    return;
                }
                else
                {
                    hv_o_ErrCode = 1;
                    hv_o_ErrStr = "Wire has defect";
                    ho_EmptyObj.Dispose();
                    ho_StartReg.Dispose();
                    ho_StopReg.Dispose();
                    ho_RefStartReg.Dispose();
                    ho_RefStopReg.Dispose();
                    ho__Wires.Dispose();
                    ho_WireInspectReg.Dispose();
                    ho__WireReg.Dispose();
                    ho__InspectReg.Dispose();
                    ho__RefEdges.Dispose();
                    ho_i_Image.Dispose();
                    ho__WireSeg.Dispose();
                    ho_StartLineReg.Dispose();
                    ho_StartContours.Dispose();
                    ho__WireLines.Dispose();
                    ho_StopLineReg.Dispose();
                    ho_StopContours.Dispose();
                    ho_UnionContour.Dispose();
                    ho__Wire.Dispose();
                    ho_WireDilateReg.Dispose();
                    ho_RegionUnion.Dispose();

                    return;
                }
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_EmptyObj.Dispose();
                ho_StartReg.Dispose();
                ho_StopReg.Dispose();
                ho_RefStartReg.Dispose();
                ho_RefStopReg.Dispose();
                ho__Wires.Dispose();
                ho_WireInspectReg.Dispose();
                ho__WireReg.Dispose();
                ho__InspectReg.Dispose();
                ho__RefEdges.Dispose();
                ho_i_Image.Dispose();
                ho__WireSeg.Dispose();
                ho_StartLineReg.Dispose();
                ho_StartContours.Dispose();
                ho__WireLines.Dispose();
                ho_StopLineReg.Dispose();
                ho_StopContours.Dispose();
                ho_UnionContour.Dispose();
                ho__Wire.Dispose();
                ho_WireDilateReg.Dispose();
                ho_RegionUnion.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public static void obtain_reference_point_direction(HObject ho_i_InspectReg, HObject ho_i_StartReg,
            out HObject ho_o_RefEdges, HTuple hv_i_Regidx, HTuple hv_i_RefEndRow, HTuple hv_i_RefEndCol,
            out HTuple hv_o_RefEndRow, out HTuple hv_o_RefEndCol, out HTuple hv_o_RegStartRow,
            out HTuple hv_o_RegStartCol, out HTuple hv_o_RegPhi)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_Rectangle, ho_RegionLines, ho_RegionLines1;
            HObject ho_RegionLines2, ho_RegionLines3, ho_RegionLines4;
            HObject ho_ObjectSelected = null, ho_Skeleton = null, ho_Contours = null;
            HObject ho__StartEdge = null, ho_Contours1 = null, ho__EndEdge = null;

            // Local control variables 

            HTuple hv_RowReg = null, hv_ColReg = null;
            HTuple hv__regPhi = null, hv__regLenHalf = null, hv__regWidthHalf = null;
            HTuple hv_Area1 = new HTuple(), hv_StartRegRow = new HTuple();
            HTuple hv_StartRegCol = new HTuple(), hv__RegRefDirection = null;
            HTuple hv_angleDiff1 = null, hv_angleDiff2 = null, hv_regPhi = new HTuple();
            HTuple hv_regLenHalf = new HTuple(), hv_regWidthHalf = new HTuple();
            HTuple hv__regStartRow = null, hv__regStartCol = null;
            HTuple hv__regEndRow = null, hv__regEndCol = null, hv_Area = null;
            HTuple hv__RefRow = null, hv__RefCol = null, hv_RefDistance1 = null;
            HTuple hv_RefDistance2 = null, hv_regStartRow = new HTuple();
            HTuple hv_regStartCol = new HTuple(), hv_regEndRow = new HTuple();
            HTuple hv_regEndCol = new HTuple(), hv_Cos = null, hv_Sin = null;
            HTuple hv_a = null, hv_b = null, hv_Row1 = null, hv_Col1 = null;
            HTuple hv_c = null, hv_d = null, hv_Row2 = null, hv_Col2 = null;
            HTuple hv_e = null, hv_f = null, hv_Row3 = null, hv_Col3 = null;
            HTuple hv_g = null, hv_h = null, hv_Row4 = null, hv_Col4 = null;
            HTuple hv_lineNum = null, hv_idx = null, hv_IsInside = new HTuple();
            HTuple hv_IsInside1 = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_RefEdges);
            HOperatorSet.GenEmptyObj(out ho_Rectangle);
            HOperatorSet.GenEmptyObj(out ho_RegionLines);
            HOperatorSet.GenEmptyObj(out ho_RegionLines1);
            HOperatorSet.GenEmptyObj(out ho_RegionLines2);
            HOperatorSet.GenEmptyObj(out ho_RegionLines3);
            HOperatorSet.GenEmptyObj(out ho_RegionLines4);
            HOperatorSet.GenEmptyObj(out ho_ObjectSelected);
            HOperatorSet.GenEmptyObj(out ho_Skeleton);
            HOperatorSet.GenEmptyObj(out ho_Contours);
            HOperatorSet.GenEmptyObj(out ho__StartEdge);
            HOperatorSet.GenEmptyObj(out ho_Contours1);
            HOperatorSet.GenEmptyObj(out ho__EndEdge);
            hv_o_RefEndRow = new HTuple();
            hv_o_RefEndCol = new HTuple();
            //


            //

            HOperatorSet.SmallestRectangle2(ho_i_InspectReg, out hv_RowReg, out hv_ColReg,
                out hv__regPhi, out hv__regLenHalf, out hv__regWidthHalf);
            //*****************************************************
            //纠正方向：lW
            //参考方向改为参考起始点至中心点方向,当前参考起始点为上个框的终止点
            if ((int)(new HTuple(hv_i_Regidx.TupleEqual(1))) != 0)
            {
                HOperatorSet.AreaCenter(ho_i_StartReg, out hv_Area1, out hv_StartRegRow, out hv_StartRegCol);
            }
            else
            {
                hv_StartRegRow = hv_i_RefEndRow.TupleSelect(hv_i_Regidx - 2);
                hv_StartRegCol = hv_i_RefEndCol.TupleSelect(hv_i_Regidx - 2);
            }
            HOperatorSet.LineOrientation(hv_StartRegRow, hv_StartRegCol, hv_RowReg, hv_ColReg,
                out hv__RegRefDirection);
            hv_angleDiff1 = ((hv__regPhi - hv__RegRefDirection)).TupleAbs();
            hv_angleDiff2 = (((hv__regPhi + ((new HTuple(90)).TupleRad())) - hv__RegRefDirection)).TupleAbs()
                ;
            //
            if ((int)(new HTuple(hv_angleDiff1.TupleGreater((new HTuple(90)).TupleRad()))) != 0)
            {
                hv_angleDiff1 = ((hv_angleDiff1 - ((new HTuple(180)).TupleRad()))).TupleAbs()
                    ;
            }
            if ((int)(new HTuple(hv_angleDiff2.TupleGreater((new HTuple(90)).TupleRad()))) != 0)
            {
                hv_angleDiff2 = ((hv_angleDiff2 - ((new HTuple(180)).TupleRad()))).TupleAbs()
                    ;
            }
            //
            if ((int)(new HTuple(hv_angleDiff1.TupleLess(hv_angleDiff2))) != 0)
            {
                hv_regPhi = hv__regPhi.Clone();
                hv_regLenHalf = hv__regLenHalf.Clone();
                hv_regWidthHalf = hv__regWidthHalf.Clone();
            }
            else
            {
                hv_regPhi = hv__regPhi + ((new HTuple(90)).TupleRad());
                //
                if ((int)(new HTuple(hv_regPhi.TupleGreater((new HTuple(90)).TupleRad()))) != 0)
                {
                    hv_regPhi = hv_regPhi - ((new HTuple(180)).TupleRad());
                }
                //
                hv_regLenHalf = hv__regWidthHalf.Clone();
                hv_regWidthHalf = hv__regLenHalf.Clone();
            }
            //
            //检测区域角度
            hv_o_RegPhi = hv_regPhi.Clone();

            //******************************************************
            //检测区域起始位置
            hv__regStartRow = hv_RowReg + (hv_regLenHalf * (((-hv_regPhi)).TupleSin()));
            hv__regStartCol = hv_ColReg + (hv_regLenHalf * (((-hv_regPhi)).TupleCos()));
            //检测区域结束点位置
            hv__regEndRow = hv_RowReg - (hv_regLenHalf * (((-hv_regPhi)).TupleSin()));
            hv__regEndCol = hv_ColReg - (hv_regLenHalf * (((-hv_regPhi)).TupleCos()));
            //金线起始点
            HOperatorSet.AreaCenter(ho_i_StartReg, out hv_Area, out hv__RefRow, out hv__RefCol);
            //起始端点确定:计算区域起始及结束点位置到参考点的距离
            HOperatorSet.DistancePp(hv__regStartRow, hv__regStartCol, hv__RefRow, hv__RefCol,
                out hv_RefDistance1);
            HOperatorSet.DistancePp(hv__regEndRow, hv__regEndCol, hv__RefRow, hv__RefCol,
                out hv_RefDistance2);
            if ((int)(new HTuple(hv_RefDistance1.TupleLess(hv_RefDistance2))) != 0)
            {
                hv_regStartRow = hv__regStartRow.Clone();
                hv_regStartCol = hv__regStartCol.Clone();
                hv_regEndRow = hv__regEndRow.Clone();
                hv_regEndCol = hv__regEndCol.Clone();
            }
            else
            {
                hv_regStartRow = hv__regEndRow.Clone();
                hv_regStartCol = hv__regEndCol.Clone();
                hv_regEndRow = hv__regStartRow.Clone();
                hv_regEndCol = hv__regStartCol.Clone();
            }

            //**************************************************************************************
            //
            ho_o_RefEdges.Dispose();
            HOperatorSet.GenEmptyObj(out ho_o_RefEdges);
            //提取仿射最小外接矩形的四个顶点坐标
            ho_Rectangle.Dispose();
            HOperatorSet.GenRectangle2ContourXld(out ho_Rectangle, hv_RowReg, hv_ColReg,
                hv_regPhi, hv_regLenHalf, hv_regWidthHalf);
            HOperatorSet.TupleCos(hv_regPhi, out hv_Cos);
            HOperatorSet.TupleSin(hv_regPhi, out hv_Sin);
            //
            hv_a = ((-hv_regLenHalf) * hv_Cos) - (hv_regWidthHalf * hv_Sin);
            hv_b = ((-hv_regLenHalf) * hv_Sin) + (hv_regWidthHalf * hv_Cos);
            //端点1
            hv_Row1 = hv_RowReg - hv_b;
            hv_Col1 = hv_ColReg + hv_a;

            //gen_cross_contour_xld (Cross, RowReg-b, ColReg+a, 6, regPhi)
            //
            hv_c = (hv_regLenHalf * hv_Cos) - (hv_regWidthHalf * hv_Sin);
            hv_d = (hv_regLenHalf * hv_Sin) + (hv_regWidthHalf * hv_Cos);
            //端点2
            hv_Row2 = hv_RowReg - hv_d;
            hv_Col2 = hv_ColReg + hv_c;

            //gen_cross_contour_xld (Cross, RowReg-d, ColReg+c, 6, regPhi)
            //
            hv_e = (hv_regLenHalf * hv_Cos) + (hv_regWidthHalf * hv_Sin);
            hv_f = (hv_regLenHalf * hv_Sin) - (hv_regWidthHalf * hv_Cos);
            //*端点3
            hv_Row3 = hv_RowReg - hv_f;
            hv_Col3 = hv_ColReg + hv_e;

            //gen_cross_contour_xld (Cross, RowReg-f, ColReg+e, 6, regPhi)
            //
            hv_g = ((-hv_regLenHalf) * hv_Cos) + (hv_regWidthHalf * hv_Sin);
            hv_h = ((-hv_regLenHalf) * hv_Sin) - (hv_regWidthHalf * hv_Cos);
            //*端点4
            hv_Row4 = hv_RowReg - hv_h;
            hv_Col4 = hv_ColReg + hv_g;
            //gen_cross_contour_xld (Cross, RowReg-h, ColReg+g, 6, regPhi)
            //
            //生成4条线段区域
            ho_RegionLines.Dispose();
            HOperatorSet.GenEmptyObj(out ho_RegionLines);
            //第一条边
            ho_RegionLines1.Dispose();
            HOperatorSet.GenRegionLine(out ho_RegionLines1, hv_RowReg - hv_b, hv_ColReg + hv_a,
                hv_RowReg - hv_d, hv_ColReg + hv_c);
            {
                HObject ExpTmpOutVar_0;
                HOperatorSet.ConcatObj(ho_RegionLines, ho_RegionLines1, out ExpTmpOutVar_0);
                ho_RegionLines.Dispose();
                ho_RegionLines = ExpTmpOutVar_0;
            }
            //第二条边
            ho_RegionLines2.Dispose();
            HOperatorSet.GenRegionLine(out ho_RegionLines2, hv_RowReg - hv_d, hv_ColReg + hv_c,
                hv_RowReg - hv_f, hv_ColReg + hv_e);
            {
                HObject ExpTmpOutVar_0;
                HOperatorSet.ConcatObj(ho_RegionLines, ho_RegionLines2, out ExpTmpOutVar_0);
                ho_RegionLines.Dispose();
                ho_RegionLines = ExpTmpOutVar_0;
            }
            //第三条边
            ho_RegionLines3.Dispose();
            HOperatorSet.GenRegionLine(out ho_RegionLines3, hv_RowReg - hv_f, hv_ColReg + hv_e,
                hv_RowReg - hv_h, hv_ColReg + hv_g);
            {
                HObject ExpTmpOutVar_0;
                HOperatorSet.ConcatObj(ho_RegionLines, ho_RegionLines3, out ExpTmpOutVar_0);
                ho_RegionLines.Dispose();
                ho_RegionLines = ExpTmpOutVar_0;
            }
            //第四条边
            ho_RegionLines4.Dispose();
            HOperatorSet.GenRegionLine(out ho_RegionLines4, hv_RowReg - hv_h, hv_ColReg + hv_g,
                hv_RowReg - hv_b, hv_ColReg + hv_a);
            {
                HObject ExpTmpOutVar_0;
                HOperatorSet.ConcatObj(ho_RegionLines, ho_RegionLines4, out ExpTmpOutVar_0);
                ho_RegionLines.Dispose();
                ho_RegionLines = ExpTmpOutVar_0;
            }
            //
            {
                HObject ExpTmpOutVar_0;
                HOperatorSet.DilationCircle(ho_RegionLines, out ExpTmpOutVar_0, 3.5);
                ho_RegionLines.Dispose();
                ho_RegionLines = ExpTmpOutVar_0;
            }
            //选择中线起始端点所在的边
            HOperatorSet.CountObj(ho_RegionLines, out hv_lineNum);
            HTuple end_val125 = hv_lineNum;
            HTuple step_val125 = 1;
            for (hv_idx = 1; hv_idx.Continue(end_val125, step_val125); hv_idx = hv_idx.TupleAdd(step_val125))
            {
                ho_ObjectSelected.Dispose();
                HOperatorSet.SelectObj(ho_RegionLines, out ho_ObjectSelected, hv_idx);
                HOperatorSet.TestRegionPoint(ho_ObjectSelected, hv_regStartRow, hv_regStartCol,
                    out hv_IsInside);
                if ((int)(hv_IsInside) != 0)
                {
                    ho_Skeleton.Dispose();
                    HOperatorSet.Skeleton(ho_ObjectSelected, out ho_Skeleton);
                    ho_Contours.Dispose();
                    HOperatorSet.GenContoursSkeletonXld(ho_Skeleton, out ho_Contours, 1, "filter");
                    ho__StartEdge.Dispose();
                    ho__StartEdge = ho_Contours.CopyObj(1, -1);
                }
                HOperatorSet.TestRegionPoint(ho_ObjectSelected, hv_regEndRow, hv_regEndCol,
                    out hv_IsInside1);
                if ((int)(hv_IsInside1) != 0)
                {
                    ho_Skeleton.Dispose();
                    HOperatorSet.Skeleton(ho_ObjectSelected, out ho_Skeleton);
                    ho_Contours1.Dispose();
                    HOperatorSet.GenContoursSkeletonXld(ho_Skeleton, out ho_Contours1, 1, "filter");
                    ho__EndEdge.Dispose();
                    ho__EndEdge = ho_Contours1.CopyObj(1, -1);
                }
            }
            ho_o_RefEdges.Dispose();
            HOperatorSet.ConcatObj(ho__StartEdge, ho__EndEdge, out ho_o_RefEdges);
            //**********************************************************************************
            //
            //保存各金线检测区域端点   ：lW
            if (hv_o_RefEndRow == null)
                hv_o_RefEndRow = new HTuple();
            hv_o_RefEndRow[hv_i_Regidx - 1] = hv_regEndRow;
            if (hv_o_RefEndCol == null)
                hv_o_RefEndCol = new HTuple();
            hv_o_RefEndCol[hv_i_Regidx - 1] = hv_regEndCol;
            //
            hv_o_RegStartRow = hv_regStartRow.Clone();
            hv_o_RegStartCol = hv_regStartCol.Clone();
            ho_Rectangle.Dispose();
            ho_RegionLines.Dispose();
            ho_RegionLines1.Dispose();
            ho_RegionLines2.Dispose();
            ho_RegionLines3.Dispose();
            ho_RegionLines4.Dispose();
            ho_ObjectSelected.Dispose();
            ho_Skeleton.Dispose();
            ho_Contours.Dispose();
            ho__StartEdge.Dispose();
            ho_Contours1.Dispose();
            ho__EndEdge.Dispose();

            return;
        }

        public static void affine_transformation_matrix(HObject ho_i_StartReg, HObject ho_i_StopReg,
            HObject ho_i_RefStartReg, HObject ho_i_RefStopReg, out HTuple hv_o_HomMat2D,
            out HTuple hv_o_RefDirection)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_Area1 = null, hv_StartRow = null;
            HTuple hv_StartColumn = null, hv_Area2 = null, hv_StopRow = null;
            HTuple hv_StopColumn = null, hv_RefRows = null, hv_RefCols = null;
            HTuple hv_ModelRows = null, hv_ModelCols = null;
            // Initialize local and output iconic variables 
            //******获取金线检测区域映射的仿射变换矩阵
            //i_StartReg：检测Die区域内金线检测实际起始焊点区域
            //i_StopReg：检测Die区域内金线检测实际结束焊点区域
            //i_RefStartReg：模板中金线检测起始焊点区域
            //i_RefStopReg：模板中金线检测起始焊点区域
            //o_HomMat2D：获得的仿射变换矩阵
            //o_RefDirection：
            //-----------获取检测区域仿射变换矩阵
            //实际焊点
            HOperatorSet.AreaCenter(ho_i_StartReg, out hv_Area1, out hv_StartRow, out hv_StartColumn);
            HOperatorSet.AreaCenter(ho_i_StopReg, out hv_Area2, out hv_StopRow, out hv_StopColumn);
            HOperatorSet.LineOrientation(hv_StartRow, hv_StartColumn, hv_StopRow, hv_StopColumn,
                out hv_o_RefDirection);
            hv_RefRows = new HTuple();
            hv_RefRows = hv_RefRows.TupleConcat(hv_StartRow);
            hv_RefRows = hv_RefRows.TupleConcat(hv_StopRow);
            hv_RefCols = new HTuple();
            hv_RefCols = hv_RefCols.TupleConcat(hv_StartColumn);
            hv_RefCols = hv_RefCols.TupleConcat(hv_StopColumn);
            //**********
            //参考模板焊点位置获取
            HOperatorSet.AreaCenter(ho_i_RefStartReg, out hv_Area1, out hv_StartRow, out hv_StartColumn);
            HOperatorSet.AreaCenter(ho_i_RefStopReg, out hv_Area2, out hv_StopRow, out hv_StopColumn);
            hv_ModelRows = new HTuple();
            hv_ModelRows = hv_ModelRows.TupleConcat(hv_StartRow);
            hv_ModelRows = hv_ModelRows.TupleConcat(hv_StopRow);
            hv_ModelCols = new HTuple();
            hv_ModelCols = hv_ModelCols.TupleConcat(hv_StartColumn);
            hv_ModelCols = hv_ModelCols.TupleConcat(hv_StopColumn);
            //求取变换仿射矩阵
            HOperatorSet.VectorToSimilarity(hv_ModelRows, hv_ModelCols, hv_RefRows, hv_RefCols,
                out hv_o_HomMat2D);
            //

            return;
        }

        public static void HTV_WireSeg_Inspect_threshold(HObject ho_i_Image, HObject ho_i_InspectReg,
            out HObject ho_o_WireSeg, HTuple hv_i_ThreshGray, HTuple hv_i_LightOrDark, HTuple hv_i_ClosingSize,
            HTuple hv_i_WireLenth, HTuple hv_i_WireWideth, HTuple hv_i_WireArea, out HTuple hv_o_ErrCode,
            out HTuple hv_o_ErrStr)
        {




            // Local iconic variables 

            HObject ho_InspectImage, ho_Region, ho_RegionOpening = null;
            HObject ho_RegionClosing = null, ho_ConnectedRegions, ho__selectRegions;
            HObject ho_RegionUnion, ho__WireRegs, ho__WireSeg = null;
            HObject ho_Skeleton = null, ho__WireSegContour = null, ho_UnionContour = null;

            // Local control variables 

            HTuple hv_imgNum = null, hv_regNum = null;
            HTuple hv_lowThresh = null, hv_highThresh = null, hv_RegNum = null;
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_WireSeg);
            HOperatorSet.GenEmptyObj(out ho_InspectImage);
            HOperatorSet.GenEmptyObj(out ho_Region);
            HOperatorSet.GenEmptyObj(out ho_RegionOpening);
            HOperatorSet.GenEmptyObj(out ho_RegionClosing);
            HOperatorSet.GenEmptyObj(out ho_ConnectedRegions);
            HOperatorSet.GenEmptyObj(out ho__selectRegions);
            HOperatorSet.GenEmptyObj(out ho_RegionUnion);
            HOperatorSet.GenEmptyObj(out ho__WireRegs);
            HOperatorSet.GenEmptyObj(out ho__WireSeg);
            HOperatorSet.GenEmptyObj(out ho_Skeleton);
            HOperatorSet.GenEmptyObj(out ho__WireSegContour);
            HOperatorSet.GenEmptyObj(out ho_UnionContour);
            //**********     阈值分割方法提取金线区域
            //i_Image: 待处理图像，对应的金线靠近起始焊点远近顺序进行检测
            //i_InspectReg: 提取出来的金线区域
            //i_IcReg :Ic区域，一般为免检或生成金线检测区域
            //i_EpoxyReg：银胶区域，为金线检测免检测区域
            //o_WireSeg: 通过阈值分割得到的金线区域
            //i_ThreshGray: 阈值分割的灰度阈值，可以为1个参数（灰度上限或下限）或2个参数（灰度上下限）
            //i_LightOrDark: 银胶为亮目标或暗目标
            //i_ClosingSize: 为去除金线干扰进行闭运算的尺寸
            //i_WireSizeTh: 金线目标的面积阈值，可以为1个参数（面积下限）或2个参数（面积上下限）
            //o_ErrCode: 错误码，代表该算子执行过程中产生的错误，0-代表正常执行，自然数-代表错误类型，-1-代表异常，-2-代表未执行
            //o_ErrStr: 错误信息，对各种错误的具体描述

            //输出初始化
            ho_o_WireSeg.Dispose();
            HOperatorSet.GenEmptyObj(out ho_o_WireSeg);
            hv_o_ErrCode = -2;
            hv_o_ErrStr = "initializing";

            //输入有效性测试
            HOperatorSet.CountObj(ho_i_Image, out hv_imgNum);
            if ((int)(new HTuple(hv_imgNum.TupleEqual(0))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "input image is null";
                ho_InspectImage.Dispose();
                ho_Region.Dispose();
                ho_RegionOpening.Dispose();
                ho_RegionClosing.Dispose();
                ho_ConnectedRegions.Dispose();
                ho__selectRegions.Dispose();
                ho_RegionUnion.Dispose();
                ho__WireRegs.Dispose();
                ho__WireSeg.Dispose();
                ho_Skeleton.Dispose();
                ho__WireSegContour.Dispose();
                ho_UnionContour.Dispose();

                return;
            }
            if ((int)((new HTuple((new HTuple(hv_i_ThreshGray.TupleLength())).TupleLess(1))).TupleOr(
                new HTuple(hv_i_ThreshGray.TupleLess(0)))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "paras illegal";
                ho_InspectImage.Dispose();
                ho_Region.Dispose();
                ho_RegionOpening.Dispose();
                ho_RegionClosing.Dispose();
                ho_ConnectedRegions.Dispose();
                ho__selectRegions.Dispose();
                ho_RegionUnion.Dispose();
                ho__WireRegs.Dispose();
                ho__WireSeg.Dispose();
                ho_Skeleton.Dispose();
                ho__WireSegContour.Dispose();
                ho_UnionContour.Dispose();

                return;
            }
            HOperatorSet.CountObj(ho_i_InspectReg, out hv_regNum);
            if ((int)(new HTuple(hv_regNum.TupleLess(1))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "Wire inspect region empty";
                ho_InspectImage.Dispose();
                ho_Region.Dispose();
                ho_RegionOpening.Dispose();
                ho_RegionClosing.Dispose();
                ho_ConnectedRegions.Dispose();
                ho__selectRegions.Dispose();
                ho_RegionUnion.Dispose();
                ho__WireRegs.Dispose();
                ho__WireSeg.Dispose();
                ho_Skeleton.Dispose();
                ho__WireSegContour.Dispose();
                ho_UnionContour.Dispose();

                return;
            }
            if ((int)((new HTuple((new HTuple(hv_i_ClosingSize.TupleLength())).TupleLess(
                1))).TupleOr(new HTuple(hv_i_ClosingSize.TupleLess(1)))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "the para i_OpeningSize must greater than 0";
                ho_InspectImage.Dispose();
                ho_Region.Dispose();
                ho_RegionOpening.Dispose();
                ho_RegionClosing.Dispose();
                ho_ConnectedRegions.Dispose();
                ho__selectRegions.Dispose();
                ho_RegionUnion.Dispose();
                ho__WireRegs.Dispose();
                ho__WireSeg.Dispose();
                ho_Skeleton.Dispose();
                ho__WireSegContour.Dispose();
                ho_UnionContour.Dispose();

                return;
            }
            if ((int)((new HTuple((new HTuple(hv_i_WireWideth.TupleLength())).TupleLess(1))).TupleOr(
                new HTuple(((hv_i_WireWideth.TupleSelect(0))).TupleLess(1)))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "the para i_WireWideth must be one integer greater than 0 at least";
                ho_InspectImage.Dispose();
                ho_Region.Dispose();
                ho_RegionOpening.Dispose();
                ho_RegionClosing.Dispose();
                ho_ConnectedRegions.Dispose();
                ho__selectRegions.Dispose();
                ho_RegionUnion.Dispose();
                ho__WireRegs.Dispose();
                ho__WireSeg.Dispose();
                ho_Skeleton.Dispose();
                ho__WireSegContour.Dispose();
                ho_UnionContour.Dispose();

                return;
            }
            if ((int)((new HTuple((new HTuple(hv_i_WireLenth.TupleLength())).TupleLess(1))).TupleOr(
                new HTuple(((hv_i_WireLenth.TupleSelect(0))).TupleLess(1)))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "the para i_WireLenth must be one integer greater than 0 at least";
                ho_InspectImage.Dispose();
                ho_Region.Dispose();
                ho_RegionOpening.Dispose();
                ho_RegionClosing.Dispose();
                ho_ConnectedRegions.Dispose();
                ho__selectRegions.Dispose();
                ho_RegionUnion.Dispose();
                ho__WireRegs.Dispose();
                ho__WireSeg.Dispose();
                ho_Skeleton.Dispose();
                ho__WireSegContour.Dispose();
                ho_UnionContour.Dispose();

                return;
            }
            if ((int)((new HTuple((new HTuple(hv_i_WireArea.TupleLength())).TupleLess(1))).TupleOr(
                new HTuple(((hv_i_WireArea.TupleSelect(0))).TupleLess(1)))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "the para i_WireArea must be one integer greater than 0 at least";
                ho_InspectImage.Dispose();
                ho_Region.Dispose();
                ho_RegionOpening.Dispose();
                ho_RegionClosing.Dispose();
                ho_ConnectedRegions.Dispose();
                ho__selectRegions.Dispose();
                ho_RegionUnion.Dispose();
                ho__WireRegs.Dispose();
                ho__WireSeg.Dispose();
                ho_Skeleton.Dispose();
                ho__WireSegContour.Dispose();
                ho_UnionContour.Dispose();

                return;
            }
            //阈值分割上下限参数
            hv_lowThresh = hv_i_ThreshGray[0];
            hv_highThresh = hv_i_ThreshGray[1];

            //检测焊点处是否有焊线，有焊线标记为1，否则为0
            //金线检测区域获取
            ho_InspectImage.Dispose();
            HOperatorSet.ReduceDomain(ho_i_Image, ho_i_InspectReg, out ho_InspectImage);
            ho_Region.Dispose();
            HOperatorSet.Threshold(ho_InspectImage, out ho_Region, hv_lowThresh, hv_highThresh);
            if ((int)(new HTuple(hv_i_ClosingSize.TupleNotEqual(0))) != 0)
            {
                ho_RegionOpening.Dispose();
                HOperatorSet.OpeningCircle(ho_Region, out ho_RegionOpening, hv_i_ClosingSize / 2);
                ho_RegionClosing.Dispose();
                HOperatorSet.ClosingCircle(ho_RegionOpening, out ho_RegionClosing, hv_i_ClosingSize / 2);
            }
            else
            {
                ho_RegionClosing.Dispose();
                ho_RegionClosing = ho_Region.CopyObj(1, -1);
            }
            ho_ConnectedRegions.Dispose();
            HOperatorSet.Connection(ho_RegionClosing, out ho_ConnectedRegions);
            //初次筛选
            ho__selectRegions.Dispose();
            HOperatorSet.SelectShape(ho_ConnectedRegions, out ho__selectRegions, ((new HTuple("width")).TupleConcat(
                "height")).TupleConcat("area"), "and", (((((hv_i_WireLenth.TupleSelect(0)) - 2)).TupleConcat(
                hv_i_WireWideth.TupleSelect(0)))).TupleConcat(hv_i_WireArea.TupleSelect(0)),
                ((((hv_i_WireLenth.TupleSelect(1))).TupleConcat(hv_i_WireWideth.TupleSelect(
                1)))).TupleConcat(hv_i_WireArea.TupleSelect(1)));
            //
            ho_RegionUnion.Dispose();
            HOperatorSet.Union1(ho__selectRegions, out ho_RegionUnion);
            //再次筛选
            ho__WireRegs.Dispose();
            HOperatorSet.SelectShape(ho_RegionUnion, out ho__WireRegs, "area", "and", hv_i_WireArea.TupleSelect(
                0), hv_i_WireArea.TupleSelect(1));
            HOperatorSet.CountObj(ho__WireRegs, out hv_RegNum);
            if ((int)(new HTuple(hv_RegNum.TupleLess(1))) != 0)
            {
                hv_o_ErrCode = 1;
                hv_o_ErrStr = "broken Wire";
                ho_InspectImage.Dispose();
                ho_Region.Dispose();
                ho_RegionOpening.Dispose();
                ho_RegionClosing.Dispose();
                ho_ConnectedRegions.Dispose();
                ho__selectRegions.Dispose();
                ho_RegionUnion.Dispose();
                ho__WireRegs.Dispose();
                ho__WireSeg.Dispose();
                ho_Skeleton.Dispose();
                ho__WireSegContour.Dispose();
                ho_UnionContour.Dispose();

                return;
            }
            else
            {
                ho__WireSeg.Dispose();
                HOperatorSet.Union1(ho__WireRegs, out ho__WireSeg);
                ho_Skeleton.Dispose();
                HOperatorSet.Skeleton(ho__WireSeg, out ho_Skeleton);
                ho__WireSegContour.Dispose();
                HOperatorSet.GenContoursSkeletonXld(ho_Skeleton, out ho__WireSegContour, 1,
                    "filter");
                ho_UnionContour.Dispose();
                HOperatorSet.UnionAdjacentContoursXld(ho__WireSegContour, out ho_UnionContour,
                    30, 2, "attr_keep");
                ho_o_WireSeg.Dispose();
                HOperatorSet.SmoothContoursXld(ho_UnionContour, out ho_o_WireSeg, 21);
                hv_o_ErrCode = 0;
                hv_o_ErrStr = "Wire is OK";
                ho_InspectImage.Dispose();
                ho_Region.Dispose();
                ho_RegionOpening.Dispose();
                ho_RegionClosing.Dispose();
                ho_ConnectedRegions.Dispose();
                ho__selectRegions.Dispose();
                ho_RegionUnion.Dispose();
                ho__WireRegs.Dispose();
                ho__WireSeg.Dispose();
                ho_Skeleton.Dispose();
                ho__WireSegContour.Dispose();
                ho_UnionContour.Dispose();

                return;
            }

        }

        public static void HTV_WireSeg_Inspect_guass_sort(HObject ho_i_Image, HObject ho_i_InspectReg,
            HObject ho_i_RefReg, HObject ho_i_RefEdges, out HObject ho_o_WireSeg, HTuple hv_i_RefPhi,
            HTuple hv_i_WireWidth, HTuple hv_i_WireContrast, HTuple hv_i_Transition, HTuple hv_i_SelMetric,
            HTuple hv_i_SelMax, HTuple hv_i_SelMin, HTuple hv_i_RegStartRow, HTuple hv_i_RegStartCol,
            HTuple hv_i_MaxWireGap, HTuple hv_i_RegEndRow, HTuple hv_i_RegEndCol, HTuple hv_i_LinePhiDiff,
            out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_linesImage, ho_Lines = null, ho_Lines1 = null;
            HObject ho_ContoursSplit, ho_SelectedContours, ho__Lines;
            HObject ho_o_Lines, ho_startEdge = null, ho_endEdge = null;
            HObject ho_UnionContour, ho_MaxContour;

            // Local control variables 

            HTuple hv_imgNum = null, hv_o_ErrString = null;
            HTuple hv_regNum = null, hv_regStartRow = null, hv_regStartCol = null;
            HTuple hv_regEndRow = null, hv_regEndCol = null, hv_Sigma = null;
            HTuple hv_Low = null, hv_High = null, hv_pos = null, hv_selGE = null;
            HTuple hv_selIndices = null, hv_MinPhi = new HTuple();
            HTuple hv_MaxPhi = new HTuple(), hv_lineSelNum = null;
            HTuple hv_Area = null, hv_RefRow = null, hv_RefColumn = null;
            HTuple hv_LineNum = null, hv_RowBegin = new HTuple(), hv_ColBegin = new HTuple();
            HTuple hv_RowEnd = new HTuple(), hv_ColEnd = new HTuple();
            HTuple hv_Nr = new HTuple(), hv_Nc = new HTuple(), hv_Dist = new HTuple();
            HTuple hv_segIntervals = new HTuple(), hv_Distance_Start1 = new HTuple();
            HTuple hv_DistanceMax = new HTuple(), hv_Distance_Start2 = new HTuple();
            HTuple hv_Distance_End1 = new HTuple(), hv_Distance_End2 = new HTuple();
            HTuple hv_Greater = new HTuple(), hv_Length = null, hv_MaxLen = null;
            HTuple hv_MaxIndice = null;
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_WireSeg);
            HOperatorSet.GenEmptyObj(out ho_linesImage);
            HOperatorSet.GenEmptyObj(out ho_Lines);
            HOperatorSet.GenEmptyObj(out ho_Lines1);
            HOperatorSet.GenEmptyObj(out ho_ContoursSplit);
            HOperatorSet.GenEmptyObj(out ho_SelectedContours);
            HOperatorSet.GenEmptyObj(out ho__Lines);
            HOperatorSet.GenEmptyObj(out ho_o_Lines);
            HOperatorSet.GenEmptyObj(out ho_startEdge);
            HOperatorSet.GenEmptyObj(out ho_endEdge);
            HOperatorSet.GenEmptyObj(out ho_UnionContour);
            HOperatorSet.GenEmptyObj(out ho_MaxContour);
            //***********************************************************************
            //*******  在IC图中检测焊点附近的焊线，判断是否断线
            //*******  i_Image: IC图像
            //*******  o_WireSeg: 检测到的线段
            //*******  i_InspectReg: 线检测区域
            //*******  i_StartReg：线检测起始点区域
            //*******  i_RefPhi: 线参考方向
            //*******  i_WireWidth: 线宽设置
            //*******  i_WireContrast: 线的对比度设置
            //*******  o_ErrCode: 检测结果标志，0-表示检测到线段，1-表示没有检测到线段，即此处断线，-2-为初始化值
            //*******  o_ErrStr: 执行结果描述
            //***********************************************************************
            //输出初始化
            ho_o_WireSeg.Dispose();
            HOperatorSet.GenEmptyObj(out ho_o_WireSeg);
            hv_o_ErrCode = -2;
            hv_o_ErrStr = "initializing";
            //

            //输入合法性检测
            HOperatorSet.CountObj(ho_i_Image, out hv_imgNum);
            if ((int)(new HTuple(hv_imgNum.TupleEqual(0))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrString = "input image is empty!";
                ho_linesImage.Dispose();
                ho_Lines.Dispose();
                ho_Lines1.Dispose();
                ho_ContoursSplit.Dispose();
                ho_SelectedContours.Dispose();
                ho__Lines.Dispose();
                ho_o_Lines.Dispose();
                ho_startEdge.Dispose();
                ho_endEdge.Dispose();
                ho_UnionContour.Dispose();
                ho_MaxContour.Dispose();

                return;
            }
            HOperatorSet.CountObj(ho_i_InspectReg, out hv_regNum);
            if ((int)(new HTuple(hv_regNum.TupleEqual(0))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrString = "inspect region is empty!";
                ho_linesImage.Dispose();
                ho_Lines.Dispose();
                ho_Lines1.Dispose();
                ho_ContoursSplit.Dispose();
                ho_SelectedContours.Dispose();
                ho__Lines.Dispose();
                ho_o_Lines.Dispose();
                ho_startEdge.Dispose();
                ho_endEdge.Dispose();
                ho_UnionContour.Dispose();
                ho_MaxContour.Dispose();

                return;
            }
            if ((int)((new HTuple((new HTuple(hv_i_WireWidth.TupleLength())).TupleEqual(0))).TupleOr(
                new HTuple(hv_i_WireWidth.TupleLess(1)))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrString = "inspect coef i_LineWidth must be above zero!";
                ho_linesImage.Dispose();
                ho_Lines.Dispose();
                ho_Lines1.Dispose();
                ho_ContoursSplit.Dispose();
                ho_SelectedContours.Dispose();
                ho__Lines.Dispose();
                ho_o_Lines.Dispose();
                ho_startEdge.Dispose();
                ho_endEdge.Dispose();
                ho_UnionContour.Dispose();
                ho_MaxContour.Dispose();

                return;
            }
            if ((int)((new HTuple((new HTuple(hv_i_WireContrast.TupleLength())).TupleEqual(
                0))).TupleOr(new HTuple(hv_i_WireContrast.TupleLess(10)))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrString = "inspect coef i_LineContrast must be above 20!";
                ho_linesImage.Dispose();
                ho_Lines.Dispose();
                ho_Lines1.Dispose();
                ho_ContoursSplit.Dispose();
                ho_SelectedContours.Dispose();
                ho__Lines.Dispose();
                ho_o_Lines.Dispose();
                ho_startEdge.Dispose();
                ho_endEdge.Dispose();
                ho_UnionContour.Dispose();
                ho_MaxContour.Dispose();

                return;
            }

            //检测区域中线端点
            hv_regStartRow = hv_i_RegStartRow.Clone();
            hv_regStartCol = hv_i_RegStartCol.Clone();
            hv_regEndRow = hv_i_RegEndRow.Clone();
            hv_regEndCol = hv_i_RegEndCol.Clone();

            //*1-------------------------检测区域获取并提取线段
            ho_linesImage.Dispose();
            HOperatorSet.ReduceDomain(ho_i_Image, ho_i_InspectReg, out ho_linesImage);
            //高斯滤波
            //gauss_filter (linesImage, ImageGauss, 7)
            calculate_lines_gauss_parameters(hv_i_WireWidth, hv_i_WireContrast, out hv_Sigma,
                out hv_Low, out hv_High);
            if ((int)(new HTuple(hv_i_Transition.TupleEqual("all"))) != 0)
            {
                ho_Lines.Dispose();
                HOperatorSet.LinesGauss(ho_linesImage, out ho_Lines, hv_Sigma, hv_Low, hv_High,
                    "dark", "true", "bar-shaped", "true");
                ho_Lines1.Dispose();
                HOperatorSet.LinesGauss(ho_linesImage, out ho_Lines1, hv_Sigma, hv_Low, hv_High,
                    "light", "true", "bar-shaped", "true");
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.ConcatObj(ho_Lines, ho_Lines1, out ExpTmpOutVar_0);
                    ho_Lines.Dispose();
                    ho_Lines = ExpTmpOutVar_0;
                }
            }
            else
            {
                ho_Lines.Dispose();
                HOperatorSet.LinesGauss(ho_linesImage, out ho_Lines, hv_Sigma, hv_Low, hv_High,
                    hv_i_Transition, "true", "bar-shaped", "true");
            }
            //
            //*2---------------------对line_gauaa获取的线段进行初次筛选并判定
            ho_ContoursSplit.Dispose();
            HOperatorSet.SegmentContoursXld(ho_Lines, out ho_ContoursSplit, "lines_circles",
                4, 2, 1);
            //如果进行角度筛选，需要参考检测区域的方向
            HOperatorSet.TupleStrstr(hv_i_SelMetric, "direction", out hv_pos);
            HOperatorSet.TupleGreaterEqualElem(hv_pos, 0, out hv_selGE);
            HOperatorSet.TupleFind(hv_selGE, 1, out hv_selIndices);
            //根据参考方向确定方向范围
            if ((int)(new HTuple(hv_selIndices.TupleGreaterEqual(0))) != 0)
            {
                hv_MinPhi = hv_i_RefPhi + (hv_i_SelMin.TupleSelect(hv_selIndices));
                hv_MaxPhi = hv_i_RefPhi + (hv_i_SelMax.TupleSelect(hv_selIndices));
            }

            //按照最小线长度、方向角度初步筛选线段
            ho_SelectedContours.Dispose();
            HOperatorSet.SelectContoursXld(ho_ContoursSplit, out ho_SelectedContours, hv_i_SelMetric.TupleSelect(
                0), hv_i_SelMin.TupleSelect(0), hv_i_SelMax.TupleSelect(0), -0.5, 0.5);
            ho__Lines.Dispose();
            HOperatorSet.SelectContoursXld(ho_SelectedContours, out ho__Lines, hv_i_SelMetric.TupleSelect(
                1), hv_MinPhi, hv_MaxPhi, -0.5, 0.5);

            //分析检测结果
            HOperatorSet.CountObj(ho__Lines, out hv_lineSelNum);
            if ((int)(new HTuple(hv_lineSelNum.TupleLess(1))) != 0)
            {
                hv_o_ErrCode = 12;
                hv_o_ErrString = "broken line or absent line!";
                ho_linesImage.Dispose();
                ho_Lines.Dispose();
                ho_Lines1.Dispose();
                ho_ContoursSplit.Dispose();
                ho_SelectedContours.Dispose();
                ho__Lines.Dispose();
                ho_o_Lines.Dispose();
                ho_startEdge.Dispose();
                ho_endEdge.Dispose();
                ho_UnionContour.Dispose();
                ho_MaxContour.Dispose();

                return;
            }
            //
            //*2--------------------------对线段进行排序、去除噪声线段
            HOperatorSet.AreaCenter(ho_i_RefReg, out hv_Area, out hv_RefRow, out hv_RefColumn);
            ho_o_Lines.Dispose();
            select_shortest_path(ho__Lines, ho_i_RefEdges, out ho_o_Lines, hv_RefRow, hv_RefColumn,
                hv_i_RegStartRow, hv_i_RegStartCol, hv_i_MaxWireGap);
            //
            //*4---------------------------对最终线段进行断线、弯曲线判断
            HOperatorSet.CountObj(ho_o_Lines, out hv_LineNum);

            if ((int)(new HTuple(hv_LineNum.TupleGreater(0))) != 0)
            {
                //
                //获取起始边缘
                ho_startEdge.Dispose();
                HOperatorSet.SelectObj(ho_i_RefEdges, out ho_startEdge, 1);
                ho_endEdge.Dispose();
                HOperatorSet.SelectObj(ho_i_RefEdges, out ho_endEdge, 2);
                //判断金线距离区域端点的距离是否满足小于Gap
                HOperatorSet.FitLineContourXld(ho_o_Lines, "huber", -1, 0, 5, 2, out hv_RowBegin,
                    out hv_ColBegin, out hv_RowEnd, out hv_ColEnd, out hv_Nr, out hv_Nc, out hv_Dist);
                hv_segIntervals = new HTuple();
                //起始线段端点到检测区域边缘的最短距离d1
                HOperatorSet.DistancePc(ho_startEdge, hv_RowBegin.TupleSelect(0), hv_ColBegin.TupleSelect(
                    0), out hv_Distance_Start1, out hv_DistanceMax);
                HOperatorSet.DistancePc(ho_startEdge, hv_RowEnd.TupleSelect(0), hv_ColEnd.TupleSelect(
                    0), out hv_Distance_Start2, out hv_DistanceMax);
                //结束线段端点到检测区域边缘的最短距离d2
                HOperatorSet.DistancePc(ho_endEdge, hv_RowBegin.TupleSelect(hv_LineNum - 1),
                    hv_ColBegin.TupleSelect(hv_LineNum - 1), out hv_Distance_End1, out hv_DistanceMax);
                HOperatorSet.DistancePc(ho_endEdge, hv_RowEnd.TupleSelect(hv_LineNum - 1), hv_ColEnd.TupleSelect(
                    hv_LineNum - 1), out hv_Distance_End2, out hv_DistanceMax);
                //
                hv_segIntervals = ((hv_segIntervals.TupleConcat(hv_Distance_Start1.TupleMin2(
                    hv_Distance_Start2)))).TupleConcat(hv_Distance_End1.TupleMin2(hv_Distance_End2));
                //判断间距是否超出阈值
                HOperatorSet.TupleGreaterElem(hv_segIntervals, hv_i_MaxWireGap, out hv_Greater);
                if ((int)(hv_Greater.TupleSum()) != 0)
                {
                    //有间距超限
                    hv_o_ErrCode = 12;
                    hv_o_ErrString = "broken line!";
                    ho_linesImage.Dispose();
                    ho_Lines.Dispose();
                    ho_Lines1.Dispose();
                    ho_ContoursSplit.Dispose();
                    ho_SelectedContours.Dispose();
                    ho__Lines.Dispose();
                    ho_o_Lines.Dispose();
                    ho_startEdge.Dispose();
                    ho_endEdge.Dispose();
                    ho_UnionContour.Dispose();
                    ho_MaxContour.Dispose();

                    return;
                }
                //判断是否弯线:使用检测起始点位置到线段各端点角度与检测区域角度进行弯曲线判断
                //Phi := []
                //for idx := 0 to LineNum-1 by 1
                //angle_ll (regStartRow, regStartCol, regEndRow, regEndCol, RowBegin[idx], ColBegin[idx], RowEnd[idx], ColEnd[idx], Angle)
                //转换角度Angle
                //if ((abs(Angle))> 1.0)
                //if (Angle>0)
                //Angle := -(rad(180)-Angle)
                //else
                //Angle := rad(180)+Angle
                //endif
                //endif
                //Phi := [Phi,Angle]
                //endfor
                //if (max(abs(Phi))>i_LinePhiDiff)
                //o_ErrCode := 13
                //o_ErrString := 'curve line!'
                //return ()
                //endif
            }
            else
            {
                hv_o_ErrCode = 12;
                hv_o_ErrString = "broken line or absent line!";
                ho_linesImage.Dispose();
                ho_Lines.Dispose();
                ho_Lines1.Dispose();
                ho_ContoursSplit.Dispose();
                ho_SelectedContours.Dispose();
                ho__Lines.Dispose();
                ho_o_Lines.Dispose();
                ho_startEdge.Dispose();
                ho_endEdge.Dispose();
                ho_UnionContour.Dispose();
                ho_MaxContour.Dispose();

                return;
            }
            //
            //*----------------------输出检测出的金线
            ho_UnionContour.Dispose();
            HOperatorSet.UnionAdjacentContoursXld(ho_o_Lines, out ho_UnionContour, hv_i_MaxWireGap,
                2, "attr_keep");
            HOperatorSet.LengthXld(ho_UnionContour, out hv_Length);
            HOperatorSet.TupleMax(hv_Length, out hv_MaxLen);
            HOperatorSet.TupleFind(hv_Length, hv_MaxLen, out hv_MaxIndice);
            ho_MaxContour.Dispose();
            HOperatorSet.SelectObj(ho_UnionContour, out ho_MaxContour, hv_MaxIndice + 1);
            ho_o_WireSeg.Dispose();
            HOperatorSet.SmoothContoursXld(ho_MaxContour, out ho_o_WireSeg, 21);
            hv_o_ErrCode = 0;
            hv_o_ErrString = "extract lines finished!";
            ho_linesImage.Dispose();
            ho_Lines.Dispose();
            ho_Lines1.Dispose();
            ho_ContoursSplit.Dispose();
            ho_SelectedContours.Dispose();
            ho__Lines.Dispose();
            ho_o_Lines.Dispose();
            ho_startEdge.Dispose();
            ho_endEdge.Dispose();
            ho_UnionContour.Dispose();
            ho_MaxContour.Dispose();

            return;

        }

        public static void HTV_WireSeg_Inspect_guass_pro(HObject ho_i_Image, HObject ho_i_InspectReg,
            HObject ho_i_StartReg, HObject ho_i_RefEdges, out HObject ho_o_WireSeg, HTuple hv_i_RefPhi,
            HTuple hv_i_WireWidth, HTuple hv_i_WireContrast, HTuple hv_i_Transition, HTuple hv_i_SelMetric,
            HTuple hv_i_SelMax, HTuple hv_i_SelMin, HTuple hv_i_LinePhiDiff, HTuple hv_i_MaxWireGap,
            HTuple hv_i_DoubleLinesFlag, HTuple hv_i_DoubleLinesType, HTuple hv_i_MorphSize,
            HTuple hv_i_regStartRow, HTuple hv_i_regStartCol, HTuple hv_i_regEndRow, HTuple hv_i_regEndCol,
            out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho__InspectReg = null, ho_ImagePart = null;
            HObject ho_ImageMorph = null, ho__InspectRegPart = null, ho_linesImagePart = null;
            HObject ho_LinesPart = null, ho_LinesTmp = null, ho_Lines = null;
            HObject ho_curLinePart = null, ho_curLine = null, ho_linesImage = null;
            HObject ho_Lines1 = null, ho_ContoursSplit, ho_SelectedContours;
            HObject ho__Lines, ho_o_Lines, ho_UnionContour;

            // Local control variables 

            HTuple hv_imgNum = null, hv_o_ErrString = null;
            HTuple hv_regNum = null, hv_Area = null, hv__RefRow = null;
            HTuple hv__RefCol = null, hv_regStartRow = null, hv_regStartCol = null;
            HTuple hv_regEndRow = null, hv_regEndCol = null, hv_LtRow = new HTuple();
            HTuple hv_LtColumn = new HTuple(), hv_RbRow = new HTuple();
            HTuple hv_RbColumn = new HTuple(), hv_Sigma = new HTuple();
            HTuple hv_Low = new HTuple(), hv_High = new HTuple(), hv_linePartNum = new HTuple();
            HTuple hv_idx = new HTuple(), hv_ContRows = new HTuple();
            HTuple hv_ContCols = new HTuple(), hv_pos = null, hv_selGE = null;
            HTuple hv_selIndices = null, hv_MinPhi = new HTuple();
            HTuple hv_MaxPhi = new HTuple(), hv_lineSelNum = null;
            HTuple hv_LineNum = null, hv_RowBegin = new HTuple(), hv_ColBegin = new HTuple();
            HTuple hv_RowEnd = new HTuple(), hv_ColEnd = new HTuple();
            HTuple hv_Nr = new HTuple(), hv_Nc = new HTuple(), hv_Dist = new HTuple();
            HTuple hv_Phi = new HTuple(), hv_Angle = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_WireSeg);
            HOperatorSet.GenEmptyObj(out ho__InspectReg);
            HOperatorSet.GenEmptyObj(out ho_ImagePart);
            HOperatorSet.GenEmptyObj(out ho_ImageMorph);
            HOperatorSet.GenEmptyObj(out ho__InspectRegPart);
            HOperatorSet.GenEmptyObj(out ho_linesImagePart);
            HOperatorSet.GenEmptyObj(out ho_LinesPart);
            HOperatorSet.GenEmptyObj(out ho_LinesTmp);
            HOperatorSet.GenEmptyObj(out ho_Lines);
            HOperatorSet.GenEmptyObj(out ho_curLinePart);
            HOperatorSet.GenEmptyObj(out ho_curLine);
            HOperatorSet.GenEmptyObj(out ho_linesImage);
            HOperatorSet.GenEmptyObj(out ho_Lines1);
            HOperatorSet.GenEmptyObj(out ho_ContoursSplit);
            HOperatorSet.GenEmptyObj(out ho_SelectedContours);
            HOperatorSet.GenEmptyObj(out ho__Lines);
            HOperatorSet.GenEmptyObj(out ho_o_Lines);
            HOperatorSet.GenEmptyObj(out ho_UnionContour);
            try
            {
                //***********************************************************************
                //*******  在IC图中检测焊点附近的焊线，判断是否断线
                //*******  i_Image: IC图像
                //*******  o_WireSeg: 检测到的线段
                //*******  i_InspectReg: 线检测区域
                //*******  i_StartReg：线检测起始点区域
                //*******  i_RefPhi: 线参考方向
                //*******  i_WireWidth: 线宽设置
                //*******  i_WireContrast: 线的对比度设置
                //*******  o_ErrCode: 检测结果标志，0-表示检测到线段，1-表示没有检测到线段，即此处断线，-2-为初始化值
                //*******  o_ErrStr: 执行结果描述
                //***********************************************************************
                //输出初始化
                ho_o_WireSeg.Dispose();
                HOperatorSet.GenEmptyObj(out ho_o_WireSeg);
                hv_o_ErrCode = -2;
                hv_o_ErrStr = "initializing";
                //

                //输入合法性检测
                HOperatorSet.CountObj(ho_i_Image, out hv_imgNum);
                if ((int)(new HTuple(hv_imgNum.TupleEqual(0))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrString = "input image is empty!";
                    ho__InspectReg.Dispose();
                    ho_ImagePart.Dispose();
                    ho_ImageMorph.Dispose();
                    ho__InspectRegPart.Dispose();
                    ho_linesImagePart.Dispose();
                    ho_LinesPart.Dispose();
                    ho_LinesTmp.Dispose();
                    ho_Lines.Dispose();
                    ho_curLinePart.Dispose();
                    ho_curLine.Dispose();
                    ho_linesImage.Dispose();
                    ho_Lines1.Dispose();
                    ho_ContoursSplit.Dispose();
                    ho_SelectedContours.Dispose();
                    ho__Lines.Dispose();
                    ho_o_Lines.Dispose();
                    ho_UnionContour.Dispose();

                    return;
                }
                HOperatorSet.CountObj(ho_i_InspectReg, out hv_regNum);
                if ((int)(new HTuple(hv_regNum.TupleEqual(0))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrString = "inspect region is empty!";
                    ho__InspectReg.Dispose();
                    ho_ImagePart.Dispose();
                    ho_ImageMorph.Dispose();
                    ho__InspectRegPart.Dispose();
                    ho_linesImagePart.Dispose();
                    ho_LinesPart.Dispose();
                    ho_LinesTmp.Dispose();
                    ho_Lines.Dispose();
                    ho_curLinePart.Dispose();
                    ho_curLine.Dispose();
                    ho_linesImage.Dispose();
                    ho_Lines1.Dispose();
                    ho_ContoursSplit.Dispose();
                    ho_SelectedContours.Dispose();
                    ho__Lines.Dispose();
                    ho_o_Lines.Dispose();
                    ho_UnionContour.Dispose();

                    return;
                }
                if ((int)((new HTuple((new HTuple(hv_i_WireWidth.TupleLength())).TupleEqual(
                    0))).TupleOr(new HTuple(hv_i_WireWidth.TupleLess(1)))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrString = "inspect coef i_LineWidth must be above zero!";
                    ho__InspectReg.Dispose();
                    ho_ImagePart.Dispose();
                    ho_ImageMorph.Dispose();
                    ho__InspectRegPart.Dispose();
                    ho_linesImagePart.Dispose();
                    ho_LinesPart.Dispose();
                    ho_LinesTmp.Dispose();
                    ho_Lines.Dispose();
                    ho_curLinePart.Dispose();
                    ho_curLine.Dispose();
                    ho_linesImage.Dispose();
                    ho_Lines1.Dispose();
                    ho_ContoursSplit.Dispose();
                    ho_SelectedContours.Dispose();
                    ho__Lines.Dispose();
                    ho_o_Lines.Dispose();
                    ho_UnionContour.Dispose();

                    return;
                }
                if ((int)((new HTuple((new HTuple(hv_i_WireContrast.TupleLength())).TupleEqual(
                    0))).TupleOr(new HTuple(hv_i_WireContrast.TupleLess(10)))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrString = "inspect coef i_LineContrast must be above 20!";
                    ho__InspectReg.Dispose();
                    ho_ImagePart.Dispose();
                    ho_ImageMorph.Dispose();
                    ho__InspectRegPart.Dispose();
                    ho_linesImagePart.Dispose();
                    ho_LinesPart.Dispose();
                    ho_LinesTmp.Dispose();
                    ho_Lines.Dispose();
                    ho_curLinePart.Dispose();
                    ho_curLine.Dispose();
                    ho_linesImage.Dispose();
                    ho_Lines1.Dispose();
                    ho_ContoursSplit.Dispose();
                    ho_SelectedContours.Dispose();
                    ho__Lines.Dispose();
                    ho_o_Lines.Dispose();
                    ho_UnionContour.Dispose();

                    return;
                }

                //
                //*1-------------------金线检测区域参考端点、参考宽度获取
                //金线起始点
                HOperatorSet.AreaCenter(ho_i_StartReg, out hv_Area, out hv__RefRow, out hv__RefCol);
                //起始端点确定:计算区域起始及结束点位置到参考点的距离
                hv_regStartRow = hv_i_regStartRow.Clone();
                hv_regStartCol = hv_i_regStartCol.Clone();
                hv_regEndRow = hv_i_regEndRow.Clone();
                hv_regEndCol = hv_i_regEndCol.Clone();

                //
                //*2-------------------------检测区域获取并提取线段
                if ((int)(hv_i_DoubleLinesFlag) != 0)
                {
                    //局部图
                    ho__InspectReg.Dispose();
                    HOperatorSet.DilationRectangle1(ho_i_InspectReg, out ho__InspectReg, hv_i_MorphSize,
                        hv_i_MorphSize);
                    //局部图预处理
                    HOperatorSet.SmallestRectangle1(ho__InspectReg, out hv_LtRow, out hv_LtColumn,
                        out hv_RbRow, out hv_RbColumn);
                    ho_ImagePart.Dispose();
                    HOperatorSet.CropRectangle1(ho_i_Image, out ho_ImagePart, hv_LtRow, hv_LtColumn,
                        hv_RbRow, hv_RbColumn);

                    if ((int)(new HTuple(hv_i_DoubleLinesType.TupleEqual("light_dark_light"))) != 0)
                    {
                        //针对白黑白图
                        ho_ImageMorph.Dispose();
                        HOperatorSet.GrayClosingRect(ho_ImagePart, out ho_ImageMorph, hv_i_MorphSize,
                            hv_i_MorphSize);
                    }
                    else
                    {
                        //针对黑白黑图
                        ho_ImageMorph.Dispose();
                        HOperatorSet.GrayOpeningRect(ho_ImagePart, out ho_ImageMorph, hv_i_MorphSize,
                            hv_i_MorphSize);
                    }

                    ho__InspectRegPart.Dispose();
                    HOperatorSet.MoveRegion(ho_i_InspectReg, out ho__InspectRegPart, -hv_LtRow,
                        -hv_LtColumn);
                    ho_linesImagePart.Dispose();
                    HOperatorSet.ReduceDomain(ho_ImageMorph, ho__InspectRegPart, out ho_linesImagePart
                        );

                    //局部图lineguass
                    calculate_lines_gauss_parameters(hv_i_WireWidth, hv_i_WireContrast, out hv_Sigma,
                        out hv_Low, out hv_High);
                    if ((int)(new HTuple(hv_i_Transition.TupleEqual("all"))) != 0)
                    {
                        ho_LinesPart.Dispose();
                        HOperatorSet.LinesGauss(ho_linesImagePart, out ho_LinesPart, hv_Sigma,
                            hv_Low, hv_High, "dark", "true", "bar-shaped", "true");
                        ho_LinesTmp.Dispose();
                        HOperatorSet.LinesGauss(ho_linesImagePart, out ho_LinesTmp, hv_Sigma, hv_Low,
                            hv_High, "light", "true", "bar-shaped", "true");
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(ho_LinesPart, ho_LinesTmp, out ExpTmpOutVar_0);
                            ho_LinesPart.Dispose();
                            ho_LinesPart = ExpTmpOutVar_0;
                        }
                    }
                    else
                    {
                        ho_LinesPart.Dispose();
                        HOperatorSet.LinesGauss(ho_linesImagePart, out ho_LinesPart, hv_Sigma,
                            hv_Low, hv_High, hv_i_Transition, "true", "bar-shaped", "false");
                    }

                    //坐标还原至大图
                    ho_Lines.Dispose();
                    HOperatorSet.GenEmptyObj(out ho_Lines);
                    HOperatorSet.CountObj(ho_LinesPart, out hv_linePartNum);
                    HTuple end_val85 = hv_linePartNum;
                    HTuple step_val85 = 1;
                    for (hv_idx = 1; hv_idx.Continue(end_val85, step_val85); hv_idx = hv_idx.TupleAdd(step_val85))
                    {
                        ho_curLinePart.Dispose();
                        HOperatorSet.SelectObj(ho_LinesPart, out ho_curLinePart, hv_idx);
                        HOperatorSet.GetContourXld(ho_curLinePart, out hv_ContRows, out hv_ContCols);
                        hv_ContRows = hv_ContRows + hv_LtRow;
                        hv_ContCols = hv_ContCols + hv_LtColumn;
                        ho_curLine.Dispose();
                        HOperatorSet.GenContourPolygonXld(out ho_curLine, hv_ContRows, hv_ContCols);
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(ho_Lines, ho_curLine, out ExpTmpOutVar_0);
                            ho_Lines.Dispose();
                            ho_Lines = ExpTmpOutVar_0;
                        }
                    }
                }
                else
                {
                    //整图lineguass
                    ho_linesImage.Dispose();
                    HOperatorSet.ReduceDomain(ho_i_Image, ho_i_InspectReg, out ho_linesImage);

                    calculate_lines_gauss_parameters(hv_i_WireWidth, hv_i_WireContrast, out hv_Sigma,
                        out hv_Low, out hv_High);
                    if ((int)(new HTuple(hv_i_Transition.TupleEqual("all"))) != 0)
                    {
                        ho_Lines.Dispose();
                        HOperatorSet.LinesGauss(ho_linesImage, out ho_Lines, hv_Sigma, hv_Low,
                            hv_High, "dark", "true", "bar-shaped", "true");
                        ho_Lines1.Dispose();
                        HOperatorSet.LinesGauss(ho_linesImage, out ho_Lines1, hv_Sigma, hv_Low,
                            hv_High, "light", "true", "bar-shaped", "true");
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(ho_Lines, ho_Lines1, out ExpTmpOutVar_0);
                            ho_Lines.Dispose();
                            ho_Lines = ExpTmpOutVar_0;
                        }
                    }
                    else
                    {
                        ho_Lines.Dispose();
                        HOperatorSet.LinesGauss(ho_linesImage, out ho_Lines, hv_Sigma, hv_Low,
                            hv_High, hv_i_Transition, "true", "bar-shaped", "true");
                    }
                }

                //
                //*3---------------------对line_gauaa获取的线段进行初次筛选并判定
                ho_ContoursSplit.Dispose();
                HOperatorSet.SegmentContoursXld(ho_Lines, out ho_ContoursSplit, "lines", 2,
                    1, 1);
                //如果进行角度筛选，需要参考检测区域的方向
                HOperatorSet.TupleStrstr(hv_i_SelMetric, "direction", out hv_pos);
                HOperatorSet.TupleGreaterEqualElem(hv_pos, 0, out hv_selGE);
                HOperatorSet.TupleFind(hv_selGE, 1, out hv_selIndices);
                //根据参考方向确定方向范围
                if ((int)(new HTuple(hv_selIndices.TupleGreaterEqual(0))) != 0)
                {
                    hv_MinPhi = hv_i_RefPhi + (hv_i_SelMin.TupleSelect(hv_selIndices));
                    hv_MaxPhi = hv_i_RefPhi + (hv_i_SelMax.TupleSelect(hv_selIndices));
                }
                //按照最小线长度、方向角度初步筛选线段
                ho_SelectedContours.Dispose();
                HOperatorSet.SelectContoursXld(ho_ContoursSplit, out ho_SelectedContours, hv_i_SelMetric.TupleSelect(
                    0), hv_i_SelMin.TupleSelect(0), hv_i_SelMax.TupleSelect(0), -0.5, 0.5);
                ho__Lines.Dispose();
                HOperatorSet.SelectContoursXld(ho_SelectedContours, out ho__Lines, hv_i_SelMetric.TupleSelect(
                    1), hv_MinPhi, hv_MaxPhi, -0.5, 0.5);
                //分析检测结果
                HOperatorSet.CountObj(ho__Lines, out hv_lineSelNum);
                if ((int)(new HTuple(hv_lineSelNum.TupleLess(1))) != 0)
                {
                    hv_o_ErrCode = 12;
                    hv_o_ErrString = "broken line or absent line!";
                    ho__InspectReg.Dispose();
                    ho_ImagePart.Dispose();
                    ho_ImageMorph.Dispose();
                    ho__InspectRegPart.Dispose();
                    ho_linesImagePart.Dispose();
                    ho_LinesPart.Dispose();
                    ho_LinesTmp.Dispose();
                    ho_Lines.Dispose();
                    ho_curLinePart.Dispose();
                    ho_curLine.Dispose();
                    ho_linesImage.Dispose();
                    ho_Lines1.Dispose();
                    ho_ContoursSplit.Dispose();
                    ho_SelectedContours.Dispose();
                    ho__Lines.Dispose();
                    ho_o_Lines.Dispose();
                    ho_UnionContour.Dispose();

                    return;
                }
                //
                //*4--------------------------对线段进行排序、去除噪声线段
                //计算参考长度
                //
                ho_o_Lines.Dispose();
                HTV_select_shortest_path(ho__Lines, ho_i_RefEdges, out ho_o_Lines, hv__RefRow,
                    hv__RefCol, hv_regStartRow, hv_regStartCol, hv_regEndRow, hv_regEndCol,
                    hv_i_MaxWireGap, hv_i_WireWidth, hv_i_RefPhi);
                //
                //*5---------------------------对最终线段进行弯曲线判断
                HOperatorSet.CountObj(ho_o_Lines, out hv_LineNum);
                if ((int)(new HTuple(hv_LineNum.TupleGreater(0))) != 0)
                {
                    //
                    HOperatorSet.FitLineContourXld(ho_o_Lines, "huber", -1, 0, 5, 2, out hv_RowBegin,
                        out hv_ColBegin, out hv_RowEnd, out hv_ColEnd, out hv_Nr, out hv_Nc,
                        out hv_Dist);
                    //****判断是否具有弯曲线段
                    hv_Phi = new HTuple();
                    HTuple end_val142 = hv_LineNum - 1;
                    HTuple step_val142 = 1;
                    for (hv_idx = 0; hv_idx.Continue(end_val142, step_val142); hv_idx = hv_idx.TupleAdd(step_val142))
                    {
                        HOperatorSet.AngleLl(hv_regStartRow, hv_regStartCol, hv_regEndRow, hv_regEndCol,
                            hv_RowBegin.TupleSelect(hv_idx), hv_ColBegin.TupleSelect(hv_idx), hv_RowEnd.TupleSelect(
                            hv_idx), hv_ColEnd.TupleSelect(hv_idx), out hv_Angle);
                        //转换角度Angle
                        if ((int)(new HTuple(((hv_Angle.TupleAbs())).TupleGreater(1.0))) != 0)
                        {
                            if ((int)(new HTuple(hv_Angle.TupleGreater(0))) != 0)
                            {
                                hv_Angle = -(((new HTuple(180)).TupleRad()) - hv_Angle);
                            }
                            else
                            {
                                hv_Angle = ((new HTuple(180)).TupleRad()) + hv_Angle;
                            }
                        }
                        hv_Phi = hv_Phi.TupleConcat(hv_Angle);
                    }
                    if ((int)(new HTuple(((((hv_Phi.TupleAbs())).TupleMax())).TupleGreater(hv_i_LinePhiDiff))) != 0)
                    {
                        hv_o_ErrCode = 13;
                        hv_o_ErrString = "curve line!";
                        ho__InspectReg.Dispose();
                        ho_ImagePart.Dispose();
                        ho_ImageMorph.Dispose();
                        ho__InspectRegPart.Dispose();
                        ho_linesImagePart.Dispose();
                        ho_LinesPart.Dispose();
                        ho_LinesTmp.Dispose();
                        ho_Lines.Dispose();
                        ho_curLinePart.Dispose();
                        ho_curLine.Dispose();
                        ho_linesImage.Dispose();
                        ho_Lines1.Dispose();
                        ho_ContoursSplit.Dispose();
                        ho_SelectedContours.Dispose();
                        ho__Lines.Dispose();
                        ho_o_Lines.Dispose();
                        ho_UnionContour.Dispose();

                        return;
                    }
                }
                else
                {
                    hv_o_ErrCode = 12;
                    hv_o_ErrString = "broken line or absent line!";
                    ho__InspectReg.Dispose();
                    ho_ImagePart.Dispose();
                    ho_ImageMorph.Dispose();
                    ho__InspectRegPart.Dispose();
                    ho_linesImagePart.Dispose();
                    ho_LinesPart.Dispose();
                    ho_LinesTmp.Dispose();
                    ho_Lines.Dispose();
                    ho_curLinePart.Dispose();
                    ho_curLine.Dispose();
                    ho_linesImage.Dispose();
                    ho_Lines1.Dispose();
                    ho_ContoursSplit.Dispose();
                    ho_SelectedContours.Dispose();
                    ho__Lines.Dispose();
                    ho_o_Lines.Dispose();
                    ho_UnionContour.Dispose();

                    return;
                }
                //
                //*----------------------输出检测出的金线
                ho_UnionContour.Dispose();
                HOperatorSet.UnionAdjacentContoursXld(ho_o_Lines, out ho_UnionContour, hv_i_MaxWireGap,
                    2, "attr_keep");
                ho_o_WireSeg.Dispose();
                HOperatorSet.SmoothContoursXld(ho_UnionContour, out ho_o_WireSeg, 21);
                hv_o_ErrCode = 0;
                hv_o_ErrString = "extract lines finished!";
                ho__InspectReg.Dispose();
                ho_ImagePart.Dispose();
                ho_ImageMorph.Dispose();
                ho__InspectRegPart.Dispose();
                ho_linesImagePart.Dispose();
                ho_LinesPart.Dispose();
                ho_LinesTmp.Dispose();
                ho_Lines.Dispose();
                ho_curLinePart.Dispose();
                ho_curLine.Dispose();
                ho_linesImage.Dispose();
                ho_Lines1.Dispose();
                ho_ContoursSplit.Dispose();
                ho_SelectedContours.Dispose();
                ho__Lines.Dispose();
                ho_o_Lines.Dispose();
                ho_UnionContour.Dispose();

                return;

            }
            catch (HalconException HDevExpDefaultException)
            {
                ho__InspectReg.Dispose();
                ho_ImagePart.Dispose();
                ho_ImageMorph.Dispose();
                ho__InspectRegPart.Dispose();
                ho_linesImagePart.Dispose();
                ho_LinesPart.Dispose();
                ho_LinesTmp.Dispose();
                ho_Lines.Dispose();
                ho_curLinePart.Dispose();
                ho_curLine.Dispose();
                ho_linesImage.Dispose();
                ho_Lines1.Dispose();
                ho_ContoursSplit.Dispose();
                ho_SelectedContours.Dispose();
                ho__Lines.Dispose();
                ho_o_Lines.Dispose();
                ho_UnionContour.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public static void HTV_TailWire_Extract_Gauss(HObject ho_i_Image, HObject ho_i_LinesReg,
            HTuple hv_i_RefPhi, HTuple hv_i_LineWidth, HTuple hv_i_LineContrast, HTuple hv_i_Transition,
            HTuple hv_i_SelMetric, HTuple hv_i_SelMin, HTuple hv_i_SelMax, HTuple hv_i_LineGap,
            HTuple hv_i_RefRow, HTuple hv_i_RefCol, out HTuple hv_o_TailWireFlag)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_o_Lines, ho_linesImage, ho_ImageGauss;
            HObject ho_Lines = null, ho_Lines1 = null, ho_ContoursSplit;
            HObject ho_SelectedContours, ho__Lines, ho_ObjectSelected = null;

            // Local control variables 

            HTuple hv_o_ErrString = null, hv_imgNum = null;
            HTuple hv_regNum = null, hv_Sigma = null, hv_Low = null;
            HTuple hv_High = null, hv_pos = null, hv_selGE = null;
            HTuple hv_selIndices = null, hv_lineSegNum = null, hv_RowReg = null;
            HTuple hv_ColReg = null, hv_regPhi = null, hv_regLenHalf = null;
            HTuple hv_regWidthHalf = null, hv_RowBegin = null, hv_ColBegin = null;
            HTuple hv_RowEnd = null, hv_ColEnd = null, hv_Nr = null;
            HTuple hv_Nc = null, hv_Dist = null, hv_regStartRow = null;
            HTuple hv_regStartCol = null, hv_regEndRow = null, hv_regEndCol = null;
            HTuple hv_idx = null, hv_Distance1 = new HTuple(), hv_Distance2 = new HTuple();
            HTuple hv_Mean = new HTuple(), hv_lineSelNum = null, hv_RefDistance1 = null;
            HTuple hv_RefDistance2 = null, hv_RefRow = new HTuple();
            HTuple hv_RefCol = new HTuple(), hv_MinDistance = null;
            HTuple hv_IdxWire = null, hv_RowBegin1 = new HTuple();
            HTuple hv_ColBegin1 = new HTuple(), hv_RowEnd1 = new HTuple();
            HTuple hv_ColEnd1 = new HTuple(), hv_D1 = new HTuple();
            HTuple hv_D2 = new HTuple(), hv_Min = new HTuple();
            HTuple hv_i_SelMax_COPY_INP_TMP = hv_i_SelMax.Clone();
            HTuple hv_i_SelMin_COPY_INP_TMP = hv_i_SelMin.Clone();

            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_Lines);
            HOperatorSet.GenEmptyObj(out ho_linesImage);
            HOperatorSet.GenEmptyObj(out ho_ImageGauss);
            HOperatorSet.GenEmptyObj(out ho_Lines);
            HOperatorSet.GenEmptyObj(out ho_Lines1);
            HOperatorSet.GenEmptyObj(out ho_ContoursSplit);
            HOperatorSet.GenEmptyObj(out ho_SelectedContours);
            HOperatorSet.GenEmptyObj(out ho__Lines);
            HOperatorSet.GenEmptyObj(out ho_ObjectSelected);
            //********************************************************************************************************************
            // 高斯剖面曲线法提取区域内的线目标（如：金线、划痕等）
            // i_Image: 输入图像，待处理图像
            // i_LinesReg: 线目标提取区域
            // o_Wire: 提取的线目标对象
            // i_LineWidth: 线目标的宽度
            // i_LineContrast: 线目标的对比度，一般大于20
            // i_SelMetric: 筛选目标时的特征量，为一个字符串序列，见select_shape的特征取值
            // i_SelMin: 筛选特征时满足的最小值，每个特征对应一个最小值
            // i_SelMax: 筛选特征时满足的最大值，每个特征对应一个最大值
            // i_LineGap: 检测过程允许的最大断线间隔
            // i_LineWidthMax: 最大允许线宽
            // o_LineWidth: 实际检测线宽
            // o_ErrCode: 错误码，代表该算子执行过程中产生的错误，0-代表正常执行，自然数-代表错误类型，-1-代表异常，-2-代表未执行
            // o_ErrStr: 错误信息，对各种错误的具体描述
            //********************************************************************************************************************

            //初始化
            hv_o_TailWireFlag = -2;
            hv_o_ErrString = "Initializing!";
            ho_o_Lines.Dispose();
            HOperatorSet.GenEmptyObj(out ho_o_Lines);
            //输入合法性检测
            HOperatorSet.CountObj(ho_i_Image, out hv_imgNum);
            if ((int)(new HTuple(hv_imgNum.TupleEqual(0))) != 0)
            {
                hv_o_TailWireFlag = -1;
                hv_o_ErrString = "input image is empty!";
                ho_o_Lines.Dispose();
                ho_linesImage.Dispose();
                ho_ImageGauss.Dispose();
                ho_Lines.Dispose();
                ho_Lines1.Dispose();
                ho_ContoursSplit.Dispose();
                ho_SelectedContours.Dispose();
                ho__Lines.Dispose();
                ho_ObjectSelected.Dispose();

                return;
            }
            HOperatorSet.CountObj(ho_i_LinesReg, out hv_regNum);
            if ((int)(new HTuple(hv_regNum.TupleEqual(0))) != 0)
            {
                hv_o_TailWireFlag = -1;
                hv_o_ErrString = "inspect region is empty!";
                ho_o_Lines.Dispose();
                ho_linesImage.Dispose();
                ho_ImageGauss.Dispose();
                ho_Lines.Dispose();
                ho_Lines1.Dispose();
                ho_ContoursSplit.Dispose();
                ho_SelectedContours.Dispose();
                ho__Lines.Dispose();
                ho_ObjectSelected.Dispose();

                return;
            }

            if ((int)((new HTuple((new HTuple(hv_i_LineWidth.TupleLength())).TupleEqual(0))).TupleOr(
                new HTuple(hv_i_LineWidth.TupleLess(1)))) != 0)
            {
                hv_o_TailWireFlag = -1;
                hv_o_ErrString = "inspect coef i_LineWidth must be above zero!";
                ho_o_Lines.Dispose();
                ho_linesImage.Dispose();
                ho_ImageGauss.Dispose();
                ho_Lines.Dispose();
                ho_Lines1.Dispose();
                ho_ContoursSplit.Dispose();
                ho_SelectedContours.Dispose();
                ho__Lines.Dispose();
                ho_ObjectSelected.Dispose();

                return;
            }
            if ((int)((new HTuple((new HTuple(hv_i_LineContrast.TupleLength())).TupleEqual(
                0))).TupleOr(new HTuple(hv_i_LineContrast.TupleLess(10)))) != 0)
            {
                hv_o_TailWireFlag = -1;
                hv_o_ErrString = "inspect coef i_LineContrast must be above 20!";
                ho_o_Lines.Dispose();
                ho_linesImage.Dispose();
                ho_ImageGauss.Dispose();
                ho_Lines.Dispose();
                ho_Lines1.Dispose();
                ho_ContoursSplit.Dispose();
                ho_SelectedContours.Dispose();
                ho__Lines.Dispose();
                ho_ObjectSelected.Dispose();

                return;
            }
            // 高斯剖面曲线法提取区域内的线目标轮廓
            ho_linesImage.Dispose();
            HOperatorSet.ReduceDomain(ho_i_Image, ho_i_LinesReg, out ho_linesImage);
            //高斯滤波
            ho_ImageGauss.Dispose();
            HOperatorSet.GaussFilter(ho_linesImage, out ho_ImageGauss, 3);
            calculate_lines_gauss_parameters(hv_i_LineWidth, hv_i_LineContrast + 20, out hv_Sigma,
                out hv_Low, out hv_High);
            if ((int)(new HTuple(((hv_i_Transition.TupleSelect(0))).TupleEqual("all"))) != 0)
            {
                ho_Lines.Dispose();
                HOperatorSet.LinesGauss(ho_linesImage, out ho_Lines, hv_Sigma, hv_Low, hv_High,
                    "dark", "true", "bar-shaped", "true");
                ho_Lines1.Dispose();
                HOperatorSet.LinesGauss(ho_linesImage, out ho_Lines1, hv_Sigma, hv_Low, hv_High,
                    "light", "true", "bar-shaped", "true");
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.ConcatObj(ho_Lines, ho_Lines1, out ExpTmpOutVar_0);
                    ho_Lines.Dispose();
                    ho_Lines = ExpTmpOutVar_0;
                }
            }
            else
            {
                ho_Lines.Dispose();
                HOperatorSet.LinesGauss(ho_linesImage, out ho_Lines, hv_Sigma, hv_Low, hv_High,
                    hv_i_Transition.TupleSelect(0), "true", "bar-shaped", "true");
            }
            ho_ContoursSplit.Dispose();
            HOperatorSet.SegmentContoursXld(ho_Lines, out ho_ContoursSplit, "lines", 2, 1,
                1);
            //如果进行角度筛选，需要参考检测区域的方向
            HOperatorSet.TupleStrstr(hv_i_SelMetric, "direction", out hv_pos);
            HOperatorSet.TupleGreaterEqualElem(hv_pos, 0, out hv_selGE);
            HOperatorSet.TupleFind(hv_selGE, 1, out hv_selIndices);
            //根据参考方向确定方向范围
            if ((int)(new HTuple(hv_selIndices.TupleGreaterEqual(0))) != 0)
            {
                //orientation_region (i_LinesReg, refPhi)
                //if (refPhi<0)
                //refPhi := 2*3.1415926+refPhi
                //endif
                if (hv_i_SelMin_COPY_INP_TMP == null)
                    hv_i_SelMin_COPY_INP_TMP = new HTuple();
                hv_i_SelMin_COPY_INP_TMP[hv_selIndices] = hv_i_RefPhi + (hv_i_SelMin_COPY_INP_TMP.TupleSelect(
                    hv_selIndices));
                if (hv_i_SelMax_COPY_INP_TMP == null)
                    hv_i_SelMax_COPY_INP_TMP = new HTuple();
                hv_i_SelMax_COPY_INP_TMP[hv_selIndices] = hv_i_RefPhi + (hv_i_SelMax_COPY_INP_TMP.TupleSelect(
                    hv_selIndices));
            }
            //**************筛选轮廓线
            //按照最小线长度筛选，2020.2.20
            ho_SelectedContours.Dispose();
            HOperatorSet.SelectContoursXld(ho_ContoursSplit, out ho_SelectedContours, hv_i_SelMetric.TupleSelect(
                0), (hv_i_SelMin_COPY_INP_TMP.TupleSelect(0)) + 1, hv_i_SelMax_COPY_INP_TMP.TupleSelect(
                0), -0.5, 0.5);
            ho__Lines.Dispose();
            HOperatorSet.SelectContoursXld(ho_SelectedContours, out ho__Lines, hv_i_SelMetric.TupleSelect(
                1), hv_i_SelMin_COPY_INP_TMP.TupleSelect(1), hv_i_SelMax_COPY_INP_TMP.TupleSelect(
                1), -0.5, 0.5);
            //---------------------------------------------------------------
            HOperatorSet.CountObj(ho__Lines, out hv_lineSegNum);
            //------对噪声线段进行筛选
            HOperatorSet.SmallestRectangle2(ho_i_LinesReg, out hv_RowReg, out hv_ColReg,
                out hv_regPhi, out hv_regLenHalf, out hv_regWidthHalf);
            HOperatorSet.FitLineContourXld(ho__Lines, "huber", -1, 0, 5, 2, out hv_RowBegin,
                out hv_ColBegin, out hv_RowEnd, out hv_ColEnd, out hv_Nr, out hv_Nc, out hv_Dist);
            //检测区域起始位置
            hv_regStartRow = hv_RowReg + (hv_regLenHalf * (((-hv_regPhi)).TupleSin()));
            hv_regStartCol = hv_ColReg + (hv_regLenHalf * (((-hv_regPhi)).TupleCos()));
            //检测区域结束点位置
            hv_regEndRow = hv_RowReg - (hv_regLenHalf * (((-hv_regPhi)).TupleSin()));
            hv_regEndCol = hv_ColReg - (hv_regLenHalf * (((-hv_regPhi)).TupleCos()));
            //筛选噪声线段
            HTuple end_val87 = hv_lineSegNum - 1;
            HTuple step_val87 = 1;
            for (hv_idx = 0; hv_idx.Continue(end_val87, step_val87); hv_idx = hv_idx.TupleAdd(step_val87))
            {
                //计算线段间的距离
                ho_ObjectSelected.Dispose();
                HOperatorSet.SelectObj(ho__Lines, out ho_ObjectSelected, hv_idx + 1);
                HOperatorSet.DistancePl(hv_RowBegin.TupleSelect(hv_idx), hv_ColBegin.TupleSelect(
                    hv_idx), hv_regStartRow, hv_regStartCol, hv_regEndRow, hv_regEndCol, out hv_Distance1);
                HOperatorSet.DistancePl(hv_RowEnd.TupleSelect(hv_idx), hv_ColEnd.TupleSelect(
                    hv_idx), hv_regStartRow, hv_regStartCol, hv_regEndRow, hv_regEndCol, out hv_Distance2);
                HOperatorSet.TupleMean(hv_Distance1.TupleConcat(hv_Distance2), out hv_Mean);
                //distance_ss (RowBegin[idx], ColBegin[idx], RowEnd[idx], ColEnd[idx], regStartRow, regStartCol, regEndRow, regEndCol, DistanceMin, DistanceMax)
                if ((int)(new HTuple(hv_Mean.TupleLess(hv_regWidthHalf))) != 0)
                {
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_o_Lines, ho_ObjectSelected, out ExpTmpOutVar_0);
                        ho_o_Lines.Dispose();
                        ho_o_Lines = ExpTmpOutVar_0;
                    }
                }
            }
            //*********************** 分析检测结果
            HOperatorSet.CountObj(ho_o_Lines, out hv_lineSelNum);
            if ((int)(new HTuple(hv_lineSelNum.TupleLess(1))) != 0)
            {
                hv_o_TailWireFlag = 0;
                ho_o_Lines.Dispose();
                ho_linesImage.Dispose();
                ho_ImageGauss.Dispose();
                ho_Lines.Dispose();
                ho_Lines1.Dispose();
                ho_ContoursSplit.Dispose();
                ho_SelectedContours.Dispose();
                ho__Lines.Dispose();
                ho_ObjectSelected.Dispose();

                return;
            }
            //----------------------------------------------------------
            //-------------------------------------------------------------------------------------------
            //判断是否是尾丝：利用线段端点到焊点为最短距离小于LineGap为标准

            //寻找距离参考点最近的区域起始点
            //计算区域起始及结束点位置到参考点的距离
            HOperatorSet.DistancePp(hv_regStartRow, hv_regStartCol, hv_i_RefRow, hv_i_RefCol,
                out hv_RefDistance1);
            HOperatorSet.DistancePp(hv_regEndRow, hv_regEndCol, hv_i_RefRow, hv_i_RefCol,
                out hv_RefDistance2);
            if ((int)(new HTuple(hv_RefDistance1.TupleLess(hv_RefDistance2))) != 0)
            {
                hv_RefRow = hv_regStartRow.Clone();
                hv_RefCol = hv_regStartCol.Clone();
            }
            else
            {
                hv_RefRow = hv_regEndRow.Clone();
                hv_RefCol = hv_regEndCol.Clone();
            }

            //判断是否为尾丝
            hv_MinDistance = new HTuple();
            HTuple end_val122 = hv_lineSelNum - 1;
            HTuple step_val122 = 1;
            for (hv_IdxWire = 0; hv_IdxWire.Continue(end_val122, step_val122); hv_IdxWire = hv_IdxWire.TupleAdd(step_val122))
            {
                HOperatorSet.FitLineContourXld(ho_o_Lines, "huber", -1, 0, 5, 2, out hv_RowBegin1,
                    out hv_ColBegin1, out hv_RowEnd1, out hv_ColEnd1, out hv_Nr, out hv_Nc,
                    out hv_Dist);
                //检测区域起始点到距离起始点最近的线段端点的距离d1
                HOperatorSet.DistancePp(hv_RefRow, hv_RefCol, hv_RowBegin1.TupleSelect(hv_IdxWire),
                    hv_ColBegin1.TupleSelect(hv_IdxWire), out hv_D1);
                HOperatorSet.DistancePp(hv_RefRow, hv_RefCol, hv_RowEnd1.TupleSelect(hv_IdxWire),
                    hv_ColEnd1.TupleSelect(hv_IdxWire), out hv_D2);
                HOperatorSet.TupleMin(hv_D1.TupleConcat(hv_D2), out hv_Min);
                hv_MinDistance = hv_MinDistance.TupleConcat(hv_Min);
            }
            if ((int)(new HTuple(((hv_MinDistance.TupleMin())).TupleLess(hv_i_LineGap))) != 0)
            {
                hv_o_TailWireFlag = 1;
                ho_o_Lines.Dispose();
                ho_linesImage.Dispose();
                ho_ImageGauss.Dispose();
                ho_Lines.Dispose();
                ho_Lines1.Dispose();
                ho_ContoursSplit.Dispose();
                ho_SelectedContours.Dispose();
                ho__Lines.Dispose();
                ho_ObjectSelected.Dispose();

                return;
            }

            hv_o_TailWireFlag = 0;
            ho_o_Lines.Dispose();
            ho_linesImage.Dispose();
            ho_ImageGauss.Dispose();
            ho_Lines.Dispose();
            ho_Lines1.Dispose();
            ho_ContoursSplit.Dispose();
            ho_SelectedContours.Dispose();
            ho__Lines.Dispose();
            ho_ObjectSelected.Dispose();

            return;
        }

        public static void calculate_lines_gauss_parameters(HTuple hv_MaxLineWidth, HTuple hv_Contrast,
            out HTuple hv_Sigma, out HTuple hv_Low, out HTuple hv_High)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ContrastHigh = null, hv_ContrastLow = new HTuple();
            HTuple hv_HalfWidth = null, hv_Help = null;
            HTuple hv_MaxLineWidth_COPY_INP_TMP = hv_MaxLineWidth.Clone();

            // Initialize local and output iconic variables 
            //Check control parameters
            if ((int)(new HTuple((new HTuple(hv_MaxLineWidth_COPY_INP_TMP.TupleLength())).TupleNotEqual(
                1))) != 0)
            {
                throw new HalconException("Wrong number of values of control parameter: 1");
            }
            if ((int)(((hv_MaxLineWidth_COPY_INP_TMP.TupleIsNumber())).TupleNot()) != 0)
            {
                throw new HalconException("Wrong type of control parameter: 1");
            }
            if ((int)(new HTuple(hv_MaxLineWidth_COPY_INP_TMP.TupleLessEqual(0))) != 0)
            {
                throw new HalconException("Wrong value of control parameter: 1");
            }
            if ((int)((new HTuple((new HTuple(hv_Contrast.TupleLength())).TupleNotEqual(1))).TupleAnd(
                new HTuple((new HTuple(hv_Contrast.TupleLength())).TupleNotEqual(2)))) != 0)
            {
                throw new HalconException("Wrong number of values of control parameter: 2");
            }
            if ((int)(new HTuple(((((hv_Contrast.TupleIsNumber())).TupleMin())).TupleEqual(
                0))) != 0)
            {
                throw new HalconException("Wrong type of control parameter: 2");
            }
            //Set and check ContrastHigh
            hv_ContrastHigh = hv_Contrast[0];
            if ((int)(new HTuple(hv_ContrastHigh.TupleLess(0))) != 0)
            {
                throw new HalconException("Wrong value of control parameter: 2");
            }
            //Set or derive ContrastLow
            if ((int)(new HTuple((new HTuple(hv_Contrast.TupleLength())).TupleEqual(2))) != 0)
            {
                hv_ContrastLow = hv_Contrast[1];
            }
            else
            {
                hv_ContrastLow = hv_ContrastHigh / 3.0;
            }
            //Check ContrastLow
            if ((int)(new HTuple(hv_ContrastLow.TupleLess(0))) != 0)
            {
                throw new HalconException("Wrong value of control parameter: 2");
            }
            if ((int)(new HTuple(hv_ContrastLow.TupleGreater(hv_ContrastHigh))) != 0)
            {
                throw new HalconException("Wrong value of control parameter: 2");
            }
            //
            //Calculate the parameters Sigma, Low, and High for lines_gauss
            if ((int)(new HTuple(hv_MaxLineWidth_COPY_INP_TMP.TupleLess((new HTuple(3.0)).TupleSqrt()
                ))) != 0)
            {
                //Note that LineWidthMax < sqrt(3.0) would result in a Sigma < 0.5,
                //which does not make any sense, because the corresponding smoothing
                //filter mask would be of size 1x1.
                //To avoid this, LineWidthMax is restricted to values greater or equal
                //to sqrt(3.0) and the contrast values are adapted to reflect the fact
                //that lines that are thinner than sqrt(3.0) pixels have a lower contrast
                //in the smoothed image (compared to lines that are sqrt(3.0) pixels wide).
                hv_ContrastLow = (hv_ContrastLow * hv_MaxLineWidth_COPY_INP_TMP) / ((new HTuple(3.0)).TupleSqrt()
                    );
                hv_ContrastHigh = (hv_ContrastHigh * hv_MaxLineWidth_COPY_INP_TMP) / ((new HTuple(3.0)).TupleSqrt()
                    );
                hv_MaxLineWidth_COPY_INP_TMP = (new HTuple(3.0)).TupleSqrt();
            }
            //Convert LineWidthMax and the given contrast values into the input parameters
            //Sigma, Low, and High required by lines_gauss
            hv_HalfWidth = hv_MaxLineWidth_COPY_INP_TMP / 2.0;
            hv_Sigma = hv_HalfWidth / ((new HTuple(3.0)).TupleSqrt());
            hv_Help = ((-2.0 * hv_HalfWidth) / (((new HTuple(6.283185307178)).TupleSqrt()) * (hv_Sigma.TuplePow(
                3.0)))) * (((-0.5 * (((hv_HalfWidth / hv_Sigma)).TuplePow(2.0)))).TupleExp());
            hv_High = ((hv_ContrastHigh * hv_Help)).TupleFabs();
            hv_Low = ((hv_ContrastLow * hv_Help)).TupleFabs();

            return;
        }

        public static void select_shortest_path(HObject ho_i_Lines, HObject ho_i_RefEdges, out HObject ho_o_Lines,
            HTuple hv_i_RefRow, HTuple hv_i_RefCol, HTuple hv_i_RegStartRow, HTuple hv_i_RegStartCol,
            HTuple hv_i_LineGap)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_ContoursSort, ho_startEdge, ho_endEdge;
            HObject ho_Cross = null, ho_ObjectSelected = null, ho_EmptyObject = null;

            // Local control variables 

            HTuple hv_RowBegin_ = null, hv_ColBegin_ = null;
            HTuple hv_RowEnd_ = null, hv_ColEnd_ = null, hv_Indices = null;
            HTuple hv_RowBegin = null, hv_ColBegin = null, hv_RowEnd = null;
            HTuple hv_ColEnd = null, hv_i = null, hv_j = new HTuple();
            HTuple hv_Dist_pp = new HTuple(), hv_DisEnd = new HTuple();
            HTuple hv_DistanceMax = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_Lines);
            HOperatorSet.GenEmptyObj(out ho_ContoursSort);
            HOperatorSet.GenEmptyObj(out ho_startEdge);
            HOperatorSet.GenEmptyObj(out ho_endEdge);
            HOperatorSet.GenEmptyObj(out ho_Cross);
            HOperatorSet.GenEmptyObj(out ho_ObjectSelected);
            HOperatorSet.GenEmptyObj(out ho_EmptyObject);
            //*****最短路径选择线段

            //**************************

            //track bond wire
            fit_line_contour_sort(ho_i_Lines, hv_i_RefRow, hv_i_RefCol, out hv_RowBegin_,
                out hv_ColBegin_, out hv_RowEnd_, out hv_ColEnd_, out hv_Indices);
            ho_ContoursSort.Dispose();
            HOperatorSet.SelectObj(ho_i_Lines, out ho_ContoursSort, hv_Indices + 1);
            //
            //线段起始点
            hv_RowBegin = new HTuple();
            hv_RowBegin = hv_RowBegin.TupleConcat(hv_i_RegStartRow);
            hv_RowBegin = hv_RowBegin.TupleConcat(hv_RowBegin_);
            hv_ColBegin = new HTuple();
            hv_ColBegin = hv_ColBegin.TupleConcat(hv_i_RegStartCol);
            hv_ColBegin = hv_ColBegin.TupleConcat(hv_ColBegin_);
            //线段结束点
            hv_RowEnd = new HTuple();
            hv_RowEnd = hv_RowEnd.TupleConcat(hv_i_RegStartRow);
            hv_RowEnd = hv_RowEnd.TupleConcat(hv_RowEnd_);
            hv_ColEnd = new HTuple();
            hv_ColEnd = hv_ColEnd.TupleConcat(hv_i_RegStartCol);
            hv_ColEnd = hv_ColEnd.TupleConcat(hv_ColEnd_);
            //获取起始边缘
            ho_startEdge.Dispose();
            HOperatorSet.SelectObj(ho_i_RefEdges, out ho_startEdge, 1);
            ho_endEdge.Dispose();
            HOperatorSet.SelectObj(ho_i_RefEdges, out ho_endEdge, 2);
            //筛选线段
            ho_o_Lines.Dispose();
            HOperatorSet.GenEmptyObj(out ho_o_Lines);
            for (hv_i = 0; (int)hv_i <= (int)((new HTuple(hv_RowBegin.TupleLength())) - 1); hv_i = (int)hv_i + 1)
            {
                //
                HTuple end_val21 = (new HTuple(hv_RowBegin.TupleLength()
                    )) - 1;
                HTuple step_val21 = 1;
                for (hv_j = hv_i + 1; hv_j.Continue(end_val21, step_val21); hv_j = hv_j.TupleAdd(step_val21))
                {
                    //
                    ho_Cross.Dispose();
                    HOperatorSet.GenCrossContourXld(out ho_Cross, hv_RowEnd.TupleSelect(hv_i),
                        hv_ColEnd.TupleSelect(hv_i), 6, 0.785398);
                    ho_Cross.Dispose();
                    HOperatorSet.GenCrossContourXld(out ho_Cross, hv_RowBegin.TupleSelect(hv_j),
                        hv_ColBegin.TupleSelect(hv_j), 6, 0.785398);
                    //求第i个线段结束端点到i+1个线段起点的距离
                    HOperatorSet.DistancePp(hv_RowEnd.TupleSelect(hv_i), hv_ColEnd.TupleSelect(
                        hv_i), hv_RowBegin.TupleSelect(hv_j), hv_ColBegin.TupleSelect(hv_j),
                        out hv_Dist_pp);
                    if ((int)(new HTuple(hv_Dist_pp.TupleLess(hv_i_LineGap))) != 0)
                    {
                        ho_ObjectSelected.Dispose();
                        HOperatorSet.SelectObj(ho_ContoursSort, out ho_ObjectSelected, hv_j);
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(ho_o_Lines, ho_ObjectSelected, out ExpTmpOutVar_0
                                );
                            ho_o_Lines.Dispose();
                            ho_o_Lines = ExpTmpOutVar_0;
                        }
                        hv_i = hv_j - 1;
                        break;
                    }
                    else
                    {
                        ho_EmptyObject.Dispose();
                        HOperatorSet.GenEmptyObj(out ho_EmptyObject);
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(ho_o_Lines, ho_EmptyObject, out ExpTmpOutVar_0);
                            ho_o_Lines.Dispose();
                            ho_o_Lines = ExpTmpOutVar_0;
                        }
                        continue;
                    }
                }
                //
                if ((int)(new HTuple(hv_j.TupleNotEqual(new HTuple(hv_RowBegin.TupleLength()
                    )))) != 0)
                {
                    //求结束点到检测区域结束边缘的距离
                    HOperatorSet.DistancePc(ho_endEdge, hv_RowEnd.TupleSelect(hv_j), hv_ColEnd.TupleSelect(
                        hv_j), out hv_DisEnd, out hv_DistanceMax);
                    if ((int)(new HTuple(hv_DisEnd.TupleLess(hv_i_LineGap * 0.8))) != 0)
                    {
                        break;
                    }
                    else
                    {
                        continue;
                    }
                }
                else
                {
                    break;
                }
            }
            ho_ContoursSort.Dispose();
            ho_startEdge.Dispose();
            ho_endEdge.Dispose();
            ho_Cross.Dispose();
            ho_ObjectSelected.Dispose();
            ho_EmptyObject.Dispose();

            return;
        }

        public static void HTV_select_shortest_path(HObject ho_i_Lines, HObject ho_i_RefEdges,
            out HObject ho_o_Lines, HTuple hv_i_RefRow, HTuple hv_i_RefCol, HTuple hv_i_StartRow,
            HTuple hv_i_StartCol, HTuple hv_i_EndRow, HTuple hv_i_EndCol, HTuple hv_i_LineGap,
            HTuple hv_i_RefLen, HTuple hv_i_RefPhi)
        {




            // Local iconic variables 

            HObject ho_ContoursSort, ho_startEdge, ho_endEdge;

            // Local control variables 

            HTuple hv_Indices = null, hv_Length = null;
            HTuple hv_SegLength = null, hv_RowBegin = null, hv_RowBegin_ = null;
            HTuple hv_ColBegin = null, hv_ColBegin_ = null, hv_RowEnd = null;
            HTuple hv_RowEnd_ = null, hv_ColEnd = null, hv_ColEnd_ = null;
            HTuple hv_IMAX = null, hv_SegNum = null, hv_DistanceMatrix = null;
            HTuple hv_Row1 = null, hv_Col1 = null, hv_j = null, hv_DistanceMin = new HTuple();
            HTuple hv_DistanceMax = new HTuple(), hv_i = null, hv_LinePhi = new HTuple();
            HTuple hv_Angle = new HTuple(), hv_Distance = null, hv_VisitedInd = null;
            HTuple hv_Less = null, hv_Previous = null, hv_DistMin = new HTuple();
            HTuple hv_Prev = new HTuple(), hv_DistanceCurrent = new HTuple();
            HTuple hv_Road = null, hv_ind = null, hv_o_ErrCode = new HTuple();
            HTuple hv_RoadSort = null;
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_Lines);
            HOperatorSet.GenEmptyObj(out ho_ContoursSort);
            HOperatorSet.GenEmptyObj(out ho_startEdge);
            HOperatorSet.GenEmptyObj(out ho_endEdge);
            //*****最短路径选择线段

            //**************************
            //初始化输出
            ho_o_Lines.Dispose();
            HOperatorSet.GenEmptyObj(out ho_o_Lines);
            //
            //track bond wire
            fit_line_contour_sort(ho_i_Lines, hv_i_RefRow, hv_i_RefCol, out hv_RowBegin_,
                out hv_ColBegin_, out hv_RowEnd_, out hv_ColEnd_, out hv_Indices);
            ho_ContoursSort.Dispose();
            HOperatorSet.SelectObj(ho_i_Lines, out ho_ContoursSort, hv_Indices + 1);
            HOperatorSet.LengthXld(ho_ContoursSort, out hv_Length);
            hv_SegLength = new HTuple();
            hv_SegLength[0] = 0;
            hv_SegLength = hv_SegLength.TupleConcat(hv_Length);
            hv_SegLength = hv_SegLength.TupleConcat(0);
            //线段起始点
            hv_RowBegin = new HTuple();
            hv_RowBegin = hv_RowBegin.TupleConcat(hv_i_StartRow);
            hv_RowBegin = hv_RowBegin.TupleConcat(hv_RowBegin_);
            hv_RowBegin = hv_RowBegin.TupleConcat(hv_i_EndRow);
            hv_ColBegin = new HTuple();
            hv_ColBegin = hv_ColBegin.TupleConcat(hv_i_StartCol);
            hv_ColBegin = hv_ColBegin.TupleConcat(hv_ColBegin_);
            hv_ColBegin = hv_ColBegin.TupleConcat(hv_i_EndCol);
            //线段结束点
            hv_RowEnd = new HTuple();
            hv_RowEnd = hv_RowEnd.TupleConcat(hv_i_StartRow);
            hv_RowEnd = hv_RowEnd.TupleConcat(hv_RowEnd_);
            hv_RowEnd = hv_RowEnd.TupleConcat(hv_i_EndRow);
            hv_ColEnd = new HTuple();
            hv_ColEnd = hv_ColEnd.TupleConcat(hv_i_StartCol);
            hv_ColEnd = hv_ColEnd.TupleConcat(hv_ColEnd_);
            hv_ColEnd = hv_ColEnd.TupleConcat(hv_i_EndCol);


            //筛选线段
            hv_IMAX = 9999;
            hv_SegNum = new HTuple(hv_RowBegin.TupleLength());
            ho_o_Lines.Dispose();
            HOperatorSet.GenEmptyObj(out ho_o_Lines);
            HOperatorSet.TupleGenConst(hv_SegNum * hv_SegNum, hv_IMAX, out hv_DistanceMatrix);

            //****************************
            //首尾端点为虚拟点，排除角度影响、检测区域偏移导致gap值过小影响
            //
            //获取起始边缘
            ho_startEdge.Dispose();
            HOperatorSet.SelectObj(ho_i_RefEdges, out ho_startEdge, 1);
            ho_endEdge.Dispose();
            HOperatorSet.SelectObj(ho_i_RefEdges, out ho_endEdge, 2);
            //首端点
            hv_Row1 = hv_RowEnd[0];
            hv_Col1 = hv_ColEnd[0];
            if (hv_DistanceMatrix == null)
                hv_DistanceMatrix = new HTuple();
            hv_DistanceMatrix[0] = 0;
            HTuple end_val35 = hv_SegNum - 1;
            HTuple step_val35 = 1;
            for (hv_j = 1; hv_j.Continue(end_val35, step_val35); hv_j = hv_j.TupleAdd(step_val35))
            {
                //distance_pc (startEdge, RowBegin[j], ColBegin[j], DistanceMin, DistanceMax)
                HOperatorSet.DistancePp(hv_Row1, hv_Col1, hv_RowBegin.TupleSelect(hv_j), hv_ColBegin.TupleSelect(
                    hv_j), out hv_DistanceMin);
                if ((int)(new HTuple(hv_DistanceMin.TupleLess(hv_i_LineGap))) != 0)
                {
                    if (hv_DistanceMatrix == null)
                        hv_DistanceMatrix = new HTuple();
                    hv_DistanceMatrix[hv_j] = hv_DistanceMin * 1.1;
                }
            }
            //
            if (hv_DistanceMatrix == null)
                hv_DistanceMatrix = new HTuple();
            hv_DistanceMatrix[(hv_SegNum * hv_SegNum) - 1] = 0;
            HTuple end_val44 = hv_SegNum - 1;
            HTuple step_val44 = 1;
            for (hv_i = 1; hv_i.Continue(end_val44, step_val44); hv_i = hv_i.TupleAdd(step_val44))
            {
                hv_Row1 = hv_RowEnd.TupleSelect(hv_i);
                hv_Col1 = hv_ColEnd.TupleSelect(hv_i);
                if (hv_DistanceMatrix == null)
                    hv_DistanceMatrix = new HTuple();
                hv_DistanceMatrix[(hv_i * hv_SegNum) + hv_i] = 0;
                HTuple end_val48 = hv_SegNum - 2;
                HTuple step_val48 = 1;
                for (hv_j = hv_i + 1; hv_j.Continue(end_val48, step_val48); hv_j = hv_j.TupleAdd(step_val48))
                {
                    HOperatorSet.DistancePp(hv_Row1, hv_Col1, hv_RowBegin.TupleSelect(hv_j),
                        hv_ColBegin.TupleSelect(hv_j), out hv_DistanceMin);
                    if ((int)(new HTuple(hv_DistanceMin.TupleLess(hv_i_LineGap))) != 0)
                    {
                        HOperatorSet.LineOrientation(hv_Row1, hv_Col1, hv_RowBegin.TupleSelect(
                            hv_j), hv_ColBegin.TupleSelect(hv_j), out hv_LinePhi);
                        hv_Angle = hv_LinePhi - hv_i_RefPhi;
                        if ((int)((new HTuple(((hv_Angle.TupleAbs())).TupleLess(1.0))).TupleOr(
                            new HTuple(hv_DistanceMin.TupleLess(hv_i_RefLen)))) != 0)
                        {
                            if (hv_DistanceMatrix == null)
                                hv_DistanceMatrix = new HTuple();
                            hv_DistanceMatrix[(hv_i * hv_SegNum) + hv_j] = (hv_DistanceMin * 1.1) + (hv_SegLength.TupleSelect(
                                hv_i));
                        }
                    }
                }
                //末端点
                hv_j = hv_SegNum - 1;
                HOperatorSet.DistancePc(ho_endEdge, hv_Row1, hv_Col1, out hv_DistanceMin, out hv_DistanceMax);
                //distance_pp (Row1, Col1, RowBegin[j], ColBegin[j], DistanceMin)
                if ((int)(new HTuple(hv_DistanceMin.TupleLess(hv_i_LineGap))) != 0)
                {
                    if ((int)(new HTuple(hv_i.TupleEqual(hv_SegNum - 1))) != 0)
                    {
                        break;
                    }
                    if (hv_DistanceMatrix == null)
                        hv_DistanceMatrix = new HTuple();
                    hv_DistanceMatrix[(hv_i * hv_SegNum) + hv_j] = (hv_DistanceMin * 1.1) + (hv_SegLength.TupleSelect(
                        hv_i));
                }
            }

            //****************************
            //for i := 0 to SegNum-1 by 1
            //Row0 := RowBegin[i]
            //Col0 := ColBegin[i]
            //Row1 := RowEnd[i]
            //Col1 := ColEnd[i]
            //DistanceMatrix[i*SegNum+i] := 0
            //for j := i+1 to SegNum-1 by 1
            //gen_cross_contour_xld (PonintCross1, Row1, Col1, 4, 0)
            //gen_cross_contour_xld (PonintCross2, RowBegin[j], ColBegin[j], 4, 0)
            //distance_pp (Row1, Col1, RowBegin[j], ColBegin[j], DistanceMin)
            //line_orientation (Row1, Col1, RowBegin[j], ColBegin[j], LinePhi)
            //Angle := LinePhi-i_RefPhi
            //if (DistanceMin < i_LineGap and (abs(Angle) < 1.0 or DistanceMin < i_RefLen))
            //DistanceMatrix[i*SegNum+j] := DistanceMin*1.1+SegLength[i]
            //endif
            //endfor
            //endfor
            //****************************
            hv_Distance = hv_DistanceMatrix.TupleSelectRange(0, hv_SegNum - 1);
            HOperatorSet.TupleGenConst(hv_SegNum, 0, out hv_VisitedInd);
            HOperatorSet.TupleLessElem(hv_Distance, hv_IMAX, out hv_Less);
            hv_Previous = hv_Less - 1;
            if (hv_VisitedInd == null)
                hv_VisitedInd = new HTuple();
            hv_VisitedInd[0] = 1;
            HTuple end_val94 = hv_SegNum - 1;
            HTuple step_val94 = 1;
            for (hv_i = 1; hv_i.Continue(end_val94, step_val94); hv_i = hv_i.TupleAdd(step_val94))
            {
                hv_DistMin = hv_IMAX.Clone();
                hv_Prev = 0;
                HTuple end_val97 = hv_SegNum - 1;
                HTuple step_val97 = 1;
                for (hv_j = 0; hv_j.Continue(end_val97, step_val97); hv_j = hv_j.TupleAdd(step_val97))
                {
                    if ((int)((new HTuple(((hv_VisitedInd.TupleSelect(hv_j))).TupleEqual(0))).TupleAnd(
                        new HTuple(((hv_Distance.TupleSelect(hv_j))).TupleLess(hv_DistMin)))) != 0)
                    {
                        hv_DistMin = hv_Distance.TupleSelect(hv_j);
                        hv_Prev = hv_j.Clone();
                    }
                }
                if (hv_VisitedInd == null)
                    hv_VisitedInd = new HTuple();
                hv_VisitedInd[hv_Prev] = 1;
                if ((int)(new HTuple(hv_Prev.TupleEqual(hv_SegNum - 1))) != 0)
                {
                    break;
                }
                HTuple end_val107 = hv_SegNum - 1;
                HTuple step_val107 = 1;
                for (hv_j = hv_Prev + 1; hv_j.Continue(end_val107, step_val107); hv_j = hv_j.TupleAdd(step_val107))
                {
                    if ((int)(new HTuple(((hv_VisitedInd.TupleSelect(hv_j))).TupleEqual(0))) != 0)
                    {
                        hv_DistanceCurrent = hv_DistanceMatrix.TupleSelect((hv_Prev * hv_SegNum) + hv_j);
                        if ((int)(new HTuple(hv_DistanceCurrent.TupleLess(hv_IMAX))) != 0)
                        {
                            if ((int)(new HTuple(((hv_Distance.TupleSelect(hv_j))).TupleGreater((hv_Distance.TupleSelect(
                                hv_Prev)) + hv_DistanceCurrent))) != 0)
                            {
                                if (hv_Distance == null)
                                    hv_Distance = new HTuple();
                                hv_Distance[hv_j] = (hv_Distance.TupleSelect(hv_Prev)) + hv_DistanceCurrent;
                                if (hv_Previous == null)
                                    hv_Previous = new HTuple();
                                hv_Previous[hv_j] = hv_Prev;
                            }
                        }
                    }
                }
            }
            hv_Road = new HTuple();
            hv_ind = hv_SegNum - 1;
            if ((int)(new HTuple(((hv_Previous.TupleSelect(hv_ind))).TupleEqual(-1))) != 0)
            {
                //   *增加根据线段长保留
                //distance_pp (i_StartRow, i_StartCol, i_EndRow, i_EndCol, RefLen)
                //tuple_greater_elem (Length, RefLen * 0.7, Greater)
                //tuple_find (Greater, 1, Indices)
                //if (Indices # -1)
                //tuple_inverse (Indices, NewInd)
                //Road := NewInd+1
                //else
                //o_ErrCode := 12
                //return ()
                //endif
                hv_o_ErrCode = 12;
                ho_ContoursSort.Dispose();
                ho_startEdge.Dispose();
                ho_endEdge.Dispose();

                return;
            }
            else
            {
                while ((int)(1) != 0)
                {
                    hv_ind = hv_Previous.TupleSelect(hv_ind);
                    if ((int)(new HTuple(hv_ind.TupleEqual(0))) != 0)
                    {
                        break;
                    }
                    hv_Road = hv_Road.TupleConcat(hv_ind);
                }
            }
            //
            //在此加判断，如果|Road|=0,则跳出
            if ((int)(new HTuple((new HTuple(hv_Road.TupleLength())).TupleEqual(0))) != 0)
            {
                ho_ContoursSort.Dispose();
                ho_startEdge.Dispose();
                ho_endEdge.Dispose();

                return;
            }

            HOperatorSet.TupleInverse(hv_Road, out hv_RoadSort);
            ho_o_Lines.Dispose();
            HOperatorSet.SelectObj(ho_ContoursSort, out ho_o_Lines, hv_RoadSort);
            ho_ContoursSort.Dispose();
            ho_startEdge.Dispose();
            ho_endEdge.Dispose();

            return;
        }

        public static void fit_line_contour_sort(HObject ho_Contours, HTuple hv_RefRow, HTuple hv_RefCol,
            out HTuple hv_RowBegin, out HTuple hv_ColBegin, out HTuple hv_RowEnd, out HTuple hv_ColEnd,
            out HTuple hv_Indices)
        {




            // Local iconic variables 

            // Local control variables 

            HTuple hv_RowBegin_ = null, hv_ColBegin_ = null;
            HTuple hv_RowEnd_ = null, hv_ColEnd_ = null, hv_Nr = null;
            HTuple hv_Nc = null, hv_Dist = null, hv_seg_num = null;
            HTuple hv_lp_row_tup = null, hv_lp_col_tup = null, hv_DistanceBegin = null;
            HTuple hv_DistanceEnd = null, hv_Greater_ = null, hv_Min2 = null;
            HTuple hv_Greater = null, hv_ind = null;
            // Initialize local and output iconic variables 


            hv_RowBegin = new HTuple();
            hv_ColBegin = new HTuple();
            hv_RowEnd = new HTuple();
            hv_ColEnd = new HTuple();
            HOperatorSet.FitLineContourXld(ho_Contours, "tukey", -1, 0, 5, 2, out hv_RowBegin_,
                out hv_ColBegin_, out hv_RowEnd_, out hv_ColEnd_, out hv_Nr, out hv_Nc, out hv_Dist);
            hv_seg_num = new HTuple(hv_RowBegin_.TupleLength());
            HOperatorSet.TupleGenConst(hv_seg_num, hv_RefRow, out hv_lp_row_tup);
            HOperatorSet.TupleGenConst(hv_seg_num, hv_RefCol, out hv_lp_col_tup);
            HOperatorSet.DistancePp(hv_lp_row_tup, hv_lp_col_tup, hv_RowBegin_, hv_ColBegin_,
                out hv_DistanceBegin);
            HOperatorSet.DistancePp(hv_lp_row_tup, hv_lp_col_tup, hv_RowEnd_, hv_ColEnd_,
                out hv_DistanceEnd);
            HOperatorSet.TupleGreaterElem(hv_DistanceBegin, hv_DistanceEnd, out hv_Greater_);
            HOperatorSet.TupleMin2(hv_DistanceBegin, hv_DistanceEnd, out hv_Min2);
            HOperatorSet.TupleSortIndex(hv_Min2, out hv_Indices);
            hv_RowBegin_ = hv_RowBegin_.TupleSelect(hv_Indices);
            hv_ColBegin_ = hv_ColBegin_.TupleSelect(hv_Indices);
            hv_RowEnd_ = hv_RowEnd_.TupleSelect(hv_Indices);
            hv_ColEnd_ = hv_ColEnd_.TupleSelect(hv_Indices);
            hv_Greater = hv_Greater_.TupleSelect(hv_Indices);
            HTuple end_val20 = hv_seg_num - 1;
            HTuple step_val20 = 1;
            for (hv_ind = 0; hv_ind.Continue(end_val20, step_val20); hv_ind = hv_ind.TupleAdd(step_val20))
            {
                if ((int)(new HTuple(((hv_Greater.TupleSelect(hv_ind))).TupleEqual(0))) != 0)
                {
                    hv_RowBegin = hv_RowBegin.TupleConcat(hv_RowBegin_.TupleSelect(hv_ind));
                    hv_ColBegin = hv_ColBegin.TupleConcat(hv_ColBegin_.TupleSelect(hv_ind));
                    hv_RowEnd = hv_RowEnd.TupleConcat(hv_RowEnd_.TupleSelect(hv_ind));
                    hv_ColEnd = hv_ColEnd.TupleConcat(hv_ColEnd_.TupleSelect(hv_ind));
                }
                else
                {
                    hv_RowBegin = hv_RowBegin.TupleConcat(hv_RowEnd_.TupleSelect(hv_ind));
                    hv_ColBegin = hv_ColBegin.TupleConcat(hv_ColEnd_.TupleSelect(hv_ind));
                    hv_RowEnd = hv_RowEnd.TupleConcat(hv_RowBegin_.TupleSelect(hv_ind));
                    hv_ColEnd = hv_ColEnd.TupleConcat(hv_ColBegin_.TupleSelect(hv_ind));
                }
            }

            return;
        }

        #endregion


        #region  单节点Demo
        public static void JSCC_AOI_read_all_inspect_parametrer(HTuple hv_i_RecipePath, out HTupleVector/*{eTupleVector,Dim=2}*/ hvec_o_FrameParameters,
            out HTupleVector/*{eTupleVector,Dim=2}*/ hvec_o_IcParameters, out HTupleVector/*{eTupleVector,Dim=3}*/ hvec_o_EpoxyParameters,
            out HTupleVector/*{eTupleVector,Dim=3}*/ hvec_o_BondParameters, out HTupleVector/*{eTupleVector,Dim=3}*/ hvec_o_WireParameters,
            out HTupleVector/*{eTupleVector,Dim=3}*/ hvec_o_AroundBallParameters, out HTuple hv_o_ErrCode,
            out HTuple hv_o_ErrStr)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_IsString = null, hv_Files = null;
            HTuple hv_Matches = null, hv_ItemFiles = null, hv__FramePath = null;
            HTuple hv__FrameNum = null, hv__FrameErrCode = new HTuple();
            HTuple hv__FrameErrStr = new HTuple(), hv__ICPath = null;
            HTuple hv__IcNum = null, hv__IcErrCode = new HTuple();
            HTuple hv__IcErrStr = new HTuple(), hv__EpoxyPath = null;
            HTuple hv__EpoxyNum = null, hv__EpoxyErrCode = new HTuple();
            HTuple hv__EpoxyErrStr = new HTuple(), hv__BondPath = null;
            HTuple hv__BondNum = null, hv__BondErrCode = new HTuple();
            HTuple hv__BondErrStr = new HTuple(), hv__WirePath = null;
            HTuple hv__WireNum = null, hv__WireErrCode = new HTuple();
            HTuple hv__WireErrStr = new HTuple(), hv__Bondpath = null;
            HTuple hv__AroundBallpath = null, hv__AroundBallErrCode = new HTuple();
            HTuple hv__AroundBallErrStr = new HTuple();
            // Initialize local and output iconic variables 
            hv_o_ErrCode = new HTuple();
            hv_o_ErrStr = new HTuple();
            //*************************读取Die区域所有检测项目的检测参数文件****************************
            //---输入控制参数
            //i_RecipePath：存放参数的路径，一般指Recipe下的文件
            //---输出控制参数
            //o_FrameParameters：frame检测需要的检测参数：二维向量
            //o_IcParameters：Ic检测所需参数集合：二维向量
            //o_EpoxyParameters：Epoxy检测所需参数集合：二维向量
            //o_WireParameters：Wire检测所需要参数集合：3维向量
            //o_ErrCode：错误码，代表该算子在执行过程中产生的错误，0-代表执行正常，-1-代表执行异常，-2-代表未执行
            //o_ErrStr: 错误信息，对各种错误的具体描述
            //************************************************************************************
            //
            //初始化
            //
            hvec_o_FrameParameters = (new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple("none"))))));
            //
            hvec_o_IcParameters = (new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple("none"))))));
            //
            hvec_o_EpoxyParameters = (new HTupleVector(3).Insert(0, (new HTupleVector(2).Insert(0, (
                new HTupleVector(1).Insert(0, new HTupleVector(new HTuple("none"))))))));
            //
            hvec_o_BondParameters = (new HTupleVector(3).Insert(0, (new HTupleVector(2).Insert(0, (
                new HTupleVector(1).Insert(0, new HTupleVector(new HTuple("none"))))))));
            //
            hvec_o_WireParameters = (new HTupleVector(3).Insert(0, (new HTupleVector(2).Insert(0, (
                new HTupleVector(1).Insert(0, new HTupleVector(new HTuple("none"))))))));
            //
            hvec_o_AroundBallParameters = (new HTupleVector(3).Insert(0, (new HTupleVector(2).Insert(0, (
                new HTupleVector(1).Insert(0, new HTupleVector(new HTuple("none"))))))));
            //传入有效性测试
            HOperatorSet.TupleIsString(hv_i_RecipePath, out hv_IsString);
            if ((int)((new HTuple(hv_IsString.TupleEqual("false"))).TupleOr(new HTuple((new HTuple(hv_i_RecipePath.TupleLength()
                )).TupleEqual(0)))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "the para i_RecipePath must be a string and the para |i_RecipePath|                  must greater than 0";

                return;
            }
            //
            //读物i_RecipePath下所有的模板文件
            HOperatorSet.ListFiles(hv_i_RecipePath, "directories", out hv_Files);
            //
            //获取Recipe下的模板项目数组
            HOperatorSet.TupleRegexpMatch(hv_Files, "Recipe.*", out hv_Matches);
            HOperatorSet.TupleRegexpReplace(hv_Matches, new HTuple("Recipe/") + "*", "", out hv_ItemFiles);

            //---------------------Frame
            //提取Frame文件夹子XML中的参数
            HOperatorSet.TupleRegexpSelect(hv_ItemFiles, "Frame.*", out hv__FramePath);

            hv__FrameNum = new HTuple(hv__FramePath.TupleLength());
            //
            if ((int)(new HTuple(hv__FrameNum.TupleGreater(0))) != 0)
            {
                hv__FramePath = hv_i_RecipePath + hv__FramePath;
                HTV_read_frame_recipe(hv__FramePath, out hvec_o_FrameParameters, out hv__FrameErrCode,
                    out hv__FrameErrStr);
            }
            else
            {
                hvec_o_FrameParameters = (new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple("none"))))));
            }
            //
            //-------------------Ic
            //提取Ic文件夹下XML中的参数
            HOperatorSet.TupleRegexpSelect(hv_ItemFiles, "IC.*", out hv__ICPath);
            //
            hv__IcNum = new HTuple(hv__ICPath.TupleLength());
            if ((int)(new HTuple(hv__IcNum.TupleGreater(0))) != 0)
            {
                hv__ICPath = hv_i_RecipePath + hv__ICPath;
                HTV_read_ic_recipe(hv__ICPath, out hvec_o_IcParameters, out hv__IcErrCode,
                    out hv__IcErrStr);
            }
            else
            {
                hvec_o_IcParameters = (new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple("none"))))));
            }
            //
            //--------------------Epoxy
            //提取Epoxy文件夹下XML中的参数
            HOperatorSet.TupleRegexpSelect(hv_ItemFiles, "Epoxy.*", out hv__EpoxyPath);
            //
            hv__EpoxyNum = new HTuple(hv__EpoxyPath.TupleLength());
            if ((int)(hv__EpoxyNum) != 0)
            {
                hv__EpoxyPath = hv_i_RecipePath + hv__EpoxyPath;
                HTV_read_epoxy_recipe(hv__EpoxyPath, out hvec_o_EpoxyParameters, out hv__EpoxyErrCode,
                    out hv__EpoxyErrStr);
            }
            else
            {
                hvec_o_EpoxyParameters = (new HTupleVector(3).Insert(0, (new HTupleVector(2).Insert(0, (
                    new HTupleVector(1).Insert(0, new HTupleVector(new HTuple("none"))))))));
            }
            //
            //---------------------Bond
            HOperatorSet.TupleRegexpSelect(hv_ItemFiles, "Bond.*", out hv__BondPath);
            //Bond类别数量
            hv__BondNum = new HTuple(hv__BondPath.TupleLength());
            if ((int)(hv__BondNum) != 0)
            {
                hv__BondPath = hv_i_RecipePath + hv__BondPath;
                HTV_read_bond_recipe(hv__BondPath, out hvec_o_BondParameters, out hv__BondErrCode,
                    out hv__BondErrStr);
            }
            else
            {
                hvec_o_BondParameters = (new HTupleVector(3).Insert(0, (new HTupleVector(2).Insert(0, (
                    new HTupleVector(1).Insert(0, new HTupleVector(new HTuple("none"))))))));
            }
            //
            //---------------------Wire
            //提取Wire文件夹下XML中的参数
            HOperatorSet.TupleRegexpSelect(hv_ItemFiles, "Wire.*", out hv__WirePath);
            //金线类别数量
            hv__WireNum = new HTuple(hv__WirePath.TupleLength());
            if ((int)(new HTuple(hv__WireNum.TupleGreater(0))) != 0)
            {
                hv__WirePath = hv_i_RecipePath + hv__WirePath;
                HTV_read_wire_recipe(hv__WirePath, out hvec_o_WireParameters, out hv__WireErrCode,
                    out hv__WireErrStr);
            }
            else
            {
                hvec_o_WireParameters = (new HTupleVector(3).Insert(0, (new HTupleVector(2).Insert(0, (
                    new HTupleVector(1).Insert(0, new HTupleVector(new HTuple("none"))))))));
            }
            //
            //---------------------AroundBond
            //提取AroundBond文件夹下XML中的检测参数
            //
            HOperatorSet.TupleRegexpSelect(hv_ItemFiles, "Bond.*", out hv__Bondpath);
            //Ball类别数量
            hv__BondNum = new HTuple(hv__Bondpath.TupleLength());
            //
            //获取AroundBall文件
            HOperatorSet.TupleRegexpSelect(hv_ItemFiles, "AroundBallRegion", out hv__AroundBallpath);
            if ((int)(hv__BondNum) != 0)
            {
                hv__AroundBallpath = hv_i_RecipePath + hv__AroundBallpath;
                HTV_read_AroundBall_recipe(hv__AroundBallpath, hv__BondNum, out hvec_o_AroundBallParameters,
                    out hv__AroundBallErrCode, out hv__AroundBallErrStr);
            }

            hv_o_ErrCode = 0;
            hv_o_ErrStr = "read all inspect parameters successful!";

            return;

        }

        public static void JSCC_AOI_Inspect(HObject ho_i_Imgs, HObject ho_i_SearchRegs, HObjectVector/*{eObjectVector,Dim=2}*/ hvec_i_FrameObjs,
            HObjectVector/*{eObjectVector,Dim=2}*/ hvec_i_IcObjs, HObjectVector/*{eObjectVector,Dim=2}*/ hvec_i_EpoxyObjs,
            HObjectVector/*{eObjectVector,Dim=2}*/ hvec_i_BondObjs, HObjectVector/*{eObjectVector,Dim=2}*/ hvec_i_WireObjs,
            out HObject ho_o_BondContours, out HObject ho_o_Wires, out HObjectVector/*{eObjectVector,Dim=4}*/ hvec_o_FailRegs,
            HTuple hv_i_InspectItemNum, HTupleVector/*{eTupleVector,Dim=3}*/ hvec_i_FrameInspectParas,
            HTupleVector/*{eTupleVector,Dim=3}*/ hvec_i_IcInspectParas, HTupleVector/*{eTupleVector,Dim=4}*/ hvec_i_EpoxyInspectParas,
            HTupleVector/*{eTupleVector,Dim=4}*/ hvec_i_BondInspectParas, HTupleVector/*{eTupleVector,Dim=4}*/ hvec_i_WireInspectParas,
            HTupleVector/*{eTupleVector,Dim=1}*/ hvec_i_CutRegionParas, HTupleVector/*{eTupleVector,Dim=3}*/ hvec_i_AroundBallParas,
            out HTupleVector/*{eTupleVector,Dim=5}*/ hvec_o_DefectValueFrames, out HTupleVector/*{eTupleVector,Dim=5}*/ hvec_o_DefectValueIcs,
            out HTupleVector/*{eTupleVector,Dim=5}*/ hvec_o_DefectValueEpoxys, out HTupleVector/*{eTupleVector,Dim=5}*/ hvec_o_DefectValueBonds,
            out HTupleVector/*{eTupleVector,Dim=5}*/ hvec_o_DefectValueWires, out HTupleVector/*{eTupleVector,Dim=4}*/ hvec_o_DefectImgIdxs,
            out HTupleVector/*{eTupleVector,Dim=4}*/ hvec_o_DefectTypes, out HTupleVector/*{eTupleVector,Dim=5}*/ hvec_o_RefValue,
            out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_EmptyObj, ho_curDie = null, ho__BondContours = null;
            HObject ho__Wires = null, ho__FailRegConcat = null;

            HObjectVector hvec__FailRegs = new HObjectVector(3);

            // Local control variables 

            HTuple hv_DieRegNum = null, hv_regidx = null;
            HTuple hv_o_OKorNG = new HTuple(), hv_o_ErrDieCode = new HTuple();
            HTuple hv_o_ErrDieStr = new HTuple(), hv__ErrVecCode = new HTuple();
            HTuple hv__ErrVecStr = new HTuple(), hv__DefectTypeTup = new HTuple();
            HTuple hv__DefectImgIdxTup = new HTuple(), hv_failNum = new HTuple();
            HTuple hv_defectLen = new HTuple(), hv_defectLen1 = new HTuple();

            HTupleVector hvec_o_DefectValueFrame = new HTupleVector(4);
            HTupleVector hvec_o_DefectValueIc = new HTupleVector(4), hvec_o_DefectValueEpoxy = new HTupleVector(4);
            HTupleVector hvec_o_DefectValueBond = new HTupleVector(4), hvec_o_DefectValueWire = new HTupleVector(4);
            HTupleVector hvec__DefectImgIdx = new HTupleVector(3), hvec__DefectType = new HTupleVector(3);
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_BondContours);
            HOperatorSet.GenEmptyObj(out ho_o_Wires);
            HOperatorSet.GenEmptyObj(out ho_EmptyObj);
            HOperatorSet.GenEmptyObj(out ho_curDie);
            HOperatorSet.GenEmptyObj(out ho__BondContours);
            HOperatorSet.GenEmptyObj(out ho__Wires);
            HOperatorSet.GenEmptyObj(out ho__FailRegConcat);
            hvec_o_FailRegs = new HObjectVector(4);
            hvec_o_RefValue = new HTupleVector(5);
            try
            {
                //**************************************************************************************************
                //---函数：JSCC_AOI_Inspect
                //---作用：执行各检测项
                //===图标参数
                //  i_Imgs：检测所需图像集合
                //  i_SearchRegs：搜索区
                //  i_FrameObjs：Frame检测区域对象
                //  i_IcObjs：Ic检测区域对象
                //  i_EpoxyObjs：Epoxy检测区域对象
                //  i_BondObjs：Bond检测区域对象
                //  i_WireObjs：Wire检测区域对象
                //  o_BondContours:检出的Bond区域
                //  o_Wires：检出的Wire区域
                //  o_FailRegs：检出失败的区域
                //===控制参数
                //  i_InspectItemNum：各检测项数目
                //  i_FrameInspectParas：Frame检测参数
                //  i_IcInspectParas：Ic检测参数
                //  i_EpoxyInspectParas：Epoxy检测参数
                //  i_BondInspectParas：Bond检测参数
                //  i_WireInspectParas：Wire检测参数
                //  o_ErrCode：错误码
                //  o_ErrStr：错误信息
                //**************************************************************************************************
                //
                //初始化
                hv_o_ErrCode = new HTuple();
                hv_o_ErrStr = "initializing";
                ho_o_BondContours.Dispose();
                HOperatorSet.GenEmptyObj(out ho_o_BondContours);
                ho_o_Wires.Dispose();
                HOperatorSet.GenEmptyObj(out ho_o_Wires);
                ho_EmptyObj.Dispose();
                HOperatorSet.GenEmptyObj(out ho_EmptyObj);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hvec_o_FailRegs = dh.Take((
                        dh.Add(new HObjectVector(4)).Insert(0, (dh.Add(new HObjectVector(3)).Insert(0, (
                        dh.Add(new HObjectVector(2)).Insert(0, (dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho_EmptyObj)))))))))));
                }

                hvec_o_DefectValueFrames = (new HTupleVector(5).Insert(0, (new HTupleVector(4).Insert(0, (
                    new HTupleVector(3).Insert(0, (new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))))))));
                hvec_o_DefectValueIcs = (new HTupleVector(5).Insert(0, (new HTupleVector(4).Insert(0, (
                    new HTupleVector(3).Insert(0, (new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))))))));
                hvec_o_DefectValueEpoxys = (new HTupleVector(5).Insert(0, (new HTupleVector(4).Insert(0, (
                    new HTupleVector(3).Insert(0, (new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))))))));
                hvec_o_DefectValueBonds = (new HTupleVector(5).Insert(0, (new HTupleVector(4).Insert(0, (
                    new HTupleVector(3).Insert(0, (new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))))))));
                hvec_o_DefectValueWires = (new HTupleVector(5).Insert(0, (new HTupleVector(4).Insert(0, (
                    new HTupleVector(3).Insert(0, (new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))))))));
                hvec_o_DefectImgIdxs = (new HTupleVector(4).Insert(0, (new HTupleVector(3).Insert(0, (
                    new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))))));
                hvec_o_DefectTypes = (new HTupleVector(4).Insert(0, (new HTupleVector(3).Insert(0, (
                    new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))))));

                //********************************************************************************************
                //开始Die区域内检测---单节点
                //
                HOperatorSet.CountObj(ho_i_SearchRegs, out hv_DieRegNum);

                HTuple end_val46 = hv_DieRegNum - 1;
                HTuple step_val46 = 1;
                for (hv_regidx = 0; hv_regidx.Continue(end_val46, step_val46); hv_regidx = hv_regidx.TupleAdd(step_val46))
                {
                    ho_curDie.Dispose();
                    HOperatorSet.SelectObj(ho_i_SearchRegs, out ho_curDie, hv_regidx + 1);
                    ho__BondContours.Dispose(); ho__Wires.Dispose(); hvec__FailRegs.Dispose();
                    JSCC_AOI_Inspect_Unit(ho_i_Imgs, ho_curDie, hvec_i_FrameObjs, hvec_i_IcObjs,
                        hvec_i_EpoxyObjs, hvec_i_BondObjs, hvec_i_WireObjs, out ho__BondContours,
                        out ho__Wires, out hvec__FailRegs, hv_i_InspectItemNum, hvec_i_FrameInspectParas,
                        hvec_i_IcInspectParas, hvec_i_EpoxyInspectParas, hvec_i_BondInspectParas,
                        hvec_i_WireInspectParas, hvec_i_CutRegionParas, hvec_i_AroundBallParas,
                        out hv_o_OKorNG, out hvec_o_DefectValueFrame, out hvec_o_DefectValueIc,
                        out hvec_o_DefectValueEpoxy, out hvec_o_DefectValueBond, out hvec_o_DefectValueWire,
                        out hvec__DefectImgIdx, out hvec__DefectType, out hvec_o_RefValue, out hv_o_ErrDieCode,
                        out hv_o_ErrDieStr);

                    ho__FailRegConcat.Dispose();
                    HTV_Vector_to_ObjectConcat_3d(hvec__FailRegs, out ho__FailRegConcat, out hv__ErrVecCode,
                        out hv__ErrVecStr);
                    HTV_Vector_to_Tuple_3d(hvec__DefectType, out hv__DefectTypeTup, out hv__ErrVecCode,
                        out hv__ErrVecStr);
                    HTV_Vector_to_Tuple_3d(hvec__DefectImgIdx, out hv__DefectImgIdxTup, out hv__ErrVecCode,
                        out hv__ErrVecStr);

                    HOperatorSet.CountObj(ho__FailRegConcat, out hv_failNum);
                    HOperatorSet.TupleLength(hv__DefectTypeTup, out hv_defectLen);
                    HOperatorSet.TupleLength(hv__DefectImgIdxTup, out hv_defectLen1);
                    //判断defect与failreg数量是否一致
                    if ((int)((new HTuple(hv_failNum.TupleNotEqual(hv_defectLen))).TupleOr(new HTuple(hv_defectLen.TupleNotEqual(
                        hv_defectLen1)))) != 0)
                    {
                        // stop(); only in hdevelop
                        hv_o_OKorNG = 2; // 调试用
                    }
                    //整合检测结果
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_o_BondContours, ho__BondContours, out ExpTmpOutVar_0
                            );
                        ho_o_BondContours.Dispose();
                        ho_o_BondContours = ExpTmpOutVar_0;
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_o_Wires, ho__Wires, out ExpTmpOutVar_0);
                        ho_o_Wires.Dispose();
                        ho_o_Wires = ExpTmpOutVar_0;
                    }
                    hvec_o_FailRegs[hv_regidx] = hvec__FailRegs.Clone();

                    //整合Defect信息
                    hvec_o_DefectValueFrames[hv_regidx] = hvec_o_DefectValueFrame.Clone();
                    hvec_o_DefectValueIcs[hv_regidx] = hvec_o_DefectValueIc.Clone();
                    hvec_o_DefectValueEpoxys[hv_regidx] = hvec_o_DefectValueEpoxy.Clone();
                    hvec_o_DefectValueBonds[hv_regidx] = hvec_o_DefectValueBond.Clone();
                    hvec_o_DefectValueWires[hv_regidx] = hvec_o_DefectValueWire.Clone();

                    hvec_o_DefectImgIdxs[hv_regidx] = hvec__DefectImgIdx.Clone();
                    hvec_o_DefectTypes[hv_regidx] = hvec__DefectType.Clone();

                    //ErrCode 改为每个die OKorNG的集合
                    hv_o_ErrCode = hv_o_ErrCode.TupleConcat(hv_o_OKorNG);
                }

                hv_o_ErrStr = "Complete all Die area tests";
                ho_EmptyObj.Dispose();
                ho_curDie.Dispose();
                ho__BondContours.Dispose();
                ho__Wires.Dispose();
                ho__FailRegConcat.Dispose();
                hvec__FailRegs.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_EmptyObj.Dispose();
                ho_curDie.Dispose();
                ho__BondContours.Dispose();
                ho__Wires.Dispose();
                ho__FailRegConcat.Dispose();
                hvec__FailRegs.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public static void JSCC_AOI_Inspect_Unit(HObject ho_i_Imgs, HObject ho_i_SearchReg, HObjectVector/*{eObjectVector,Dim=2}*/ hvec_i_FrameObjs,
            HObjectVector/*{eObjectVector,Dim=2}*/ hvec_i_IcObjs, HObjectVector/*{eObjectVector,Dim=2}*/ hvec_i_EpoxyObjs,
            HObjectVector/*{eObjectVector,Dim=2}*/ hvec_i_BondObjs, HObjectVector/*{eObjectVector,Dim=2}*/ hvec_i_WireObjs,
            out HObject ho_o_Balls, out HObject ho_o_Wires, out HObjectVector/*{eObjectVector,Dim=3}*/ hvec_o_FailRegs,
            HTuple hv_i_InspectItemNum, HTupleVector/*{eTupleVector,Dim=3}*/ hvec_i_FrameInspectParas,
            HTupleVector/*{eTupleVector,Dim=3}*/ hvec_i_IcInspectParas, HTupleVector/*{eTupleVector,Dim=4}*/ hvec_i_EpoxyInspectParas,
            HTupleVector/*{eTupleVector,Dim=4}*/ hvec_i_BondInspectParas, HTupleVector/*{eTupleVector,Dim=4}*/ hvec_i_WireInspectParas,
            HTupleVector/*{eTupleVector,Dim=1}*/ hvec_i_CutRegionParas, HTupleVector/*{eTupleVector,Dim=3}*/ hvec_i_AroundBallParas,
            out HTuple hv_o_OKorNG, out HTupleVector/*{eTupleVector,Dim=4}*/ hvec_o_DefectValueFrame,
            out HTupleVector/*{eTupleVector,Dim=4}*/ hvec_o_DefectValueIc, out HTupleVector/*{eTupleVector,Dim=4}*/ hvec_o_DefectValueEpoxy,
            out HTupleVector/*{eTupleVector,Dim=4}*/ hvec_o_DefectValueBond, out HTupleVector/*{eTupleVector,Dim=4}*/ hvec_o_DefectValueWire,
            out HTupleVector/*{eTupleVector,Dim=3}*/ hvec_o_DefectImgIdx, out HTupleVector/*{eTupleVector,Dim=3}*/ hvec_o_DefectType,
            out HTupleVector/*{eTupleVector,Dim=5}*/ hvec_o_RefValue, out HTuple hv_o_ErrCode,
            out HTuple hv_o_ErrStr)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_EmptyObj, ho__RejectRegUnion, ho_EmptyObject;
            HObject ho_InspectObj = null;

            HObjectVector hvec__frameLocFailRegs = new HObjectVector(2);
            HObjectVector hvec__icFailRegs = new HObjectVector(2), hvec__Ics = new HObjectVector(1);
            HObjectVector hvec__Epoxys = new HObjectVector(1), hvec_o_epoxyFailRegs = new HObjectVector(2);
            HObjectVector hvec__BallContours = new HObjectVector(1), hvec__PadRegions = new HObjectVector(1);
            HObjectVector hvec__bondFailRegs = new HObjectVector(2), hvec__WireContours = new HObjectVector(1);
            HObjectVector hvec_o_wireFailRegs = new HObjectVector(2), hvec__RejectRegs = new HObjectVector(1);
            HObjectVector hvec__frameInsFailRegs = new HObjectVector(2), hvec_o_frameFailRegs = new HObjectVector(2);
            HObjectVector hvec__aroundBallFailRegs = new HObjectVector(2);
            HObjectVector hvec_o_BondContours = new HObjectVector(1), hvec__PadContours = new HObjectVector(1);
            HObjectVector hvec_o_bondFailRegs = new HObjectVector(2), hvec_o_icFailRegs = new HObjectVector(2);

            // Local control variables 

            HTuple hv_objIdx = null, hv_i_frameObjNum = null;
            HTuple hv__frameErrCode = null, hv__frameErrStr = null;
            HTuple hv_i_icObjNum = null, hv__icErrCode = null, hv__icErrStr = null;
            HTuple hv_i_epoxyObjNum = null, hv__epoxyErrCode = null;
            HTuple hv__epoxyErrStr = null, hv_i_BondObjNum = null;
            HTuple hv__bondErrCode = null, hv__bondErrStr = null, hv_i_WireObjNum = null;
            HTuple hv__wireErrCode = null, hv__wireErrStr = null, hv__editErrCode = null;
            HTuple hv__editErrStr = null, hv_idx = null, hv_tupLen = new HTuple();
            HTuple hv_i_AroundBondObjNum = null, hv__aroundBallErrCode = null;
            HTuple hv__aroundBallErrStr = null, hv_objNum = new HTuple();
            HTuple hv_j = new HTuple(), hv__cutErrCode = null, hv__cutErrStr = null;
            HTuple hv__DieErrCode = null, hv__DieErrStr = null;

            HTupleVector hvec__frameLocPara = new HTupleVector(1);
            HTupleVector hvec__frameHomMat2D = new HTupleVector(1), hvec__frameLocDefectType = new HTupleVector(2);
            HTupleVector hvec__LocDefectValueFrame = new HTupleVector(3);
            HTupleVector hvec__frameLocDefectImgIdx = new HTupleVector(2);
            HTupleVector hvec__LocRefValueFrame = new HTupleVector(3), hvec__icHomMat2D = new HTupleVector(1);
            HTupleVector hvec__icDefectType = new HTupleVector(2), hvec__DefectValueIc = new HTupleVector(4);
            HTupleVector hvec__icDefectImgIdx = new HTupleVector(2), hvec_o_RefValueIc = new HTupleVector(4);
            HTupleVector hvec__epoxyDefectType = new HTupleVector(2), hvec__epoxyDefectImgIdx = new HTupleVector(2);
            HTupleVector hvec_o_RefValueEpoxy = new HTupleVector(4), hvec__BallType = new HTupleVector(1);
            HTupleVector hvec__bondDefectType = new HTupleVector(2), hvec__DefectValueBond = new HTupleVector(4);
            HTupleVector hvec__bondDefectImgIdx = new HTupleVector(2), hvec__RefValueBond = new HTupleVector(4);
            HTupleVector hvec__wireDefectType = new HTupleVector(2), hvec__wireDefectImgIdx = new HTupleVector(2);
            HTupleVector hvec_o_RefValueWire = new HTupleVector(4), hvec__frameInsDefectType = new HTupleVector(2);
            HTupleVector hvec__InsDefectValueFrame = new HTupleVector(3);
            HTupleVector hvec__frameInsDefectImgIdx = new HTupleVector(2);
            HTupleVector hvec__InsRefValueFrame = new HTupleVector(3), hvec_o_frameDefectType = new HTupleVector(2);
            HTupleVector hvec_o_frameDefectImgIdx = new HTupleVector(2), hvec_o_RefValueFrame = new HTupleVector(4);
            HTupleVector hvec__aroundBallDefectType = new HTupleVector(2);
            HTupleVector hvec__aroundBallDefectImgIdx = new HTupleVector(2);
            HTupleVector hvec__RefValueAroundBond = new HTupleVector(4), hvec_o_bondDefectType = new HTupleVector(2);
            HTupleVector hvec_o_bondDefectImgIdx = new HTupleVector(2), hvec_o_RefValueBond = new HTupleVector(4);
            HTupleVector hvec_o_icDefectType = new HTupleVector(2), hvec_o_icDefectImgIdx = new HTupleVector(2);
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_Balls);
            HOperatorSet.GenEmptyObj(out ho_o_Wires);
            HOperatorSet.GenEmptyObj(out ho_EmptyObj);
            HOperatorSet.GenEmptyObj(out ho__RejectRegUnion);
            HOperatorSet.GenEmptyObj(out ho_EmptyObject);
            HOperatorSet.GenEmptyObj(out ho_InspectObj);
            hvec_o_FailRegs = new HObjectVector(3);
            try
            {
                //**************************************************************************************************
                //---函数：JSCC_AOI_Inspect_Unit
                //---作用：执行各检测项
                //---参数：
                //===图标参数
                //  i_Imgs：检测所需图像集合
                //  i_SearchRegs：搜索区
                //  i_FrameObjs：Frame检测区域对象
                //  i_IcObjs：Ic检测区域对象
                //  i_EpoxyObjs：Epoxy检测区域对象
                //  i_BondObjs：Bond检测区域对象
                //  i_WireObjs：Wire检测区域对象
                //  o_Balls:检出的Bond区域
                //  o_Wires：检出的Wire区域
                //  o_FailRegs：检出失败的区域
                //===控制参数
                //  i_InspectItemNum：各检测项数目
                //  i_FrameInspectParas：Frame检测参数
                //  i_IcInspectParas：Ic检测参数
                //  i_EpoxyInspectParas：Epoxy检测参数
                //  i_BondInspectParas：Bond检测参数
                //  i_WireInspectParas：Wire检测参数
                //  o_OKorNG：OK或NG标志
                //  o_DefectType：输出的检测得到的异常区域的缺陷类型
                //  o_DefectImgIdx：异常区域的所检图像索引
                //  o_ErrCode：错误码
                //  o_ErrStr：错误信息
                //**************************************************************************************************

                //初始化
                hv_o_OKorNG = new HTuple();
                hvec_o_DefectType = (new HTupleVector(3).Insert(0, (new HTupleVector(2).Insert(0, (
                    new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))));
                hvec_o_DefectImgIdx = (new HTupleVector(3).Insert(0, (new HTupleVector(2).Insert(0, (
                    new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))));
                hvec_o_RefValue = (new HTupleVector(5).Insert(0, (new HTupleVector(4).Insert(0, (
                    new HTupleVector(3).Insert(0, (new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))))))));
                hv_o_ErrCode = -2;
                hv_o_ErrStr = "initializing";

                //Frame检测结果初值
                //[定位Score, frame检测缺陷信息,  PegRack检测缺陷信息,  Bridge检测缺陷信息]
                hvec_o_DefectValueFrame = (new HTupleVector(4).Insert(0, (new HTupleVector(3).Insert(0, (
                    new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))))));
                HTuple end_val40 = (hv_i_InspectItemNum.TupleSelect(
                    0)) - 1;
                HTuple step_val40 = 1;
                for (hv_objIdx = 0; hv_objIdx.Continue(end_val40, step_val40); hv_objIdx = hv_objIdx.TupleAdd(step_val40))
                {
                    hvec_o_DefectValueFrame[hv_objIdx] = (new HTupleVector(3).Insert(0, ((((new HTupleVector(2).Insert(0, (
                        new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(-2)))))).Insert(
                        1, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple()))))).Insert(
                        2, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple()))))).Insert(
                        3, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))));
                }

                //Ic检测结果初值
                //[定位Score, IC偏移量, IC旋转角度, 重点区异物信息, 崩边区异物信息]
                hvec_o_DefectValueIc = (new HTupleVector(4).Insert(0, (new HTupleVector(3).Insert(0, (
                    new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))))));
                HTuple end_val47 = (hv_i_InspectItemNum.TupleSelect(
                    1)) - 1;
                HTuple step_val47 = 1;
                for (hv_objIdx = 0; hv_objIdx.Continue(end_val47, step_val47); hv_objIdx = hv_objIdx.TupleAdd(step_val47))
                {
                    hvec_o_DefectValueIc[hv_objIdx] = (new HTupleVector(3).Insert(0, (((((new HTupleVector(2).Insert(0, (
                        new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(-2)))))).Insert(
                        1, (new HTupleVector(1).Insert(0, new HTupleVector((new HTuple(-2)).TupleConcat(
                        -2)))))).Insert(2, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(-2)))))).Insert(
                        3, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple()))))).Insert(
                        4, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))));
                }

                //Epoxy检测结果初值
                //[银胶区长度比, 银胶区高度]
                hvec_o_DefectValueEpoxy = (new HTupleVector(4).Insert(0, (new HTupleVector(3).Insert(0, (
                    new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))))));
                HTuple end_val54 = (hv_i_InspectItemNum.TupleSelect(
                    2)) - 1;
                HTuple step_val54 = 1;
                for (hv_objIdx = 0; hv_objIdx.Continue(end_val54, step_val54); hv_objIdx = hv_objIdx.TupleAdd(step_val54))
                {
                    hvec_o_DefectValueEpoxy[hv_objIdx] = (new HTupleVector(3).Insert(0, (new HTupleVector(2).Insert(0, (
                        new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))));
                }

                //Bond检测结果初值
                //[焊球半径,偏移量, 尾丝长, 焊盘异物信息]
                hvec_o_DefectValueBond = (new HTupleVector(4).Insert(0, (new HTupleVector(3).Insert(0, (
                    new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))))));
                HTuple end_val61 = (hv_i_InspectItemNum.TupleSelect(
                    3)) - 1;
                HTuple step_val61 = 1;
                for (hv_objIdx = 0; hv_objIdx.Continue(end_val61, step_val61); hv_objIdx = hv_objIdx.TupleAdd(step_val61))
                {
                    hvec_o_DefectValueBond[hv_objIdx] = (new HTupleVector(3).Insert(0, (new HTupleVector(2).Insert(0, (
                        new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))));
                }

                //Wire检测结果初值
                //[断线距离]
                hvec_o_DefectValueWire = (new HTupleVector(4).Insert(0, (new HTupleVector(3).Insert(0, (
                    new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))))));
                HTuple end_val68 = (hv_i_InspectItemNum.TupleSelect(
                    4)) - 1;
                HTuple step_val68 = 1;
                for (hv_objIdx = 0; hv_objIdx.Continue(end_val68, step_val68); hv_objIdx = hv_objIdx.TupleAdd(step_val68))
                {
                    hvec_o_DefectValueWire[hv_objIdx] = (new HTupleVector(3).Insert(0, (new HTupleVector(2).Insert(0, (
                        new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))));
                }

                //
                ho_o_Balls.Dispose();
                HOperatorSet.GenEmptyObj(out ho_o_Balls);
                ho_o_Wires.Dispose();
                HOperatorSet.GenEmptyObj(out ho_o_Wires);
                ho_EmptyObj.Dispose();
                HOperatorSet.GenEmptyObj(out ho_EmptyObj);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hvec_o_FailRegs = dh.Take((
                        dh.Add(new HObjectVector(3)).Insert(0, (dh.Add(new HObjectVector(2)).Insert(0, (
                        dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho_EmptyObj)))))))));
                }

                //
                //***************************对Die区域进行分区域检测****************************
                //
                //--------Frame定位
                //
                //检测frame项目数量
                hv_i_frameObjNum = hv_i_InspectItemNum[0];
                //
                hvec__frameLocFailRegs.Dispose();
                HTV_frames_locate(ho_i_Imgs, ho_i_SearchReg, hvec_i_FrameObjs, out hvec__frameLocFailRegs,
                    hv_i_frameObjNum, hvec_i_FrameInspectParas, out hvec__frameLocPara, out hvec__frameHomMat2D,
                    out hvec__frameLocDefectType, out hvec__LocDefectValueFrame, out hvec__frameLocDefectImgIdx,
                    out hvec__LocRefValueFrame, out hv__frameErrCode, out hv__frameErrStr);
                //
                //--------Ic检测：Ic定位，表面，旋转、偏移检测
                //
                //检测ic项目数量
                hv_i_icObjNum = hv_i_InspectItemNum[1];
                //
                hvec__icFailRegs.Dispose(); hvec__Ics.Dispose();
                HTV_ics_inspect(ho_i_Imgs, hvec_i_IcObjs, out hvec__icFailRegs, out hvec__Ics,
                    hv_i_icObjNum, hvec__frameHomMat2D, hvec__frameLocPara, hvec_i_IcInspectParas,
                    out hvec__icHomMat2D, out hvec__icDefectType, out hvec__DefectValueIc,
                    out hvec__icDefectImgIdx, out hvec_o_RefValueIc, out hv__icErrCode, out hv__icErrStr);
                //
                //--------Epoxy检测：是否有银胶
                //
                //检测epoxy项目数量
                hv_i_epoxyObjNum = hv_i_InspectItemNum[2];
                //
                hvec__Epoxys.Dispose(); hvec_o_epoxyFailRegs.Dispose();
                HTV_epoxys_inspect(ho_i_Imgs, hvec_i_EpoxyObjs, out hvec__Epoxys, out hvec_o_epoxyFailRegs,
                    hv_i_epoxyObjNum, hvec__icHomMat2D, hvec_i_EpoxyInspectParas, out hvec__epoxyDefectType,
                    out hvec_o_DefectValueEpoxy, out hvec__epoxyDefectImgIdx, out hvec_o_RefValueEpoxy,
                    out hv__epoxyErrCode, out hv__epoxyErrStr);
                //
                //--------Bond检测：Bond定位
                //
                //检测bond项目数量
                hv_i_BondObjNum = hv_i_InspectItemNum[3];
                //
                hvec__BallContours.Dispose(); hvec__PadRegions.Dispose(); hvec__bondFailRegs.Dispose();
                HTV_bonds_inspect(ho_i_Imgs, hvec_i_BondObjs, out hvec__BallContours, out hvec__PadRegions,
                    out hvec__bondFailRegs, hv_i_BondObjNum, hvec__frameHomMat2D, hvec__icHomMat2D,
                    hvec_i_BondInspectParas, out hvec__BallType, out hvec__bondDefectType,
                    out hvec__DefectValueBond, out hvec__bondDefectImgIdx, out hvec__RefValueBond,
                    out hv__bondErrCode, out hv__bondErrStr);
                //
                //--------Wire检测：断线、弯曲线，双丝、塌丝
                //
                //检测wire项目数量
                hv_i_WireObjNum = hv_i_InspectItemNum[4];
                //
                hvec__WireContours.Dispose(); hvec_o_wireFailRegs.Dispose();
                HTV_wires_inspect(ho_i_Imgs, hvec_i_WireObjs, hvec__BallContours, out hvec__WireContours,
                    out hvec_o_wireFailRegs, hv_i_WireObjNum, hvec__frameHomMat2D, hvec__icHomMat2D,
                    hvec_i_WireInspectParas, hvec__BallType, out hvec__wireDefectType, out hvec_o_DefectValueWire,
                    out hvec__wireDefectImgIdx, out hvec_o_RefValueWire, out hv__wireErrCode,
                    out hv__wireErrStr);
                //
                //--------区域编辑：表面检测需要去除的免检测区域
                //
                ho__RejectRegUnion.Dispose(); hvec__RejectRegs.Dispose();
                HTV_gen_inspect_cutReg(hvec__Ics, hvec__Epoxys, hvec__BallContours, hvec__WireContours,
                    out ho__RejectRegUnion, out hvec__RejectRegs, hvec_i_CutRegionParas, out hv__editErrCode,
                    out hv__editErrStr);
                //
                //--------Frame检测：钉架\桥接\框架表面检测
                //
                hvec__frameInsFailRegs.Dispose();
                HTV_frames_inspect(ho_i_Imgs, hvec_i_FrameObjs, ho__RejectRegUnion, out hvec__frameInsFailRegs,
                    hv_i_frameObjNum, hvec_i_FrameInspectParas, hvec__frameHomMat2D, out hvec__frameInsDefectType,
                    out hvec__InsDefectValueFrame, out hvec__frameInsDefectImgIdx, out hvec__InsRefValueFrame,
                    out hv__frameErrCode, out hv__frameErrStr);

                //--------合并Frame结果
                ho_EmptyObject.Dispose();
                HOperatorSet.GenEmptyObj(out ho_EmptyObject);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hvec_o_frameFailRegs = dh.Take((
                        dh.Add(new HObjectVector(2)).Insert(0, (dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho_EmptyObject)))))));
                }
                hvec_o_frameDefectType = (new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))));
                hvec_o_frameDefectImgIdx = (new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))));
                hvec_o_RefValueFrame = (new HTupleVector(4).Insert(0, (new HTupleVector(3).Insert(0, (
                    new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))))));
                HTuple end_val130 = hv_i_frameObjNum - 1;
                HTuple step_val130 = 1;
                for (hv_idx = 0; hv_idx.Continue(end_val130, step_val130); hv_idx = hv_idx.TupleAdd(step_val130))
                {
                    //一个Frame只有一个检测ID
                    hvec_o_frameFailRegs[hv_idx][0] = new HObjectVector(ho_EmptyObject.CopyObj(1, -1));

                    hvec_o_frameDefectType[hv_idx][0] = new HTupleVector((hvec__frameLocDefectType[hv_idx][0].T).TupleConcat(
                        hvec__frameInsDefectType[hv_idx][0].T));
                    hvec_o_frameDefectImgIdx[hv_idx][0] = new HTupleVector((hvec__frameLocDefectImgIdx[hv_idx][0].T).TupleConcat(
                        hvec__frameInsDefectImgIdx[hv_idx][0].T));
                    //去除正常项错误码
                    HOperatorSet.TupleLength(hvec_o_frameDefectType[hv_idx][0].T, out hv_tupLen);
                    if ((int)((new HTuple(hv_tupLen.TupleGreater(1))).TupleAnd(new HTuple((hvec__frameLocDefectType[hv_idx][0].T).TupleEqual(
                        0)))) != 0)
                    {
                        hvec_o_frameDefectType[hv_idx][0] = hvec__frameInsDefectType[hv_idx][0];
                        hvec_o_frameDefectImgIdx[hv_idx][0] = hvec__frameInsDefectImgIdx[hv_idx][0];
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(hvec_o_frameFailRegs[hv_idx][0].O, hvec__frameInsFailRegs[hv_idx][0].O,
                                out ExpTmpOutVar_0);
                            hvec_o_frameFailRegs[hv_idx][0].O = ExpTmpOutVar_0;
                            ExpTmpOutVar_0.Dispose();
                        }
                    }
                    else
                    {
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(hvec_o_frameFailRegs[hv_idx][0].O, hvec__frameLocFailRegs[hv_idx][0].O,
                                out ExpTmpOutVar_0);
                            hvec_o_frameFailRegs[hv_idx][0].O = ExpTmpOutVar_0;
                            ExpTmpOutVar_0.Dispose();
                        }
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(hvec_o_frameFailRegs[hv_idx][0].O, hvec__frameInsFailRegs[hv_idx][0].O,
                                out ExpTmpOutVar_0);
                            hvec_o_frameFailRegs[hv_idx][0].O = ExpTmpOutVar_0;
                            ExpTmpOutVar_0.Dispose();
                        }
                    }
                    //
                    hvec_o_DefectValueFrame[hv_idx][0][0] = hvec__LocDefectValueFrame[hv_idx][0];
                    hvec_o_DefectValueFrame[hv_idx][0][1] = hvec__InsDefectValueFrame[hv_idx][0];
                    hvec_o_DefectValueFrame[hv_idx][0][2] = hvec__InsDefectValueFrame[hv_idx][1];
                    hvec_o_DefectValueFrame[hv_idx][0][3] = hvec__InsDefectValueFrame[hv_idx][2];
                    //
                    hvec_o_RefValueFrame[hv_idx][0][0] = hvec__LocRefValueFrame[hv_idx][0];
                    hvec_o_RefValueFrame[hv_idx][0][1] = hvec__InsRefValueFrame[hv_idx][0];
                    hvec_o_RefValueFrame[hv_idx][0][2] = hvec__InsRefValueFrame[hv_idx][1];
                    hvec_o_RefValueFrame[hv_idx][0][3] = hvec__InsRefValueFrame[hv_idx][2];
                }
                //
                //--------Ball周围区域异常检测：如 焊点偏移检测, 焊点处尾丝检测, 焊盘上外来物
                //
                //检测aroundBond项目数量
                hv_i_AroundBondObjNum = hv_i_InspectItemNum[3];
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hvec__aroundBallFailRegs.Dispose(); hvec_o_BondContours.Dispose(); hvec__PadContours.Dispose();
                    HTV_aroundBalls_inspect(ho_i_Imgs, hvec__BallContours, hvec__PadRegions, hvec__RejectRegs[3].O,
                        out hvec__aroundBallFailRegs, out hvec_o_BondContours, out hvec__PadContours,
                        hv_i_AroundBondObjNum, hvec_i_AroundBallParas, hvec__DefectValueBond, out hvec__aroundBallDefectType,
                        out hvec_o_DefectValueBond, out hvec__aroundBallDefectImgIdx, out hvec__RefValueAroundBond,
                        out hv__aroundBallErrCode, out hv__aroundBallErrStr);
                }

                //--------合并Bond结果
                ho_EmptyObject.Dispose();
                HOperatorSet.GenEmptyObj(out ho_EmptyObject);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hvec_o_bondFailRegs = dh.Take((
                        dh.Add(new HObjectVector(2)).Insert(0, (dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho_EmptyObject)))))));
                }
                hvec_o_bondDefectType = (new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))));
                hvec_o_bondDefectImgIdx = (new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))));
                hvec_o_RefValueBond = (new HTupleVector(4).Insert(0, (new HTupleVector(3).Insert(0, (
                    new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))))));
                HTuple end_val170 = hv_i_AroundBondObjNum - 1;
                HTuple step_val170 = 1;
                for (hv_idx = 0; hv_idx.Continue(end_val170, step_val170); hv_idx = hv_idx.TupleAdd(step_val170))
                {
                    ho_InspectObj.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_InspectObj = hvec__BallContours[hv_idx].O.CopyObj(1, -1);
                    }
                    HOperatorSet.CountObj(ho_InspectObj, out hv_objNum);
                    HTuple end_val173 = hv_objNum - 1;
                    HTuple step_val173 = 1;
                    for (hv_j = 0; hv_j.Continue(end_val173, step_val173); hv_j = hv_j.TupleAdd(step_val173))
                    {
                        //一个Bond一个检测ID
                        hvec_o_bondFailRegs[hv_idx][hv_j] = new HObjectVector(ho_EmptyObject.CopyObj(1, -1));
                        hvec_o_bondDefectType[hv_idx][hv_j] = new HTupleVector((hvec__bondDefectType[hv_idx][hv_j].T).TupleConcat(
                            hvec__aroundBallDefectType[hv_idx][hv_j].T));
                        hvec_o_bondDefectImgIdx[hv_idx][hv_j] = new HTupleVector((hvec__bondDefectImgIdx[hv_idx][hv_j].T).TupleConcat(
                            hvec__aroundBallDefectImgIdx[hv_idx][hv_j].T));
                        //去除正常项错误码
                        HOperatorSet.TupleLength(hvec_o_bondDefectType[hv_idx][hv_j].T, out hv_tupLen);
                        if ((int)((new HTuple(hv_tupLen.TupleGreater(1))).TupleAnd(new HTuple((hvec__bondDefectType[hv_idx][hv_j].T).TupleEqual(
                            0)))) != 0)
                        {
                            hvec_o_bondDefectType[hv_idx][hv_j] = hvec__aroundBallDefectType[hv_idx][hv_j];
                            hvec_o_bondDefectImgIdx[hv_idx][hv_j] = hvec__aroundBallDefectImgIdx[hv_idx][hv_j];
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.ConcatObj(hvec_o_bondFailRegs[hv_idx][hv_j].O, hvec__aroundBallFailRegs[hv_idx][hv_j].O,
                                    out ExpTmpOutVar_0);
                                hvec_o_bondFailRegs[hv_idx][hv_j].O = ExpTmpOutVar_0;
                                ExpTmpOutVar_0.Dispose();
                            }
                        }
                        else
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.ConcatObj(hvec_o_bondFailRegs[hv_idx][hv_j].O, hvec__bondFailRegs[hv_idx][hv_j].O,
                                    out ExpTmpOutVar_0);
                                hvec_o_bondFailRegs[hv_idx][hv_j].O = ExpTmpOutVar_0;
                                ExpTmpOutVar_0.Dispose();
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.ConcatObj(hvec_o_bondFailRegs[hv_idx][hv_j].O, hvec__aroundBallFailRegs[hv_idx][hv_j].O,
                                    out ExpTmpOutVar_0);
                                hvec_o_bondFailRegs[hv_idx][hv_j].O = ExpTmpOutVar_0;
                                ExpTmpOutVar_0.Dispose();
                            }
                        }
                        //
                        hvec_o_RefValueBond[hv_idx][hv_j][0] = hvec__RefValueBond[hv_idx][hv_j][0];
                        hvec_o_RefValueBond[hv_idx][hv_j][1] = hvec__RefValueAroundBond[hv_idx][hv_j][1];
                        hvec_o_RefValueBond[hv_idx][hv_j][2] = hvec__RefValueAroundBond[hv_idx][hv_j][2];
                        hvec_o_RefValueBond[hv_idx][hv_j][3] = hvec__RefValueAroundBond[hv_idx][hv_j][3];
                    }
                }
                //
                //--------Ic剪切免检区域
                //
                hvec_o_icFailRegs.Dispose();
                HTV_ics_cut_region(hvec__Ics, hvec__icFailRegs, hvec__RejectRegs, hvec__PadContours,
                    out hvec_o_icFailRegs, hv_i_icObjNum, hvec__icDefectType, hvec__icDefectImgIdx,
                    hvec__DefectValueIc, hvec_i_IcInspectParas, out hvec_o_icDefectType, out hvec_o_icDefectImgIdx,
                    out hvec_o_DefectValueIc, out hv__cutErrCode, out hv__cutErrStr);

                //
                //--------Die区域各检测项目检测结果筛选
                //
                hvec_o_FailRegs.Dispose(); ho_o_Balls.Dispose(); ho_o_Wires.Dispose();
                HTV_Select_DieInspect_Result(hvec_o_frameFailRegs, hvec_o_icFailRegs, hvec_o_epoxyFailRegs,
                    hvec_o_bondFailRegs, hvec_o_wireFailRegs, hvec_o_BondContours, hvec__WireContours,
                    out hvec_o_FailRegs, out ho_o_Balls, out ho_o_Wires, hv_i_InspectItemNum,
                    hvec_o_frameDefectType, hvec_o_frameDefectImgIdx, hvec_o_icDefectType,
                    hvec_o_icDefectImgIdx, hvec__epoxyDefectType, hvec__epoxyDefectImgIdx,
                    hvec_o_bondDefectType, hvec_o_bondDefectImgIdx, hvec__wireDefectType, hvec__wireDefectImgIdx,
                    hvec_o_RefValueFrame, hvec_o_RefValueIc, hvec_o_RefValueEpoxy, hvec_o_RefValueBond,
                    hvec_o_RefValueWire, out hvec_o_DefectType, out hvec_o_DefectImgIdx, out hvec_o_RefValue,
                    out hv_o_OKorNG, out hv__DieErrCode, out hv__DieErrStr);


                hv_o_ErrCode = 0;
                hv_o_ErrStr = "inspect all items suceessful";
                ho_EmptyObj.Dispose();
                ho__RejectRegUnion.Dispose();
                ho_EmptyObject.Dispose();
                ho_InspectObj.Dispose();
                hvec__frameLocFailRegs.Dispose();
                hvec__icFailRegs.Dispose();
                hvec__Ics.Dispose();
                hvec__Epoxys.Dispose();
                hvec_o_epoxyFailRegs.Dispose();
                hvec__BallContours.Dispose();
                hvec__PadRegions.Dispose();
                hvec__bondFailRegs.Dispose();
                hvec__WireContours.Dispose();
                hvec_o_wireFailRegs.Dispose();
                hvec__RejectRegs.Dispose();
                hvec__frameInsFailRegs.Dispose();
                hvec_o_frameFailRegs.Dispose();
                hvec__aroundBallFailRegs.Dispose();
                hvec_o_BondContours.Dispose();
                hvec__PadContours.Dispose();
                hvec_o_bondFailRegs.Dispose();
                hvec_o_icFailRegs.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_EmptyObj.Dispose();
                ho__RejectRegUnion.Dispose();
                ho_EmptyObject.Dispose();
                ho_InspectObj.Dispose();
                hvec__frameLocFailRegs.Dispose();
                hvec__icFailRegs.Dispose();
                hvec__Ics.Dispose();
                hvec__Epoxys.Dispose();
                hvec_o_epoxyFailRegs.Dispose();
                hvec__BallContours.Dispose();
                hvec__PadRegions.Dispose();
                hvec__bondFailRegs.Dispose();
                hvec__WireContours.Dispose();
                hvec_o_wireFailRegs.Dispose();
                hvec__RejectRegs.Dispose();
                hvec__frameInsFailRegs.Dispose();
                hvec_o_frameFailRegs.Dispose();
                hvec__aroundBallFailRegs.Dispose();
                hvec_o_BondContours.Dispose();
                hvec__PadContours.Dispose();
                hvec_o_bondFailRegs.Dispose();
                hvec_o_icFailRegs.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public static void HTV_read_ic_model(out HObjectVector/*{eObjectVector,Dim=2}*/ hvec_o_IcObjs,
            HTuple hv_i_IcModelPath, out HTupleVector/*{eTupleVector,Dim=2}*/ hvec_o_IcModels,
            out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {



            // Local iconic variables 

            HObject ho_EmptyObject, ho_Inspect_Region = null;
            HObject ho_Match_Region = null, ho_Sub_Region = null, ho_Reject_Region = null;
            HObject ho_Light_Image = null, ho_Dark_Image = null, ho_Mean_Image = null;

            // Local control variables 

            HTuple hv_IsString = null, hv_fileidx = null;
            HTuple hv__Path = new HTuple(), hv__IcModel = new HTuple();
            HTuple hv__filePath = new HTuple(), hv_FileExists = new HTuple();
            HTuple hv_Task_Enable = new HTuple(), hv_Image_Index = new HTuple();
            HTuple hv_OnWhat = new HTuple(), hv_Model_Type = new HTuple();
            HTuple hv_PosModel = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_EmptyObject);
            HOperatorSet.GenEmptyObj(out ho_Inspect_Region);
            HOperatorSet.GenEmptyObj(out ho_Match_Region);
            HOperatorSet.GenEmptyObj(out ho_Sub_Region);
            HOperatorSet.GenEmptyObj(out ho_Reject_Region);
            HOperatorSet.GenEmptyObj(out ho_Light_Image);
            HOperatorSet.GenEmptyObj(out ho_Dark_Image);
            HOperatorSet.GenEmptyObj(out ho_Mean_Image);
            hvec_o_IcObjs = new HObjectVector(2);
            try
            {
                //***************读取所有Ic的模板文件***************************************************************
                //---输入控制参数
                //i_IcModelPath ：存放模板的路径，一般指Moldes下的文件
                //---输出图标参数
                //o_IcObjs：Ic检测所需对象集合：二维集合向量
                //---输出控制参数
                //o_IcModels：Ic检测所需参数集合：一维向量
                //o_ErrCode：错误码，代表该算子在执行过程中产生的错误，0-代表执行正常，-1-代表执行异常，-2-代表未执行
                //o_ErrStr: 错误信息，对各种错误的具体描述
                //*******************************************************************************************************88
                //
                //初始化
                //
                ho_EmptyObject.Dispose();
                HOperatorSet.GenEmptyObj(out ho_EmptyObject);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hvec_o_IcObjs = dh.Take((
                        dh.Add(new HObjectVector(2)).Insert(0, (dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho_EmptyObject)))))));
                }
                //
                hvec_o_IcModels = (new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))));
                //
                hv_o_ErrCode = -2;
                hv_o_ErrStr = "initializing!";
                //
                //传入有效性测试
                HOperatorSet.TupleIsString(hv_i_IcModelPath, out hv_IsString);
                if ((int)((new HTuple(hv_IsString.TupleEqual("false"))).TupleOr(new HTuple((new HTuple(hv_i_IcModelPath.TupleLength()
                    )).TupleEqual(0)))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "the para i_IcModelPath must be a string and the para |i_IcModelPath| must greater than 0";
                    ho_EmptyObject.Dispose();
                    ho_Inspect_Region.Dispose();
                    ho_Match_Region.Dispose();
                    ho_Sub_Region.Dispose();
                    ho_Reject_Region.Dispose();
                    ho_Light_Image.Dispose();
                    ho_Dark_Image.Dispose();
                    ho_Mean_Image.Dispose();

                    return;
                }

                //
                //读取各检测所需文件
                //
                for (hv_fileidx = 0; (int)hv_fileidx <= (int)((new HTuple(hv_i_IcModelPath.TupleLength()
                    )) - 1); hv_fileidx = (int)hv_fileidx + 1)
                {
                    //
                    hv__Path = hv_i_IcModelPath.TupleSelect(hv_fileidx);
                    hv__IcModel = new HTuple();
                    //IC检测区域
                    hv__filePath = hv__Path + "Inspect_Region.reg";
                    ho_Inspect_Region.Dispose();
                    HOperatorSet.ReadRegion(out ho_Inspect_Region, hv__filePath);
                    //IC匹配区域
                    hv__filePath = hv__Path + "Match_Region.reg";
                    ho_Match_Region.Dispose();
                    HOperatorSet.ReadRegion(out ho_Match_Region, hv__filePath);
                    //IC重点检测区域
                    hv__filePath = hv__Path + "Sub_Region.reg";
                    ho_Sub_Region.Dispose();
                    HOperatorSet.ReadRegion(out ho_Sub_Region, hv__filePath);
                    //Ic免检区域
                    hv__filePath = hv__Path + "Reject_Region.reg";
                    HOperatorSet.FileExists(hv__filePath, out hv_FileExists);
                    if ((int)(hv_FileExists) != 0)
                    {
                        ho_Reject_Region.Dispose();
                        HOperatorSet.ReadRegion(out ho_Reject_Region, hv__filePath);
                    }
                    else
                    {
                        ho_Reject_Region.Dispose();
                        HOperatorSet.GenEmptyObj(out ho_Reject_Region);
                    }
                    //Ic亮图
                    hv__filePath = hv__Path + "Light_Image.tiff";
                    ho_Light_Image.Dispose();
                    HOperatorSet.ReadImage(out ho_Light_Image, hv__filePath);
                    //Ic暗图
                    hv__filePath = hv__Path + "Dark_Image.tiff";
                    ho_Dark_Image.Dispose();
                    HOperatorSet.ReadImage(out ho_Dark_Image, hv__filePath);
                    //均值图
                    hv__filePath = hv__Path + "Mean_Image.tiff";
                    ho_Mean_Image.Dispose();
                    HOperatorSet.ReadImage(out ho_Mean_Image, hv__filePath);
                    //
                    //整合Ic_Object对象
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hvec_o_IcObjs[hv_fileidx] = dh.Take((((((((
                            dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho_Inspect_Region)))).Insert(
                            1, dh.Add(new HObjectVector(ho_Match_Region)))).Insert(2, dh.Add(new HObjectVector(ho_Sub_Region)))).Insert(
                            3, dh.Add(new HObjectVector(ho_Reject_Region)))).Insert(4, dh.Add(new HObjectVector(ho_Light_Image)))).Insert(
                            5, dh.Add(new HObjectVector(ho_Dark_Image)))).Insert(6, dh.Add(new HObjectVector(ho_Mean_Image)))));
                    }
                    //
                    //读取检测任务使能
                    hv__filePath = hv__Path + "TaskEnable.tup";
                    HOperatorSet.ReadTuple(hv__filePath, out hv_Task_Enable);
                    //
                    //读取制作模板所用图序
                    hv__filePath = hv__Path + "Image_Index.tup";
                    HOperatorSet.ReadTuple(hv__filePath, out hv_Image_Index);
                    //
                    //读取Ic位置信息
                    hv__filePath = hv__Path + "OnWhat.tup";
                    HOperatorSet.ReadTuple(hv__filePath, out hv_OnWhat);
                    //读取IC定位模板参数
                    hv__filePath = hv__Path + "Model_Type.tup";
                    HOperatorSet.ReadTuple(hv__filePath, out hv_Model_Type);
                    //
                    hv__filePath = hv__Path + "PosModel.dat";
                    if ((int)(new HTuple(hv_Model_Type.TupleEqual("ncc"))) != 0)
                    {
                        HOperatorSet.ReadNccModel(hv__filePath, out hv_PosModel);
                    }
                    else if ((int)(new HTuple(hv_Model_Type.TupleEqual("shape"))) != 0)
                    {
                        HOperatorSet.ReadShapeModel(hv__filePath, out hv_PosModel);
                    }
                    //
                    //整合Ic_Models模板参数
                    hv__IcModel = new HTuple();
                    hv__IcModel = hv__IcModel.TupleConcat(hv_OnWhat);
                    hv__IcModel = hv__IcModel.TupleConcat(hv_Model_Type);
                    hv__IcModel = hv__IcModel.TupleConcat(hv_PosModel);
                    hvec_o_IcModels[hv_fileidx] = (((new HTupleVector(1).Insert(0, new HTupleVector(hv_Task_Enable))).Insert(
                        1, new HTupleVector(hv_Image_Index))).Insert(2, new HTupleVector(hv__IcModel)));
                }

                hv_o_ErrCode = 0;
                hv_o_ErrStr = "read Ic models successful!";
                ho_EmptyObject.Dispose();
                ho_Inspect_Region.Dispose();
                ho_Match_Region.Dispose();
                ho_Sub_Region.Dispose();
                ho_Reject_Region.Dispose();
                ho_Light_Image.Dispose();
                ho_Dark_Image.Dispose();
                ho_Mean_Image.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_EmptyObject.Dispose();
                ho_Inspect_Region.Dispose();
                ho_Match_Region.Dispose();
                ho_Sub_Region.Dispose();
                ho_Reject_Region.Dispose();
                ho_Light_Image.Dispose();
                ho_Dark_Image.Dispose();
                ho_Mean_Image.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public static void HTV_read_epoxy_model(out HObjectVector/*{eObjectVector,Dim=2}*/ hvec_o_EpoxyObjs,
            HTuple hv_i_EpoxyModelPath, out HTupleVector/*{eTupleVector,Dim=2}*/ hvec_o_EpoxyModels,
            out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {



            // Local iconic variables 

            HObject ho_EmptyObject, ho_Inspect_Region = null;
            HObject ho_Reference_Region = null;

            // Local control variables 

            HTuple hv_IsString = null, hv_fileidx = null;
            HTuple hv__Path = new HTuple(), hv__EpoxyModel = new HTuple();
            HTuple hv__filePath = new HTuple(), hv_Image_Index = new HTuple();
            HTuple hv_OnWhat = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_EmptyObject);
            HOperatorSet.GenEmptyObj(out ho_Inspect_Region);
            HOperatorSet.GenEmptyObj(out ho_Reference_Region);
            hvec_o_EpoxyObjs = new HObjectVector(2);
            //***********读取所有Epoxy的模板文件********
            //---输入控制参数
            //i_EpoxyModelPath：存放Epoxy模板文件的路径；
            //---输出图标参数
            //o_EpoxyObjs：Epoxy检测所需要的对象集合：二维集合向量
            //---输出控制参数
            //o_EpoxyModels：Epoxy检测所需要参数集合：一维向量
            //o_ErrCode：错误码，代表该算子在执行过程中产生的错误，0-代表执行正常，-1-代表执行异常，-2-代表未执行
            //o_ErrStr: 错误信息，对各种错误的具体描述
            //*************************************************************************************
            //
            //初始化
            //
            ho_EmptyObject.Dispose();
            HOperatorSet.GenEmptyObj(out ho_EmptyObject);
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hvec_o_EpoxyObjs = dh.Take((
                    dh.Add(new HObjectVector(2)).Insert(0, (dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho_EmptyObject)))))));
            }
            //
            hvec_o_EpoxyModels = (new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))));
            //
            hv_o_ErrCode = -2;
            hv_o_ErrStr = "initializing!";

            //传入有效性测试
            HOperatorSet.TupleIsString(hv_i_EpoxyModelPath, out hv_IsString);
            if ((int)((new HTuple(hv_IsString.TupleEqual("false"))).TupleOr(new HTuple((new HTuple(hv_i_EpoxyModelPath.TupleLength()
                )).TupleEqual(0)))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "the para i_EpoxyModelPath must be a string and the para |i_EpoxyModelPath| must greater than 0";
                ho_EmptyObject.Dispose();
                ho_Inspect_Region.Dispose();
                ho_Reference_Region.Dispose();

                return;
            }
            //
            //读取各检测需要的文件
            for (hv_fileidx = 0; (int)hv_fileidx <= (int)((new HTuple(hv_i_EpoxyModelPath.TupleLength()
                )) - 1); hv_fileidx = (int)hv_fileidx + 1)
            {
                //
                hv__Path = hv_i_EpoxyModelPath.TupleSelect(hv_fileidx);
                hv__EpoxyModel = new HTuple();
                //Epoxy检测区域
                hv__filePath = hv__Path + "Inspect_Regions.reg";
                ho_Inspect_Region.Dispose();
                HOperatorSet.ReadRegion(out ho_Inspect_Region, hv__filePath);
                //Epoxy参考区域
                hv__filePath = hv__Path + "Reference_Region.reg";
                ho_Reference_Region.Dispose();
                HOperatorSet.ReadRegion(out ho_Reference_Region, hv__filePath);
                //整合o_EpoxyObjs对象
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hvec_o_EpoxyObjs[hv_fileidx] = dh.Take(((
                        dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho_Inspect_Region)))).Insert(
                        1, dh.Add(new HObjectVector(ho_Reference_Region)))));
                }
                //
                //读取制作模板所用图序
                hv__filePath = hv__Path + "Image_Index.tup";
                HOperatorSet.ReadTuple(hv__filePath, out hv_Image_Index);
                //
                //读取Epoxy位置信息
                hv__filePath = hv__Path + "OnWhat.tup";
                HOperatorSet.ReadTuple(hv__filePath, out hv_OnWhat);
                //
                hvec_o_EpoxyModels[hv_fileidx] = ((new HTupleVector(1).Insert(0, new HTupleVector(hv_Image_Index))).Insert(
                    1, new HTupleVector(hv_OnWhat)));
            }
            hv_o_ErrCode = 0;
            hv_o_ErrStr = "read epoxy models successful!";
            ho_EmptyObject.Dispose();
            ho_Inspect_Region.Dispose();
            ho_Reference_Region.Dispose();

            return;
        }


        public static void HTV_read_wire_model(out HObjectVector/*{eObjectVector,Dim=2}*/ hvec_o_WireObjs,
            HTuple hv_i_WireModelPath, out HTupleVector/*{eTupleVector,Dim=2}*/ hvec_o_WireModels,
            out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {



            // Local iconic variables 

            HObject ho_EmptyObject, ho_Start_Regions = null;
            HObject ho_Stop_Regions = null, ho_Inspect_Regions = null;

            // Local control variables 

            HTuple hv_IsString = null, hv_fileidx = null;
            HTuple hv__Path = new HTuple(), hv__WireModel = new HTuple();
            HTuple hv__filePath = new HTuple(), hv_IsEnableVirtualBond = new HTuple();
            HTuple hv_StartRegBelongToWhat = new HTuple(), hv_StopRegBelongToWhat = new HTuple();
            HTuple hv_InspectRegNum = new HTuple(), hv_Startreg_index_after_sort = new HTuple();
            HTuple hv_FileExists = new HTuple(), hv_Stopreg_index_after_sort = new HTuple();
            HTuple hv_Startreg_need_sort = new HTuple(), hv_Stopreg_need_sort = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_EmptyObject);
            HOperatorSet.GenEmptyObj(out ho_Start_Regions);
            HOperatorSet.GenEmptyObj(out ho_Stop_Regions);
            HOperatorSet.GenEmptyObj(out ho_Inspect_Regions);
            hvec_o_WireObjs = new HObjectVector(2);
            //***************读取所有Wire的模板文件***************************************************************
            //---输入控制参数
            //i_WireModelPath ：存放Wire模板的路径，一般指Moldes下的文件
            //---输出图标参数
            //o_WireObjs：Wire检测所需对象集合：二维集合向量
            //---输出控制参数
            //o_WireModels：Wire检测所需要的模板文件中的参数集合：一维向量
            //o_ErrCode：错误码，代表该算子在执行过程中产生的错误，0-代表执行正常，-1-代表执行异常，-2-代表未执行
            //o_ErrStr: 错误信息，对各种错误的具体描述
            //*******************************************************************************************************88
            //
            //初始化
            //

            ho_EmptyObject.Dispose();
            HOperatorSet.GenEmptyObj(out ho_EmptyObject);
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hvec_o_WireObjs = dh.Take((
                    dh.Add(new HObjectVector(2)).Insert(0, (dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho_EmptyObject)))))));
            }
            //
            hvec_o_WireModels = (new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))));
            //
            hv_o_ErrCode = -2;
            hv_o_ErrStr = "initializing!";

            //传入有效性测试
            HOperatorSet.TupleIsString(hv_i_WireModelPath, out hv_IsString);
            if ((int)((new HTuple(hv_IsString.TupleEqual("false"))).TupleOr(new HTuple((new HTuple(hv_i_WireModelPath.TupleLength()
                )).TupleEqual(0)))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "the para i_LightOrDark must be a                 string and the para |i_WireModelPath| must greater than 0";
                ho_EmptyObject.Dispose();
                ho_Start_Regions.Dispose();
                ho_Stop_Regions.Dispose();
                ho_Inspect_Regions.Dispose();

                return;
            }

            //读取检测所取文件
            //
            for (hv_fileidx = 0; (int)hv_fileidx <= (int)((new HTuple(hv_i_WireModelPath.TupleLength()
                )) - 1); hv_fileidx = (int)hv_fileidx + 1)
            {
                //
                hv__Path = hv_i_WireModelPath.TupleSelect(hv_fileidx);
                hv__WireModel = new HTuple();
                //----object类型
                //金线起始焊点区域
                hv__filePath = hv__Path + "Start_Regions.reg";
                ho_Start_Regions.Dispose();
                HOperatorSet.ReadRegion(out ho_Start_Regions, hv__filePath);
                //金线结束焊点区域
                hv__filePath = hv__Path + "Stop_Regions.reg";
                ho_Stop_Regions.Dispose();
                HOperatorSet.ReadRegion(out ho_Stop_Regions, hv__filePath);
                //Wire检测区域
                hv__filePath = hv__Path + "Inspect_Regions.reg";
                ho_Inspect_Regions.Dispose();
                HOperatorSet.ReadRegion(out ho_Inspect_Regions, hv__filePath);
                //整合Wire_object对象
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hvec_o_WireObjs[hv_fileidx] = dh.Take((((
                        dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho_Start_Regions)))).Insert(
                        1, dh.Add(new HObjectVector(ho_Stop_Regions)))).Insert(2, dh.Add(new HObjectVector(ho_Inspect_Regions)))));
                }
                //
                //---parameter tuple类型
                //读取制作模板所用图序:不使用唯一图像索引进行金线检测
                //_filePath := _Path+'Image_Index.tup'
                //read_tuple (_filePath, Image_Index)
                //读取检测金线是否使用起始焊点区域、结束焊点区域作为金线检测的实际焊点区域
                hv__filePath = hv__Path + "IsEnableVirtualBond.tup";
                HOperatorSet.ReadTuple(hv__filePath, out hv_IsEnableVirtualBond);
                //读取金线起始焊点区域归属
                hv__filePath = hv__Path + "StartRegBelongToWhat.tup";
                HOperatorSet.ReadTuple(hv__filePath, out hv_StartRegBelongToWhat);
                //读取金线结束焊点区域归属
                hv__filePath = hv__Path + "StopRegBelongToWhat.tup";
                HOperatorSet.ReadTuple(hv__filePath, out hv_StopRegBelongToWhat);
                //读取金线检测区域数量数组
                hv__filePath = hv__Path + "InspectRegNum.tup";
                HOperatorSet.ReadTuple(hv__filePath, out hv_InspectRegNum);
                //
                //1104 增加读取焊点组合后的排序信息
                hv_Startreg_index_after_sort = new HTuple();
                hv__filePath = hv__Path + "Startreg_index_after_sort.tup";
                HOperatorSet.FileExists(hv__filePath, out hv_FileExists);
                if ((int)(hv_FileExists) != 0)
                {
                    HOperatorSet.ReadTuple(hv__filePath, out hv_Startreg_index_after_sort);
                }
                else
                {
                    hv_Startreg_index_after_sort = HTuple.TupleGenSequence(1, new HTuple(hv_InspectRegNum.TupleLength()
                        ), 1);
                }
                //
                hv_Stopreg_index_after_sort = new HTuple();
                hv__filePath = hv__Path + "Stopreg_index_after_sort.tup";
                HOperatorSet.FileExists(hv__filePath, out hv_FileExists);
                if ((int)(hv_FileExists) != 0)
                {
                    HOperatorSet.ReadTuple(hv__filePath, out hv_Stopreg_index_after_sort);
                }
                else
                {
                    hv_Stopreg_index_after_sort = HTuple.TupleGenSequence(1, new HTuple(hv_InspectRegNum.TupleLength()
                        ), 1);
                }
                //
                hv__filePath = hv__Path + "Startreg_need_sort.tup";
                hv_Startreg_need_sort = 0;
                HOperatorSet.FileExists(hv__filePath, out hv_FileExists);
                if ((int)(hv_FileExists) != 0)
                {
                    HOperatorSet.ReadTuple(hv__filePath, out hv_Startreg_need_sort);
                }
                //
                hv__filePath = hv__Path + "Stopreg_need_sort.tup";
                hv_Stopreg_need_sort = 0;
                HOperatorSet.FileExists(hv__filePath, out hv_FileExists);
                if ((int)(hv_FileExists) != 0)
                {
                    HOperatorSet.ReadTuple(hv__filePath, out hv_Stopreg_need_sort);
                }
                //整合WireModels对象
                hvec_o_WireModels[hv_fileidx] = ((((((((new HTupleVector(1).Insert(0, new HTupleVector(hv_IsEnableVirtualBond))).Insert(
                    1, new HTupleVector(hv_StartRegBelongToWhat))).Insert(2, new HTupleVector(hv_StopRegBelongToWhat))).Insert(
                    3, new HTupleVector(hv_InspectRegNum))).Insert(4, new HTupleVector(hv_Startreg_index_after_sort))).Insert(
                    5, new HTupleVector(hv_Stopreg_index_after_sort))).Insert(6, new HTupleVector(hv_Startreg_need_sort))).Insert(
                    7, new HTupleVector(hv_Stopreg_need_sort)));
            }
            hv_o_ErrCode = 0;
            hv_o_ErrStr = "read Wire models successful!";
            ho_EmptyObject.Dispose();
            ho_Start_Regions.Dispose();
            ho_Stop_Regions.Dispose();
            ho_Inspect_Regions.Dispose();

            return;
        }

        public static void HTV_read_bond_model(out HObjectVector/*{eObjectVector,Dim=2}*/ hvec_o_BondObjs,
            HTuple hv_i_BondModelPath, out HTupleVector/*{eTupleVector,Dim=2}*/ hvec_o_BondModels,
            out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {



            // Local iconic variables 

            HObject ho_EmptyObject, ho_Inspect_Regions = null;
            HObject ho_Model_Image = null, ho_Pad_Regions = null;

            // Local control variables 

            HTuple hv_IsString = null, hv_fileidx = null;
            HTuple hv__Path = new HTuple(), hv_Matches = new HTuple();
            HTuple hv__filePath = new HTuple(), hv__RecipePath = new HTuple();
            HTuple hv_OnWhat = new HTuple(), hv__InspectMethod = new HTuple();
            HTuple hv_Model_Type = new HTuple(), hv_PosModel = new HTuple();
            HTuple hv_FileExists = new HTuple(), hv_MetrologyType = new HTuple();
            HTuple hv_MetrologyHandle = new HTuple(), hv_DistanceThreshold = new HTuple();
            HTuple hv_Indices = new HTuple(), hv_Idx = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_EmptyObject);
            HOperatorSet.GenEmptyObj(out ho_Inspect_Regions);
            HOperatorSet.GenEmptyObj(out ho_Model_Image);
            HOperatorSet.GenEmptyObj(out ho_Pad_Regions);
            hvec_o_BondObjs = new HObjectVector(2);
            try
            {
                //***********读取所有Bond的模板文件******************************************
                //---输入控制参数
                //i_BondModelPath ：存放bond模板的路径，一般指Moldes下的文件
                //---输出图标参数
                //o_BondObjs：bond检测所需对象集合：二维集合向量
                //---输出控制参数
                //o_BondModels：Ic检测所需参数集合：一维向量
                //o_ErrCode：错误码，代表该算子在执行过程中产生的错误，0-代表执行正常，-1-代表执行异常，-2-代表未执行
                //o_ErrStr: 错误信息，对各种错误的具体描述
                //****************************************************************************
                //
                //初始化
                //
                ho_EmptyObject.Dispose();
                HOperatorSet.GenEmptyObj(out ho_EmptyObject);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hvec_o_BondObjs = dh.Take((
                        dh.Add(new HObjectVector(2)).Insert(0, (dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho_EmptyObject)))))));
                }
                //
                hvec_o_BondModels = (new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))));
                //
                hv_o_ErrCode = -2;
                hv_o_ErrStr = "initializing!";
                //
                //传入有效性测试
                HOperatorSet.TupleIsString(hv_i_BondModelPath, out hv_IsString);
                if ((int)((new HTuple(hv_IsString.TupleEqual("false"))).TupleOr(new HTuple((new HTuple(hv_i_BondModelPath.TupleLength()
                    )).TupleEqual(0)))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "the para i_BondModelPath must be a string and the para |i_BondModelPath| must greater than 0";
                    ho_EmptyObject.Dispose();
                    ho_Inspect_Regions.Dispose();
                    ho_Model_Image.Dispose();
                    ho_Pad_Regions.Dispose();

                    return;
                }
                //
                //读取各检测所取文件
                //
                for (hv_fileidx = 0; (int)hv_fileidx <= (int)((new HTuple(hv_i_BondModelPath.TupleLength()
                    )) - 1); hv_fileidx = (int)hv_fileidx + 1)
                {
                    //
                    hv__Path = hv_i_BondModelPath.TupleSelect(hv_fileidx);
                    //分类别读取
                    HOperatorSet.TupleRegexpMatch(hv__Path, "Match", out hv_Matches);
                    //
                    if ((int)(new HTuple(hv_Matches.TupleEqual("Match"))) != 0)
                    {
                        //读取Bond检测区域
                        hv__filePath = hv__Path + "Inspect_Regions.reg";
                        ho_Inspect_Regions.Dispose();
                        HOperatorSet.ReadRegion(out ho_Inspect_Regions, hv__filePath);
                        //读取Bond模板旋正图（在recipe下）
                        HOperatorSet.TupleRegexpReplace(hv__Path, new HTuple("Models/") + "*", "Recipe/",
                            out hv__RecipePath);
                        hv__filePath = hv__RecipePath + "RotatedImage1.tiff";
                        ho_Model_Image.Dispose();
                        HOperatorSet.ReadImage(out ho_Model_Image, hv__filePath);

                        //整合检测区域和图像
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hvec_o_BondObjs[hv_fileidx] = dh.Take(((
                                dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho_Inspect_Regions)))).Insert(
                                1, dh.Add(new HObjectVector(ho_Model_Image)))));
                        }
                        //
                        //modify by wj 01-12
                        //读取制作模板所用图序
                        //_filePath := _Path+'Image_Index.tup'
                        //read_tuple (_filePath, Image_Index)
                        //
                        //读取Bond位置信息
                        hv__filePath = hv__Path + "OnWhat.tup";
                        HOperatorSet.ReadTuple(hv__filePath, out hv_OnWhat);
                        //选定Bond的检测方法
                        hv__InspectMethod = 0;
                        //
                        hv__filePath = hv__Path + "Model_Type.tup";
                        HOperatorSet.ReadTuple(hv__filePath, out hv_Model_Type);
                        //
                        hv__filePath = hv__Path + "PosModel.dat";
                        if ((int)(new HTuple(hv_Model_Type.TupleEqual("ncc"))) != 0)
                        {
                            HOperatorSet.ReadNccModel(hv__filePath, out hv_PosModel);
                        }
                        else if ((int)(new HTuple(hv_Model_Type.TupleEqual("shape"))) != 0)
                        {
                            HOperatorSet.ReadShapeModel(hv__filePath, out hv_PosModel);
                        }

                        //modify by wj 2021-01-12
                        //读取检测区域内检测Bond数量
                        //_filePath := _Path+'BallNum_OnRegion.tup'
                        //read_tuple (_filePath, BallNum_OnRegion)
                        //读取bond模板匹配的起始角度
                        //_filePath := _Path+'Match_StartAngle.tup'
                        //read_tuple (_filePath, Match_StartAngle)

                        //读取bond模板匹配的匹配角度范围
                        //_filePath := _Path+'Match_AngleExt.tup'
                        //read_tuple (_filePath, Match_AngleExt)
                        //读取bond模板匹配的匹配最小分数
                        //_filePath := _Path+'Match_MinScore.tup'
                        //read_tuple (_filePath, Match_MinScore)
                        //读取匹配到的焊点设置半径
                        //_filePath := _Path+'BallRadius.tup'
                        //read_tuple (_filePath, BallRadius)
                        //焊点匹配优化参数
                        //读取匹配优化开关
                        //_filePath := _Path+'IsBondRegRefine.tup'
                        //file_exists (_filePath, FileExists)
                        //if (FileExists)
                        //read_tuple (_filePath, IsBondRegRefine)
                        //else
                        //IsBondRegRefine := 0
                        //endif
                        //读取检测Bond增加数量
                        //_filePath := _Path+'AddBallNum.tup'
                        //file_exists (_filePath, FileExists)
                        //if (FileExists)
                        //read_tuple (_filePath, AddBallNum)
                        //else
                        //AddBallNum := 3
                        //endif
                        //读取匹配结果最大重合度
                        //_filePath := _Path+'MaxOverlap.tup'
                        //file_exists (_filePath, FileExists)
                        //if (FileExists)
                        //read_tuple (_filePath, MaxOverlap)
                        //else
                        //MaxOverlap := 0.9
                        //endif
                        //读取匹配结果最小直方图相似性分数
                        //_filePath := _Path+'MinHistScore.tup'
                        //file_exists (_filePath, FileExists)
                        //if (FileExists)
                        //read_tuple (_filePath, MinHistScore)
                        //else
                        //MinHistScore := 0.5
                        //endif

                        //整合Bond_Models模板参数
                        hvec_o_BondModels[hv_fileidx] = ((((new HTupleVector(1).Insert(0, new HTupleVector(hv_OnWhat))).Insert(
                            1, new HTupleVector(hv__InspectMethod))).Insert(2, new HTupleVector(hv_Model_Type))).Insert(
                            3, new HTupleVector(hv_PosModel)));
                    }
                    else
                    {
                        //读取bond焊盘区域
                        hv__filePath = hv__Path + "Pad_Regions.reg";
                        ho_Pad_Regions.Dispose();
                        HOperatorSet.ReadRegion(out ho_Pad_Regions, hv__filePath);
                        //整合检测区域
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hvec_o_BondObjs[hv_fileidx] = dh.Take((
                                dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho_Pad_Regions)))));
                        }
                        //
                        //读取制作模板所用图序
                        //_filePath := _Path+'Image_Index.tup'
                        //read_tuple (_filePath, Image_Index)
                        //
                        //读取Bond位置信息
                        hv__filePath = hv__Path + "OnWhat.tup";
                        HOperatorSet.ReadTuple(hv__filePath, out hv_OnWhat);
                        //选定bond的检测方法
                        hv__InspectMethod = 1;
                        //测量句柄类型
                        hv__filePath = hv__Path + "MetrologyType.tup";
                        HOperatorSet.ReadTuple(hv__filePath, out hv_MetrologyType);
                        //测量句柄
                        hv__filePath = hv__Path + "MetrologyHandle.mtr";
                        HOperatorSet.ReadMetrologyModel(hv__filePath, out hv_MetrologyHandle);

                        //***因为write_metrology_model无法保存distance_threshold参数，故此设置参数 add lw1021
                        //***读取边缘点距离阈值参数用以更新MetrologyHandle
                        hv__filePath = hv__Path + "MetrologyDistanceThreshold.tup";
                        HOperatorSet.FileExists(hv__filePath, out hv_FileExists);
                        if ((int)(hv_FileExists) != 0)
                        {
                            HOperatorSet.ReadTuple(hv__filePath, out hv_DistanceThreshold);
                            HOperatorSet.GetMetrologyObjectIndices(hv_MetrologyHandle, out hv_Indices);
                            if ((int)(new HTuple((new HTuple(hv_Indices.TupleLength())).TupleEqual(
                                new HTuple(hv_DistanceThreshold.TupleLength())))) != 0)
                            {
                                for (hv_Idx = 0; (int)hv_Idx <= (int)((new HTuple(hv_Indices.TupleLength()
                                    )) - 1); hv_Idx = (int)hv_Idx + 1)
                                {
                                    HOperatorSet.SetMetrologyObjectParam(hv_MetrologyHandle, hv_Indices.TupleSelect(
                                        hv_Idx), "distance_threshold", hv_DistanceThreshold.TupleSelect(
                                        hv_Idx));
                                }
                            }
                        }

                        //读取焊点过大系数
                        //_filePath := _Path+'BondOverSizeFactor.tup'
                        //file_exists (_filePath, FileExists)
                        //if (FileExists)
                        //read_tuple (_filePath, BondOverSizeFactor)
                        //else
                        //BondOverSizeFactor := 1.5
                        //endif
                        //读取焊点过小系数
                        //_filePath := _Path+'BondUnderSizeFactor.tup'
                        //file_exists (_filePath, FileExists)
                        //if (FileExists)
                        //read_tuple (_filePath, BondUnderSizeFactor)
                        //else
                        //BondUnderSizeFactor := 0.5
                        //endif
                        //预判断参数
                        //_filePath := _Path+'PreJudgeEnable.tup'
                        //file_exists (_filePath, FileExists)
                        //if (FileExists)
                        //read_tuple (_filePath, PreJudgeEnable)
                        //else
                        //PreJudgeEnable := 0
                        //endif
                        //预判断分割阈值
                        //_filePath := _Path+'SegThreshGray.tup'
                        //file_exists (_filePath, FileExists)
                        //if (FileExists)
                        //read_tuple (_filePath, SegThreshGray)
                        //else
                        //SegThreshGray := [180, 255]
                        //endif
                        //预判断分割面积占比
                        //_filePath := _Path+'SegRegAreaFactor.tup'
                        //file_exists (_filePath, FileExists)
                        //if (FileExists)
                        //read_tuple (_filePath, SegRegAreaFactor)
                        //else
                        //SegRegAreaFactor := 0.4
                        //endif

                        //整合Bond_Models模板参数
                        hvec_o_BondModels[hv_fileidx] = ((((new HTupleVector(1).Insert(0, new HTupleVector(hv_OnWhat))).Insert(
                            1, new HTupleVector(hv__InspectMethod))).Insert(2, new HTupleVector(hv_MetrologyType))).Insert(
                            3, new HTupleVector(hv_MetrologyHandle)));
                    }
                }
                hv_o_ErrCode = 0;
                hv_o_ErrStr = "read bond models successful!";
                ho_EmptyObject.Dispose();
                ho_Inspect_Regions.Dispose();
                ho_Model_Image.Dispose();
                ho_Pad_Regions.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_EmptyObject.Dispose();
                ho_Inspect_Regions.Dispose();
                ho_Model_Image.Dispose();
                ho_Pad_Regions.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public static void HTV_read_frame_recipe(HTuple hv_i_FrameRecipePath, out HTupleVector/*{eTupleVector,Dim=2}*/ hvec_o_FrameParameters,
            out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_IsString = null, hv_fileidx = null;
            HTuple hv__xmlPath = new HTuple(), hv__MinMatchScore = new HTuple();
            HTuple hv__MatchStartAngle = new HTuple(), hv__MatchAngleExt = new HTuple();
            HTuple hv__MatchNum = new HTuple(), hv__DilationSize = new HTuple();
            HTuple hv__FrameLocParameters = new HTuple(), hv_fileExists = new HTuple();
            HTuple hv_RegSegMethod = new HTuple(), hv_RegSegMethodIndex = new HTuple();
            HTuple hv__AdaptiveMethod = new HTuple(), hv__BlockSize = new HTuple();
            HTuple hv__Contrast = new HTuple(), hv__LightOrDark = new HTuple();
            HTuple hv__CloseSize = new HTuple(), hv__MinLength = new HTuple();
            HTuple hv__MinWidth = new HTuple(), hv__MinArea = new HTuple();
            HTuple hv__SelOperation = new HTuple(), hv__FrameInsParameters = new HTuple();
            HTuple hv_ThreshGray = new HTuple(), hv_ThreshGrayInOrOut = new HTuple();
            HTuple hv_MorphSize = new HTuple(), hv__PegRackParameters = new HTuple();
            HTuple hv__BridgeParameters = new HTuple();

            HTupleVector hvec_LoadedElements = new HTupleVector(2);
            HTupleVector hvec_ParameterVector = new HTupleVector(3), hvec_subParameterVector = new HTupleVector(2);
            // Initialize local and output iconic variables 
            //***************读取所有Frame的检测参数文件***************************************************************
            //---输入控制参数
            //i_FrameRecipePath ：存放Frame模板的路径，一般指Moldes下的文件
            //---输出控制参数
            //o_FrameParameters：Frame检测所需参数集合：二维向量
            //o_ErrCode：错误码，代表该算子在执行过程中产生的错误，0-代表执行正常，-1-代表执行异常，-2-代表未执行
            //o_ErrStr: 错误信息，对各种错误的具体描述
            //************************************************************************************************
            //
            //初始化
            //
            hvec_o_FrameParameters = (new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))));
            //
            hv_o_ErrCode = -2;
            hv_o_ErrStr = "initializing!";

            //传入有效性测试
            HOperatorSet.TupleIsString(hv_i_FrameRecipePath, out hv_IsString);
            if ((int)((new HTuple(hv_IsString.TupleEqual("false"))).TupleOr(new HTuple((new HTuple(hv_i_FrameRecipePath.TupleLength()
                )).TupleEqual(0)))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "the para i_FrameRecipePath must be a string and the para |i_FrameRecipePath|                 must greater than 0";

                return;
            }
            //
            //读取Frame检测项检测参数
            //
            for (hv_fileidx = 0; (int)hv_fileidx <= (int)((new HTuple(hv_i_FrameRecipePath.TupleLength()
                )) - 1); hv_fileidx = (int)hv_fileidx + 1)
            {
                //
                //********xml中读取以下参数***************************************************
                hv__xmlPath = (hv_i_FrameRecipePath.TupleSelect(hv_fileidx)) + "FrameRecipe.xml";
                fread_xml_to_vector(hv__xmlPath, out hvec_LoadedElements);
                //
                //1------Frame定位参数
                get_subvector_param(hvec_LoadedElements, "FrameLocateParameter", "/FrameLocateParameter",
                    out hvec_ParameterVector);
                //
                //选取参数
                hvec_subParameterVector = hvec_ParameterVector[0];
                //定位参数
                get_vector_param_value(hvec_subParameterVector, "MinMatchScore", out hv__MinMatchScore);
                get_vector_param_value(hvec_subParameterVector, "AngleStart", out hv__MatchStartAngle);
                get_vector_param_value(hvec_subParameterVector, "AngleExt", out hv__MatchAngleExt);
                get_vector_param_value(hvec_subParameterVector, "MatchNum", out hv__MatchNum);
                get_vector_param_value(hvec_subParameterVector, "DilationSize", out hv__DilationSize);
                //
                hv__FrameLocParameters = new HTuple();
                hv__FrameLocParameters = hv__FrameLocParameters.TupleConcat(hv__MinMatchScore);
                hv__FrameLocParameters = hv__FrameLocParameters.TupleConcat(hv__MatchStartAngle);
                hv__FrameLocParameters = hv__FrameLocParameters.TupleConcat(hv__MatchAngleExt);
                hv__FrameLocParameters = hv__FrameLocParameters.TupleConcat(hv__MatchNum);
                hv__FrameLocParameters = hv__FrameLocParameters.TupleConcat(hv__DilationSize);

                //------检测参数
                hv__xmlPath = (hv_i_FrameRecipePath.TupleSelect(hv_fileidx)) + "SurfaceDetectionRecipe.xml";

                //不进行框架表面检测不存在该xml
                HOperatorSet.FileExists(hv__xmlPath, out hv_fileExists);
                if ((int)(hv_fileExists) != 0)
                {
                    fread_xml_to_vector(hv__xmlPath, out hvec_LoadedElements);

                    //2------Frame检测参数
                    get_subvector_param(hvec_LoadedElements, "FrameInspectParameter", "/FrameInspectParameter",
                        out hvec_ParameterVector);
                    //
                    hvec_subParameterVector = hvec_ParameterVector[0];
                    get_vector_param_value(hvec_subParameterVector, "RegSegMethod", out hv_RegSegMethod);
                    //
                    if ((int)(new HTuple(hv_RegSegMethod.TupleEqual("Adaptive"))) != 0)
                    {
                        hv_RegSegMethodIndex = 0;
                        get_vector_param_value(hvec_subParameterVector, "AdaptiveMethod", out hv__AdaptiveMethod);
                        get_vector_param_value(hvec_subParameterVector, "BlockSize", out hv__BlockSize);
                        get_vector_param_value(hvec_subParameterVector, "Contrast", out hv__Contrast);
                        get_vector_param_value(hvec_subParameterVector, "LightOrDark", out hv__LightOrDark);
                        get_vector_param_value(hvec_subParameterVector, "CloseSize", out hv__CloseSize);
                        get_vector_param_value(hvec_subParameterVector, "MinLength", out hv__MinLength);
                        get_vector_param_value(hvec_subParameterVector, "MinWidth", out hv__MinWidth);
                        get_vector_param_value(hvec_subParameterVector, "MinArea", out hv__MinArea);
                        get_vector_param_value(hvec_subParameterVector, "SelOperation", out hv__SelOperation);

                        hv__FrameInsParameters = new HTuple();
                        hv__FrameInsParameters = hv__FrameInsParameters.TupleConcat(hv_RegSegMethodIndex);
                        hv__FrameInsParameters = hv__FrameInsParameters.TupleConcat(hv__AdaptiveMethod);
                        hv__FrameInsParameters = hv__FrameInsParameters.TupleConcat(hv__BlockSize);
                        hv__FrameInsParameters = hv__FrameInsParameters.TupleConcat(hv__Contrast);
                        hv__FrameInsParameters = hv__FrameInsParameters.TupleConcat(hv__LightOrDark);
                        hv__FrameInsParameters = hv__FrameInsParameters.TupleConcat(hv__CloseSize);
                        hv__FrameInsParameters = hv__FrameInsParameters.TupleConcat(hv__MinLength);
                        hv__FrameInsParameters = hv__FrameInsParameters.TupleConcat(hv__MinWidth);
                        hv__FrameInsParameters = hv__FrameInsParameters.TupleConcat(hv__MinArea);
                        hv__FrameInsParameters = hv__FrameInsParameters.TupleConcat(hv__SelOperation);
                    }
                    else if ((int)(new HTuple(hv_RegSegMethod.TupleEqual("Global"))) != 0)
                    {
                        hv_RegSegMethodIndex = 1;
                        get_vector_param_value(hvec_subParameterVector, "ThreshGray", out hv_ThreshGray);
                        get_vector_param_value(hvec_subParameterVector, "ThreshGrayInOrOut", out hv_ThreshGrayInOrOut);
                        get_vector_param_value(hvec_subParameterVector, "MorphSize", out hv_MorphSize);
                        get_vector_param_value(hvec_subParameterVector, "CloseSize", out hv__CloseSize);
                        get_vector_param_value(hvec_subParameterVector, "MinLength", out hv__MinLength);
                        get_vector_param_value(hvec_subParameterVector, "MinWidth", out hv__MinWidth);
                        get_vector_param_value(hvec_subParameterVector, "MinArea", out hv__MinArea);
                        get_vector_param_value(hvec_subParameterVector, "SelOperation", out hv__SelOperation);

                        hv__FrameInsParameters = new HTuple();
                        hv__FrameInsParameters = hv__FrameInsParameters.TupleConcat(hv_RegSegMethodIndex);
                        hv__FrameInsParameters = hv__FrameInsParameters.TupleConcat(hv_ThreshGray);
                        hv__FrameInsParameters = hv__FrameInsParameters.TupleConcat(hv_ThreshGrayInOrOut);
                        hv__FrameInsParameters = hv__FrameInsParameters.TupleConcat(hv_MorphSize);
                        hv__FrameInsParameters = hv__FrameInsParameters.TupleConcat(hv__CloseSize);
                        hv__FrameInsParameters = hv__FrameInsParameters.TupleConcat(hv__MinLength);
                        hv__FrameInsParameters = hv__FrameInsParameters.TupleConcat(hv__MinWidth);
                        hv__FrameInsParameters = hv__FrameInsParameters.TupleConcat(hv__MinArea);
                        hv__FrameInsParameters = hv__FrameInsParameters.TupleConcat(hv__SelOperation);
                    }
                    //
                    //3----PegRack检测参数
                    //PegRackInspectParameter
                    get_subvector_param(hvec_LoadedElements, "PegRackInspectParameter", "/PegRackInspectParameter",
                        out hvec_ParameterVector);
                    //
                    hvec_subParameterVector = hvec_ParameterVector[0];
                    get_vector_param_value(hvec_subParameterVector, "RegSegMethod", out hv_RegSegMethod);
                    //
                    if ((int)(new HTuple(hv_RegSegMethod.TupleEqual("Adaptive"))) != 0)
                    {
                        hv_RegSegMethodIndex = 0;
                        get_vector_param_value(hvec_subParameterVector, "AdaptiveMethod", out hv__AdaptiveMethod);
                        get_vector_param_value(hvec_subParameterVector, "BlockSize", out hv__BlockSize);
                        get_vector_param_value(hvec_subParameterVector, "Contrast", out hv__Contrast);
                        get_vector_param_value(hvec_subParameterVector, "LightOrDark", out hv__LightOrDark);
                        get_vector_param_value(hvec_subParameterVector, "CloseSize", out hv__CloseSize);
                        get_vector_param_value(hvec_subParameterVector, "MinLength", out hv__MinLength);
                        get_vector_param_value(hvec_subParameterVector, "MinWidth", out hv__MinWidth);
                        get_vector_param_value(hvec_subParameterVector, "MinArea", out hv__MinArea);
                        get_vector_param_value(hvec_subParameterVector, "SelOperation", out hv__SelOperation);

                        hv__PegRackParameters = new HTuple();
                        hv__PegRackParameters = hv__PegRackParameters.TupleConcat(hv_RegSegMethodIndex);
                        hv__PegRackParameters = hv__PegRackParameters.TupleConcat(hv__AdaptiveMethod);
                        hv__PegRackParameters = hv__PegRackParameters.TupleConcat(hv__BlockSize);
                        hv__PegRackParameters = hv__PegRackParameters.TupleConcat(hv__Contrast);
                        hv__PegRackParameters = hv__PegRackParameters.TupleConcat(hv__LightOrDark);
                        hv__PegRackParameters = hv__PegRackParameters.TupleConcat(hv__CloseSize);
                        hv__PegRackParameters = hv__PegRackParameters.TupleConcat(hv__MinLength);
                        hv__PegRackParameters = hv__PegRackParameters.TupleConcat(hv__MinWidth);
                        hv__PegRackParameters = hv__PegRackParameters.TupleConcat(hv__MinArea);
                        hv__PegRackParameters = hv__PegRackParameters.TupleConcat(hv__SelOperation);
                    }
                    else if ((int)(new HTuple(hv_RegSegMethod.TupleEqual("Global"))) != 0)
                    {
                        hv_RegSegMethodIndex = 1;
                        get_vector_param_value(hvec_subParameterVector, "ThreshGray", out hv_ThreshGray);
                        get_vector_param_value(hvec_subParameterVector, "ThreshGrayInOrOut", out hv_ThreshGrayInOrOut);
                        get_vector_param_value(hvec_subParameterVector, "MorphSize", out hv_MorphSize);
                        get_vector_param_value(hvec_subParameterVector, "CloseSize", out hv__CloseSize);
                        get_vector_param_value(hvec_subParameterVector, "MinLength", out hv__MinLength);
                        get_vector_param_value(hvec_subParameterVector, "MinWidth", out hv__MinWidth);
                        get_vector_param_value(hvec_subParameterVector, "MinArea", out hv__MinArea);
                        get_vector_param_value(hvec_subParameterVector, "SelOperation", out hv__SelOperation);

                        hv__PegRackParameters = new HTuple();
                        hv__PegRackParameters = hv__PegRackParameters.TupleConcat(hv_RegSegMethodIndex);
                        hv__PegRackParameters = hv__PegRackParameters.TupleConcat(hv_ThreshGray);
                        hv__PegRackParameters = hv__PegRackParameters.TupleConcat(hv_ThreshGrayInOrOut);
                        hv__PegRackParameters = hv__PegRackParameters.TupleConcat(hv_MorphSize);
                        hv__PegRackParameters = hv__PegRackParameters.TupleConcat(hv__CloseSize);
                        hv__PegRackParameters = hv__PegRackParameters.TupleConcat(hv__MinLength);
                        hv__PegRackParameters = hv__PegRackParameters.TupleConcat(hv__MinWidth);
                        hv__PegRackParameters = hv__PegRackParameters.TupleConcat(hv__MinArea);
                        hv__PegRackParameters = hv__PegRackParameters.TupleConcat(hv__SelOperation);
                    }
                    //4----Bridge检测参数
                    //BridgeInspectParameter
                    get_subvector_param(hvec_LoadedElements, "BridgeInspectParameter", "/BridgeInspectParameter",
                        out hvec_ParameterVector);
                    //
                    hvec_subParameterVector = hvec_ParameterVector[0];
                    get_vector_param_value(hvec_subParameterVector, "RegSegMethod", out hv_RegSegMethod);

                    if ((int)(new HTuple(hv_RegSegMethod.TupleEqual("Adaptive"))) != 0)
                    {
                        hv_RegSegMethodIndex = 0;
                        get_vector_param_value(hvec_subParameterVector, "AdaptiveMethod", out hv__AdaptiveMethod);
                        get_vector_param_value(hvec_subParameterVector, "BlockSize", out hv__BlockSize);
                        get_vector_param_value(hvec_subParameterVector, "Contrast", out hv__Contrast);
                        get_vector_param_value(hvec_subParameterVector, "LightOrDark", out hv__LightOrDark);
                        get_vector_param_value(hvec_subParameterVector, "CloseSize", out hv__CloseSize);
                        get_vector_param_value(hvec_subParameterVector, "MinLength", out hv__MinLength);
                        get_vector_param_value(hvec_subParameterVector, "MinWidth", out hv__MinWidth);
                        get_vector_param_value(hvec_subParameterVector, "MinArea", out hv__MinArea);
                        get_vector_param_value(hvec_subParameterVector, "SelOperation", out hv__SelOperation);

                        hv__BridgeParameters = new HTuple();
                        hv__BridgeParameters = hv__BridgeParameters.TupleConcat(hv_RegSegMethodIndex);
                        hv__BridgeParameters = hv__BridgeParameters.TupleConcat(hv__AdaptiveMethod);
                        hv__BridgeParameters = hv__BridgeParameters.TupleConcat(hv__BlockSize);
                        hv__BridgeParameters = hv__BridgeParameters.TupleConcat(hv__Contrast);
                        hv__BridgeParameters = hv__BridgeParameters.TupleConcat(hv__LightOrDark);
                        hv__BridgeParameters = hv__BridgeParameters.TupleConcat(hv__CloseSize);
                        hv__BridgeParameters = hv__BridgeParameters.TupleConcat(hv__MinLength);
                        hv__BridgeParameters = hv__BridgeParameters.TupleConcat(hv__MinWidth);
                        hv__BridgeParameters = hv__BridgeParameters.TupleConcat(hv__MinArea);
                        hv__BridgeParameters = hv__BridgeParameters.TupleConcat(hv__SelOperation);
                    }
                    else if ((int)(new HTuple(hv_RegSegMethod.TupleEqual("Global"))) != 0)
                    {
                        hv_RegSegMethodIndex = 1;
                        get_vector_param_value(hvec_subParameterVector, "ThreshGray", out hv_ThreshGray);
                        get_vector_param_value(hvec_subParameterVector, "ThreshGrayInOrOut", out hv_ThreshGrayInOrOut);
                        get_vector_param_value(hvec_subParameterVector, "MorphSize", out hv_MorphSize);
                        get_vector_param_value(hvec_subParameterVector, "CloseSize", out hv__CloseSize);
                        get_vector_param_value(hvec_subParameterVector, "MinLength", out hv__MinLength);
                        get_vector_param_value(hvec_subParameterVector, "MinWidth", out hv__MinWidth);
                        get_vector_param_value(hvec_subParameterVector, "MinArea", out hv__MinArea);
                        get_vector_param_value(hvec_subParameterVector, "SelOperation", out hv__SelOperation);

                        hv__BridgeParameters = new HTuple();
                        hv__BridgeParameters = hv__BridgeParameters.TupleConcat(hv_RegSegMethodIndex);
                        hv__BridgeParameters = hv__BridgeParameters.TupleConcat(hv_ThreshGray);
                        hv__BridgeParameters = hv__BridgeParameters.TupleConcat(hv_ThreshGrayInOrOut);
                        hv__BridgeParameters = hv__BridgeParameters.TupleConcat(hv_MorphSize);
                        hv__BridgeParameters = hv__BridgeParameters.TupleConcat(hv__CloseSize);
                        hv__BridgeParameters = hv__BridgeParameters.TupleConcat(hv__MinLength);
                        hv__BridgeParameters = hv__BridgeParameters.TupleConcat(hv__MinWidth);
                        hv__BridgeParameters = hv__BridgeParameters.TupleConcat(hv__MinArea);
                        hv__BridgeParameters = hv__BridgeParameters.TupleConcat(hv__SelOperation);
                    }
                }
                else
                {
                    hv__FrameInsParameters = new HTuple();
                    hv__PegRackParameters = new HTuple();
                    hv__BridgeParameters = new HTuple();
                }
                //
                //********************************************************************************
                //
                //接口函数输出结果
                hvec_o_FrameParameters[hv_fileidx] = ((((new HTupleVector(1).Insert(0, new HTupleVector(hv__FrameLocParameters))).Insert(
                    1, new HTupleVector(hv__FrameInsParameters))).Insert(2, new HTupleVector(hv__PegRackParameters))).Insert(
                    3, new HTupleVector(hv__BridgeParameters)));
                //
                hv__FrameLocParameters = new HTuple();
                hv__FrameInsParameters = new HTuple();
                hv__PegRackParameters = new HTuple();
                hv__BridgeParameters = new HTuple();
            }
            hv_o_ErrCode = 0;
            hv_o_ErrStr = "read Frame parameters successful!";

            return;
        }

        public static void HTV_read_ic_recipe(HTuple hv_i_IcRecipePath, out HTupleVector/*{eTupleVector,Dim=2}*/ hvec_o_IcParameters,
            out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_IsString = null, hv_fileidx = null;
            HTuple hv__xmlPath = new HTuple(), hv__ThreshGray = new HTuple();
            HTuple hv__LightOrDark = new HTuple(), hv__CloseSize = new HTuple();
            HTuple hv__IcSizeTh = new HTuple(), hv__DilationSize = new HTuple();
            HTuple hv__MinMatchScore = new HTuple(), hv__MatchStartAngle = new HTuple();
            HTuple hv__MatchAngleExt = new HTuple(), hv__MatchNum = new HTuple();
            HTuple hv__RowDiffTh = new HTuple(), hv__ColDiffTh = new HTuple();
            HTuple hv__AngleDiffTh = new HTuple(), hv__GrayContrast = new HTuple();
            HTuple hv__MinLength = new HTuple(), hv__MinWidth = new HTuple();
            HTuple hv__MinArea = new HTuple(), hv__SelOperation = new HTuple();
            HTuple hv__IsChromatismProcess = new HTuple(), hv__IsGlobalChromatism = new HTuple();

            HTupleVector hvec_LoadedElements = new HTupleVector(2);
            HTupleVector hvec_ParameterVector = new HTupleVector(3), hvec_subParameterVector = new HTupleVector(2);
            HTupleVector hvec_IcParameters = new HTupleVector(1);
            // Initialize local and output iconic variables 
            //***************读取所有Frame的检测参数文件***************************************************************
            //---输入控制参数
            //i_IcRecipePath ：存放Ic模板的路径，一般指Moldes下的文件
            //---输出控制参数
            //o_IcParameters：Ic检测所需参数集合：二维向量
            //o_ErrCode：错误码，代表该算子在执行过程中产生的错误，0-代表执行正常，-1-代表执行异常，-2-代表未执行
            //o_ErrStr: 错误信息，对各种错误的具体描述
            //************************************************************************************************
            //
            //初始化
            //
            hvec_o_IcParameters = (new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))));
            //
            hv_o_ErrCode = -2;
            hv_o_ErrStr = "initializing!";

            //传入有效性测试
            HOperatorSet.TupleIsString(hv_i_IcRecipePath, out hv_IsString);
            if ((int)((new HTuple(hv_IsString.TupleEqual("false"))).TupleOr(new HTuple((new HTuple(hv_i_IcRecipePath.TupleLength()
                )).TupleEqual(0)))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "the para i_IcRecipePathmust be a string and the para |i_IcRecipePath|                 must greater than 0";

                return;
            }
            //
            //读取Ic检测项检测参数
            //
            for (hv_fileidx = 0; (int)hv_fileidx <= (int)((new HTuple(hv_i_IcRecipePath.TupleLength()
                )) - 1); hv_fileidx = (int)hv_fileidx + 1)
            {
                //
                //
                //********xml中读取以下参数***************************************************
                hv__xmlPath = (hv_i_IcRecipePath.TupleSelect(hv_fileidx)) + "IcRecipe.xml";
                fread_xml_to_vector(hv__xmlPath, out hvec_LoadedElements);

                //GoldenModelInspectParameter
                get_subvector_param(hvec_LoadedElements, "GoldenModelInspectParameter", "/GoldenModelInspectParameter",
                    out hvec_ParameterVector);
                //
                hvec_subParameterVector = hvec_ParameterVector[0];
                //有无检测参数
                get_vector_param_value(hvec_subParameterVector, "ThreshGray", out hv__ThreshGray);
                get_vector_param_value(hvec_subParameterVector, "LightOrDark", out hv__LightOrDark);
                get_vector_param_value(hvec_subParameterVector, "CloseSize", out hv__CloseSize);
                get_vector_param_value(hvec_subParameterVector, "IcSizeTh", out hv__IcSizeTh);
                //匹配定位参数
                get_vector_param_value(hvec_subParameterVector, "DilationSize", out hv__DilationSize);
                get_vector_param_value(hvec_subParameterVector, "MinMatchScore", out hv__MinMatchScore);
                get_vector_param_value(hvec_subParameterVector, "AngleStart", out hv__MatchStartAngle);
                get_vector_param_value(hvec_subParameterVector, "AngleExt", out hv__MatchAngleExt);
                get_vector_param_value(hvec_subParameterVector, "MatchNum", out hv__MatchNum);
                //偏移参数
                get_vector_param_value(hvec_subParameterVector, "RowDiffTh", out hv__RowDiffTh);
                get_vector_param_value(hvec_subParameterVector, "ColDiffTh", out hv__ColDiffTh);
                get_vector_param_value(hvec_subParameterVector, "AngleDiffTh", out hv__AngleDiffTh);
                //表面检测参数
                get_vector_param_value(hvec_subParameterVector, "GrayContrast", out hv__GrayContrast);
                get_vector_param_value(hvec_subParameterVector, "MinLength", out hv__MinLength);
                get_vector_param_value(hvec_subParameterVector, "MinWidth", out hv__MinWidth);
                get_vector_param_value(hvec_subParameterVector, "MinArea", out hv__MinArea);
                get_vector_param_value(hvec_subParameterVector, "SelOperation", out hv__SelOperation);
                //色差图检测优化参数
                get_vector_param_value(hvec_subParameterVector, "IsChromatismProcess", out hv__IsChromatismProcess);
                get_vector_param_value(hvec_subParameterVector, "IsGlobalChromatism", out hv__IsGlobalChromatism);
                //
                hvec_IcParameters = (((((((((((((((((((new HTupleVector(1).Insert(0, new HTupleVector(hv__ThreshGray))).Insert(
                    1, new HTupleVector(hv__LightOrDark))).Insert(2, new HTupleVector(hv__CloseSize))).Insert(
                    3, new HTupleVector(hv__IcSizeTh))).Insert(4, new HTupleVector(hv__DilationSize))).Insert(
                    5, new HTupleVector(hv__MinMatchScore))).Insert(6, new HTupleVector(hv__MatchStartAngle))).Insert(
                    7, new HTupleVector(hv__MatchAngleExt))).Insert(8, new HTupleVector(hv__MatchNum))).Insert(
                    9, new HTupleVector(hv__RowDiffTh))).Insert(10, new HTupleVector(hv__ColDiffTh))).Insert(
                    11, new HTupleVector(hv__AngleDiffTh))).Insert(12, new HTupleVector(hv__GrayContrast))).Insert(
                    13, new HTupleVector(hv__MinLength))).Insert(14, new HTupleVector(hv__MinWidth))).Insert(
                    15, new HTupleVector(hv__MinArea))).Insert(16, new HTupleVector(hv__SelOperation))).Insert(
                    17, new HTupleVector(hv__IsChromatismProcess))).Insert(18, new HTupleVector(hv__IsGlobalChromatism)));
                //
                //*****************************************************************************
                //接口函数输出结果
                hvec_o_IcParameters[hv_fileidx] = hvec_IcParameters.Clone();
                hvec_IcParameters = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())));
            }
            hv_o_ErrCode = 0;
            hv_o_ErrStr = "read ic parameters successful!";

            return;
        }

        // 在【表面检测】：更新HTV_read_frame_recipe函数，【单节点】中的此函数HTV_read_frame_recipe替换--更新时间2020-08-12 

        public static void HTV_read_epoxy_recipe(HTuple hv_i_EpoxyRecipePath, out HTupleVector/*{eTupleVector,Dim=3}*/ hvec_o_EpoxyParameters,
            out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_IsString = null, hv_fileidx = null;
            HTuple hv__xmlPath = new HTuple(), hv_Idx = new HTuple();
            HTuple hv__ThreshGray = new HTuple(), hv__LightOrDark = new HTuple();
            HTuple hv__OpeningSize = new HTuple(), hv__EpoxyLenTh = new HTuple();
            HTuple hv__EpoxyHeiTh = new HTuple();

            HTupleVector hvec_LoadedElements = new HTupleVector(2);
            HTupleVector hvec_ParameterVector = new HTupleVector(3), hvec_subParameterVector = new HTupleVector(2);
            HTupleVector hvec__EpoxyInspect_Paras = new HTupleVector(2);
            // Initialize local and output iconic variables 
            //***************读取所有Frame的检测参数文件***************************************************************
            //---输入控制参数
            //i_EpoxyRecipePath ：存放Frame模板的路径，一般指Moldes下的文件
            //---输出控制参数
            //o_EpoxyParameters：Frame检测所需参数集合：二维向量
            //o_ErrCode：错误码，代表该算子在执行过程中产生的错误，0-代表执行正常，-1-代表执行异常，-2-代表未执行
            //o_ErrStr: 错误信息，对各种错误的具体描述
            //************************************************************************************************
            //
            //初始化
            //
            hvec_o_EpoxyParameters = (new HTupleVector(3).Insert(0, (new HTupleVector(2).Insert(0, (
                new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))));
            //
            hv_o_ErrCode = -2;
            hv_o_ErrStr = "initializing!";

            //
            //传入有效性测试
            HOperatorSet.TupleIsString(hv_i_EpoxyRecipePath, out hv_IsString);
            if ((int)((new HTuple(hv_IsString.TupleEqual("false"))).TupleOr(new HTuple((new HTuple(hv_i_EpoxyRecipePath.TupleLength()
                )).TupleEqual(0)))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "the para i_EpoxyRecipePath must be a string and the para |i_EpoxyRecipePath| must greater than 0";

                return;
            }
            //
            //读取Epoxy检测项参数
            //
            for (hv_fileidx = 0; (int)hv_fileidx <= (int)((new HTuple(hv_i_EpoxyRecipePath.TupleLength()
                )) - 1); hv_fileidx = (int)hv_fileidx + 1)
            {
                //
                //****************xml中读取以下参数***************************************************
                //
                hv__xmlPath = (hv_i_EpoxyRecipePath.TupleSelect(hv_fileidx)) + "EpoxyRecipe.xml";
                fread_xml_to_vector(hv__xmlPath, out hvec_LoadedElements);
                //EpoxyModelVerifyParameter
                get_subvector_param(hvec_LoadedElements, "EpoxyVerifyParameterSet", "/EpoxyVerifyParameterSet",
                    out hvec_ParameterVector);
                //
                HTuple end_val36 = new HTuple(hvec_ParameterVector.Length) - 1;
                HTuple step_val36 = 1;
                for (hv_Idx = 0; hv_Idx.Continue(end_val36, step_val36); hv_Idx = hv_Idx.TupleAdd(step_val36))
                {
                    //
                    hvec_subParameterVector = hvec_ParameterVector[hv_Idx];
                    //Epoxy检测参数设置
                    get_vector_param_value(hvec_subParameterVector, "ThreshGray", out hv__ThreshGray);
                    get_vector_param_value(hvec_subParameterVector, "LightOrDark", out hv__LightOrDark);
                    get_vector_param_value(hvec_subParameterVector, "OpeningSize", out hv__OpeningSize);
                    get_vector_param_value(hvec_subParameterVector, "EpoxyLenTh", out hv__EpoxyLenTh);
                    get_vector_param_value(hvec_subParameterVector, "EpoxyHeiTh", out hv__EpoxyHeiTh);
                    //
                    hvec__EpoxyInspect_Paras[hv_Idx] = (((((new HTupleVector(1).Insert(0, new HTupleVector(hv__ThreshGray))).Insert(
                        1, new HTupleVector(hv__LightOrDark))).Insert(2, new HTupleVector(hv__OpeningSize))).Insert(
                        3, new HTupleVector(hv__EpoxyLenTh))).Insert(4, new HTupleVector(hv__EpoxyHeiTh)));

                }
                //***********************************************************************************
                //
                //接口函数输出结果
                hvec_o_EpoxyParameters[hv_fileidx] = hvec__EpoxyInspect_Paras.Clone();

                hvec__EpoxyInspect_Paras = (new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))));
            }
            //
            hv_o_ErrCode = 0;
            hv_o_ErrStr = "read epoxy parameters successful!";

            return;
        }

        public static void get_vector_param_value(HTupleVector/*{eTupleVector,Dim=2}*/ hvec_vector,
            HTuple hv_param, out HTuple hv_value)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_Names = null, hv_i = null, hv_index = null;
            HTuple hv_valueCount = null, hv_idx = new HTuple(), hv_foundValue = new HTuple();

            HTupleVector hvec_curVertor = new HTupleVector(1);
            // Initialize local and output iconic variables 
            hv_Names = new HTuple();
            HTuple end_val1 = new HTuple(hvec_vector.Length) - 1;
            HTuple step_val1 = 1;
            for (hv_i = 0; hv_i.Continue(end_val1, step_val1); hv_i = hv_i.TupleAdd(step_val1))
            {
                hv_Names = hv_Names.TupleConcat(hvec_vector[hv_i][0].T);
            }
            hv_value = new HTuple();
            hv_index = hv_Names.TupleFind(hv_param);
            if ((int)(new HTuple(hv_index.TupleLess(0))) != 0)
            {
                hv_value = 9999;

                return;
            }
            for (hv_valueCount = 0; (int)hv_valueCount <= (int)((new HTuple(hv_index.TupleLength()
                )) - 1); hv_valueCount = (int)hv_valueCount + 1)
            {
                hvec_curVertor = hvec_vector[hv_index.TupleSelect(hv_valueCount)];
                HTuple end_val12 = new HTuple(hvec_curVertor.Length) - 1;
                HTuple step_val12 = 1;
                for (hv_idx = 1; hv_idx.Continue(end_val12, step_val12); hv_idx = hv_idx.TupleAdd(step_val12))
                {
                    hv_foundValue = hvec_vector[hv_index.TupleSelect(hv_valueCount)][hv_idx].T.Clone();
                    if ((int)(hv_foundValue.TupleIsNumber()) != 0)
                    {
                        HOperatorSet.TupleNumber(hv_foundValue, out hv_foundValue);
                    }
                    hv_value = hv_value.TupleConcat(hv_foundValue);
                }
            }

            return;
        }

        public static void HTV_read_wire_recipe(HTuple hv_i_WireRecipePath, out HTupleVector/*{eTupleVector,Dim=3}*/ hvec_o_WireParameters,
            out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_IsString = null, hv_fileIdx = null;
            HTuple hv__Path = new HTuple(), hv__filePath = new HTuple();
            HTuple hv_InspectRegNum = new HTuple(), hv_RegSum = new HTuple();
            HTuple hv__xmlPath = new HTuple(), hv_regIdx = new HTuple();
            HTuple hv_InspectMethod = new HTuple(), hv__InspectMethod = new HTuple();
            HTuple hv__ImgIdx = new HTuple(), hv__ThreshGray = new HTuple();
            HTuple hv__LightOrDark = new HTuple(), hv__ClosingSize = new HTuple();
            HTuple hv__WireWidth = new HTuple(), hv__WireLenth = new HTuple();
            HTuple hv__WireArea = new HTuple(), hv__DistTh = new HTuple();
            HTuple hv__WireContrast = new HTuple(), hv__Transition = new HTuple();
            HTuple hv__SelMetric = new HTuple(), hv__SelMin = new HTuple();
            HTuple hv__SelMax = new HTuple(), hv__LinePhiDiff = new HTuple();
            HTuple hv__MaxWireGap = new HTuple(), hv__IsDoubleLines = new HTuple();
            HTuple hv__DoubleLinesType = new HTuple(), hv__MiddleLineWidth = new HTuple();

            HTupleVector hvec_LoadedElements = new HTupleVector(2);
            HTupleVector hvec_ParameterVector = new HTupleVector(3), hvec_subParameterVector = new HTupleVector(2);
            HTupleVector hvec_Reg_InspectPara = new HTupleVector(1), hvec__WireInspect_Paras = new HTupleVector(2);
            // Initialize local and output iconic variables 
            //***************读取所有Wire的检测参数文件***************************************************************
            //---输入控制参数
            //i_WireRecipePath ：存放Frame模板的路径，一般指Moldes下的文件
            //---输出控制参数
            //o_WireParameters：Frame检测所需参数集合：三维向量
            //o_ErrCode：错误码，代表该算子在执行过程中产生的错误，0-代表执行正常，-1-代表执行异常，-2-代表未执行
            //o_ErrStr: 错误信息，对各种错误的具体描述
            //************************************************************************************************
            //
            //初始化
            //
            hvec_o_WireParameters = (new HTupleVector(3).Insert(0, (new HTupleVector(2).Insert(0, (
                new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))));
            //
            hv_o_ErrCode = -2;
            hv_o_ErrStr = "initializing!";

            //传入有效性测试
            HOperatorSet.TupleIsString(hv_i_WireRecipePath, out hv_IsString);
            if ((int)((new HTuple(hv_IsString.TupleEqual("false"))).TupleOr(new HTuple((new HTuple(hv_i_WireRecipePath.TupleLength()
                )).TupleEqual(0)))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "the para i_WireRecipePath must be a string and the para |i_WireRecipePath|                 must greater than 0";

                return;
            }
            //
            //读取Wire检测项检测参数
            for (hv_fileIdx = 0; (int)hv_fileIdx <= (int)((new HTuple(hv_i_WireRecipePath.TupleLength()
                )) - 1); hv_fileIdx = (int)hv_fileIdx + 1)
            {
                //
                hv__Path = hv_i_WireRecipePath.TupleSelect(hv_fileIdx);
                //
                hv__filePath = hv__Path + "InspectRegNum.tup";
                HOperatorSet.ReadTuple(hv__filePath, out hv_InspectRegNum);
                //
                HOperatorSet.TupleSum(hv_InspectRegNum, out hv_RegSum);
                //
                //**************XML中读取以下参数*********************************************************
                //
                hv__xmlPath = (hv_i_WireRecipePath.TupleSelect(hv_fileIdx)) + "WireRecipe.xml";
                fread_xml_to_vector(hv__xmlPath, out hvec_LoadedElements);
                //
                //---------金线检测区域内金线检测参数
                //Parameter
                get_subvector_param(hvec_LoadedElements, "Parameter", "/Parameter", out hvec_ParameterVector);
                HTuple end_val42 = hv_RegSum - 1;
                HTuple step_val42 = 1;
                for (hv_regIdx = 0; hv_regIdx.Continue(end_val42, step_val42); hv_regIdx = hv_regIdx.TupleAdd(step_val42))
                {
                    //
                    hvec_subParameterVector = hvec_ParameterVector[hv_regIdx];
                    //获取区域检测金线使用的检测算法:0-'threshold',1-'line_guass_sort',2-'line_guass_pro'
                    get_vector_param_value(hvec_subParameterVector, "Name", out hv_InspectMethod);
                    if ((int)(new HTuple(hv_InspectMethod.TupleEqual("threshold"))) != 0)
                    {
                        hv__InspectMethod = 0;
                    }
                    else if ((int)(new HTuple(hv_InspectMethod.TupleEqual("line_guass_sort"))) != 0)
                    {
                        hv__InspectMethod = 1;
                    }
                    else if ((int)(new HTuple(hv_InspectMethod.TupleEqual("line_guass_pro"))) != 0)
                    {
                        hv__InspectMethod = 2;
                    }
                    //
                    switch (hv__InspectMethod.I)
                    {

                        case 0:
                            //
                            get_vector_param_value(hvec_subParameterVector, "ImageIndex", out hv__ImgIdx);
                            hv__ImgIdx = hv__ImgIdx + 1;
                            get_vector_param_value(hvec_subParameterVector, "ThreshGray", out hv__ThreshGray);
                            get_vector_param_value(hvec_subParameterVector, "LightOrDark", out hv__LightOrDark);
                            get_vector_param_value(hvec_subParameterVector, "ClosingSize", out hv__ClosingSize);
                            get_vector_param_value(hvec_subParameterVector, "WireWidth", out hv__WireWidth);
                            get_vector_param_value(hvec_subParameterVector, "WireLength", out hv__WireLenth);
                            get_vector_param_value(hvec_subParameterVector, "WireArea", out hv__WireArea);
                            get_vector_param_value(hvec_subParameterVector, "DistTh", out hv__DistTh);
                            if ((int)(new HTuple(hv__DistTh.TupleEqual(0))) != 0)
                            {
                                hv__DistTh = 9999;
                            }
                            //
                            //整合单检测区域检测参数
                            hvec_Reg_InspectPara = (((((((((new HTupleVector(1).Insert(0, new HTupleVector(hv__InspectMethod))).Insert(
                                1, new HTupleVector(hv__ImgIdx))).Insert(2, new HTupleVector(hv__ThreshGray))).Insert(
                                3, new HTupleVector(hv__LightOrDark))).Insert(4, new HTupleVector(hv__ClosingSize))).Insert(
                                5, new HTupleVector(hv__WireWidth))).Insert(6, new HTupleVector(hv__WireLenth))).Insert(
                                7, new HTupleVector(hv__WireArea))).Insert(8, new HTupleVector(hv__DistTh)));
                            break;
                        case 1:
                            //
                            get_vector_param_value(hvec_subParameterVector, "ImageIndex", out hv__ImgIdx);
                            hv__ImgIdx = hv__ImgIdx + 1;
                            get_vector_param_value(hvec_subParameterVector, "WireWidth", out hv__WireWidth);
                            get_vector_param_value(hvec_subParameterVector, "WireContrast", out hv__WireContrast);
                            get_vector_param_value(hvec_subParameterVector, "LightOrDark", out hv__Transition);
                            get_vector_param_value(hvec_subParameterVector, "SelMetric", out hv__SelMetric);
                            get_vector_param_value(hvec_subParameterVector, "SelMin", out hv__SelMin);
                            get_vector_param_value(hvec_subParameterVector, "SelMax", out hv__SelMax);
                            get_vector_param_value(hvec_subParameterVector, "LinePhiDiff", out hv__LinePhiDiff);
                            get_vector_param_value(hvec_subParameterVector, "MaxWireGap", out hv__MaxWireGap);
                            get_vector_param_value(hvec_subParameterVector, "DistTh", out hv__DistTh);
                            if ((int)(new HTuple(hv__DistTh.TupleEqual(0))) != 0)
                            {
                                hv__DistTh = 9999;
                            }
                            //
                            //整合单检测区域检测参数
                            hvec_Reg_InspectPara = (((((((((((new HTupleVector(1).Insert(0, new HTupleVector(hv__InspectMethod))).Insert(
                                1, new HTupleVector(hv__ImgIdx))).Insert(2, new HTupleVector(hv__WireWidth))).Insert(
                                3, new HTupleVector(hv__WireContrast))).Insert(4, new HTupleVector(hv__Transition))).Insert(
                                5, new HTupleVector(hv__SelMetric))).Insert(6, new HTupleVector(hv__SelMin))).Insert(
                                7, new HTupleVector(hv__SelMax))).Insert(8, new HTupleVector(hv__LinePhiDiff))).Insert(
                                9, new HTupleVector(hv__MaxWireGap))).Insert(10, new HTupleVector(hv__DistTh)));
                            break;
                        case 2:
                            get_vector_param_value(hvec_subParameterVector, "ImageIndex", out hv__ImgIdx);
                            hv__ImgIdx = hv__ImgIdx + 1;
                            get_vector_param_value(hvec_subParameterVector, "WireWidth", out hv__WireWidth);
                            get_vector_param_value(hvec_subParameterVector, "WireContrast", out hv__WireContrast);
                            get_vector_param_value(hvec_subParameterVector, "LightOrDark", out hv__Transition);
                            get_vector_param_value(hvec_subParameterVector, "SelMetric", out hv__SelMetric);
                            get_vector_param_value(hvec_subParameterVector, "SelMin", out hv__SelMin);
                            get_vector_param_value(hvec_subParameterVector, "SelMax", out hv__SelMax);
                            get_vector_param_value(hvec_subParameterVector, "LinePhiDiff", out hv__LinePhiDiff);
                            get_vector_param_value(hvec_subParameterVector, "MaxWireGap", out hv__MaxWireGap);
                            get_vector_param_value(hvec_subParameterVector, "IsDoubleLines", out hv__IsDoubleLines);
                            if ((int)(new HTuple(hv__IsDoubleLines.TupleEqual(9999))) != 0)
                            {
                                hv__IsDoubleLines = 0;
                            }
                            get_vector_param_value(hvec_subParameterVector, "DoubleLinesType", out hv__DoubleLinesType);
                            if ((int)(new HTuple(hv__DoubleLinesType.TupleEqual(9999))) != 0)
                            {
                                hv__DoubleLinesType = "light_dark_light";
                            }
                            get_vector_param_value(hvec_subParameterVector, "MiddleLineWidth", out hv__MiddleLineWidth);
                            if ((int)(new HTuple(hv__MiddleLineWidth.TupleEqual(9999))) != 0)
                            {
                                hv__MiddleLineWidth = 3;
                            }
                            get_vector_param_value(hvec_subParameterVector, "DistTh", out hv__DistTh);
                            if ((int)(new HTuple(hv__DistTh.TupleEqual(0))) != 0)
                            {
                                hv__DistTh = 9999;
                            }
                            //
                            //整合单检测区域检测参数
                            hvec_Reg_InspectPara = ((((((((((((((new HTupleVector(1).Insert(0, new HTupleVector(hv__InspectMethod))).Insert(
                                1, new HTupleVector(hv__ImgIdx))).Insert(2, new HTupleVector(hv__WireWidth))).Insert(
                                3, new HTupleVector(hv__WireContrast))).Insert(4, new HTupleVector(hv__Transition))).Insert(
                                5, new HTupleVector(hv__SelMetric))).Insert(6, new HTupleVector(hv__SelMin))).Insert(
                                7, new HTupleVector(hv__SelMax))).Insert(8, new HTupleVector(hv__LinePhiDiff))).Insert(
                                9, new HTupleVector(hv__MaxWireGap))).Insert(10, new HTupleVector(hv__IsDoubleLines))).Insert(
                                11, new HTupleVector(hv__DoubleLinesType))).Insert(12, new HTupleVector(hv__MiddleLineWidth))).Insert(
                                13, new HTupleVector(hv__DistTh)));
                            break;
                        default:
                            break;
                    }
                    //
                    hvec__WireInspect_Paras[hv_regIdx] = hvec_Reg_InspectPara.Clone();
                    //
                    hvec_Reg_InspectPara = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())));
                }
                //
                hvec_o_WireParameters[hv_fileIdx] = hvec__WireInspect_Paras.Clone();
                //
                hvec__WireInspect_Paras = (new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))));
            }
            //***************************************************************************************
            hv_o_ErrCode = 0;
            hv_o_ErrStr = "read wire parameters successful!";

            return;
        }
        public static void HTV_read_bond_recipe(HTuple hv_i_BondRecipePath, out HTupleVector/*{eTupleVector,Dim=3}*/ hvec_o_BondParameters,
            out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_IsString = null, hv_fileIdx = null;
            HTuple hv__Path = new HTuple(), hv_Matches = new HTuple();
            HTuple hv__xmlPath = new HTuple(), hv_RegNum = new HTuple();
            HTuple hv_regIdx = new HTuple(), hv_InspectMethod = new HTuple();
            HTuple hv__InspectMethod = new HTuple(), hv__ImgIdx = new HTuple();
            HTuple hv__IsCircleBond = new HTuple(), hv__CircleBondSize = new HTuple();
            HTuple hv__BondSize = new HTuple(), hv__EllipsBondSize = new HTuple();
            HTuple hv__ThreshGray = new HTuple(), hv__ClosingSize = new HTuple();
            HTuple hv__BondOverSizeFactor = new HTuple(), hv__BondUnderSizeFactor = new HTuple();
            HTuple hv__PreJudgeEnable = new HTuple(), hv__SegThreshGray = new HTuple();
            HTuple hv__SegRegAreaFactor = new HTuple(), hv__BallNum_OnRegion = new HTuple();
            HTuple hv__MinMatchScore = new HTuple(), hv__AngleStart = new HTuple();
            HTuple hv__AngleExt = new HTuple(), hv__IsBondRegRefine = new HTuple();
            HTuple hv__AddBallNum = new HTuple(), hv__MaxOverlap = new HTuple();
            HTuple hv__MinHistScore = new HTuple();

            HTupleVector hvec_LoadedElements = new HTupleVector(2);
            HTupleVector hvec_ParameterVector = new HTupleVector(3), hvec_subParameterVector = new HTupleVector(2);
            HTupleVector hvec_Reg_InspectPara = new HTupleVector(1), hvec__BondInspect_Paras = new HTupleVector(2);
            // Initialize local and output iconic variables 
            //***************读取所有Wire的检测参数文件***************************************************************
            //---输入控制参数
            //i_BondRecipePath ：存放Bond检测参数XML的路径，一般指Recipe下的文件
            //---输出控制参数
            //o_BondParameters：Bond检测所需参数集合：三维向量
            //o_ErrCode：错误码，代表该算子在执行过程中产生的错误，0-代表执行正常，-1-代表执行异常，-2-代表未执行
            //o_ErrStr: 错误信息，对各种错误的具体描述
            //************************************************************************************************
            //
            //初始化
            //
            hvec_o_BondParameters = (new HTupleVector(3).Insert(0, (new HTupleVector(2).Insert(0, (
                new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))));
            //
            hv_o_ErrCode = -2;
            hv_o_ErrStr = "initializing!";

            //传入有效性测试
            HOperatorSet.TupleIsString(hv_i_BondRecipePath, out hv_IsString);
            if ((int)((new HTuple(hv_IsString.TupleEqual("false"))).TupleOr(new HTuple((new HTuple(hv_i_BondRecipePath.TupleLength()
                )).TupleEqual(0)))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "the para i_BondRecipePath must be a string and the para |i_BondRecipePath|                 must greater than 0";

                return;
            }
            //
            //读取Bond检测项检测参数
            for (hv_fileIdx = 0; (int)hv_fileIdx <= (int)((new HTuple(hv_i_BondRecipePath.TupleLength()
                )) - 1); hv_fileIdx = (int)hv_fileIdx + 1)
            {
                //
                hv__Path = hv_i_BondRecipePath.TupleSelect(hv_fileIdx);
                //分类别读取XML文件
                HOperatorSet.TupleRegexpMatch(hv__Path, "Match", out hv_Matches);
                //
                if ((int)(new HTuple(hv_Matches.TupleEqual("Match"))) != 0)
                {
                    hv__xmlPath = hv__Path + "BondRecipe.xml";
                }
                else
                {
                    hv__xmlPath = hv__Path + "BondMeasureRecipe.xml";
                }

                //
                //**************XML中读取以下参数*********************************************************
                fread_xml_to_vector(hv__xmlPath, out hvec_LoadedElements);
                //
                //---------检测区域内Bond检测参数
                //BondVerifyParameter
                get_subvector_param(hvec_LoadedElements, "BondVerifyParameter", "/BondVerifyParameter",
                    out hvec_ParameterVector);
                //
                hv_RegNum = new HTuple(hvec_ParameterVector.Length);
                HTuple end_val46 = hv_RegNum - 1;
                HTuple step_val46 = 1;
                for (hv_regIdx = 0; hv_regIdx.Continue(end_val46, step_val46); hv_regIdx = hv_regIdx.TupleAdd(step_val46))
                {
                    //
                    hvec_subParameterVector = hvec_ParameterVector[hv_regIdx];
                    //获取区域检测金线使用的检测算法:0-'threshold',1-'line_guass_sort',2-'line_guass_pro'
                    get_vector_param_value(hvec_subParameterVector, "Name", out hv_InspectMethod);
                    if ((int)(new HTuple(hv_InspectMethod.TupleEqual("threshold"))) != 0)
                    {
                        hv__InspectMethod = 0;
                    }
                    else if ((int)(new HTuple(hv_InspectMethod.TupleEqual("measure"))) != 0)
                    {
                        hv__InspectMethod = 1;
                    }
                    else if ((int)(new HTuple(hv_InspectMethod.TupleEqual("match"))) != 0)
                    {
                        hv__InspectMethod = 2;
                    }
                    //
                    switch (hv__InspectMethod.I)
                    {

                        case 0:
                            //
                            get_vector_param_value(hvec_subParameterVector, "ImageIndex", out hv__ImgIdx);
                            hv__ImgIdx = hv__ImgIdx + 1;
                            get_vector_param_value(hvec_subParameterVector, "IsCircleBond", out hv__IsCircleBond);
                            if ((int)(hv__IsCircleBond) != 0)
                            {
                                get_vector_param_value(hvec_subParameterVector, "BondSize", out hv__CircleBondSize);
                                hv__BondSize = hv__CircleBondSize.Clone();
                            }
                            else
                            {
                                get_vector_param_value(hvec_subParameterVector, "EllipsBondSize", out hv__EllipsBondSize);
                                hv__BondSize = hv__EllipsBondSize.Clone();
                            }
                            get_vector_param_value(hvec_subParameterVector, "ThreshGray", out hv__ThreshGray);
                            get_vector_param_value(hvec_subParameterVector, "ClosingSize", out hv__ClosingSize);
                            get_vector_param_value(hvec_subParameterVector, "BondOverSizeFactor", out hv__BondOverSizeFactor);
                            get_vector_param_value(hvec_subParameterVector, "BondUnderSizeFactor",
                                out hv__BondUnderSizeFactor);
                            //
                            //整合单检测区域检测参数
                            hvec_Reg_InspectPara = (((((((new HTupleVector(1).Insert(0, new HTupleVector(hv__InspectMethod))).Insert(
                                1, new HTupleVector(hv__ImgIdx))).Insert(2, new HTupleVector(hv__BondSize))).Insert(
                                3, new HTupleVector(hv__ThreshGray))).Insert(4, new HTupleVector(hv__ClosingSize))).Insert(
                                5, new HTupleVector(hv__BondOverSizeFactor))).Insert(6, new HTupleVector(hv__BondUnderSizeFactor)));
                            break;
                        case 1:
                            //
                            get_vector_param_value(hvec_subParameterVector, "ImageIndex", out hv__ImgIdx);
                            hv__ImgIdx = hv__ImgIdx + 1;
                            get_vector_param_value(hvec_subParameterVector, "BondOverSizeFactor", out hv__BondOverSizeFactor);
                            get_vector_param_value(hvec_subParameterVector, "BondUnderSizeFactor",
                                out hv__BondUnderSizeFactor);
                            get_vector_param_value(hvec_subParameterVector, "PreJudgeEnable", out hv__PreJudgeEnable);
                            get_vector_param_value(hvec_subParameterVector, "SegThreshGray", out hv__SegThreshGray);
                            get_vector_param_value(hvec_subParameterVector, "SegRegAreaFactor", out hv__SegRegAreaFactor);
                            //
                            //整合单检测区域检测参数
                            hvec_Reg_InspectPara = (((((((new HTupleVector(1).Insert(0, new HTupleVector(hv__InspectMethod))).Insert(
                                1, new HTupleVector(hv__ImgIdx))).Insert(2, new HTupleVector(hv__BondOverSizeFactor))).Insert(
                                3, new HTupleVector(hv__BondUnderSizeFactor))).Insert(4, new HTupleVector(hv__PreJudgeEnable))).Insert(
                                5, new HTupleVector(hv__SegThreshGray))).Insert(6, new HTupleVector(hv__SegRegAreaFactor)));

                            break;
                        case 2:
                            //
                            get_vector_param_value(hvec_subParameterVector, "ImageIndex", out hv__ImgIdx);
                            hv__ImgIdx = hv__ImgIdx + 1;
                            get_vector_param_value(hvec_subParameterVector, "BallNum_OnRegion", out hv__BallNum_OnRegion);
                            get_vector_param_value(hvec_subParameterVector, "MinMatchScore", out hv__MinMatchScore);
                            get_vector_param_value(hvec_subParameterVector, "AngleStart", out hv__AngleStart);
                            get_vector_param_value(hvec_subParameterVector, "AngleExt", out hv__AngleExt);
                            get_vector_param_value(hvec_subParameterVector, "IsCircleBond", out hv__IsCircleBond);
                            if ((int)(hv__IsCircleBond) != 0)
                            {
                                get_vector_param_value(hvec_subParameterVector, "BondSize", out hv__CircleBondSize);
                                hv__BondSize = hv__CircleBondSize.Clone();
                            }
                            else
                            {
                                get_vector_param_value(hvec_subParameterVector, "EllipsBondSize", out hv__EllipsBondSize);
                                hv__BondSize = hv__EllipsBondSize.Clone();
                            }
                            get_vector_param_value(hvec_subParameterVector, "IsBondRegRefine", out hv__IsBondRegRefine);
                            get_vector_param_value(hvec_subParameterVector, "AddBallNum", out hv__AddBallNum);
                            get_vector_param_value(hvec_subParameterVector, "MaxOverlap", out hv__MaxOverlap);
                            get_vector_param_value(hvec_subParameterVector, "MinHistScore", out hv__MinHistScore);
                            //
                            //整合单检测区域检测参数
                            hvec_Reg_InspectPara = (((((((((((new HTupleVector(1).Insert(0, new HTupleVector(hv__InspectMethod))).Insert(
                                1, new HTupleVector(hv__ImgIdx))).Insert(2, new HTupleVector(hv__BallNum_OnRegion))).Insert(
                                3, new HTupleVector(hv__MinMatchScore))).Insert(4, new HTupleVector(hv__AngleStart))).Insert(
                                5, new HTupleVector(hv__AngleExt))).Insert(6, new HTupleVector(hv__BondSize))).Insert(
                                7, new HTupleVector(hv__IsBondRegRefine))).Insert(8, new HTupleVector(hv__AddBallNum))).Insert(
                                9, new HTupleVector(hv__MaxOverlap))).Insert(10, new HTupleVector(hv__MinHistScore)));

                            break;
                        default:
                            break;
                    }
                    //
                    hvec__BondInspect_Paras[hv_regIdx] = hvec_Reg_InspectPara.Clone();
                    //
                    hvec_Reg_InspectPara = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())));

                }
                //
                hvec_o_BondParameters[hv_fileIdx] = hvec__BondInspect_Paras.Clone();
                //
                hvec__BondInspect_Paras = (new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))));
            }
            //****************************************************************************************************************************
            hv_o_ErrCode = 0;
            hv_o_ErrStr = "read bond parameters successful!";

            return;
        }
        public static void HTV_read_AroundBall_recipe(HTuple hv_i_AroundBallPath, HTuple hv_i_BondNum,
            out HTupleVector/*{eTupleVector,Dim=3}*/ hvec_o_AroundBallParameters, out HTuple hv_o_ErrCode,
            out HTuple hv_o_ErrStr)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_IsString = null, hv_fileIdx = null;
            HTuple hv__xmlPath = null, hv__IsInspect = new HTuple();
            HTuple hv__IsBallShiftInspect = new HTuple(), hv__ShiftInspectMethodIndex = new HTuple();
            HTuple hv__ShiftImageIndex = new HTuple(), hv__IsMeasurePad = new HTuple();
            HTuple hv__PadMeasureType = new HTuple(), hv__PadMeasureRadius = new HTuple();
            HTuple hv__PadMeasureSize = new HTuple(), hv__PadMeasureLenAndWidth = new HTuple();
            HTuple hv__PadMeasureGrayThr = new HTuple(), hv__PadMeasureTrans = new HTuple();
            HTuple hv__PadGrayThresh = new HTuple(), hv__IsMeasureBall = new HTuple();
            HTuple hv__BallGrayThresh = new HTuple(), hv__BallMeasureType = new HTuple();
            HTuple hv__CircleBallSize = new HTuple(), hv__BallMeasureSize = new HTuple();
            HTuple hv__EllipsBondSize = new HTuple(), hv__BallMeasureGrayThr = new HTuple();
            HTuple hv__BallMeasureTrans = new HTuple(), hv__BallShiftRatioThr = new HTuple();
            HTuple hv__IsTailInspect = new HTuple(), hv__TailInspectMethodIndex = new HTuple();
            HTuple hv__TailImageIndex = new HTuple(), hv__TailDilationSize = new HTuple();
            HTuple hv__WireWidth = new HTuple(), hv__WireContrast = new HTuple();
            HTuple hv__SelMetric = new HTuple(), hv__LightOrDark = new HTuple();
            HTuple hv__SelMin = new HTuple(), hv__SelMax = new HTuple();
            HTuple hv__MaxWireGap = new HTuple(), hv__TailGrayThresh = new HTuple();
            HTuple hv__TailLenTh = new HTuple(), hv__IsWireJudgeAgain = new HTuple();
            HTuple hv__IsSurfaceInspect = new HTuple(), hv__SurfaceInspectMethodIndex = new HTuple();
            HTuple hv__SurfImageIndex = new HTuple(), hv__SurfDilationSize = new HTuple();
            HTuple hv__AdaptiveMethod = new HTuple(), hv__BlockSize = new HTuple();
            HTuple hv__Contrast = new HTuple(), hv__CloseSize = new HTuple();
            HTuple hv__MinLength = new HTuple(), hv__MinWidth = new HTuple();
            HTuple hv__MinArea = new HTuple(), hv__SelOperation = new HTuple();
            HTuple hv__ThreshGray = new HTuple(), hv__ThreshGrayInOrOut = new HTuple();
            HTuple hv__MorphSize = new HTuple();

            HTupleVector hvec_LoadedElements = new HTupleVector(2);
            HTupleVector hvec_ParameterVector = new HTupleVector(3), hvec_subParameterVector = new HTupleVector(2);
            HTupleVector hvec_ShiftParameterVector = new HTupleVector(3);
            HTupleVector hvec_subShiftParameterVector = new HTupleVector(2);
            HTupleVector hvec_Shift_InspectPara = new HTupleVector(1), hvec_TailParameterVector = new HTupleVector(3);
            HTupleVector hvec_subTailParameterVector = new HTupleVector(2);
            HTupleVector hvec_Tail_InspectPara = new HTupleVector(1), hvec_SurfParameterVector = new HTupleVector(3);
            HTupleVector hvec_subSurfParameterVector = new HTupleVector(2);
            HTupleVector hvec_Surface_InspectPara = new HTupleVector(1), hvec_Reg_InspectPara = new HTupleVector(2);
            // Initialize local and output iconic variables 
            //***************读取所有ArondBallRegion的检测参数文件***************************************************************
            //---输入控制参数
            //i_RecipePath ：存放检测参数的recipe的路径，一般指Recipe下的文件
            //i_BondNum：Bond的类别数量
            //i_ArondBallItem：AroundBallRegion项目检测文件
            //---输出控制参数
            //o_AroundBallParameters：AroundBall检测所需参数集合：二维向量
            //o_ErrCode：错误码，代表该算子在执行过程中产生的错误，0-代表执行正常，-1-代表执行异常，-2-代表未执行
            //o_ErrStr: 错误信息，对各种错误的具体描述
            //************************************************************************************************
            //

            hvec_o_AroundBallParameters = (new HTupleVector(3).Insert(0, (new HTupleVector(2).Insert(0, (
                new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))));
            //
            hv_o_ErrCode = -2;
            hv_o_ErrStr = "initializing!";

            //传入有效性测试
            HOperatorSet.TupleIsString(hv_i_AroundBallPath, out hv_IsString);
            if ((int)((new HTuple(hv_IsString.TupleEqual("false"))).TupleOr(new HTuple((new HTuple(hv_i_AroundBallPath.TupleLength()
                )).TupleEqual(0)))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "the para i_AroundBallPath must be a string and the para |i_AroundBallPath|                 must greater than 0";

                HTuple end_val23 = hv_i_BondNum - 1;
                HTuple step_val23 = 1;
                for (hv_fileIdx = 0; hv_fileIdx.Continue(end_val23, step_val23); hv_fileIdx = hv_fileIdx.TupleAdd(step_val23))
                {
                    hvec_o_AroundBallParameters[hv_fileIdx] = (new HTupleVector(2).Insert(0, (
                        new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(0))))));
                }


                return;
            }


            //**************XML中读取以下参数*******************************************************
            hv__xmlPath = hv_i_AroundBallPath + "AroundBallRegionRecipe.xml";
            //
            fread_xml_to_vector(hv__xmlPath, out hvec_LoadedElements);
            //
            //按照Bond的类别个数读取ArondBall检测项检测参数
            //Parameter
            get_subvector_param(hvec_LoadedElements, "Region", "/Region", out hvec_ParameterVector);

            HTuple end_val40 = hv_i_BondNum - 1;
            HTuple step_val40 = 1;
            for (hv_fileIdx = 0; hv_fileIdx.Continue(end_val40, step_val40); hv_fileIdx = hv_fileIdx.TupleAdd(step_val40))
            {
                //
                hvec_subParameterVector = hvec_ParameterVector[hv_fileIdx];
                //获取ArondBond区域是否检测：1-检测，0-不检测
                get_vector_param_value(hvec_subParameterVector, "IsInspect", out hv__IsInspect);
                //
                if ((int)(hv__IsInspect) != 0)
                {
                    //获取AroundBond需要检测的项目及参数

                    //***********1是否焊点偏移、焊盘周围表面检测
                    get_vector_param_value(hvec_subParameterVector, "IsBallShiftInspect", out hv__IsBallShiftInspect);
                    //
                    if ((int)(hv__IsBallShiftInspect) != 0)
                    {
                        //读取该项目检测参数
                        //BallShiftInspectParameter
                        get_subvector_param(hvec_subParameterVector, "BallShiftInspectParameter",
                            "/BallShiftInspectParameter", out hvec_ShiftParameterVector);
                        //
                        hvec_subShiftParameterVector = hvec_ShiftParameterVector[0];
                        //---读取焊点偏移检测算法索引号，0-match_mearsure，1---，2---，等等
                        get_vector_param_value(hvec_subParameterVector, "ShiftInspectMethodIndex",
                            out hv__ShiftInspectMethodIndex);
                        //
                        switch (hv__ShiftInspectMethodIndex.I)
                        {
                            case 0:
                                //match_measure
                                get_vector_param_value(hvec_subShiftParameterVector, "ShiftImageIndex",
                                    out hv__ShiftImageIndex);
                                hv__ShiftImageIndex = hv__ShiftImageIndex + 1;
                                //
                                //判断是否进行焊盘测量
                                get_vector_param_value(hvec_subShiftParameterVector, "IsMeasurePad",
                                    out hv__IsMeasurePad);
                                //
                                get_vector_param_value(hvec_subShiftParameterVector, "PadMeasureType",
                                    out hv__PadMeasureType);
                                //
                                //读取测量半长、半宽、或半径
                                if ((int)(new HTuple(hv__PadMeasureType.TupleEqual("circle"))) != 0)
                                {
                                    get_vector_param_value(hvec_subShiftParameterVector, "PadMeasureRadius",
                                        out hv__PadMeasureRadius);
                                    hv__PadMeasureSize = hv__PadMeasureRadius.Clone();
                                }
                                else
                                {
                                    //
                                    get_vector_param_value(hvec_subShiftParameterVector, "PadMeasureLenAndWidth",
                                        out hv__PadMeasureLenAndWidth);
                                    hv__PadMeasureSize = hv__PadMeasureLenAndWidth.Clone();
                                }
                                //
                                get_vector_param_value(hvec_subShiftParameterVector, "PadMeasureGrayThr",
                                    out hv__PadMeasureGrayThr);
                                //
                                get_vector_param_value(hvec_subShiftParameterVector, "PadMeasureTrans",
                                    out hv__PadMeasureTrans);
                                //在测量区域内阈值分割提取焊盘灰度阈值
                                get_vector_param_value(hvec_subShiftParameterVector, "PadGrayThresh",
                                    out hv__PadGrayThresh);
                                //
                                //判断是否进行焊点测量
                                get_vector_param_value(hvec_subShiftParameterVector, "IsMeasureBall",
                                    out hv__IsMeasureBall);
                                //
                                get_vector_param_value(hvec_subShiftParameterVector, "BallGrayThresh",
                                    out hv__BallGrayThresh);
                                //
                                get_vector_param_value(hvec_subShiftParameterVector, "BallMeasureType",
                                    out hv__BallMeasureType);
                                //
                                //读取测量半长、半宽、或半径
                                if ((int)(new HTuple(hv__BallMeasureType.TupleEqual("circle"))) != 0)
                                {
                                    get_vector_param_value(hvec_subShiftParameterVector, "CircleBallSize",
                                        out hv__CircleBallSize);
                                    hv__BallMeasureSize = hv__CircleBallSize.Clone();
                                }
                                else
                                {
                                    //
                                    get_vector_param_value(hvec_subShiftParameterVector, "EllipsBondSize",
                                        out hv__EllipsBondSize);
                                    hv__BallMeasureSize = hv__EllipsBondSize.Clone();
                                }
                                //
                                get_vector_param_value(hvec_subShiftParameterVector, "BallMeasureGrayThr",
                                    out hv__BallMeasureGrayThr);
                                //
                                get_vector_param_value(hvec_subShiftParameterVector, "BallMeasureTrans",
                                    out hv__BallMeasureTrans);
                                //
                                get_vector_param_value(hvec_subShiftParameterVector, "BallShiftRatioThr",
                                    out hv__BallShiftRatioThr);
                                //整合单焊点类周围区域检测参数
                                hvec_Shift_InspectPara = ((((((((((((((((new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(1)))).Insert(
                                    1, new HTupleVector(hv__ShiftInspectMethodIndex))).Insert(2, new HTupleVector(hv__ShiftImageIndex))).Insert(
                                    3, new HTupleVector(hv__IsMeasurePad))).Insert(4, new HTupleVector(hv__PadMeasureType))).Insert(
                                    5, new HTupleVector(hv__PadMeasureSize))).Insert(6, new HTupleVector(hv__PadMeasureGrayThr))).Insert(
                                    7, new HTupleVector(hv__PadMeasureTrans))).Insert(8, new HTupleVector(hv__PadGrayThresh))).Insert(
                                    9, new HTupleVector(hv__IsMeasureBall))).Insert(10, new HTupleVector(hv__BallGrayThresh))).Insert(
                                    11, new HTupleVector(hv__BallMeasureType))).Insert(12, new HTupleVector(hv__BallMeasureSize))).Insert(
                                    13, new HTupleVector(hv__BallMeasureGrayThr))).Insert(14, new HTupleVector(hv__BallMeasureTrans))).Insert(
                                    15, new HTupleVector(hv__BallShiftRatioThr)));
                                break;
                            default:
                                break;
                        }
                    }
                    else
                    {
                        //焊点偏移不检测
                        hvec_Shift_InspectPara = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(0))));
                    }
                    //*******************************************************************************************************************
                    //****************2 焊点周围是否尾丝检测、焊盘表面异物检测
                    get_vector_param_value(hvec_subParameterVector, "IsTailInspect", out hv__IsTailInspect);
                    //
                    if ((int)(hv__IsTailInspect) != 0)
                    {
                        //
                        //读取该项目检测参数
                        get_subvector_param(hvec_subParameterVector, "TailInspectParameter", "/TailInspectParameter",
                            out hvec_TailParameterVector);
                        //
                        hvec_subTailParameterVector = hvec_TailParameterVector[0];
                        //---读取尾丝检测算法索引号，0-Line_Gauss，1---，2---，等等
                        get_vector_param_value(hvec_subParameterVector, "TailInspectMethodIndex",
                            out hv__TailInspectMethodIndex);
                        //
                        switch (hv__TailInspectMethodIndex.I)
                        {
                            case 0:
                                //Line_gauss
                                //
                                get_vector_param_value(hvec_subTailParameterVector, "TailImageIndex",
                                    out hv__TailImageIndex);
                                hv__TailImageIndex = hv__TailImageIndex + 1;
                                //
                                get_vector_param_value(hvec_subTailParameterVector, "TailDilationSize",
                                    out hv__TailDilationSize);
                                //
                                get_vector_param_value(hvec_subTailParameterVector, "WireWidth", out hv__WireWidth);
                                //
                                get_vector_param_value(hvec_subTailParameterVector, "WireContrast", out hv__WireContrast);
                                //
                                get_vector_param_value(hvec_subTailParameterVector, "SelMetric", out hv__SelMetric);
                                //
                                get_vector_param_value(hvec_subTailParameterVector, "LightOrDark", out hv__LightOrDark);
                                //
                                get_vector_param_value(hvec_subTailParameterVector, "SelMin", out hv__SelMin);
                                //
                                get_vector_param_value(hvec_subTailParameterVector, "SelMax", out hv__SelMax);
                                //
                                get_vector_param_value(hvec_subTailParameterVector, "MaxWireGap", out hv__MaxWireGap);
                                //
                                get_vector_param_value(hvec_subTailParameterVector, "TailGrayThresh",
                                    out hv__TailGrayThresh);
                                //
                                get_vector_param_value(hvec_subTailParameterVector, "TailLenTh", out hv__TailLenTh);
                                //
                                get_vector_param_value(hvec_subTailParameterVector, "IsWireJudgeAgain",
                                    out hv__IsWireJudgeAgain);
                                if ((int)(new HTuple(hv__IsWireJudgeAgain.TupleEqual(9999))) != 0)
                                {
                                    hv__IsWireJudgeAgain = 0;
                                }
                                //
                                //整合单焊点类周围区域检测参数
                                hvec_Tail_InspectPara = ((((((((((((((new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(1)))).Insert(
                                    1, new HTupleVector(hv__TailInspectMethodIndex))).Insert(2, new HTupleVector(hv__TailImageIndex))).Insert(
                                    3, new HTupleVector(hv__TailDilationSize))).Insert(4, new HTupleVector(hv__WireWidth))).Insert(
                                    5, new HTupleVector(hv__WireContrast))).Insert(6, new HTupleVector(hv__SelMetric))).Insert(
                                    7, new HTupleVector(hv__LightOrDark))).Insert(8, new HTupleVector(hv__SelMin))).Insert(
                                    9, new HTupleVector(hv__SelMax))).Insert(10, new HTupleVector(hv__MaxWireGap))).Insert(
                                    11, new HTupleVector(hv__TailGrayThresh))).Insert(12, new HTupleVector(hv__TailLenTh))).Insert(
                                    13, new HTupleVector(hv__IsWireJudgeAgain)));
                                break;

                            default:
                                break;

                        }
                    }
                    else
                    {
                        //
                        hvec_Tail_InspectPara = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(0))));
                    }
                    //****************************************************************************************************************
                    //*************************3 焊盘表面异物检测
                    get_vector_param_value(hvec_subParameterVector, "IsSurfaceInspect", out hv__IsSurfaceInspect);
                    //
                    if ((int)(hv__IsSurfaceInspect) != 0)
                    {
                        //
                        //读取该项目检测参数
                        get_subvector_param(hvec_subParameterVector, "SurfaceInspectParameter",
                            "/SurfaceInspectParameter", out hvec_SurfParameterVector);
                        //
                        hvec_subSurfParameterVector = hvec_SurfParameterVector[0];
                        //---读取焊盘表面检测算法索引号，0-Adaptive，1-Global，2---，等等
                        get_vector_param_value(hvec_subParameterVector, "SurfaceInspectMethodIndex",
                            out hv__SurfaceInspectMethodIndex);
                        //
                        switch (hv__SurfaceInspectMethodIndex.I)
                        {
                            case 0:
                                //
                                get_vector_param_value(hvec_subSurfParameterVector, "SurfImageIndex",
                                    out hv__SurfImageIndex);
                                hv__SurfImageIndex = hv__SurfImageIndex + 1;

                                //
                                get_vector_param_value(hvec_subSurfParameterVector, "SurfDilationSize",
                                    out hv__SurfDilationSize);
                                //
                                get_vector_param_value(hvec_subSurfParameterVector, "AdaptiveMethod",
                                    out hv__AdaptiveMethod);
                                //
                                get_vector_param_value(hvec_subSurfParameterVector, "BlockSize", out hv__BlockSize);
                                //
                                get_vector_param_value(hvec_subSurfParameterVector, "Contrast", out hv__Contrast);
                                //
                                get_vector_param_value(hvec_subSurfParameterVector, "LightOrDark", out hv__LightOrDark);
                                //
                                get_vector_param_value(hvec_subSurfParameterVector, "CloseSize", out hv__CloseSize);
                                //
                                get_vector_param_value(hvec_subSurfParameterVector, "MinLength", out hv__MinLength);
                                //
                                get_vector_param_value(hvec_subSurfParameterVector, "MinWidth", out hv__MinWidth);
                                //
                                get_vector_param_value(hvec_subSurfParameterVector, "MinArea", out hv__MinArea);
                                //
                                get_vector_param_value(hvec_subSurfParameterVector, "SelOperation", out hv__SelOperation);
                                //
                                //整合单焊点类周围区域检测参数
                                hvec_Surface_InspectPara = (((((((((((((new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(1)))).Insert(
                                    1, new HTupleVector(hv__SurfaceInspectMethodIndex))).Insert(2, new HTupleVector(hv__SurfImageIndex))).Insert(
                                    3, new HTupleVector(hv__SurfDilationSize))).Insert(4, new HTupleVector(hv__AdaptiveMethod))).Insert(
                                    5, new HTupleVector(hv__BlockSize))).Insert(6, new HTupleVector(hv__Contrast))).Insert(
                                    7, new HTupleVector(hv__LightOrDark))).Insert(8, new HTupleVector(hv__CloseSize))).Insert(
                                    9, new HTupleVector(hv__MinLength))).Insert(10, new HTupleVector(hv__MinWidth))).Insert(
                                    11, new HTupleVector(hv__MinArea))).Insert(12, new HTupleVector(hv__SelOperation)));

                                break;
                            case 1:
                                //
                                get_vector_param_value(hvec_subSurfParameterVector, "SurfImageIndex",
                                    out hv__SurfImageIndex);
                                hv__SurfImageIndex = hv__SurfImageIndex + 1;
                                //
                                get_vector_param_value(hvec_subSurfParameterVector, "SurfDilationSize",
                                    out hv__SurfDilationSize);
                                //
                                get_vector_param_value(hvec_subSurfParameterVector, "ThreshGray", out hv__ThreshGray);
                                //
                                get_vector_param_value(hvec_subSurfParameterVector, "ThreshGrayInOrOut",
                                    out hv__ThreshGrayInOrOut);
                                //
                                get_vector_param_value(hvec_subSurfParameterVector, "MorphSize", out hv__MorphSize);
                                //
                                get_vector_param_value(hvec_subSurfParameterVector, "CloseSize", out hv__CloseSize);
                                //
                                get_vector_param_value(hvec_subSurfParameterVector, "MinLength", out hv__MinLength);
                                //
                                get_vector_param_value(hvec_subSurfParameterVector, "MinWidth", out hv__MinWidth);
                                //
                                get_vector_param_value(hvec_subSurfParameterVector, "MinArea", out hv__MinArea);
                                //
                                get_vector_param_value(hvec_subSurfParameterVector, "SelOperation", out hv__SelOperation);
                                //
                                //整合单焊点类周围区域检测参数
                                hvec_Surface_InspectPara = ((((((((((((new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(1)))).Insert(
                                    1, new HTupleVector(hv__SurfaceInspectMethodIndex))).Insert(2, new HTupleVector(hv__SurfImageIndex))).Insert(
                                    3, new HTupleVector(hv__SurfDilationSize))).Insert(4, new HTupleVector(hv__ThreshGray))).Insert(
                                    5, new HTupleVector(hv__ThreshGrayInOrOut))).Insert(6, new HTupleVector(hv__MorphSize))).Insert(
                                    7, new HTupleVector(hv__CloseSize))).Insert(8, new HTupleVector(hv__MinLength))).Insert(
                                    9, new HTupleVector(hv__MinWidth))).Insert(10, new HTupleVector(hv__MinArea))).Insert(
                                    11, new HTupleVector(hv__SelOperation)));
                                break;

                            default:

                                break;

                        }

                    }
                    else
                    {
                        //
                        hvec_Surface_InspectPara = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(0))));

                    }
                    //***************************************************************************************************************
                    //输出各项检测参数
                    hvec_Reg_InspectPara = ((((new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(1)))))).Insert(
                        1, hvec_Shift_InspectPara)).Insert(2, hvec_Tail_InspectPara)).Insert(3, hvec_Surface_InspectPara));
                }
                else
                {
                    //输出区域不检测参数
                    hvec_Reg_InspectPara = (new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(0))))));
                }
                //整合AroundBond周围检测算法参数
                hvec_o_AroundBallParameters[hv_fileIdx] = hvec_Reg_InspectPara.Clone();
            }
            //***************************************************************************************
            hv_o_ErrCode = 0;
            hv_o_ErrStr = "read aroundBondRegion parameters successful!";

            return;
        }

        public static void HTV_frames_inspect(HObject ho_i_Imgs, HObjectVector/*{eObjectVector,Dim=2}*/ hvec_i_FrameObjs,
            HObject ho_i_RejectReg, out HObjectVector/*{eObjectVector,Dim=2}*/ hvec_o_FailRegs,
            HTuple hv_i_ObjNum, HTupleVector/*{eTupleVector,Dim=3}*/ hvec_i_FrameInspectParas,
            HTupleVector/*{eTupleVector,Dim=1}*/ hvec_i_HomMatMod2Img, out HTupleVector/*{eTupleVector,Dim=2}*/ hvec_o_DefectTypes,
            out HTupleVector/*{eTupleVector,Dim=3}*/ hvec_o_DefectValue, out HTupleVector/*{eTupleVector,Dim=2}*/ hvec_o_DefectImgIdx,
            out HTupleVector/*{eTupleVector,Dim=3}*/ hvec_o_RefValue, out HTuple hv_o_ErrCode,
            out HTuple hv_o_ErrStr)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_EmptyObject, ho__FailFrameRegs = null;
            HObject ho__FrameReg = null, ho__PegRackReg = null, ho__BridgeReg = null;
            HObject ho_i_Image = null, ho__FailFrameInsReg = null, ho__FailPegRackReg = null;
            HObject ho__FailBridgeReg = null;

            HObjectVector hvec__InspectObj = new HObjectVector(1);

            // Local control variables 

            HTuple hv_objIdx = null, hv__DefectFrameTypes = new HTuple();
            HTuple hv__DefectFrameImgIdxs = new HTuple(), hv__TaskEnable = new HTuple();
            HTuple hv__FrameInsEnable = new HTuple(), hv__PegRackInsEnable = new HTuple();
            HTuple hv__BridgeInsEnable = new HTuple(), hv__ImageIdx = new HTuple();
            HTuple hv__FrameHomMat2D = new HTuple(), hv_HomMatSum = new HTuple();
            HTuple hv_LocSuccFlag = new HTuple(), hv__InspectFramePara = new HTuple();
            HTuple hv_RegSegMethodIndex = new HTuple(), hv__AdaptiveMethod = new HTuple();
            HTuple hv__BlockSize = new HTuple(), hv__Contrast = new HTuple();
            HTuple hv__LightOrDark = new HTuple(), hv__CloseSize = new HTuple();
            HTuple hv__MinLength = new HTuple(), hv__MinWidth = new HTuple();
            HTuple hv__MinArea = new HTuple(), hv__SelOperation = new HTuple();
            HTuple hv__LowThreshGray = new HTuple(), hv__HighThreshGray = new HTuple();
            HTuple hv__ThreshInOrOut = new HTuple(), hv__MorphSize = new HTuple();
            HTuple hv__ThreshGray = new HTuple(), hv__DefectFrameType = new HTuple();
            HTuple hv__DefectFrameImgIdx = new HTuple(), hv__ErrFrameCode = new HTuple();
            HTuple hv__ErrFrameStr = new HTuple(), hv__InspectpegrackPara = new HTuple();
            HTuple hv__DefectPegRackType = new HTuple(), hv__DefectPegRackImgIdx = new HTuple();
            HTuple hv__ErrPegRackCode = new HTuple(), hv__ErrPegRackStr = new HTuple();
            HTuple hv__InspectbridgePara = new HTuple(), hv__DefectBridgeType = new HTuple();
            HTuple hv__DefectBridgeImgIdx = new HTuple(), hv__ErrBridgeCode = new HTuple();
            HTuple hv__ErrBridgeStr = new HTuple();

            HTupleVector hvec__DefectFrameInsValues = new HTupleVector(2);
            HTupleVector hvec__RegSegParas = new HTupleVector(1), hvec__DefectFrameInsValue = new HTupleVector(1);
            HTupleVector hvec__RefValue = new HTupleVector(2), hvec__DefectPegRackInsValue = new HTupleVector(1);
            HTupleVector hvec__DefectBridgeInsValue = new HTupleVector(1);
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_EmptyObject);
            HOperatorSet.GenEmptyObj(out ho__FailFrameRegs);
            HOperatorSet.GenEmptyObj(out ho__FrameReg);
            HOperatorSet.GenEmptyObj(out ho__PegRackReg);
            HOperatorSet.GenEmptyObj(out ho__BridgeReg);
            HOperatorSet.GenEmptyObj(out ho_i_Image);
            HOperatorSet.GenEmptyObj(out ho__FailFrameInsReg);
            HOperatorSet.GenEmptyObj(out ho__FailPegRackReg);
            HOperatorSet.GenEmptyObj(out ho__FailBridgeReg);
            hvec_o_FailRegs = new HObjectVector(2);
            try
            {
                //**************************************************************************************************
                //---函数：HTV_frames_inspect
                //---作用：Frames检测：多框架、多钉架检测
                //---参数：
                //===图标参数
                //  i_Imgs：检测所需图像集合
                //  i_SearchRegs：搜索区
                //  i_FrameObjs：Frame检测区域对象
                //  i_RejectRegs：检测得到的拒绝区
                //  o_FailRegs：检出失败的区域
                //===控制参数
                //  i_ObjNum：框架数目
                //  i_FrameInspectParas：Frame检测参数
                //  i_HomMatMod2Img：Frame定位映射矩阵
                //  o_DefectTypes：异常区域的缺陷类型
                //  o_ErrCode：错误码
                //  o_ErrStr：错误信息
                //**************************************************************************************************
                //
                //初始化
                hvec_o_DefectTypes = (new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))));
                hvec_o_DefectImgIdx = (new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))));
                hvec_o_DefectValue = (new HTupleVector(3).Insert(0, (new HTupleVector(2).Insert(0, (
                    new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))));
                hvec_o_RefValue = (new HTupleVector(3).Insert(0, (new HTupleVector(2).Insert(0, (
                    new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))));
                ho_EmptyObject.Dispose();
                HOperatorSet.GenEmptyObj(out ho_EmptyObject);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hvec_o_FailRegs = dh.Take((
                        dh.Add(new HObjectVector(2)).Insert(0, (dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho_EmptyObject)))))));
                }
                HTuple end_val26 = hv_i_ObjNum - 1;
                HTuple step_val26 = 1;
                for (hv_objIdx = 0; hv_objIdx.Continue(end_val26, step_val26); hv_objIdx = hv_objIdx.TupleAdd(step_val26))
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hvec_o_FailRegs[hv_objIdx] = dh.Take((
                            dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho_EmptyObject)))));
                    }
                    hvec_o_DefectTypes[hv_objIdx] = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())));
                    hvec_o_DefectImgIdx[hv_objIdx] = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())));
                }
                hv_o_ErrCode = -2;
                hv_o_ErrStr = "initializing";
                //输入合法性测试
                //
                //----------------------------------Inspect------------------------------
                //
                //
                HTuple end_val38 = hv_i_ObjNum - 1;
                HTuple step_val38 = 1;
                for (hv_objIdx = 0; hv_objIdx.Continue(end_val38, step_val38); hv_objIdx = hv_objIdx.TupleAdd(step_val38))
                {
                    //
                    ho__FailFrameRegs.Dispose();
                    HOperatorSet.GenEmptyObj(out ho__FailFrameRegs);
                    hv__DefectFrameTypes = new HTuple();
                    hv__DefectFrameImgIdxs = new HTuple();
                    hvec__DefectFrameInsValues = (new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))));

                    //获取Frame检测对象
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        //hvec__InspectObj = dh.Take(hvec_i_FrameObjs[hv_objIdx]);
                        hvec__InspectObj = hvec_i_FrameObjs.At(hv_objIdx).Clone();
                    }
                    //框架检测区域
                    ho__FrameReg.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho__FrameReg = hvec__InspectObj[2].O.CopyObj(1, -1);
                    }
                    //钉架区域
                    ho__PegRackReg.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho__PegRackReg = hvec__InspectObj[3].O.CopyObj(1, -1);
                    }
                    //桥接区域
                    ho__BridgeReg.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho__BridgeReg = hvec__InspectObj[4].O.CopyObj(1, -1);
                    }

                    //获取frame检测参数
                    //定位任务项使能
                    hv__TaskEnable = hvec_i_FrameInspectParas[0][hv_objIdx][3].T.Clone();
                    hv__FrameInsEnable = hv__TaskEnable[0];
                    hv__PegRackInsEnable = hv__TaskEnable[1];
                    hv__BridgeInsEnable = hv__TaskEnable[2];
                    //frame检测使用图层
                    hv__ImageIdx = hvec_i_FrameInspectParas[0][hv_objIdx][4].T.Clone();
                    //
                    //frame定位映射矩阵
                    hv__FrameHomMat2D = hvec_i_HomMatMod2Img[hv_objIdx].T.Clone();

                    //传入映射矩阵有效性测试
                    HOperatorSet.TupleSum(hv__FrameHomMat2D, out hv_HomMatSum);
                    if ((int)(new HTuple(hv_HomMatSum.TupleEqual(-12))) != 0)
                    {
                        hv_LocSuccFlag = -1;
                    }
                    else
                    {
                        hv_LocSuccFlag = 1;
                    }
                    //
                    //*******************frame检测*********************
                    if ((int)((new HTuple(hv__FrameInsEnable.TupleEqual(1))).TupleAnd(new HTuple(hv_LocSuccFlag.TupleEqual(
                        1)))) != 0)
                    {
                        //获取frame检测参数
                        hv__InspectFramePara = hvec_i_FrameInspectParas[1][hv_objIdx][1].T.Clone();
                        //选择方法
                        hv_RegSegMethodIndex = hv__InspectFramePara[0];
                        //参数设置
                        if ((int)(new HTuple(hv_RegSegMethodIndex.TupleEqual(0))) != 0)
                        {
                            //
                            //自适应阈值分割
                            hv__AdaptiveMethod = hv__InspectFramePara[1];
                            hv__BlockSize = hv__InspectFramePara[2];
                            hv__Contrast = hv__InspectFramePara[3];
                            hv__LightOrDark = hv__InspectFramePara[4];
                            hv__CloseSize = hv__InspectFramePara[5];
                            hv__MinLength = hv__InspectFramePara[6];
                            hv__MinWidth = hv__InspectFramePara[7];
                            hv__MinArea = hv__InspectFramePara[8];
                            hv__SelOperation = hv__InspectFramePara[9];
                            //
                            hvec__RegSegParas = (((((new HTupleVector(1).Insert(0, new HTupleVector(hv_RegSegMethodIndex))).Insert(
                                1, new HTupleVector(hv__AdaptiveMethod))).Insert(2, new HTupleVector(hv__BlockSize))).Insert(
                                3, new HTupleVector(hv__Contrast))).Insert(4, new HTupleVector(hv__LightOrDark)));
                            //
                        }
                        else if ((int)(new HTuple(hv_RegSegMethodIndex.TupleEqual(1))) != 0)
                        {
                            //全局阈值分割
                            hv__LowThreshGray = hv__InspectFramePara[1];
                            hv__HighThreshGray = hv__InspectFramePara[2];
                            hv__ThreshInOrOut = hv__InspectFramePara[3];
                            hv__MorphSize = hv__InspectFramePara[4];
                            hv__CloseSize = hv__InspectFramePara[5];
                            hv__MinLength = hv__InspectFramePara[6];
                            hv__MinWidth = hv__InspectFramePara[7];
                            hv__MinArea = hv__InspectFramePara[8];
                            hv__SelOperation = hv__InspectFramePara[9];
                            //
                            hv__ThreshGray = new HTuple();
                            hv__ThreshGray = hv__ThreshGray.TupleConcat(hv__LowThreshGray);
                            hv__ThreshGray = hv__ThreshGray.TupleConcat(hv__HighThreshGray);
                            hvec__RegSegParas = ((((new HTupleVector(1).Insert(0, new HTupleVector(hv_RegSegMethodIndex))).Insert(
                                1, new HTupleVector(hv__ThreshGray))).Insert(2, new HTupleVector(hv__ThreshInOrOut))).Insert(
                                3, new HTupleVector(hv__MorphSize)));
                            //
                        }
                        //选择图像
                        ho_i_Image.Dispose();
                        HOperatorSet.SelectObj(ho_i_Imgs, out ho_i_Image, hv__ImageIdx.TupleSelect(
                            0));
                        ho__FailFrameInsReg.Dispose();
                        HTV_Frame_Inspect(ho_i_Image, ho__FrameReg, ho_i_RejectReg, out ho__FailFrameInsReg,
                            hv__FrameHomMat2D, hvec__RegSegParas, hv__CloseSize, hv__MinLength,
                            hv__MinWidth, hv__MinArea, hv__SelOperation, hv__ImageIdx.TupleSelect(
                            0), out hv__DefectFrameType, out hv__DefectFrameImgIdx, out hvec__DefectFrameInsValue,
                            out hv__ErrFrameCode, out hv__ErrFrameStr);

                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(ho__FailFrameRegs, ho__FailFrameInsReg, out ExpTmpOutVar_0
                                );
                            ho__FailFrameRegs.Dispose();
                            ho__FailFrameRegs = ExpTmpOutVar_0;
                        }
                        hv__DefectFrameTypes = hv__DefectFrameTypes.TupleConcat(hv__DefectFrameType);
                        hv__DefectFrameImgIdxs = hv__DefectFrameImgIdxs.TupleConcat(hv__DefectFrameImgIdx);
                        hvec__DefectFrameInsValues[0] = hvec__DefectFrameInsValue.Clone();
                        hvec__RefValue[0] = (((new HTupleVector(1).Insert(0, new HTupleVector(hv__MinArea))).Insert(
                            1, new HTupleVector(new HTuple(0)))).Insert(2, new HTupleVector(new HTuple(0))));
                    }
                    else
                    {
                        hvec__DefectFrameInsValues[0] = (((new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(0)))).Insert(
                            1, new HTupleVector(new HTuple(0)))).Insert(2, new HTupleVector(new HTuple(0))));
                        hvec__RefValue[0] = (((new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(-2)))).Insert(
                            1, new HTupleVector(new HTuple(0)))).Insert(2, new HTupleVector(new HTuple(0))));
                    }
                    //
                    //*********************pegrack检测*********************
                    if ((int)((new HTuple(hv__PegRackInsEnable.TupleEqual(1))).TupleAnd(new HTuple(hv_LocSuccFlag.TupleEqual(
                        1)))) != 0)
                    {
                        //获取pegrack检测参数
                        hv__InspectpegrackPara = hvec_i_FrameInspectParas[1][hv_objIdx][2].T.Clone();
                        //选择方法
                        hv_RegSegMethodIndex = hv__InspectpegrackPara[0];
                        //参数设置
                        if ((int)(new HTuple(hv_RegSegMethodIndex.TupleEqual(0))) != 0)
                        {
                            //
                            //自适应阈值分割
                            hv__AdaptiveMethod = hv__InspectpegrackPara[1];
                            hv__BlockSize = hv__InspectpegrackPara[2];
                            hv__Contrast = hv__InspectpegrackPara[3];
                            hv__LightOrDark = hv__InspectpegrackPara[4];
                            hv__CloseSize = hv__InspectpegrackPara[5];
                            hv__MinLength = hv__InspectpegrackPara[6];
                            hv__MinWidth = hv__InspectpegrackPara[7];
                            hv__MinArea = hv__InspectpegrackPara[8];
                            hv__SelOperation = hv__InspectpegrackPara[9];
                            //
                            hvec__RegSegParas = (((((new HTupleVector(1).Insert(0, new HTupleVector(hv_RegSegMethodIndex))).Insert(
                                1, new HTupleVector(hv__AdaptiveMethod))).Insert(2, new HTupleVector(hv__BlockSize))).Insert(
                                3, new HTupleVector(hv__Contrast))).Insert(4, new HTupleVector(hv__LightOrDark)));
                            //
                        }
                        else if ((int)(new HTuple(hv_RegSegMethodIndex.TupleEqual(1))) != 0)
                        {
                            //全局阈值分割
                            hv__LowThreshGray = hv__InspectpegrackPara[1];
                            hv__HighThreshGray = hv__InspectpegrackPara[2];
                            hv__ThreshInOrOut = hv__InspectpegrackPara[3];
                            hv__MorphSize = hv__InspectpegrackPara[4];
                            hv__CloseSize = hv__InspectpegrackPara[5];
                            hv__MinLength = hv__InspectpegrackPara[6];
                            hv__MinWidth = hv__InspectpegrackPara[7];
                            hv__MinArea = hv__InspectpegrackPara[8];
                            hv__SelOperation = hv__InspectpegrackPara[9];
                            //
                            hv__ThreshGray = new HTuple();
                            hv__ThreshGray = hv__ThreshGray.TupleConcat(hv__LowThreshGray);
                            hv__ThreshGray = hv__ThreshGray.TupleConcat(hv__HighThreshGray);
                            hvec__RegSegParas = ((((new HTupleVector(1).Insert(0, new HTupleVector(hv_RegSegMethodIndex))).Insert(
                                1, new HTupleVector(hv__ThreshGray))).Insert(2, new HTupleVector(hv__ThreshInOrOut))).Insert(
                                3, new HTupleVector(hv__MorphSize)));
                            //
                        }
                        //选择图像
                        ho_i_Image.Dispose();
                        HOperatorSet.SelectObj(ho_i_Imgs, out ho_i_Image, hv__ImageIdx.TupleSelect(
                            1));
                        ho__FailPegRackReg.Dispose();
                        HTV_PegRack_Inspect(ho_i_Image, ho__PegRackReg, ho_i_RejectReg, out ho__FailPegRackReg,
                            hv__FrameHomMat2D, hvec__RegSegParas, hv__CloseSize, hv__MinLength,
                            hv__MinWidth, hv__MinArea, hv__SelOperation, hv__ImageIdx.TupleSelect(
                            1), out hv__DefectPegRackType, out hv__DefectPegRackImgIdx, out hvec__DefectPegRackInsValue,
                            out hv__ErrPegRackCode, out hv__ErrPegRackStr);

                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(ho__FailFrameRegs, ho__FailPegRackReg, out ExpTmpOutVar_0
                                );
                            ho__FailFrameRegs.Dispose();
                            ho__FailFrameRegs = ExpTmpOutVar_0;
                        }
                        hv__DefectFrameTypes = hv__DefectFrameTypes.TupleConcat(hv__DefectPegRackType);
                        hv__DefectFrameImgIdxs = hv__DefectFrameImgIdxs.TupleConcat(hv__DefectPegRackImgIdx);
                        hvec__DefectFrameInsValues[1] = hvec__DefectPegRackInsValue.Clone();
                        hvec__RefValue[1] = (((new HTupleVector(1).Insert(0, new HTupleVector(hv__MinArea))).Insert(
                            1, new HTupleVector(new HTuple(0)))).Insert(2, new HTupleVector(new HTuple(0))));
                    }
                    else
                    {
                        hvec__DefectFrameInsValues[1] = (((new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(0)))).Insert(
                            1, new HTupleVector(new HTuple(0)))).Insert(2, new HTupleVector(new HTuple(0))));
                        hvec__RefValue[1] = (((new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(-2)))).Insert(
                            1, new HTupleVector(new HTuple(0)))).Insert(2, new HTupleVector(new HTuple(0))));
                    }

                    //*********************Bridge检测*********************
                    if ((int)((new HTuple(hv__BridgeInsEnable.TupleEqual(1))).TupleAnd(new HTuple(hv_LocSuccFlag.TupleEqual(
                        1)))) != 0)
                    {
                        //获取pegrack检测参数
                        hv__InspectbridgePara = hvec_i_FrameInspectParas[1][hv_objIdx][3].T.Clone();
                        //选择方法
                        hv_RegSegMethodIndex = hv__InspectbridgePara[0];
                        //参数设置
                        if ((int)(new HTuple(hv_RegSegMethodIndex.TupleEqual(0))) != 0)
                        {
                            //
                            //自适应阈值分割
                            hv__AdaptiveMethod = hv__InspectbridgePara[1];
                            hv__BlockSize = hv__InspectbridgePara[2];
                            hv__Contrast = hv__InspectbridgePara[3];
                            hv__LightOrDark = hv__InspectbridgePara[4];
                            hv__CloseSize = hv__InspectbridgePara[5];
                            hv__MinLength = hv__InspectbridgePara[6];
                            hv__MinWidth = hv__InspectbridgePara[7];
                            hv__MinArea = hv__InspectbridgePara[8];
                            hv__SelOperation = hv__InspectbridgePara[9];
                            //
                            hvec__RegSegParas = (((((new HTupleVector(1).Insert(0, new HTupleVector(hv_RegSegMethodIndex))).Insert(
                                1, new HTupleVector(hv__AdaptiveMethod))).Insert(2, new HTupleVector(hv__BlockSize))).Insert(
                                3, new HTupleVector(hv__Contrast))).Insert(4, new HTupleVector(hv__LightOrDark)));
                            //
                        }
                        else if ((int)(new HTuple(hv_RegSegMethodIndex.TupleEqual(1))) != 0)
                        {
                            //
                            //全局阈值分割
                            hv__LowThreshGray = hv__InspectbridgePara[1];
                            hv__HighThreshGray = hv__InspectbridgePara[2];
                            hv__ThreshInOrOut = hv__InspectbridgePara[3];
                            hv__MorphSize = hv__InspectbridgePara[4];
                            hv__CloseSize = hv__InspectbridgePara[5];
                            hv__MinLength = hv__InspectbridgePara[6];
                            hv__MinWidth = hv__InspectbridgePara[7];
                            hv__MinArea = hv__InspectbridgePara[8];
                            hv__SelOperation = hv__InspectbridgePara[9];
                            //
                            hv__ThreshGray = new HTuple();
                            hv__ThreshGray = hv__ThreshGray.TupleConcat(hv__LowThreshGray);
                            hv__ThreshGray = hv__ThreshGray.TupleConcat(hv__HighThreshGray);
                            hvec__RegSegParas = ((((new HTupleVector(1).Insert(0, new HTupleVector(hv_RegSegMethodIndex))).Insert(
                                1, new HTupleVector(hv__ThreshGray))).Insert(2, new HTupleVector(hv__ThreshInOrOut))).Insert(
                                3, new HTupleVector(hv__MorphSize)));
                            //
                        }
                        //选择图像
                        ho_i_Image.Dispose();
                        HOperatorSet.SelectObj(ho_i_Imgs, out ho_i_Image, hv__ImageIdx.TupleSelect(
                            2));
                        ho__FailBridgeReg.Dispose();
                        HTV_Bridge_Inspect(ho_i_Image, ho__BridgeReg, ho_i_RejectReg, out ho__FailBridgeReg,
                            hv__FrameHomMat2D, hvec__RegSegParas, hv__CloseSize, hv__MinLength,
                            hv__MinWidth, hv__MinArea, hv__SelOperation, hv__ImageIdx.TupleSelect(
                            2), out hv__DefectBridgeType, out hv__DefectBridgeImgIdx, out hvec__DefectBridgeInsValue,
                            out hv__ErrBridgeCode, out hv__ErrBridgeStr);

                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(ho__FailFrameRegs, ho__FailBridgeReg, out ExpTmpOutVar_0
                                );
                            ho__FailFrameRegs.Dispose();
                            ho__FailFrameRegs = ExpTmpOutVar_0;
                        }
                        hv__DefectFrameTypes = hv__DefectFrameTypes.TupleConcat(hv__DefectBridgeType);
                        hv__DefectFrameImgIdxs = hv__DefectFrameImgIdxs.TupleConcat(hv__DefectBridgeImgIdx);
                        hvec__DefectFrameInsValues[2] = hvec__DefectBridgeInsValue.Clone();
                        hvec__RefValue[2] = (((new HTupleVector(1).Insert(0, new HTupleVector(hv__MinArea))).Insert(
                            1, new HTupleVector(new HTuple(0)))).Insert(2, new HTupleVector(new HTuple(0))));
                    }
                    else
                    {
                        hvec__DefectFrameInsValues[2] = (((new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(0)))).Insert(
                            1, new HTupleVector(new HTuple(0)))).Insert(2, new HTupleVector(new HTuple(0))));
                        hvec__RefValue[2] = (((new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(-2)))).Insert(
                            1, new HTupleVector(new HTuple(0)))).Insert(2, new HTupleVector(new HTuple(0))));
                    }
                    //
                    //整合多frame区域检测结果
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hvec_o_FailRegs[hv_objIdx] = dh.Take((
                            dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho__FailFrameRegs)))));
                    }
                    hvec_o_DefectTypes[hv_objIdx] = (new HTupleVector(1).Insert(0, new HTupleVector(hv__DefectFrameTypes)));
                    hvec_o_DefectImgIdx[hv_objIdx] = (new HTupleVector(1).Insert(0, new HTupleVector(hv__DefectFrameImgIdxs)));
                    hvec_o_DefectValue[hv_objIdx] = hvec__DefectFrameInsValues.Clone();
                    hvec_o_RefValue[hv_objIdx] = hvec__RefValue.Clone();
                    //
                }
                //
                hv_o_ErrCode = 0;
                hv_o_ErrStr = "frames inspect successful";
                ho_EmptyObject.Dispose();
                ho__FailFrameRegs.Dispose();
                ho__FrameReg.Dispose();
                ho__PegRackReg.Dispose();
                ho__BridgeReg.Dispose();
                ho_i_Image.Dispose();
                ho__FailFrameInsReg.Dispose();
                ho__FailPegRackReg.Dispose();
                ho__FailBridgeReg.Dispose();
                hvec__InspectObj.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_EmptyObject.Dispose();
                ho__FailFrameRegs.Dispose();
                ho__FrameReg.Dispose();
                ho__PegRackReg.Dispose();
                ho__BridgeReg.Dispose();
                ho_i_Image.Dispose();
                ho__FailFrameInsReg.Dispose();
                ho__FailPegRackReg.Dispose();
                ho__FailBridgeReg.Dispose();
                hvec__InspectObj.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public static void get_subvector_param(HTupleVector/*{eTupleVector,Dim=2}*/ hvec_Vector,
            HTuple hv_startKey, HTuple hv_endKey, out HTupleVector/*{eTupleVector,Dim=3}*/ hvec_subVector)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_Names = null, hv_i = null, hv_value = null;
            HTuple hv_StratIndex = null, hv_EndIndex = null, hv_groupIndex = null;
            HTuple hv_idx = new HTuple();

            HTupleVector hvec_curVector = new HTupleVector(2);
            // Initialize local and output iconic variables 
            hvec_subVector = (new HTupleVector(3).Insert(0, (new HTupleVector(2).Insert(0, (
                new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))));
            hv_Names = new HTuple();
            HTuple end_val2 = new HTuple(hvec_Vector.Length) - 1;
            HTuple step_val2 = 1;
            for (hv_i = 0; hv_i.Continue(end_val2, step_val2); hv_i = hv_i.TupleAdd(step_val2))
            {
                hv_Names = hv_Names.TupleConcat(hvec_Vector[hv_i][0].T);
            }
            hv_value = new HTuple();
            hv_StratIndex = hv_Names.TupleFind(hv_startKey);
            hv_EndIndex = hv_Names.TupleFind(hv_endKey);
            if ((int)((new HTuple(hv_StratIndex.TupleLess(0))).TupleOr(new HTuple(hv_EndIndex.TupleLess(
                0)))) != 0)
            {

                return;
            }

            if ((int)(new HTuple((new HTuple(hv_StratIndex.TupleLength())).TupleNotEqual(
                new HTuple(hv_EndIndex.TupleLength())))) != 0)
            {

                return;
            }
            //
            for (hv_groupIndex = 0; (int)hv_groupIndex <= (int)((new HTuple(hv_StratIndex.TupleLength()
                )) - 1); hv_groupIndex = (int)hv_groupIndex + 1)
            {
                hvec_curVector = (new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))));
                HTuple end_val18 = ((hv_EndIndex.TupleSelect(
                    hv_groupIndex)) - (hv_StratIndex.TupleSelect(hv_groupIndex))) - 1;
                HTuple step_val18 = 1;
                for (hv_idx = 0; hv_idx.Continue(end_val18, step_val18); hv_idx = hv_idx.TupleAdd(step_val18))
                {
                    hvec_curVector[hv_idx] = hvec_Vector[hv_idx + (hv_StratIndex.TupleSelect(hv_groupIndex))];
                }
                hvec_subVector[hv_groupIndex] = hvec_curVector.Clone();
            }

            return;
        }

        public static void fread_xml_to_vector(HTuple hv_FileName, out HTupleVector/*{eTupleVector,Dim=2}*/ hvec_Elements)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_FileExists = null, hv_TextSE = new HTuple();
            HTuple hv_S = new HTuple(), hv_NameStrt = new HTuple();
            HTuple hv_NameChar = new HTuple(), hv_Name = new HTuple();
            HTuple hv_ElementTagRE = new HTuple(), hv_EndTagSE = new HTuple();
            HTuple hv_EndTagRE = new HTuple(), hv_ElementValueRE = new HTuple();
            HTuple hv_NameChar_attribute = new HTuple(), hv_Name_attribute = new HTuple();
            HTuple hv_ElementTagRE_attribute = new HTuple(), hv_FileHandle = new HTuple();
            HTuple hv_IsEof = new HTuple(), hv_XmlElement = new HTuple();
            HTuple hv_Matches = new HTuple(), hv_Matches_attribute0 = new HTuple();
            HTuple hv_Length0 = new HTuple(), hv_Matches_attribute = new HTuple();
            HTuple hv_Length1 = new HTuple(), hv_kan = new HTuple();
            HTuple hv_Separator = new HTuple(), hv_Matches_attribute_cut = new HTuple();
            HTuple hv_Substrings = new HTuple(), hv_num_attribute = new HTuple();
            HTuple hv_name_cut_left = new HTuple(), hv_name_att = new HTuple();
            HTuple hv_index = new HTuple(), hv_cur_att_all = new HTuple();
            HTuple hv_Length2 = new HTuple(), hv_Group_test = new HTuple();
            HTuple hv_Region_test = new HTuple(), hv_Length3 = new HTuple();
            HTuple hv_Length = new HTuple(), hv_ElementTag = new HTuple();
            HTuple hv_curElementsLen = new HTuple();

            HTupleVector hvec_vector = new HTupleVector(1);
            HTupleVector hvec_curElement = new HTupleVector(1);
            // Initialize local and output iconic variables 
            hvec_Elements = new HTupleVector(2);
            HOperatorSet.FileExists(hv_FileName, out hv_FileExists);
            if ((int)(hv_FileExists) != 0)
            {
                hv_TextSE = "[^<>]+";
                hv_S = "[ \\n\\t\\r]?";
                hv_NameStrt = "[A-Za-z/]";
                hv_NameChar = "[A-Za-z0-9_:.-]";
                hv_Name = ((("(?:" + hv_NameStrt) + ")(?:") + hv_NameChar) + ")*";
                hv_ElementTagRE = ("<" + hv_Name) + ">";
                hv_EndTagSE = "</";
                hv_EndTagRE = ((hv_EndTagSE + hv_Name) + hv_S) + ">+";
                hv_ElementValueRE = ">(.*?)" + hv_EndTagSE;

                hv_NameChar_attribute = "[A-Za-z0-9_:.\\-=/ \\\"\\\\]";
                hv_Name_attribute = ((("(?:" + hv_NameStrt) + ")(?:") + hv_NameChar_attribute) + ")*";
                hv_ElementTagRE_attribute = ("<" + hv_Name_attribute) + ">";


                HOperatorSet.OpenFile(hv_FileName, "input", out hv_FileHandle);
                hv_IsEof = 0;
                hvec_Elements = new HTupleVector(2);
                hvec_Elements.Clear();
                while ((int)(hv_IsEof.TupleNot()) != 0)
                {
                    HOperatorSet.FreadLine(hv_FileHandle, out hv_XmlElement, out hv_IsEof);
                    if ((int)(hv_IsEof) != 0)
                    {
                        break;
                    }
                    HOperatorSet.TupleRegexpMatch(hv_XmlElement, (((((((((("(?:(" + hv_ElementTagRE) + ")(.*)") + "(") + hv_EndTagRE) + "))|") + "(") + hv_ElementTagRE) + ")|") + "(") + hv_EndTagRE) + ")",
                        out hv_Matches);
                    //all_str := '(?:(' + ElementTagRE + ')(.*)' + '(' + EndTagRE + '))|' +                               '(' + ElementTagRE + ')|' +                               '(' + EndTagRE + ')'


                    //单行属性-在一行进行多参数设置多参数
                    HOperatorSet.TupleRegexpMatch(hv_XmlElement, new HTuple(new HTuple("(<.*") + "=\"") + ".*>)",
                        out hv_Matches_attribute0);
                    HOperatorSet.TupleStrlen(hv_Matches_attribute0, out hv_Length0);
                    if ((int)(new HTuple(hv_Length0.TupleGreater(0))) != 0)
                    {

                        HOperatorSet.TupleRegexpMatch(hv_XmlElement, ("(" + hv_ElementTagRE_attribute) + ")",
                            out hv_Matches_attribute);
                        HOperatorSet.TupleStrlen(hv_Matches_attribute, out hv_Length1);
                        if ((int)(new HTuple(hv_Length1.TupleGreater(0))) != 0)
                        {
                            hv_kan = hv_Matches_attribute.Clone();

                            //提取单行字符串中的多属性值
                            hv_Separator = " ";
                            //tuple_regexp_match (XmlElement, '<'+'(.*)'+'/?>', Matches_attribute_cut)
                            HOperatorSet.TupleSplit(hv_Matches_attribute, hv_Separator, out hv_Substrings);

                            hv_num_attribute = new HTuple(hv_Substrings.TupleLength());

                            HOperatorSet.TupleRegexpMatch(hv_Substrings.TupleSelect(0), new HTuple("<") + "(.*)",
                                out hv_name_cut_left);
                            hv_name_att = hv_name_cut_left.Clone();
                            hvec_vector = ((new HTupleVector(1).Insert(0, new HTupleVector(hv_name_att))).Insert(
                                1, new HTupleVector(new HTuple(""))));
                            hvec_Elements.Insert(new HTuple(hvec_Elements.Length), hvec_vector);

                            for (hv_index = 1; (int)hv_index <= (int)((new HTuple(hv_Substrings.TupleLength()
                                )) - 1); hv_index = (int)hv_index + 1)
                            {
                                hv_cur_att_all = hv_Substrings.TupleSelect(hv_index);
                                HOperatorSet.TupleRegexpMatch(hv_cur_att_all, "(.*)(=\\\")(.*)\\\"",
                                    out hv_Matches_attribute_cut);
                                HOperatorSet.TupleStrlen(hv_Matches_attribute_cut, out hv_Length2);
                                if ((int)(new HTuple(((hv_Length2.TupleSelect(0))).TupleGreater(0))) != 0)
                                {
                                    hvec_vector = ((new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(hv_Matches_attribute_cut.TupleSelect(
                                        0))))).Insert(1, new HTupleVector(new HTuple(hv_Matches_attribute_cut.TupleSelect(
                                        2)))));
                                    hvec_Elements.Insert(new HTuple(hvec_Elements.Length), hvec_vector);
                                }
                            }
                        }
                    }


                    //if ((int)(0) != 0)
                    //{
                    //    //多行属性--Group Index=
                    //    HOperatorSet.TupleRegexpMatch(hv_XmlElement, new HTuple(new HTuple(new HTuple("<") + "Group Index=\\\"") + "([0-9]+)") + "\\\"",
                    //        out hv_Group_test);
                    //    HOperatorSet.TupleStrlen(hv_Group_test, out hv_Length2);
                    //    if ((int)(new HTuple(hv_Length2.TupleGreater(0))) != 0)
                    //    {
                    //        hv_kan = hv_Group_test.Clone();
                    //        hvec_vector = ((new HTupleVector(1).Insert(0, new HTupleVector(new HTuple("Group Index")))).Insert(
                    //            1, new HTupleVector(hv_Group_test)));
                    //        hvec_Elements.Insert(new HTuple(hvec_Elements.Length), hvec_vector);
                    //    }

                    //    //多行属性--Region Index=
                    //    HOperatorSet.TupleRegexpMatch(hv_XmlElement, new HTuple(new HTuple(new HTuple("<") + "Region Index=\\\"") + "([0-9]+)") + "\\\"",
                    //        out hv_Region_test);
                    //    HOperatorSet.TupleStrlen(hv_Region_test, out hv_Length3);
                    //    if ((int)(new HTuple(hv_Length3.TupleGreater(0))) != 0)
                    //    {
                    //        hv_kan = hv_Region_test.Clone();
                    //        hvec_vector = ((new HTupleVector(1).Insert(0, new HTupleVector(new HTuple("Region Index")))).Insert(
                    //            1, new HTupleVector(hv_Region_test)));
                    //        hvec_Elements.Insert(new HTuple(hvec_Elements.Length), hvec_vector);
                    //    }
                    //}

                    HOperatorSet.TupleStrlen(hv_Matches, out hv_Length);
                    if ((int)(new HTuple(((hv_Length.TupleSelect(3))).TupleGreater(0))) != 0)
                    {
                        HOperatorSet.TupleRegexpMatch(hv_Matches.TupleSelect(3), hv_TextSE, out hv_ElementTag);
                        hvec_vector = (new HTupleVector(1).Insert(0, new HTupleVector(hv_ElementTag)));
                        hvec_Elements.Insert(new HTuple(hvec_Elements.Length), hvec_vector);
                    }
                    else if ((int)(new HTuple(((hv_Length.TupleSelect(4))).TupleGreater(
                        0))) != 0)
                    {
                        HOperatorSet.TupleRegexpMatch(hv_Matches.TupleSelect(4), hv_TextSE, out hv_ElementTag);
                        hvec_vector = (new HTupleVector(1).Insert(0, new HTupleVector(hv_ElementTag)));
                        hvec_Elements.Insert(new HTuple(hvec_Elements.Length), hvec_vector);
                    }
                    else if ((int)(new HTuple(((hv_Length.TupleSelect(0))).TupleGreater(
                        0))) != 0)
                    {
                        if ((int)(new HTuple(((hv_Matches.TupleSelect(0))).TupleEqual("<para>"))) != 0)
                        {
                            hv_curElementsLen = new HTuple(hvec_Elements.Length);
                            hvec_curElement = hvec_Elements[hv_curElementsLen - 1];
                            hvec_curElement.Insert(new HTuple(hvec_curElement.Length), new HTupleVector(new HTuple(hv_Matches.TupleSelect(
                                1))));
                            hvec_Elements.Remove(hv_curElementsLen - 1);
                            hvec_Elements.Insert(new HTuple(hvec_Elements.Length), hvec_curElement);
                        }
                        else
                        {
                            HOperatorSet.TupleRegexpMatch(hv_Matches.TupleSelect(0), hv_TextSE, out hv_ElementTag);
                            hvec_vector = ((new HTupleVector(1).Insert(0, new HTupleVector(hv_ElementTag))).Insert(
                                1, new HTupleVector(new HTuple(hv_Matches.TupleSelect(1)))));
                            hvec_Elements.Insert(new HTuple(hvec_Elements.Length), hvec_vector);
                        }
                    }

                }
                HOperatorSet.CloseFile(hv_FileHandle);
            }
            else
            {
            }

            return;
        }

        public static void HTV_ics_inspect(HObject ho_i_Imgs, HObjectVector/*{eObjectVector,Dim=2}*/ hvec_i_IcObjs,
            out HObjectVector/*{eObjectVector,Dim=2}*/ hvec_o_FailRegs, out HObjectVector/*{eObjectVector,Dim=1}*/ hvec_o_Ics,
            HTuple hv_i_ObjNum, HTupleVector/*{eTupleVector,Dim=1}*/ hvec_i_RefHomMatMod2Img,
            HTupleVector/*{eTupleVector,Dim=1}*/ hvec_i_refLocPara, HTupleVector/*{eTupleVector,Dim=3}*/ hvec_i_IcInspectParas,
            out HTupleVector/*{eTupleVector,Dim=1}*/ hvec_o_HomMatMod2Img, out HTupleVector/*{eTupleVector,Dim=2}*/ hvec_o_DefectTypes,
            out HTupleVector/*{eTupleVector,Dim=4}*/ hvec_o_DefectValue, out HTupleVector/*{eTupleVector,Dim=2}*/ hvec_o_DefectImgIdx,
            out HTupleVector/*{eTupleVector,Dim=4}*/ hvec_o_RefValue, out HTuple hv_o_ErrCode,
            out HTuple hv_o_ErrStr)
        {




            // Local iconic variables 

            HObject ho_EmptyObject, ho__IcInspectReg = null;
            HObject ho__IcMatchReg = null, ho__IcSubReg = null, ho__IcRejectReg = null;
            HObject ho__IcLightImg = null, ho__IcDarkImg = null, ho__IcMeanImg = null;
            HObject ho__FailIcRegs = null, ho__IcReg = null;

            HObjectVector hvec__InspectObj = new HObjectVector(1);

            // Local control variables 

            HTuple hv_objIdx = null, hv__TaskEnable = new HTuple();
            HTuple hv__ImageIdx = new HTuple(), hv__InspectModel = new HTuple();
            HTuple hv_IcOnWhat = new HTuple(), hv__IcHomMat2D = new HTuple();
            HTuple hv__MatErrCode = new HTuple(), hv__MatErrStr = new HTuple();
            HTuple hv__ModelType = new HTuple(), hv__ModelID = new HTuple();
            HTuple hv__ThreshGray = new HTuple(), hv__LightOrDark = new HTuple();
            HTuple hv__CloseSize = new HTuple(), hv__IcSizeTh = new HTuple();
            HTuple hv__DilationSize = new HTuple(), hv__MatchMinScore = new HTuple();
            HTuple hv__MatchStartAngle = new HTuple(), hv__MatchAngleExt = new HTuple();
            HTuple hv__MatchNum = new HTuple(), hv__RowDiffTh = new HTuple();
            HTuple hv__ColDiffTh = new HTuple(), hv__AngleDiffTh = new HTuple();
            HTuple hv_ObjIdxStr = new HTuple(), hv_frameIdx = new HTuple();
            HTuple hv__refLocPara = new HTuple(), hv__GrayContrast = new HTuple();
            HTuple hv__MinLength = new HTuple(), hv__MinWidth = new HTuple();
            HTuple hv__MinArea = new HTuple(), hv__SelOperation = new HTuple();
            HTuple hv__isChromatismProcess = new HTuple(), hv__isGlobalChromatism = new HTuple();
            HTuple hv__IcLocPara = new HTuple(), hv__DefectIcType = new HTuple();
            HTuple hv__DefectImgIdx = new HTuple(), hv__ErrIcCode = new HTuple();
            HTuple hv_o_ErrIcStr = new HTuple();

            HTupleVector hvec_i_DefectValue = new HTupleVector(2);
            HTupleVector hvec__RefHomMatMod2ImgIc = new HTupleVector(1), hvec__InspectIcPara = new HTupleVector(1);
            HTupleVector hvec__RefValue = new HTupleVector(2), hvec__DefectValue = new HTupleVector(2);
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_EmptyObject);
            HOperatorSet.GenEmptyObj(out ho__IcInspectReg);
            HOperatorSet.GenEmptyObj(out ho__IcMatchReg);
            HOperatorSet.GenEmptyObj(out ho__IcSubReg);
            HOperatorSet.GenEmptyObj(out ho__IcRejectReg);
            HOperatorSet.GenEmptyObj(out ho__IcLightImg);
            HOperatorSet.GenEmptyObj(out ho__IcDarkImg);
            HOperatorSet.GenEmptyObj(out ho__IcMeanImg);
            HOperatorSet.GenEmptyObj(out ho__FailIcRegs);
            HOperatorSet.GenEmptyObj(out ho__IcReg);
            hvec_o_FailRegs = new HObjectVector(2);
            hvec_o_Ics = new HObjectVector(1);
            try
            {
                //**************************************************************************************************
                //---函数：HTV_ics_inspect
                //---作用：Ics检测：多Ic检测
                //---参数：
                //===图标参数
                //  i_Imgs：检测所需图像集合
                //  i_IcObjs：IC检测区域对象
                //  o_FailRegs：检出失败的区域
                //  o_Ics：检出缺陷的区域
                //===控制参数
                //  i_ObjNum：框架数目
                //  i_RefHomMatMod2Img：框架定位映射矩阵
                //  i_IcInspectParas：IC检测参数
                //  o_HomMatMod2Img：IC定位映射矩阵
                //  o_DefectTypes：异常区域的缺陷类型
                //  o_ErrCode：错误码
                //  o_ErrStr：错误信息
                //**************************************************************************************************
                //
                //初始化
                hvec_o_DefectTypes = (new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))));
                hvec_o_DefectImgIdx = (new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))));
                hvec_o_HomMatMod2Img = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())));
                hvec_o_DefectValue = (new HTupleVector(4).Insert(0, (new HTupleVector(3).Insert(0, (
                    new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))))));
                hvec_o_RefValue = (new HTupleVector(4).Insert(0, (new HTupleVector(3).Insert(0, (
                    new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))))));
                ho_EmptyObject.Dispose();
                HOperatorSet.GenEmptyObj(out ho_EmptyObject);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hvec_o_FailRegs = dh.Take((
                        dh.Add(new HObjectVector(2)).Insert(0, (dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho_EmptyObject)))))));
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hvec_o_Ics = dh.Take((
                        dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho_EmptyObject)))));
                }
                HTuple end_val28 = hv_i_ObjNum - 1;
                HTuple step_val28 = 1;
                for (hv_objIdx = 0; hv_objIdx.Continue(end_val28, step_val28); hv_objIdx = hv_objIdx.TupleAdd(step_val28))
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hvec_o_FailRegs[hv_objIdx] = dh.Take((
                            dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho_EmptyObject)))));
                    }
                    hvec_o_Ics[hv_objIdx] = new HObjectVector(ho_EmptyObject.CopyObj(1, -1));
                    hvec_o_DefectTypes[hv_objIdx] = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())));
                    hvec_o_DefectImgIdx[hv_objIdx] = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())));
                    hvec_o_HomMatMod2Img[hv_objIdx] = new HTupleVector((((((new HTuple(-2)).TupleConcat(
                        -2)).TupleConcat(-2)).TupleConcat(-2)).TupleConcat(-2)).TupleConcat(-2));
                }
                hv_o_ErrCode = -2;
                hv_o_ErrStr = "initializing";
                //
                //单个IC_ID的DefectValue初始化：定位Score, [deltaX, deltaY], deltaAng, 芯片区异物信息, 崩边区异物信息
                hvec_i_DefectValue = (((((new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(-2)))))).Insert(
                    1, (new HTupleVector(1).Insert(0, new HTupleVector((new HTuple(-2)).TupleConcat(
                    -2)))))).Insert(2, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(-2)))))).Insert(
                    3, (((new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(0)))).Insert(
                    1, new HTupleVector(new HTuple(0)))).Insert(2, new HTupleVector(new HTuple(0)))))).Insert(
                    4, (((new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(0)))).Insert(
                    1, new HTupleVector(new HTuple(0)))).Insert(2, new HTupleVector(new HTuple(0))))));

                //输入合法性测试
                //
                //----------------------------------Inspect------------------------------
                //
                HTuple end_val45 = hv_i_ObjNum - 1;
                HTuple step_val45 = 1;
                for (hv_objIdx = 0; hv_objIdx.Continue(end_val45, step_val45); hv_objIdx = hv_objIdx.TupleAdd(step_val45))
                {
                    //
                    //-------获取ic检测model参数
                    hv__TaskEnable = hvec_i_IcInspectParas[0][hv_objIdx][0].T.Clone();
                    //选择Ic所需图层号
                    hv__ImageIdx = hvec_i_IcInspectParas[0][hv_objIdx][1].T.Clone();
                    //选择Ic所在区域
                    hv__InspectModel = hvec_i_IcInspectParas[0][hv_objIdx][2].T.Clone();
                    hv_IcOnWhat = hv__InspectModel[0];
                    //获取Ic检测需要的映射矩阵
                    hvec__RefHomMatMod2ImgIc = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())));
                    HTV_Gen_HomMat_onWhat(hv_IcOnWhat, hvec_i_RefHomMatMod2Img, hvec__RefHomMatMod2ImgIc,
                        out hv__IcHomMat2D, out hv__MatErrCode, out hv__MatErrStr);

                    if ((int)(new HTuple(hv__MatErrCode.TupleLess(0))) != 0)
                    {
                        //参数异常
                        hv_o_ErrCode = hv__MatErrCode.Clone();
                        hv_o_ErrStr = hv__MatErrStr.Clone();
                        ho_EmptyObject.Dispose();
                        ho__IcInspectReg.Dispose();
                        ho__IcMatchReg.Dispose();
                        ho__IcSubReg.Dispose();
                        ho__IcRejectReg.Dispose();
                        ho__IcLightImg.Dispose();
                        ho__IcDarkImg.Dispose();
                        ho__IcMeanImg.Dispose();
                        ho__FailIcRegs.Dispose();
                        ho__IcReg.Dispose();
                        hvec__InspectObj.Dispose();

                        return;
                    }

                    //ic定位模板type、Id
                    hv__ModelType = hv__InspectModel[1];
                    hv__ModelID = hv__InspectModel[2];
                    //
                    //---------获取ic检测对象参数
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        //hvec__InspectObj = dh.Take(hvec_i_IcObjs[hv_objIdx]);
                        hvec__InspectObj = hvec_i_IcObjs.At(hv_objIdx).Clone();
                    }
                    //检测区域
                    ho__IcInspectReg.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho__IcInspectReg = hvec__InspectObj[0].O.CopyObj(1, -1);
                    }
                    //匹配区域
                    ho__IcMatchReg.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho__IcMatchReg = hvec__InspectObj[1].O.CopyObj(1, -1);
                    }
                    //重点检测区域
                    ho__IcSubReg.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho__IcSubReg = hvec__InspectObj[2].O.CopyObj(1, -1);
                    }
                    //免检测区域
                    ho__IcRejectReg.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho__IcRejectReg = hvec__InspectObj[3].O.CopyObj(1, -1);
                    }
                    //亮图
                    ho__IcLightImg.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho__IcLightImg = hvec__InspectObj[4].O.CopyObj(1, -1);
                    }
                    //暗图
                    ho__IcDarkImg.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho__IcDarkImg = hvec__InspectObj[5].O.CopyObj(1, -1);
                    }
                    //均值图
                    ho__IcMeanImg.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho__IcMeanImg = hvec__InspectObj[6].O.CopyObj(1, -1);
                    }
                    //
                    //--------获取ic检测参数
                    hvec__InspectIcPara = hvec_i_IcInspectParas[1][hv_objIdx];
                    //Ic存在参数
                    hv__ThreshGray = hvec__InspectIcPara[0].T.Clone();
                    hv__LightOrDark = hvec__InspectIcPara[1].T.Clone();
                    hv__CloseSize = hvec__InspectIcPara[2].T.Clone();
                    hv__IcSizeTh = hvec__InspectIcPara[3].T.Clone();
                    //Ic定位参数
                    hv__DilationSize = hvec__InspectIcPara[4].T.Clone();
                    hv__MatchMinScore = hvec__InspectIcPara[5].T.Clone();
                    hv__MatchStartAngle = hvec__InspectIcPara[6].T.Clone();
                    hv__MatchAngleExt = hvec__InspectIcPara[7].T.Clone();
                    hv__MatchNum = hvec__InspectIcPara[8].T.Clone();
                    //位移角度偏移阈值
                    hv__RowDiffTh = hvec__InspectIcPara[9].T.Clone();
                    hv__ColDiffTh = hvec__InspectIcPara[10].T.Clone();
                    hv__AngleDiffTh = hvec__InspectIcPara[11].T.Clone();
                    //偏移参考位置
                    //解析在哪个Frame上 lw 0125
                    HOperatorSet.TupleRegexpMatch(hv_IcOnWhat, "Frame(.*)", out hv_ObjIdxStr);
                    if ((int)(new HTuple(hv_ObjIdxStr.TupleNotEqual(""))) != 0)
                    {
                        HOperatorSet.TupleNumber(hv_ObjIdxStr, out hv_frameIdx);
                        hv_frameIdx = hv_frameIdx - 1;
                    }
                    hv__refLocPara = hvec_i_refLocPara[hv_frameIdx].T.Clone();
                    //表面检测参数
                    hv__GrayContrast = hvec__InspectIcPara[12].T.Clone();
                    hv__MinLength = hvec__InspectIcPara[13].T.Clone();
                    hv__MinWidth = hvec__InspectIcPara[14].T.Clone();
                    hv__MinArea = hvec__InspectIcPara[15].T.Clone();
                    hv__SelOperation = hvec__InspectIcPara[16].T.Clone();
                    //色差图检测优化参数
                    hv__isChromatismProcess = hvec__InspectIcPara[17].T.Clone();
                    hv__isGlobalChromatism = hvec__InspectIcPara[18].T.Clone();
                    //
                    //参考设置值
                    hvec__RefValue = (((((new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(hv__MatchMinScore))))).Insert(
                        1, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(hv__RowDiffTh.TupleConcat(
                        hv__ColDiffTh))))))).Insert(2, (new HTupleVector(1).Insert(0, new HTupleVector(hv__AngleDiffTh))))).Insert(
                        3, (((new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(hv__MinArea.TupleSelect(
                        1))))).Insert(1, new HTupleVector(new HTuple(0)))).Insert(2, new HTupleVector(new HTuple(0)))))).Insert(
                        4, (((new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(hv__MinArea.TupleSelect(
                        0))))).Insert(1, new HTupleVector(new HTuple(0)))).Insert(2, new HTupleVector(new HTuple(0))))));
                    //
                    //单个IC定位检测
                    ho__FailIcRegs.Dispose(); ho__IcReg.Dispose();
                    HTV_Ic_Inspect_GoldenModel(ho_i_Imgs, ho__IcLightImg, ho__IcDarkImg, ho__IcMeanImg,
                        ho__IcInspectReg, ho__IcMatchReg, ho__IcRejectReg, ho__IcSubReg, out ho__FailIcRegs,
                        out ho__IcReg, hv__ImageIdx, hv__TaskEnable, hv__IcHomMat2D, hv__refLocPara,
                        hv__ThreshGray, hv__LightOrDark, hv__CloseSize, hv__IcSizeTh, hv__DilationSize,
                        hv__ModelType, hv__ModelID, hv__MatchMinScore, hv__MatchStartAngle, hv__MatchAngleExt,
                        hv__MatchNum, hv__RowDiffTh, hv__ColDiffTh, hv__AngleDiffTh, hv__GrayContrast,
                        hv__MinLength, hv__MinWidth, hv__MinArea, hv__SelOperation, hv__isChromatismProcess,
                        hv__isGlobalChromatism, hvec_i_DefectValue, out hv__IcLocPara, out hv__IcHomMat2D,
                        out hv__DefectIcType, out hvec__DefectValue, out hv__DefectImgIdx, out hv__ErrIcCode,
                        out hv_o_ErrIcStr);
                    //
                    //整合多ic区域检测结果
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hvec_o_FailRegs[hv_objIdx] = dh.Take((
                            dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho__FailIcRegs)))));
                    }
                    hvec_o_Ics[hv_objIdx] = new HObjectVector(ho__IcReg.CopyObj(1, -1));
                    hvec_o_HomMatMod2Img[hv_objIdx] = new HTupleVector(hv__IcHomMat2D).Clone();
                    //一个IC只有一个检测ID
                    hvec_o_DefectTypes[hv_objIdx] = (new HTupleVector(1).Insert(0, new HTupleVector(hv__DefectIcType)));
                    hvec_o_DefectImgIdx[hv_objIdx] = (new HTupleVector(1).Insert(0, new HTupleVector(hv__DefectImgIdx)));
                    hvec_o_DefectValue[hv_objIdx] = (new HTupleVector(3).Insert(0, hvec__DefectValue));
                    hvec_o_RefValue[hv_objIdx] = (new HTupleVector(3).Insert(0, hvec__RefValue));
                    //
                }
                //
                hv_o_ErrCode = 0;
                hv_o_ErrStr = "ics inspect successful";
                ho_EmptyObject.Dispose();
                ho__IcInspectReg.Dispose();
                ho__IcMatchReg.Dispose();
                ho__IcSubReg.Dispose();
                ho__IcRejectReg.Dispose();
                ho__IcLightImg.Dispose();
                ho__IcDarkImg.Dispose();
                ho__IcMeanImg.Dispose();
                ho__FailIcRegs.Dispose();
                ho__IcReg.Dispose();
                hvec__InspectObj.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_EmptyObject.Dispose();
                ho__IcInspectReg.Dispose();
                ho__IcMatchReg.Dispose();
                ho__IcSubReg.Dispose();
                ho__IcRejectReg.Dispose();
                ho__IcLightImg.Dispose();
                ho__IcDarkImg.Dispose();
                ho__IcMeanImg.Dispose();
                ho__FailIcRegs.Dispose();
                ho__IcReg.Dispose();
                hvec__InspectObj.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public static void HTV_epoxys_inspect(HObject ho_i_Imgs, HObjectVector/*{eObjectVector,Dim=2}*/ hvec_i_EpoxyObjs,
            out HObjectVector/*{eObjectVector,Dim=1}*/ hvec_o_Epoxys, out HObjectVector/*{eObjectVector,Dim=2}*/ hvec_o_FailRegs,
            HTuple hv_i_ObjNum, HTupleVector/*{eTupleVector,Dim=1}*/ hvec_i_RefHomMatMod2Img,
            HTupleVector/*{eTupleVector,Dim=4}*/ hvec_i_EpoxyInspectParas, out HTupleVector/*{eTupleVector,Dim=2}*/ hvec_o_DefectTypes,
            out HTupleVector/*{eTupleVector,Dim=4}*/ hvec_o_DefectValue, out HTupleVector/*{eTupleVector,Dim=2}*/ hvec_o_DefectImgIdx,
            out HTupleVector/*{eTupleVector,Dim=4}*/ hvec_o_RefValue, out HTuple hv_o_ErrCode,
            out HTuple hv_o_ErrStr)
        {




            // Local iconic variables 

            HObject ho_EmptyObject, ho__EpoxyInspectReg = null;
            HObject ho__EpoxyRefReg = null, ho_i_image = null, ho__ExtractEpoxyRegs = null;

            HObjectVector hvec__InspectObj = new HObjectVector(1);
            HObjectVector hvec__FailEpoxyRegs = new HObjectVector(1);

            // Local control variables 

            HTuple hv_objIdx = null, hv__ImageIdx = new HTuple();
            HTuple hv_EpoxyToWhat = new HTuple(), hv__EpoxyHomMat2D = new HTuple();
            HTuple hv__MatErrCode = new HTuple(), hv__MatErrStr = new HTuple();
            HTuple hv__LightOrDarks = new HTuple(), hv__OpeningSizes = new HTuple();
            HTuple hv__EpoxyLenThs = new HTuple(), hv__EpoxyHeiThs = new HTuple();
            HTuple hv_idx = new HTuple(), hv__ThreshGray = new HTuple();
            HTuple hv__LightOrDark = new HTuple(), hv__OpeningSize = new HTuple();
            HTuple hv__EpoxyLenTh = new HTuple(), hv__EpoxyHeiTh = new HTuple();
            HTuple hv_regNum = new HTuple(), hv__ErrEpoxyCode = new HTuple();
            HTuple hv__ErrEpoxyStr = new HTuple();

            HTupleVector hvec_i_DefectValue = new HTupleVector(3);
            HTupleVector hvec__RefHomMatMod2ImgFrame = new HTupleVector(1);
            HTupleVector hvec__InspectEpoxyPara = new HTupleVector(2), hvec__ThreshGrays = new HTupleVector(1);
            HTupleVector hvec__RefValue = new HTupleVector(3), hvec__DefectEpoxyType = new HTupleVector(1);
            HTupleVector hvec__DefectImgIdx = new HTupleVector(1), hvec__DefectValue = new HTupleVector(3);
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_EmptyObject);
            HOperatorSet.GenEmptyObj(out ho__EpoxyInspectReg);
            HOperatorSet.GenEmptyObj(out ho__EpoxyRefReg);
            HOperatorSet.GenEmptyObj(out ho_i_image);
            HOperatorSet.GenEmptyObj(out ho__ExtractEpoxyRegs);
            hvec_o_Epoxys = new HObjectVector(1);
            hvec_o_FailRegs = new HObjectVector(2);
            hvec_o_DefectValue = new HTupleVector(4);
            try
            {
                //**************************************************************************************************
                //---函数：HTV_epoxys_inspect
                //---作用：银胶检测：多epoxys检测
                //---参数：
                //===图标参数
                //  i_Imgs：检测所需图像集合
                //  i_EpoxyObjs：Epoxy检测区域对象
                //  o_Epoxys：检出成功的区域
                //  o_FailRegs：检出失败的区域
                //===控制参数
                //  i_ObjNum：Epoxy数目
                //  i_RefHomMatMod2Img：参考映射矩阵
                //  i_EpoxyInspectParas：Epoxy检测参数
                //  o_DefectTypes：异常区域的缺陷类型
                //  o_ErrCode：错误码
                //  o_ErrStr：错误信息
                //**************************************************************************************************
                //
                //初始化

                hvec_o_DefectTypes = (new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))));
                hvec_o_DefectImgIdx = (new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))));
                hvec_o_RefValue = (new HTupleVector(4).Insert(0, (new HTupleVector(3).Insert(0, (
                    new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))))));
                ho_EmptyObject.Dispose();
                HOperatorSet.GenEmptyObj(out ho_EmptyObject);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hvec_o_FailRegs = dh.Take((
                        dh.Add(new HObjectVector(2)).Insert(0, (dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho_EmptyObject)))))));
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hvec_o_Epoxys = dh.Take((
                        dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho_EmptyObject)))));
                }
                HTuple end_val26 = hv_i_ObjNum - 1;
                HTuple step_val26 = 1;
                for (hv_objIdx = 0; hv_objIdx.Continue(end_val26, step_val26); hv_objIdx = hv_objIdx.TupleAdd(step_val26))
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hvec_o_FailRegs[hv_objIdx] = dh.Take((
                            dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho_EmptyObject)))));
                    }
                    hvec_o_Epoxys[hv_objIdx] = new HObjectVector(ho_EmptyObject.CopyObj(1, -1));
                    hvec_o_DefectTypes[hv_objIdx] = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())));
                    hvec_o_DefectImgIdx[hv_objIdx] = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())));
                }
                hv_o_ErrCode = -2;
                hv_o_ErrStr = "initializing";
                //
                //单个银胶初始化
                hvec_i_DefectValue = (new HTupleVector(3).Insert(0, (new HTupleVector(2).Insert(0, (
                    new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))));
                //
                //输入合法性测试

                //
                //-----------------------------------Inspect-----------------------------------
                //
                HTuple end_val43 = hv_i_ObjNum - 1;
                HTuple step_val43 = 1;
                for (hv_objIdx = 0; hv_objIdx.Continue(end_val43, step_val43); hv_objIdx = hv_objIdx.TupleAdd(step_val43))
                {
                    //
                    //--------获取epoxy检测对象参数
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        //hvec__InspectObj = dh.Take(hvec_i_EpoxyObjs[hv_objIdx]);
                        hvec__InspectObj = hvec_i_EpoxyObjs.At(hv_objIdx).Clone();
                    }
                    //检测区域
                    ho__EpoxyInspectReg.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho__EpoxyInspectReg = hvec__InspectObj[0].O.CopyObj(1, -1);
                    }
                    //参考区域
                    ho__EpoxyRefReg.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho__EpoxyRefReg = hvec__InspectObj[1].O.CopyObj(1, -1);
                    }
                    //
                    //--------获取epoxy检测model参数
                    //epoxy检测使用图层
                    hv__ImageIdx = hvec_i_EpoxyInspectParas[0][0][hv_objIdx][0].T.Clone();
                    //选择epoxy所属区域
                    hv_EpoxyToWhat = hvec_i_EpoxyInspectParas[0][0][hv_objIdx][1].T.Clone();
                    //获取epoxy检测需要的映射矩阵
                    hvec__RefHomMatMod2ImgFrame = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())));
                    HTV_Gen_HomMat_onWhat(hv_EpoxyToWhat, hvec__RefHomMatMod2ImgFrame, hvec_i_RefHomMatMod2Img,
                        out hv__EpoxyHomMat2D, out hv__MatErrCode, out hv__MatErrStr);

                    if ((int)(new HTuple(hv__MatErrCode.TupleLess(0))) != 0)
                    {
                        //参数异常
                        hv_o_ErrCode = hv__MatErrCode.Clone();
                        hv_o_ErrStr = hv__MatErrStr.Clone();
                        ho_EmptyObject.Dispose();
                        ho__EpoxyInspectReg.Dispose();
                        ho__EpoxyRefReg.Dispose();
                        ho_i_image.Dispose();
                        ho__ExtractEpoxyRegs.Dispose();
                        hvec__InspectObj.Dispose();
                        hvec__FailEpoxyRegs.Dispose();

                        return;
                    }
                    //
                    //选择指定图层
                    ho_i_image.Dispose();
                    HOperatorSet.SelectObj(ho_i_Imgs, out ho_i_image, hv__ImageIdx);
                    //
                    //--------获取epoxy检测参数
                    hvec__InspectEpoxyPara = hvec_i_EpoxyInspectParas[1][hv_objIdx];
                    //Epoxy检测参数设置
                    hvec__ThreshGrays = new HTupleVector(1);
                    hv__LightOrDarks = new HTuple();
                    hv__OpeningSizes = new HTuple();
                    hv__EpoxyLenThs = new HTuple();
                    hv__EpoxyHeiThs = new HTuple();
                    HTuple end_val79 = new HTuple(hvec__InspectEpoxyPara.Length) - 1;
                    HTuple step_val79 = 1;
                    for (hv_idx = 0; hv_idx.Continue(end_val79, step_val79); hv_idx = hv_idx.TupleAdd(step_val79))
                    {
                        //
                        hv__ThreshGray = hvec__InspectEpoxyPara[hv_idx][0].T.Clone();
                        hv__LightOrDark = hvec__InspectEpoxyPara[hv_idx][1].T.Clone();
                        hv__OpeningSize = hvec__InspectEpoxyPara[hv_idx][2].T.Clone();
                        hv__EpoxyLenTh = hvec__InspectEpoxyPara[hv_idx][3].T.Clone();
                        hv__EpoxyHeiTh = hvec__InspectEpoxyPara[hv_idx][4].T.Clone();

                        hvec__ThreshGrays[hv_idx] = new HTupleVector(hv__ThreshGray).Clone();
                        hv__LightOrDarks = hv__LightOrDarks.TupleConcat(hv__LightOrDark);
                        hv__OpeningSizes = hv__OpeningSizes.TupleConcat(hv__OpeningSize);
                        hv__EpoxyLenThs = hv__EpoxyLenThs.TupleConcat(hv__EpoxyLenTh);
                        hv__EpoxyHeiThs = hv__EpoxyHeiThs.TupleConcat(hv__EpoxyHeiTh);

                    }
                    //参考设置值
                    HOperatorSet.CountObj(ho__EpoxyInspectReg, out hv_regNum);
                    HTuple end_val96 = hv_regNum - 1;
                    HTuple step_val96 = 1;
                    for (hv_idx = 0; hv_idx.Continue(end_val96, step_val96); hv_idx = hv_idx.TupleAdd(step_val96))
                    {
                        hvec__RefValue[hv_idx][0] = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(hv__EpoxyLenThs.TupleSelect(
                            hv_idx)))));
                        hvec__RefValue[hv_idx][1] = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(hv__EpoxyHeiThs.TupleSelect(
                            hv_idx)))));
                    }
                    //
                    ho__ExtractEpoxyRegs.Dispose(); hvec__FailEpoxyRegs.Dispose();
                    HTV_Epoxy_Inspect_Threshold(ho_i_image, ho__EpoxyInspectReg, ho__EpoxyRefReg,
                        out ho__ExtractEpoxyRegs, out hvec__FailEpoxyRegs, hv__EpoxyHomMat2D,
                        hvec__ThreshGrays, hv__LightOrDarks, hv__OpeningSizes, hv__EpoxyLenThs,
                        hv__EpoxyHeiThs, hvec_i_DefectValue, hv__ImageIdx, out hvec__DefectEpoxyType,
                        out hvec__DefectImgIdx, out hvec__DefectValue, out hv__ErrEpoxyCode,
                        out hv__ErrEpoxyStr);

                    //
                    //整合多epoxy区域检测结果
                    hvec_o_FailRegs[hv_objIdx] = hvec__FailEpoxyRegs.Clone();
                    hvec_o_Epoxys[hv_objIdx] = new HObjectVector(ho__ExtractEpoxyRegs.CopyObj(1, -1));
                    hvec_o_DefectTypes[hv_objIdx] = hvec__DefectEpoxyType.Clone();
                    hvec_o_DefectImgIdx[hv_objIdx] = hvec__DefectImgIdx.Clone();
                    hvec_o_DefectValue[hv_objIdx] = hvec__DefectValue.Clone();
                    hvec_o_RefValue[hv_objIdx] = hvec__RefValue.Clone();
                    //
                }
                //
                hv_o_ErrCode = 0;
                hv_o_ErrStr = "epoxys inspect successful";
                ho_EmptyObject.Dispose();
                ho__EpoxyInspectReg.Dispose();
                ho__EpoxyRefReg.Dispose();
                ho_i_image.Dispose();
                ho__ExtractEpoxyRegs.Dispose();
                hvec__InspectObj.Dispose();
                hvec__FailEpoxyRegs.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_EmptyObject.Dispose();
                ho__EpoxyInspectReg.Dispose();
                ho__EpoxyRefReg.Dispose();
                ho_i_image.Dispose();
                ho__ExtractEpoxyRegs.Dispose();
                hvec__InspectObj.Dispose();
                hvec__FailEpoxyRegs.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public static void HTV_bonds_inspect(HObject ho_i_Imgs, HObjectVector/*{eObjectVector,Dim=2}*/ hvec_i_BondObjs,
            out HObjectVector/*{eObjectVector,Dim=1}*/ hvec_o_BondContours, out HObjectVector/*{eObjectVector,Dim=1}*/ hvec_o_PadRegions,
            out HObjectVector/*{eObjectVector,Dim=2}*/ hvec_o_FailRegs, HTuple hv_i_ObjNum,
            HTupleVector/*{eTupleVector,Dim=1}*/ hvec_i_RefHomMatMod2ImgFrame, HTupleVector/*{eTupleVector,Dim=1}*/ hvec_i_RefHomMatMod2ImgIc,
            HTupleVector/*{eTupleVector,Dim=4}*/ hvec_i_BondInspectParas, out HTupleVector/*{eTupleVector,Dim=1}*/ hvec_o_BallType,
            out HTupleVector/*{eTupleVector,Dim=2}*/ hvec_o_DefectTypes, out HTupleVector/*{eTupleVector,Dim=4}*/ hvec_o_DefectValue,
            out HTupleVector/*{eTupleVector,Dim=2}*/ hvec_o_DefectImgIdx, out HTupleVector/*{eTupleVector,Dim=4}*/ hvec_o_RefValue,
            out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_EmptyObject, ho__InspectReg = null;
            HObject ho__ModelImg = null, ho__BondInspectRegs = null, ho__BondContours = null;
            HObject ho_EmptyObj = null, ho__BondInspectReg = null, ho__BondContour = null;
            HObject ho__FailBondReg = null;

            HObjectVector hvec__InspectObj = new HObjectVector(1);
            HObjectVector hvec__FailBondRegs = new HObjectVector(1);

            // Local control variables 

            HTuple hv_objIdx = null, hv_measuretype = null;
            HTuple hv_matchtype = null, hv_BondOnWhat = new HTuple();
            HTuple hv__BondHomMat2D = new HTuple(), hv__MatErrCode = new HTuple();
            HTuple hv__MatErrStr = new HTuple(), hv_BondInspectMethod = new HTuple();
            HTuple hv_BallType = new HTuple(), hv__measureType = new HTuple();
            HTuple hv__metrologyHandle = new HTuple(), hv__modelType = new HTuple();
            HTuple hv__modelID = new HTuple(), hv_regNum = new HTuple();
            HTuple hv_regidx = new HTuple(), hv__InspectMethod = new HTuple();
            HTuple hv__ImageIdx = new HTuple(), hv__BondSize = new HTuple();
            HTuple hv__ThreshGray = new HTuple(), hv__ClosingSize = new HTuple();
            HTuple hv__BondOverSizeFactor = new HTuple(), hv__BondUnderSizeFactor = new HTuple();
            HTuple hv__DefectTypeReg = new HTuple(), hv__DefectImgIdxReg = new HTuple();
            HTuple hv__ErrRegCode = new HTuple(), hv__ErrRegStr = new HTuple();
            HTuple hv__isPreJudge = new HTuple(), hv__SegRegAreaFactor = new HTuple();
            HTuple hv__ballNum_onReg = new HTuple(), hv__matchMinScore = new HTuple();
            HTuple hv__matchAngleStart = new HTuple(), hv__matchAngleExt = new HTuple();
            HTuple hv__bondSize = new HTuple(), hv__IsBondRegRefine = new HTuple();
            HTuple hv__AddNum = new HTuple(), hv__OverLap = new HTuple();
            HTuple hv__MinHistScore = new HTuple();

            HTupleVector hvec__InspectModel = new HTupleVector(1);
            HTupleVector hvec__BondParas = new HTupleVector(2), hvec__DefectBondImgIdx = new HTupleVector(1);
            HTupleVector hvec__DefectBondType = new HTupleVector(1), hvec__DefectBondValue = new HTupleVector(3);
            HTupleVector hvec__RefBondValue = new HTupleVector(3), hvec__RegInspectParas = new HTupleVector(1);
            HTupleVector hvec__DefectValueReg = new HTupleVector(1), hvec__RefValueReg = new HTupleVector(1);
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_EmptyObject);
            HOperatorSet.GenEmptyObj(out ho__InspectReg);
            HOperatorSet.GenEmptyObj(out ho__ModelImg);
            HOperatorSet.GenEmptyObj(out ho__BondInspectRegs);
            HOperatorSet.GenEmptyObj(out ho__BondContours);
            HOperatorSet.GenEmptyObj(out ho_EmptyObj);
            HOperatorSet.GenEmptyObj(out ho__BondInspectReg);
            HOperatorSet.GenEmptyObj(out ho__BondContour);
            HOperatorSet.GenEmptyObj(out ho__FailBondReg);
            hvec_o_BondContours = new HObjectVector(1);
            hvec_o_PadRegions = new HObjectVector(1);
            hvec_o_FailRegs = new HObjectVector(2);
            try
            {
                //**************************************************************************************************
                //---函数：HTV_bonds_inspect
                //---作用：Bonds检测：1）模板匹配的方式进行检测，2）测量的方式进行检测
                //---参数：
                //===图标参数
                //  i_Imgs：检测所需图像集合
                //  i_BondObjs：bond检测区域对象
                //  o_BondContours：检出成功的区域
                //  o_FailRegs：检出失败的区域
                //===控制参数
                //  i_ObjNum：bond组数目
                //  i_RefHomMatMod2ImgFrame：Frame映射矩阵集合
                //  i_RefHomMatMod2ImgIc：Ic映射矩阵集合
                //  i_BondInspectParas：Bond检测参数
                //  o_DefectTypes：异常区域的缺陷类型
                //  o_DefectImgIdx:输出图像索引号
                //  o_DefectValue:返回检测结果
                //  o_RefValue:返回参考结果
                //  o_ErrCode：错误码
                //  o_ErrStr：错误信息
                //***************************************************************************
                //
                //初始化
                hvec_o_DefectTypes = (new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))));
                hvec_o_DefectImgIdx = (new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))));
                hvec_o_DefectValue = (new HTupleVector(4).Insert(0, (new HTupleVector(3).Insert(0, (
                    new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))))));
                hvec_o_RefValue = (new HTupleVector(4).Insert(0, (new HTupleVector(3).Insert(0, (
                    new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))))));
                ho_EmptyObject.Dispose();
                HOperatorSet.GenEmptyObj(out ho_EmptyObject);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hvec_o_FailRegs = dh.Take((
                        dh.Add(new HObjectVector(2)).Insert(0, (dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho_EmptyObject)))))));
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hvec_o_BondContours = dh.Take((
                        dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho_EmptyObject)))));
                }
                //
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hvec_o_PadRegions = dh.Take((
                        dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho_EmptyObject)))));
                }
                //
                HTuple end_val33 = hv_i_ObjNum - 1;
                HTuple step_val33 = 1;
                for (hv_objIdx = 0; hv_objIdx.Continue(end_val33, step_val33); hv_objIdx = hv_objIdx.TupleAdd(step_val33))
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hvec_o_FailRegs[hv_objIdx] = dh.Take((
                            dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho_EmptyObject)))));
                    }
                    hvec_o_BondContours[hv_objIdx] = new HObjectVector(ho_EmptyObject.CopyObj(1, -1));
                    hvec_o_DefectTypes[hv_objIdx] = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())));
                    hvec_o_DefectImgIdx[hv_objIdx] = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())));
                    hvec_o_DefectValue[hv_objIdx] = (new HTupleVector(3).Insert(0, (new HTupleVector(2).Insert(0, (
                        new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))));
                }
                //
                hvec_o_BallType = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())));
                hv_o_ErrCode = -2;
                hv_o_ErrStr = "initializing";

                //输入合法性测试
                //
                //------------------------------------------Inspect------------------------------
                //
                hv_measuretype = 1;
                hv_matchtype = 1;
                //
                HTuple end_val52 = hv_i_ObjNum - 1;
                HTuple step_val52 = 1;
                for (hv_objIdx = 0; hv_objIdx.Continue(end_val52, step_val52); hv_objIdx = hv_objIdx.TupleAdd(step_val52))
                {
                    //--------获取bond检测对象参数
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        //hvec__InspectObj = dh.Take(hvec_i_BondObjs[hv_objIdx]);
                        hvec__InspectObj = hvec_i_BondObjs.At(hv_objIdx).Clone();
                    }
                    //检测区域
                    ho__InspectReg.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho__InspectReg = hvec__InspectObj[0].O.CopyObj(1, -1);
                    }
                    //-------获取bond检测model参数
                    hvec__InspectModel = hvec_i_BondInspectParas[0][0][hv_objIdx];
                    //选择bond所属区域
                    hv_BondOnWhat = hvec__InspectModel[0].T.Clone();
                    //获取bond检测需要的映射矩阵
                    HTV_Gen_HomMat_onWhat(hv_BondOnWhat, hvec_i_RefHomMatMod2ImgFrame, hvec_i_RefHomMatMod2ImgIc,
                        out hv__BondHomMat2D, out hv__MatErrCode, out hv__MatErrStr);
                    if ((int)(new HTuple(hv__MatErrCode.TupleLess(0))) != 0)
                    {
                        //参数异常
                        hv_o_ErrCode = hv__MatErrCode.Clone();
                        hv_o_ErrStr = hv__MatErrStr.Clone();
                        ho_EmptyObject.Dispose();
                        ho__InspectReg.Dispose();
                        ho__ModelImg.Dispose();
                        ho__BondInspectRegs.Dispose();
                        ho__BondContours.Dispose();
                        ho_EmptyObj.Dispose();
                        ho__BondInspectReg.Dispose();
                        ho__BondContour.Dispose();
                        ho__FailBondReg.Dispose();
                        hvec__InspectObj.Dispose();
                        hvec__FailBondRegs.Dispose();

                        return;
                    }
                    //
                    //获取bond模板类型：0-match;1-measure
                    hv_BondInspectMethod = hvec__InspectModel[1].T.Clone();
                    //输出类型带入Wire检测
                    if ((int)(new HTuple(hv_BondInspectMethod.TupleEqual(1))) != 0)
                    {
                        //
                        hv_BallType = "BondMeasure" + hv_measuretype;
                        hv_measuretype = hv_measuretype + 1;
                        //
                        //获取检测测量模板参数
                        hv__measureType = hvec__InspectModel[2].T.Clone();
                        hv__metrologyHandle = hvec__InspectModel[3].T.Clone();
                    }
                    else
                    {
                        //
                        hv_BallType = "BondMatch" + hv_matchtype;
                        hv_matchtype = hv_matchtype + 1;
                        //获取检测匹配模板参数
                        //模板旋正图像
                        ho__ModelImg.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho__ModelImg = hvec__InspectObj[1].O.CopyObj(1, -1);
                        }
                        //
                        hv__modelType = hvec__InspectModel[2].T.Clone();
                        hv__modelID = hvec__InspectModel[3].T.Clone();

                    }
                    //-----获取Bond检测参数
                    hvec__BondParas = hvec_i_BondInspectParas[1][hv_objIdx];
                    //
                    //*******************************************检测区域内选择合适方法进行检测*************************************
                    //获取焊点映射后的检测区域
                    ho__BondInspectRegs.Dispose();
                    HOperatorSet.AffineTransRegion(ho__InspectReg, out ho__BondInspectRegs, hv__BondHomMat2D,
                        "nearest_neighbor");
                    HOperatorSet.CountObj(ho__BondInspectRegs, out hv_regNum);
                    //
                    //初始化Bond检测输出
                    hvec__DefectBondImgIdx = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())));
                    hvec__DefectBondType = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())));
                    hvec__DefectBondValue = (new HTupleVector(3).Insert(0, (new HTupleVector(2).Insert(0, (
                        new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))));
                    hvec__RefBondValue = (new HTupleVector(3).Insert(0, (new HTupleVector(2).Insert(0, (
                        new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))));
                    //
                    ho__BondContours.Dispose();
                    HOperatorSet.GenEmptyObj(out ho__BondContours);
                    //
                    ho_EmptyObj.Dispose();
                    HOperatorSet.GenEmptyObj(out ho_EmptyObj);
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hvec__FailBondRegs = dh.Take((
                            dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho_EmptyObj)))));
                    }
                    //
                    HTuple end_val112 = hv_regNum - 1;
                    HTuple step_val112 = 1;
                    for (hv_regidx = 0; hv_regidx.Continue(end_val112, step_val112); hv_regidx = hv_regidx.TupleAdd(step_val112))
                    {
                        ho__BondInspectReg.Dispose();
                        HOperatorSet.SelectObj(ho__BondInspectRegs, out ho__BondInspectReg, hv_regidx + 1);
                        //获取区域内检测参数
                        hvec__RegInspectParas = hvec__BondParas[hv_regidx];
                        //获取bond检测区域内检测方法:0-threshold,1-measure,2-match
                        hv__InspectMethod = hvec__RegInspectParas[0].T.Clone();
                        //
                        switch (hv__InspectMethod.I)
                        {
                            case 0:
                                //----阈值分割参数获取
                                hv__ImageIdx = hvec__RegInspectParas[1].T.Clone();
                                hv__BondSize = hvec__RegInspectParas[2].T.Clone();
                                hv__ThreshGray = hvec__RegInspectParas[3].T.Clone();
                                hv__ClosingSize = hvec__RegInspectParas[4].T.Clone();
                                hv__BondOverSizeFactor = hvec__RegInspectParas[5].T.Clone();
                                hv__BondUnderSizeFactor = hvec__RegInspectParas[6].T.Clone();
                                //
                                ho__BondContour.Dispose(); ho__FailBondReg.Dispose();
                                HTV_Bond_Inspect_threshold(ho_i_Imgs, ho__BondInspectReg, out ho__BondContour,
                                    out ho__FailBondReg, hv__ImageIdx, hv__BondSize, hv__ThreshGray,
                                    hv__ClosingSize, hv__BondOverSizeFactor, hv__BondUnderSizeFactor,
                                    out hv__DefectTypeReg, out hv__DefectImgIdxReg, out hvec__DefectValueReg,
                                    out hvec__RefValueReg, out hv__ErrRegCode, out hv__ErrRegStr);
                                //
                                break;
                            case 1:
                                //---测量模板参数获取
                                hv__ImageIdx = hvec__RegInspectParas[1].T.Clone();
                                hv__BondOverSizeFactor = hvec__RegInspectParas[2].T.Clone();
                                hv__BondUnderSizeFactor = hvec__RegInspectParas[3].T.Clone();
                                hv__isPreJudge = hvec__RegInspectParas[4].T.Clone();
                                hv__ThreshGray = hvec__RegInspectParas[5].T.Clone();
                                hv__SegRegAreaFactor = hvec__RegInspectParas[6].T.Clone();
                                //
                                //开始检测
                                ho__BondContour.Dispose(); ho__FailBondReg.Dispose();
                                HTV_Bond_Inspect_measure(ho_i_Imgs, ho__BondInspectReg, out ho__BondContour,
                                    out ho__FailBondReg, hv__BondHomMat2D, hv_regidx, hv__ImageIdx, hv__measureType,
                                    hv__metrologyHandle, hv__BondOverSizeFactor, hv__BondUnderSizeFactor,
                                    hv__isPreJudge, hv__ThreshGray, hv__SegRegAreaFactor, out hv__DefectTypeReg,
                                    out hv__DefectImgIdxReg, out hvec__DefectValueReg, out hvec__RefValueReg,
                                    out hv__ErrRegCode, out hv__ErrRegStr);
                                //

                                break;
                            case 2:
                                //---匹配模板参数获取
                                hv__ImageIdx = hvec__RegInspectParas[1].T.Clone();
                                hv__ballNum_onReg = hvec__RegInspectParas[2].T.Clone();
                                hv__matchMinScore = hvec__RegInspectParas[3].T.Clone();
                                hv__matchAngleStart = hvec__RegInspectParas[4].T.Clone();
                                hv__matchAngleExt = hvec__RegInspectParas[5].T.Clone();
                                hv__bondSize = hvec__RegInspectParas[6].T.Clone();
                                hv__IsBondRegRefine = hvec__RegInspectParas[7].T.Clone();
                                hv__AddNum = hvec__RegInspectParas[8].T.Clone();
                                hv__OverLap = hvec__RegInspectParas[9].T.Clone();
                                hv__MinHistScore = hvec__RegInspectParas[10].T.Clone();
                                //
                                //开始检测
                                ho__BondContour.Dispose(); ho__FailBondReg.Dispose();
                                HTV_Bond_Inspect_model(ho_i_Imgs, ho__ModelImg, ho__BondInspectReg, out ho__BondContour,
                                    out ho__FailBondReg, hv__ImageIdx, hv__ballNum_onReg, hv__modelType,
                                    hv__modelID, hv__matchMinScore, hv__matchAngleStart, hv__matchAngleExt,
                                    hv__bondSize, hv__IsBondRegRefine, hv__AddNum, hv__OverLap, hv__MinHistScore,
                                    out hv__DefectTypeReg, out hv__DefectImgIdxReg, out hvec__DefectValueReg,
                                    out hvec__RefValueReg, out hv__ErrRegCode, out hv__ErrRegStr);
                                break;
                        }
                        //整合区域检测结果
                        //
                        hvec__DefectBondType[hv_regidx] = new HTupleVector(hv__DefectTypeReg).Clone();
                        hvec__DefectBondImgIdx[hv_regidx] = new HTupleVector(hv__DefectImgIdxReg).Clone();
                        hvec__DefectBondValue[hv_regidx] = (new HTupleVector(2).Insert(0, hvec__DefectValueReg));
                        hvec__RefBondValue[hv_regidx] = (new HTupleVector(2).Insert(0, hvec__RefValueReg));
                        //
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(ho__BondContours, ho__BondContour, out ExpTmpOutVar_0
                                );
                            ho__BondContours.Dispose();
                            ho__BondContours = ExpTmpOutVar_0;
                        }
                        hvec__FailBondRegs[hv_regidx] = new HObjectVector(ho__FailBondReg.CopyObj(1, -1));

                    }
                    //
                    //整合多bond区域检测结果
                    hvec_o_FailRegs[hv_objIdx] = hvec__FailBondRegs.Clone();
                    hvec_o_BondContours[hv_objIdx] = new HObjectVector(ho__BondContours.CopyObj(1, -1));
                    //输出检测区域作为Aroundbond周围检测参考焊盘区域
                    hvec_o_PadRegions[hv_objIdx] = new HObjectVector(ho__BondInspectRegs.CopyObj(1, -1));
                    //
                    //
                    hvec_o_DefectTypes[hv_objIdx] = hvec__DefectBondType.Clone();
                    hvec_o_DefectValue[hv_objIdx] = hvec__DefectBondValue.Clone();
                    hvec_o_DefectImgIdx[hv_objIdx] = hvec__DefectBondImgIdx.Clone();
                    hvec_o_RefValue[hv_objIdx] = hvec__RefBondValue.Clone();
                    //焊点类型与所在位置
                    hvec_o_BallType[hv_objIdx] = new HTupleVector(hv_BallType.TupleConcat(hv_BondOnWhat));

                }
                //
                hv_o_ErrCode = 0;
                hv_o_ErrStr = "bonds inspect successful";
                ho_EmptyObject.Dispose();
                ho__InspectReg.Dispose();
                ho__ModelImg.Dispose();
                ho__BondInspectRegs.Dispose();
                ho__BondContours.Dispose();
                ho_EmptyObj.Dispose();
                ho__BondInspectReg.Dispose();
                ho__BondContour.Dispose();
                ho__FailBondReg.Dispose();
                hvec__InspectObj.Dispose();
                hvec__FailBondRegs.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_EmptyObject.Dispose();
                ho__InspectReg.Dispose();
                ho__ModelImg.Dispose();
                ho__BondInspectRegs.Dispose();
                ho__BondContours.Dispose();
                ho_EmptyObj.Dispose();
                ho__BondInspectReg.Dispose();
                ho__BondContour.Dispose();
                ho__FailBondReg.Dispose();
                hvec__InspectObj.Dispose();
                hvec__FailBondRegs.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public static void HTV_wires_inspect(HObject ho_i_Imgs, HObjectVector/*{eObjectVector,Dim=2}*/ hvec_i_WireObjs,
            HObjectVector/*{eObjectVector,Dim=1}*/ hvec_i_RealBalls, out HObjectVector/*{eObjectVector,Dim=1}*/ hvec_o_Wires,
            out HObjectVector/*{eObjectVector,Dim=2}*/ hvec_o_FailRegs, HTuple hv_i_ObjNum,
            HTupleVector/*{eTupleVector,Dim=1}*/ hvec_i_RefHomMatMod2ImgFrame, HTupleVector/*{eTupleVector,Dim=1}*/ hvec_i_RefHomMatMod2ImgIc,
            HTupleVector/*{eTupleVector,Dim=4}*/ hvec_i_WireInspectParas, HTupleVector/*{eTupleVector,Dim=1}*/ hvec_i_BallType,
            out HTupleVector/*{eTupleVector,Dim=2}*/ hvec_o_DefectTypes, out HTupleVector/*{eTupleVector,Dim=4}*/ hvec_o_DefectValue,
            out HTupleVector/*{eTupleVector,Dim=2}*/ hvec_o_DefectImgIdx, out HTupleVector/*{eTupleVector,Dim=4}*/ hvec_o_RefValue,
            out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_EmptyObject, ho_realStartBall = null;
            HObject ho_tmp_realStartBall = null, ho_realStopBall = null;
            HObject ho_tmp_realStopBall = null, ho__StartRegs = null, ho__StopRegs = null;
            HObject ho_realStartBall_sort = null, ho_realStopBall_sort = null;
            HObject ho_tmp_reg = null, ho_virtualStartBall1 = null, ho_virtualStopBall1 = null;
            HObject ho_virtualStartBall2 = null, ho_virtualStopBall2 = null;
            HObject ho_virtualStartBall3 = null, ho_virtualStopBall3 = null;
            HObject ho__LineStartRegs = null, ho__LineStopRegs = null, ho__tmp_reg_aff = null;
            HObject ho_tmpvirtualStartreg = null, ho_tmprealStartReg = null;
            HObject ho_tmpvirtualStopreg = null, ho_tmprealStopReg = null;
            HObject ho__InspectRegs = null, ho__Wires = null;

            HObjectVector hvec__InspectObj = new HObjectVector(1);
            HObjectVector hvec__FailWireRegs = new HObjectVector(1);

            // Local control variables 

            HTuple hv_objIdx = null, hv_Number_start_group = null;
            HTuple hv_Number_stop_group = null, hv__IsUseStartReg = new HTuple();
            HTuple hv_StartRegBelongToWhat = new HTuple(), hv_StartRegOnWhat = new HTuple();
            HTuple hv__StartHomMat2D = new HTuple(), hv__MatErrCode = new HTuple();
            HTuple hv__MatErrStr = new HTuple(), hv_ii = new HTuple();
            HTuple hv_idxLen = new HTuple(), hv_idx = new HTuple();
            HTuple hv_realBallType = new HTuple(), hv_tmp_num = new HTuple();
            HTuple hv__IsUseStopReg = new HTuple(), hv_StopRegBelongToWhat = new HTuple();
            HTuple hv_StopRegOnWhat = new HTuple(), hv__StopHomMat2D = new HTuple();
            HTuple hv_wireNumber = new HTuple(), hv_wireidx = new HTuple();
            HTuple hv_Startreg_index_after_sort = new HTuple(), hv_Stopreg_index_after_sort = new HTuple();
            HTuple hv_Startreg_need_sort = new HTuple(), hv_Stopreg_need_sort = new HTuple();
            HTuple hv_start_regnum = new HTuple(), hv_sort_num = new HTuple();
            HTuple hv_ind = new HTuple(), hv_tmp_ind = new HTuple();
            HTuple hv_stop_regnum = new HTuple(), hv_HomMatStartFlag = new HTuple();
            HTuple hv_HomMatSum = new HTuple(), hv_HomMatStopFlag = new HTuple();
            HTuple hv_start_num = new HTuple(), hv_i = new HTuple();
            HTuple hv_i_index = new HTuple(), hv_first_ind = new HTuple();
            HTuple hv_j = new HTuple(), hv_end_ind = new HTuple();
            HTuple hv__StartHomMat2D_tmp = new HTuple(), hv_new_j = new HTuple();
            HTuple hv_StartRegArea = new HTuple(), hv_Row = new HTuple();
            HTuple hv_Column = new HTuple(), hv_stop_num = new HTuple();
            HTuple hv__StopHomMat2D_tmp = new HTuple(), hv_StopRegArea = new HTuple();
            HTuple hv__InspectRegNum = new HTuple(), hv__ErrInspectCode = new HTuple();
            HTuple hv__ErrInspectStr = new HTuple();

            HTupleVector hvec_HomMatMod2_start_group = new HTupleVector(1);
            HTupleVector hvec_HomMatMod2_stop_group = new HTupleVector(1);
            HTupleVector hvec__InspectModel = new HTupleVector(1), hvec_i_DefectValueWire = new HTupleVector(3);
            HTupleVector hvec__WireInspect_Paras = new HTupleVector(2), hvec__DefectWireType = new HTupleVector(1);
            HTupleVector hvec__DefectWireImgIdx = new HTupleVector(1), hvec__DefectValueWire = new HTupleVector(3);
            HTupleVector hvec__RefValueWire = new HTupleVector(3);
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_EmptyObject);
            HOperatorSet.GenEmptyObj(out ho_realStartBall);
            HOperatorSet.GenEmptyObj(out ho_tmp_realStartBall);
            HOperatorSet.GenEmptyObj(out ho_realStopBall);
            HOperatorSet.GenEmptyObj(out ho_tmp_realStopBall);
            HOperatorSet.GenEmptyObj(out ho__StartRegs);
            HOperatorSet.GenEmptyObj(out ho__StopRegs);
            HOperatorSet.GenEmptyObj(out ho_realStartBall_sort);
            HOperatorSet.GenEmptyObj(out ho_realStopBall_sort);
            HOperatorSet.GenEmptyObj(out ho_tmp_reg);
            HOperatorSet.GenEmptyObj(out ho_virtualStartBall1);
            HOperatorSet.GenEmptyObj(out ho_virtualStopBall1);
            HOperatorSet.GenEmptyObj(out ho_virtualStartBall2);
            HOperatorSet.GenEmptyObj(out ho_virtualStopBall2);
            HOperatorSet.GenEmptyObj(out ho_virtualStartBall3);
            HOperatorSet.GenEmptyObj(out ho_virtualStopBall3);
            HOperatorSet.GenEmptyObj(out ho__LineStartRegs);
            HOperatorSet.GenEmptyObj(out ho__LineStopRegs);
            HOperatorSet.GenEmptyObj(out ho__tmp_reg_aff);
            HOperatorSet.GenEmptyObj(out ho_tmpvirtualStartreg);
            HOperatorSet.GenEmptyObj(out ho_tmprealStartReg);
            HOperatorSet.GenEmptyObj(out ho_tmpvirtualStopreg);
            HOperatorSet.GenEmptyObj(out ho_tmprealStopReg);
            HOperatorSet.GenEmptyObj(out ho__InspectRegs);
            HOperatorSet.GenEmptyObj(out ho__Wires);
            hvec_o_Wires = new HObjectVector(1);
            hvec_o_FailRegs = new HObjectVector(2);
            hvec_o_DefectValue = new HTupleVector(4);
            try
            {
                //**************************************************************************************************
                //---函数：HTV_wires_inspect
                //---作用：wires检测：1）line_guass方式进行检测，2）threshold的方式进行检测
                //---参数：
                //===图标参数
                //  i_Imgs：检测所需图像集合
                //  i_WireObjs：wire检测区域对象
                //  o_Wires：检出成功的区域
                //  o_FailRegs：检出失败的区域
                //===控制参数
                //  i_ObjNum：bond组数目
                //  i_RefHomMatMod2ImgFrame：Frame映射矩阵集合
                //  i_RefHomMatMod2ImgIc：Ic映射矩阵集合
                //  i_WireInspectParas：Bond检测参数
                //  o_DefectTypes：异常区域的缺陷类型
                //  o_ErrCode：错误码
                //  o_ErrStr：错误信息
                //***************************************************************************
                //
                //初始化
                hvec_o_DefectTypes = (new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))));
                hvec_o_DefectImgIdx = (new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))));
                hvec_o_RefValue = (new HTupleVector(4).Insert(0, (new HTupleVector(3).Insert(0, (
                    new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))))));
                ho_EmptyObject.Dispose();
                HOperatorSet.GenEmptyObj(out ho_EmptyObject);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hvec_o_FailRegs = dh.Take((
                        dh.Add(new HObjectVector(2)).Insert(0, (dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho_EmptyObject)))))));
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hvec_o_Wires = dh.Take((
                        dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho_EmptyObject)))));
                }
                HTuple end_val26 = hv_i_ObjNum - 1;
                HTuple step_val26 = 1;
                for (hv_objIdx = 0; hv_objIdx.Continue(end_val26, step_val26); hv_objIdx = hv_objIdx.TupleAdd(step_val26))
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hvec_o_FailRegs[hv_objIdx] = dh.Take((
                            dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho_EmptyObject)))));
                    }
                    hvec_o_Wires[hv_objIdx] = new HObjectVector(ho_EmptyObject.CopyObj(1, -1));
                    hvec_o_DefectTypes[hv_objIdx] = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())));
                    hvec_o_DefectImgIdx[hv_objIdx] = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())));
                    hvec_o_DefectValue[hv_objIdx] = (new HTupleVector(3).Insert(0, (new HTupleVector(2).Insert(0, (
                        new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))));
                }
                hv_o_ErrCode = -2;
                hv_o_ErrStr = "initializing";
                //输入合法性测试

                HOperatorSet.SetSystem("clip_region", "false");
                //
                //------------------------------------------Inspect------------------------------
                //
                //1104
                hvec_HomMatMod2_start_group = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())));
                hvec_HomMatMod2_stop_group = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())));
                hv_Number_start_group = new HTuple();
                hv_Number_stop_group = new HTuple();

                HTuple end_val47 = hv_i_ObjNum - 1;
                HTuple step_val47 = 1;
                for (hv_objIdx = 0; hv_objIdx.Continue(end_val47, step_val47); hv_objIdx = hv_objIdx.TupleAdd(step_val47))
                {
                    //
                    hv_Number_start_group = new HTuple();
                    hv_Number_stop_group = new HTuple();
                    //-------获取wire检测model参数
                    hvec__InspectModel = hvec_i_WireInspectParas[0][0][hv_objIdx];
                    //
                    //获取金线检测所需图层
                    //_ImageIdx := _InspectModel.at(0)
                    //******************************************************************************
                    //获取金线起始焊点、是否启用虚拟焊点：1-启用，使用虚拟焊点；0-不启用，使用真实焊点
                    hv__IsUseStartReg = hvec__InspectModel[0].T[0];
                    if ((int)(hv__IsUseStartReg) != 0)
                    {
                        //-------使用虚拟焊点
                        //获取起始焊点归属区域并获取其映射矩阵：Frame*,IC*
                        hv_StartRegBelongToWhat = hvec__InspectModel[1].T.Clone();
                        hv_StartRegOnWhat = hv_StartRegBelongToWhat.Clone();
                        //
                        //1104
                        if ((int)(new HTuple((new HTuple(hv_StartRegBelongToWhat.TupleLength())).TupleNotEqual(
                            1))) != 0)
                        {
                            hv_o_ErrCode = -1;
                            hv_o_ErrStr = "start region with err info";
                            ho_EmptyObject.Dispose();
                            ho_realStartBall.Dispose();
                            ho_tmp_realStartBall.Dispose();
                            ho_realStopBall.Dispose();
                            ho_tmp_realStopBall.Dispose();
                            ho__StartRegs.Dispose();
                            ho__StopRegs.Dispose();
                            ho_realStartBall_sort.Dispose();
                            ho_realStopBall_sort.Dispose();
                            ho_tmp_reg.Dispose();
                            ho_virtualStartBall1.Dispose();
                            ho_virtualStopBall1.Dispose();
                            ho_virtualStartBall2.Dispose();
                            ho_virtualStopBall2.Dispose();
                            ho_virtualStartBall3.Dispose();
                            ho_virtualStopBall3.Dispose();
                            ho__LineStartRegs.Dispose();
                            ho__LineStopRegs.Dispose();
                            ho__tmp_reg_aff.Dispose();
                            ho_tmpvirtualStartreg.Dispose();
                            ho_tmprealStartReg.Dispose();
                            ho_tmpvirtualStopreg.Dispose();
                            ho_tmprealStopReg.Dispose();
                            ho__InspectRegs.Dispose();
                            ho__Wires.Dispose();
                            hvec__InspectObj.Dispose();
                            hvec__FailWireRegs.Dispose();

                            return;
                        }
                        HTV_Gen_HomMat_onWhat(hv_StartRegOnWhat, hvec_i_RefHomMatMod2ImgFrame,
                            hvec_i_RefHomMatMod2ImgIc, out hv__StartHomMat2D, out hv__MatErrCode,
                            out hv__MatErrStr);

                        hvec_HomMatMod2_start_group[0] = new HTupleVector(hv__StartHomMat2D).Clone();

                        //置空真实焊点
                        ho_realStartBall.Dispose();
                        HOperatorSet.GenEmptyObj(out ho_realStartBall);
                    }
                    else
                    {
                        //
                        ho_realStartBall.Dispose();
                        HOperatorSet.GenEmptyObj(out ho_realStartBall);
                        //--------使用真实焊点
                        //获取起始焊点归属的真实焊点类：BondMatch*,BondMeasure*，并获取虚拟焊点的映射矩阵
                        hv_StartRegBelongToWhat = hvec__InspectModel[1].T.Clone();

                        //1104 lht
                        for (hv_ii = 0; (int)hv_ii <= (int)((new HTuple(hv_StartRegBelongToWhat.TupleLength()
                            )) - 1); hv_ii = (int)hv_ii + 1)
                        {
                            //真实焊点类数
                            hv_idxLen = new HTuple(hvec_i_BallType.Length);
                            HTuple end_val88 = hv_idxLen - 1;
                            HTuple step_val88 = 1;
                            for (hv_idx = 0; hv_idx.Continue(end_val88, step_val88); hv_idx = hv_idx.TupleAdd(step_val88))
                            {
                                //
                                hv_realBallType = hvec_i_BallType[hv_idx].T[0];
                                if ((int)(new HTuple(hv_realBallType.TupleEqual(hv_StartRegBelongToWhat.TupleSelect(
                                    hv_ii)))) != 0)
                                {

                                    hv_StartRegOnWhat = hvec_i_BallType[hv_idx].T[1];
                                    HTV_Gen_HomMat_onWhat(hv_StartRegOnWhat, hvec_i_RefHomMatMod2ImgFrame,
                                        hvec_i_RefHomMatMod2ImgIc, out hv__StartHomMat2D, out hv__MatErrCode,
                                        out hv__MatErrStr);
                                    hvec_HomMatMod2_start_group[hv_ii] = new HTupleVector(hv__StartHomMat2D).Clone();

                                    ho_tmp_realStartBall.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        ho_tmp_realStartBall = hvec_i_RealBalls[hv_idx].O.CopyObj(1, -1);
                                    }
                                    HOperatorSet.CountObj(ho_tmp_realStartBall, out hv_tmp_num);
                                    if (hv_Number_start_group == null)
                                        hv_Number_start_group = new HTuple();
                                    hv_Number_start_group[hv_ii] = hv_tmp_num;
                                    {
                                        HObject ExpTmpOutVar_0;
                                        HOperatorSet.ConcatObj(ho_realStartBall, ho_tmp_realStartBall, out ExpTmpOutVar_0
                                            );
                                        ho_realStartBall.Dispose();
                                        ho_realStartBall = ExpTmpOutVar_0;
                                    }
                                    break;
                                }
                            }
                        }
                    }
                    //*参数异常
                    if ((int)(new HTuple(hv__MatErrCode.TupleLess(0))) != 0)
                    {
                        hv_o_ErrCode = hv__MatErrCode.Clone();
                        hv_o_ErrStr = hv__MatErrStr.Clone();
                        ho_EmptyObject.Dispose();
                        ho_realStartBall.Dispose();
                        ho_tmp_realStartBall.Dispose();
                        ho_realStopBall.Dispose();
                        ho_tmp_realStopBall.Dispose();
                        ho__StartRegs.Dispose();
                        ho__StopRegs.Dispose();
                        ho_realStartBall_sort.Dispose();
                        ho_realStopBall_sort.Dispose();
                        ho_tmp_reg.Dispose();
                        ho_virtualStartBall1.Dispose();
                        ho_virtualStopBall1.Dispose();
                        ho_virtualStartBall2.Dispose();
                        ho_virtualStopBall2.Dispose();
                        ho_virtualStartBall3.Dispose();
                        ho_virtualStopBall3.Dispose();
                        ho__LineStartRegs.Dispose();
                        ho__LineStopRegs.Dispose();
                        ho__tmp_reg_aff.Dispose();
                        ho_tmpvirtualStartreg.Dispose();
                        ho_tmprealStartReg.Dispose();
                        ho_tmpvirtualStopreg.Dispose();
                        ho_tmprealStopReg.Dispose();
                        ho__InspectRegs.Dispose();
                        ho__Wires.Dispose();
                        hvec__InspectObj.Dispose();
                        hvec__FailWireRegs.Dispose();

                        return;
                    }
                    //************************************************************************************
                    //获取金线结束焊点是否启用虚拟焊点：1-启用，使用虚拟焊点；0-不启用，使用真实焊点
                    hv__IsUseStopReg = hvec__InspectModel[0].T[1];
                    if ((int)(hv__IsUseStopReg) != 0)
                    {
                        //---------------使用虚拟焊点
                        //获取结束点归属区域：Frame*,IC*，并获取其映射矩阵
                        hv_StopRegBelongToWhat = hvec__InspectModel[2].T.Clone();
                        hv_StopRegOnWhat = hv_StopRegBelongToWhat.Clone();
                        //1104
                        if ((int)(new HTuple((new HTuple(hv_StopRegBelongToWhat.TupleLength())).TupleNotEqual(
                            1))) != 0)
                        {
                            hv_o_ErrCode = -1;
                            hv_o_ErrStr = "stop region with err info";
                            ho_EmptyObject.Dispose();
                            ho_realStartBall.Dispose();
                            ho_tmp_realStartBall.Dispose();
                            ho_realStopBall.Dispose();
                            ho_tmp_realStopBall.Dispose();
                            ho__StartRegs.Dispose();
                            ho__StopRegs.Dispose();
                            ho_realStartBall_sort.Dispose();
                            ho_realStopBall_sort.Dispose();
                            ho_tmp_reg.Dispose();
                            ho_virtualStartBall1.Dispose();
                            ho_virtualStopBall1.Dispose();
                            ho_virtualStartBall2.Dispose();
                            ho_virtualStopBall2.Dispose();
                            ho_virtualStartBall3.Dispose();
                            ho_virtualStopBall3.Dispose();
                            ho__LineStartRegs.Dispose();
                            ho__LineStopRegs.Dispose();
                            ho__tmp_reg_aff.Dispose();
                            ho_tmpvirtualStartreg.Dispose();
                            ho_tmprealStartReg.Dispose();
                            ho_tmpvirtualStopreg.Dispose();
                            ho_tmprealStopReg.Dispose();
                            ho__InspectRegs.Dispose();
                            ho__Wires.Dispose();
                            hvec__InspectObj.Dispose();
                            hvec__FailWireRegs.Dispose();

                            return;
                        }
                        HTV_Gen_HomMat_onWhat(hv_StopRegOnWhat, hvec_i_RefHomMatMod2ImgFrame, hvec_i_RefHomMatMod2ImgIc,
                            out hv__StopHomMat2D, out hv__MatErrCode, out hv__MatErrStr);

                        hvec_HomMatMod2_stop_group[0] = new HTupleVector(hv__StopHomMat2D).Clone();

                        //置空结束焊点区域
                        ho_realStopBall.Dispose();
                        HOperatorSet.GenEmptyObj(out ho_realStopBall);
                        //
                    }
                    else
                    {
                        //
                        ho_realStopBall.Dispose();
                        HOperatorSet.GenEmptyObj(out ho_realStopBall);
                        //---------------使用真实焊点
                        //获取结束焊点归属的真实焊点类：BondMatch*,BondMeasure*，并获取虚拟焊点的映射矩阵
                        hv_StopRegBelongToWhat = hvec__InspectModel[2].T.Clone();

                        //1104 lht
                        for (hv_ii = 0; (int)hv_ii <= (int)((new HTuple(hv_StopRegBelongToWhat.TupleLength()
                            )) - 1); hv_ii = (int)hv_ii + 1)
                        {

                            //真实焊点类数
                            hv_idxLen = new HTuple(hvec_i_BallType.Length);
                            HTuple end_val145 = hv_idxLen - 1;
                            HTuple step_val145 = 1;
                            for (hv_idx = 0; hv_idx.Continue(end_val145, step_val145); hv_idx = hv_idx.TupleAdd(step_val145))
                            {
                                //
                                hv_realBallType = hvec_i_BallType[hv_idx].T[0];
                                if ((int)(new HTuple(hv_realBallType.TupleEqual(hv_StopRegBelongToWhat.TupleSelect(
                                    hv_ii)))) != 0)
                                {

                                    hv_StopRegOnWhat = hvec_i_BallType[hv_idx].T[1];
                                    HTV_Gen_HomMat_onWhat(hv_StopRegOnWhat, hvec_i_RefHomMatMod2ImgFrame,
                                        hvec_i_RefHomMatMod2ImgIc, out hv__StopHomMat2D, out hv__MatErrCode,
                                        out hv__MatErrStr);
                                    hvec_HomMatMod2_stop_group[hv_ii] = new HTupleVector(hv__StopHomMat2D).Clone();

                                    ho_tmp_realStopBall.Dispose();
                                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                    {
                                        ho_tmp_realStopBall = hvec_i_RealBalls[hv_idx].O.CopyObj(1, -1);
                                    }
                                    HOperatorSet.CountObj(ho_tmp_realStopBall, out hv_tmp_num);
                                    if (hv_Number_stop_group == null)
                                        hv_Number_stop_group = new HTuple();
                                    hv_Number_stop_group[hv_ii] = hv_tmp_num;
                                    {
                                        HObject ExpTmpOutVar_0;
                                        HOperatorSet.ConcatObj(ho_realStopBall, ho_tmp_realStopBall, out ExpTmpOutVar_0
                                            );
                                        ho_realStopBall.Dispose();
                                        ho_realStopBall = ExpTmpOutVar_0;
                                    }
                                    break;
                                }
                            }
                        }
                    }
                    //参数异常处理
                    if ((int)(new HTuple(hv__MatErrCode.TupleLess(0))) != 0)
                    {
                        hv_o_ErrCode = hv__MatErrCode.Clone();
                        hv_o_ErrStr = hv__MatErrStr.Clone();
                        ho_EmptyObject.Dispose();
                        ho_realStartBall.Dispose();
                        ho_tmp_realStartBall.Dispose();
                        ho_realStopBall.Dispose();
                        ho_tmp_realStopBall.Dispose();
                        ho__StartRegs.Dispose();
                        ho__StopRegs.Dispose();
                        ho_realStartBall_sort.Dispose();
                        ho_realStopBall_sort.Dispose();
                        ho_tmp_reg.Dispose();
                        ho_virtualStartBall1.Dispose();
                        ho_virtualStopBall1.Dispose();
                        ho_virtualStartBall2.Dispose();
                        ho_virtualStopBall2.Dispose();
                        ho_virtualStartBall3.Dispose();
                        ho_virtualStopBall3.Dispose();
                        ho__LineStartRegs.Dispose();
                        ho__LineStopRegs.Dispose();
                        ho__tmp_reg_aff.Dispose();
                        ho_tmpvirtualStartreg.Dispose();
                        ho_tmprealStartReg.Dispose();
                        ho_tmpvirtualStopreg.Dispose();
                        ho_tmprealStopReg.Dispose();
                        ho__InspectRegs.Dispose();
                        ho__Wires.Dispose();
                        hvec__InspectObj.Dispose();
                        hvec__FailWireRegs.Dispose();

                        return;
                    }

                    //*********************************************************************************
                    //------------获取wire检测对象参数
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        //hvec__InspectObj = dh.Take(hvec_i_WireObjs[hv_objIdx]);
                        hvec__InspectObj = hvec_i_WireObjs.At(hv_objIdx).Clone();
                    }
                    //获取金线检测起始区域
                    ho__StartRegs.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho__StartRegs = hvec__InspectObj[0].O.CopyObj(1, -1);
                    }
                    //---------------------------------------------------------------------------------
                    //初始化单类金线检测结果
                    hvec_i_DefectValueWire = (new HTupleVector(3).Insert(0, (new HTupleVector(2).Insert(0, (
                        new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))));
                    HOperatorSet.CountObj(ho__StartRegs, out hv_wireNumber);
                    HTuple end_val179 = hv_wireNumber - 1;
                    HTuple step_val179 = 1;
                    for (hv_wireidx = 0; hv_wireidx.Continue(end_val179, step_val179); hv_wireidx = hv_wireidx.TupleAdd(step_val179))
                    {
                        hvec_i_DefectValueWire[hv_wireidx][0] = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(-2))));
                        hvec_o_DefectValue[hv_objIdx] = hvec_i_DefectValueWire.Clone();
                        hvec_o_RefValue[hv_objIdx] = hvec_i_DefectValueWire.Clone();
                    }
                    //----------------------------------------------------------------------------------
                    //获取金线检测结束区域
                    ho__StopRegs.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho__StopRegs = hvec__InspectObj[1].O.CopyObj(1, -1);
                    }

                    //2020-1104 根据组合后排序信息重新计算虚拟焊点和真实焊点
                    ho_realStartBall_sort.Dispose();
                    HOperatorSet.GenEmptyObj(out ho_realStartBall_sort);
                    ho_realStopBall_sort.Dispose();
                    HOperatorSet.GenEmptyObj(out ho_realStopBall_sort);
                    hv_Startreg_index_after_sort = hvec__InspectModel[4].T.Clone();
                    hv_Stopreg_index_after_sort = hvec__InspectModel[5].T.Clone();
                    hv_Startreg_need_sort = hvec__InspectModel[6].T.Clone();
                    hv_Stopreg_need_sort = hvec__InspectModel[7].T.Clone();

                    if ((int)(hv__IsUseStartReg) != 0)
                    {
                        hv_Startreg_need_sort = 0;
                    }
                    if ((int)(hv__IsUseStopReg) != 0)
                    {
                        hv_Stopreg_need_sort = 0;
                    }

                    //1- 根据组合排序信息编辑真实焊点
                    //1-1 真实起始焊点区域排序编辑
                    if ((int)(hv_Startreg_need_sort) != 0)
                    {
                        HOperatorSet.CountObj(ho_realStartBall, out hv_start_regnum);
                        hv_sort_num = new HTuple(hv_Startreg_index_after_sort.TupleLength());
                        if ((int)(new HTuple(hv_start_regnum.TupleNotEqual(hv_sort_num))) != 0)
                        {
                            hv_o_ErrCode = -1;
                            hv_o_ErrStr = "number mismatch of start region and sort_vec";
                            ho_EmptyObject.Dispose();
                            ho_realStartBall.Dispose();
                            ho_tmp_realStartBall.Dispose();
                            ho_realStopBall.Dispose();
                            ho_tmp_realStopBall.Dispose();
                            ho__StartRegs.Dispose();
                            ho__StopRegs.Dispose();
                            ho_realStartBall_sort.Dispose();
                            ho_realStopBall_sort.Dispose();
                            ho_tmp_reg.Dispose();
                            ho_virtualStartBall1.Dispose();
                            ho_virtualStopBall1.Dispose();
                            ho_virtualStartBall2.Dispose();
                            ho_virtualStopBall2.Dispose();
                            ho_virtualStartBall3.Dispose();
                            ho_virtualStopBall3.Dispose();
                            ho__LineStartRegs.Dispose();
                            ho__LineStopRegs.Dispose();
                            ho__tmp_reg_aff.Dispose();
                            ho_tmpvirtualStartreg.Dispose();
                            ho_tmprealStartReg.Dispose();
                            ho_tmpvirtualStopreg.Dispose();
                            ho_tmprealStopReg.Dispose();
                            ho__InspectRegs.Dispose();
                            ho__Wires.Dispose();
                            hvec__InspectObj.Dispose();
                            hvec__FailWireRegs.Dispose();

                            return;
                        }

                        HTuple end_val214 = hv_start_regnum - 1;
                        HTuple step_val214 = 1;
                        for (hv_ind = 0; hv_ind.Continue(end_val214, step_val214); hv_ind = hv_ind.TupleAdd(step_val214))
                        {
                            hv_tmp_ind = hv_Startreg_index_after_sort.TupleSelect(hv_ind);
                            ho_tmp_reg.Dispose();
                            HOperatorSet.SelectObj(ho_realStartBall, out ho_tmp_reg, hv_tmp_ind);
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.ConcatObj(ho_realStartBall_sort, ho_tmp_reg, out ExpTmpOutVar_0
                                    );
                                ho_realStartBall_sort.Dispose();
                                ho_realStartBall_sort = ExpTmpOutVar_0;
                            }
                        }
                    }
                    else
                    {
                        ho_realStartBall_sort.Dispose();
                        ho_realStartBall_sort = ho_realStartBall.CopyObj(1, -1);
                    }
                    //1-2 真实结束焊点区域排序编辑
                    if ((int)(hv_Stopreg_need_sort) != 0)
                    {
                        HOperatorSet.CountObj(ho_realStopBall, out hv_stop_regnum);
                        hv_sort_num = new HTuple(hv_Stopreg_index_after_sort.TupleLength());
                        if ((int)(new HTuple(hv_stop_regnum.TupleNotEqual(hv_sort_num))) != 0)
                        {
                            hv_o_ErrCode = -1;
                            hv_o_ErrStr = "number mismatch of stop region and sort_vec";
                            ho_EmptyObject.Dispose();
                            ho_realStartBall.Dispose();
                            ho_tmp_realStartBall.Dispose();
                            ho_realStopBall.Dispose();
                            ho_tmp_realStopBall.Dispose();
                            ho__StartRegs.Dispose();
                            ho__StopRegs.Dispose();
                            ho_realStartBall_sort.Dispose();
                            ho_realStopBall_sort.Dispose();
                            ho_tmp_reg.Dispose();
                            ho_virtualStartBall1.Dispose();
                            ho_virtualStopBall1.Dispose();
                            ho_virtualStartBall2.Dispose();
                            ho_virtualStopBall2.Dispose();
                            ho_virtualStartBall3.Dispose();
                            ho_virtualStopBall3.Dispose();
                            ho__LineStartRegs.Dispose();
                            ho__LineStopRegs.Dispose();
                            ho__tmp_reg_aff.Dispose();
                            ho_tmpvirtualStartreg.Dispose();
                            ho_tmprealStartReg.Dispose();
                            ho_tmpvirtualStopreg.Dispose();
                            ho_tmprealStopReg.Dispose();
                            ho__InspectRegs.Dispose();
                            ho__Wires.Dispose();
                            hvec__InspectObj.Dispose();
                            hvec__FailWireRegs.Dispose();

                            return;
                        }

                        HTuple end_val232 = hv_stop_regnum - 1;
                        HTuple step_val232 = 1;
                        for (hv_ind = 0; hv_ind.Continue(end_val232, step_val232); hv_ind = hv_ind.TupleAdd(step_val232))
                        {
                            hv_tmp_ind = hv_Stopreg_index_after_sort.TupleSelect(hv_ind);
                            ho_tmp_reg.Dispose();
                            HOperatorSet.SelectObj(ho_realStopBall, out ho_tmp_reg, hv_tmp_ind);
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.ConcatObj(ho_realStopBall_sort, ho_tmp_reg, out ExpTmpOutVar_0
                                    );
                                ho_realStopBall_sort.Dispose();
                                ho_realStopBall_sort = ExpTmpOutVar_0;
                            }
                        }
                    }
                    else
                    {
                        ho_realStopBall_sort.Dispose();
                        ho_realStopBall_sort = ho_realStopBall.CopyObj(1, -1);
                    }
                    //2- 根据组合排序信息编辑虚拟焊点
                    ho_virtualStartBall1.Dispose();
                    HOperatorSet.GenEmptyObj(out ho_virtualStartBall1);
                    ho_virtualStopBall1.Dispose();
                    HOperatorSet.GenEmptyObj(out ho_virtualStopBall1);
                    ho_virtualStartBall2.Dispose();
                    HOperatorSet.GenEmptyObj(out ho_virtualStartBall2);
                    ho_virtualStopBall2.Dispose();
                    HOperatorSet.GenEmptyObj(out ho_virtualStopBall2);
                    ho_virtualStartBall3.Dispose();
                    HOperatorSet.GenEmptyObj(out ho_virtualStartBall3);
                    ho_virtualStopBall3.Dispose();
                    HOperatorSet.GenEmptyObj(out ho_virtualStopBall3);
                    ho__LineStartRegs.Dispose();
                    HOperatorSet.GenEmptyObj(out ho__LineStartRegs);
                    ho__LineStopRegs.Dispose();
                    HOperatorSet.GenEmptyObj(out ho__LineStopRegs);

                    //判断映射矩阵是否有效  add_lw 1119
                    hv_HomMatStartFlag = 1;
                    HTuple end_val252 = new HTuple(hvec_HomMatMod2_start_group.Length);
                    HTuple step_val252 = 1;
                    for (hv_idx = 0; hv_idx.Continue(end_val252, step_val252); hv_idx = hv_idx.TupleAdd(step_val252))
                    {
                        HOperatorSet.TupleSum(hvec_HomMatMod2_start_group[0].T, out hv_HomMatSum);
                        if ((int)(new HTuple(hv_HomMatSum.TupleEqual(-12))) != 0)
                        {
                            hv_HomMatStartFlag = 0;
                            break;
                        }
                    }

                    hv_HomMatStopFlag = 1;
                    HTuple end_val261 = new HTuple(hvec_HomMatMod2_stop_group.Length);
                    HTuple step_val261 = 1;
                    for (hv_idx = 0; hv_idx.Continue(end_val261, step_val261); hv_idx = hv_idx.TupleAdd(step_val261))
                    {
                        HOperatorSet.TupleSum(hvec_HomMatMod2_stop_group[0].T, out hv_HomMatSum);
                        if ((int)(new HTuple(hv_HomMatSum.TupleEqual(-12))) != 0)
                        {
                            hv_HomMatStopFlag = 0;
                            break;
                        }
                    }

                    if ((int)(hv_HomMatStartFlag.TupleAnd(hv_HomMatStopFlag)) != 0)
                    {
                        //2-1 虚拟起始焊点区域排序编辑
                        if ((int)(hv__IsUseStartReg) != 0)
                        {
                            hv__StartHomMat2D = hvec_HomMatMod2_start_group[0].T.Clone();
                            ho__LineStartRegs.Dispose();
                            HOperatorSet.AffineTransRegion(ho__StartRegs, out ho__LineStartRegs,
                                hv__StartHomMat2D, "nearest_neighbor");
                        }
                        else
                        {
                            //用真实焊点时，计算真实焊点对应的虚拟焊点（真实焊点的搜索中心或者测量中心）
                            //step-1: 模板区域按照焊点组合重新排列（组合排序之前的原始顺序）
                            if ((int)(hv_Startreg_need_sort) != 0)
                            {
                                HOperatorSet.CountObj(ho__StartRegs, out hv_start_num);
                                HTuple end_val279 = hv_start_num;
                                HTuple step_val279 = 1;
                                for (hv_i = 1; hv_i.Continue(end_val279, step_val279); hv_i = hv_i.TupleAdd(step_val279))
                                {
                                    HOperatorSet.TupleFind(hv_Startreg_index_after_sort, hv_i, out hv_i_index);
                                    ho_tmp_reg.Dispose();
                                    HOperatorSet.SelectObj(ho__StartRegs, out ho_tmp_reg, hv_i_index + 1);
                                    {
                                        HObject ExpTmpOutVar_0;
                                        HOperatorSet.ConcatObj(ho_virtualStartBall1, ho_tmp_reg, out ExpTmpOutVar_0
                                            );
                                        ho_virtualStartBall1.Dispose();
                                        ho_virtualStartBall1 = ExpTmpOutVar_0;
                                    }
                                }
                            }
                            else
                            {
                                ho_virtualStartBall1.Dispose();
                                ho_virtualStartBall1 = ho__StartRegs.CopyObj(1, -1);
                            }
                            //step-2:根据对应矩阵，转换对应的模板区域，生成位置变换后的虚拟焊点区域
                            hv_first_ind = 1;
                            for (hv_j = 0; (int)hv_j <= (int)((new HTuple(hv_Number_start_group.TupleLength()
                                )) - 1); hv_j = (int)hv_j + 1)
                            {

                                hv_end_ind = (hv_first_ind + (hv_Number_start_group.TupleSelect(hv_j))) - 1;
                                hv__StartHomMat2D_tmp = hvec_HomMatMod2_start_group[hv_j].T.Clone();

                                HTuple end_val294 = hv_end_ind;
                                HTuple step_val294 = 1;
                                for (hv_new_j = hv_first_ind; hv_new_j.Continue(end_val294, step_val294); hv_new_j = hv_new_j.TupleAdd(step_val294))
                                {
                                    ho_tmp_reg.Dispose();
                                    HOperatorSet.SelectObj(ho_virtualStartBall1, out ho_tmp_reg, hv_new_j);
                                    ho__tmp_reg_aff.Dispose();
                                    HOperatorSet.AffineTransRegion(ho_tmp_reg, out ho__tmp_reg_aff, hv__StartHomMat2D_tmp,
                                        "nearest_neighbor");
                                    {
                                        HObject ExpTmpOutVar_0;
                                        HOperatorSet.ConcatObj(ho_virtualStartBall2, ho__tmp_reg_aff, out ExpTmpOutVar_0
                                            );
                                        ho_virtualStartBall2.Dispose();
                                        ho_virtualStartBall2 = ExpTmpOutVar_0;
                                    }
                                }

                                hv_first_ind = hv_end_ind + 1;
                            }
                            //step-3:根据组合排序向量，对位置变换后的虚拟焊点区域进行重新排序，得到与真实焊点对应的虚拟焊点
                            HOperatorSet.CountObj(ho__StartRegs, out hv_start_num);
                            HTuple end_val304 = hv_start_num;
                            HTuple step_val304 = 1;
                            for (hv_i = 1; hv_i.Continue(end_val304, step_val304); hv_i = hv_i.TupleAdd(step_val304))
                            {
                                hv_tmp_ind = hv_Startreg_index_after_sort.TupleSelect(hv_i - 1);
                                ho_tmpvirtualStartreg.Dispose();
                                HOperatorSet.SelectObj(ho_virtualStartBall2, out ho_tmpvirtualStartreg,
                                    hv_tmp_ind);
                                {
                                    HObject ExpTmpOutVar_0;
                                    HOperatorSet.ConcatObj(ho_virtualStartBall3, ho_tmpvirtualStartreg,
                                        out ExpTmpOutVar_0);
                                    ho_virtualStartBall3.Dispose();
                                    ho_virtualStartBall3 = ExpTmpOutVar_0;
                                }

                                //根据真实焊点是否有计算结果，来选取合适的采用区域，有计算结果则采用真实焊点，无计算结果则采用变换后的虚拟焊点位置
                                ho_tmprealStartReg.Dispose();
                                HOperatorSet.SelectObj(ho_realStartBall_sort, out ho_tmprealStartReg,
                                    hv_i);
                                //********判断真实焊点是否存在：是-启用真实焊点，否-启用虚拟焊点
                                HOperatorSet.AreaCenter(ho_tmprealStartReg, out hv_StartRegArea, out hv_Row,
                                    out hv_Column);
                                if ((int)(new HTuple(hv_StartRegArea.TupleEqual(0))) != 0)
                                {
                                    //启用虚拟焊点
                                    {
                                        HObject ExpTmpOutVar_0;
                                        HOperatorSet.ConcatObj(ho__LineStartRegs, ho_tmpvirtualStartreg,
                                            out ExpTmpOutVar_0);
                                        ho__LineStartRegs.Dispose();
                                        ho__LineStartRegs = ExpTmpOutVar_0;
                                    }
                                }
                                else
                                {
                                    //启用真实焊点
                                    {
                                        HObject ExpTmpOutVar_0;
                                        HOperatorSet.ConcatObj(ho__LineStartRegs, ho_tmprealStartReg, out ExpTmpOutVar_0
                                            );
                                        ho__LineStartRegs.Dispose();
                                        ho__LineStartRegs = ExpTmpOutVar_0;
                                    }
                                }
                            }
                        }

                        //2-2 虚拟起始焊点区域排序编辑
                        if ((int)(hv__IsUseStopReg) != 0)
                        {
                            hv__StopHomMat2D = hvec_HomMatMod2_stop_group[0].T.Clone();
                            ho__LineStopRegs.Dispose();
                            HOperatorSet.AffineTransRegion(ho__StopRegs, out ho__LineStopRegs, hv__StopHomMat2D,
                                "nearest_neighbor");
                        }
                        else
                        {
                            //用真实焊点时，计算真实焊点对应的虚拟焊点（真实焊点的搜索中心或者测量中心）
                            //step-1: 模板区域按照焊点组合重新排列（组合排序之前的原始顺序）
                            if ((int)(hv_Stopreg_need_sort) != 0)
                            {
                                HOperatorSet.CountObj(ho__StopRegs, out hv_stop_num);
                                HTuple end_val332 = hv_stop_num;
                                HTuple step_val332 = 1;
                                for (hv_i = 1; hv_i.Continue(end_val332, step_val332); hv_i = hv_i.TupleAdd(step_val332))
                                {
                                    HOperatorSet.TupleFind(hv_Stopreg_index_after_sort, hv_i, out hv_i_index);
                                    ho_tmp_reg.Dispose();
                                    HOperatorSet.SelectObj(ho__StopRegs, out ho_tmp_reg, hv_i_index + 1);
                                    {
                                        HObject ExpTmpOutVar_0;
                                        HOperatorSet.ConcatObj(ho_virtualStopBall1, ho_tmp_reg, out ExpTmpOutVar_0
                                            );
                                        ho_virtualStopBall1.Dispose();
                                        ho_virtualStopBall1 = ExpTmpOutVar_0;
                                    }
                                }
                            }
                            else
                            {
                                ho_virtualStopBall1.Dispose();
                                ho_virtualStopBall1 = ho__StopRegs.CopyObj(1, -1);
                            }
                            //step-2:根据对应矩阵，转换对应的模板区域，生成位置变换后的虚拟焊点区域
                            hv_first_ind = 1;
                            for (hv_j = 0; (int)hv_j <= (int)((new HTuple(hv_Number_stop_group.TupleLength()
                                )) - 1); hv_j = (int)hv_j + 1)
                            {

                                hv_end_ind = (hv_first_ind + (hv_Number_stop_group.TupleSelect(hv_j))) - 1;
                                hv__StopHomMat2D_tmp = hvec_HomMatMod2_stop_group[hv_j].T.Clone();

                                HTuple end_val347 = hv_end_ind;
                                HTuple step_val347 = 1;
                                for (hv_new_j = hv_first_ind; hv_new_j.Continue(end_val347, step_val347); hv_new_j = hv_new_j.TupleAdd(step_val347))
                                {
                                    ho_tmp_reg.Dispose();
                                    HOperatorSet.SelectObj(ho_virtualStopBall1, out ho_tmp_reg, hv_new_j);
                                    ho__tmp_reg_aff.Dispose();
                                    HOperatorSet.AffineTransRegion(ho_tmp_reg, out ho__tmp_reg_aff, hv__StopHomMat2D_tmp,
                                        "nearest_neighbor");
                                    {
                                        HObject ExpTmpOutVar_0;
                                        HOperatorSet.ConcatObj(ho_virtualStopBall2, ho__tmp_reg_aff, out ExpTmpOutVar_0
                                            );
                                        ho_virtualStopBall2.Dispose();
                                        ho_virtualStopBall2 = ExpTmpOutVar_0;
                                    }
                                }

                                hv_first_ind = hv_end_ind + 1;
                            }
                            //step-3:根据组合排序向量，对位置变换后的虚拟焊点区域进行重新排序，得到与真实焊点对应的虚拟焊点
                            HOperatorSet.CountObj(ho__StopRegs, out hv_stop_num);
                            HTuple end_val357 = hv_stop_num;
                            HTuple step_val357 = 1;
                            for (hv_i = 1; hv_i.Continue(end_val357, step_val357); hv_i = hv_i.TupleAdd(step_val357))
                            {
                                hv_tmp_ind = hv_Stopreg_index_after_sort.TupleSelect(hv_i - 1);
                                ho_tmpvirtualStopreg.Dispose();
                                HOperatorSet.SelectObj(ho_virtualStopBall2, out ho_tmpvirtualStopreg,
                                    hv_tmp_ind);
                                {
                                    HObject ExpTmpOutVar_0;
                                    HOperatorSet.ConcatObj(ho_virtualStopBall3, ho_tmpvirtualStopreg, out ExpTmpOutVar_0
                                        );
                                    ho_virtualStopBall3.Dispose();
                                    ho_virtualStopBall3 = ExpTmpOutVar_0;
                                }

                                //根据真实焊点是否有计算结果，来选取合适的采用区域，有计算结果则采用真实焊点，无计算结果则采用变换后的虚拟焊点位置
                                ho_tmprealStopReg.Dispose();
                                HOperatorSet.SelectObj(ho_realStopBall_sort, out ho_tmprealStopReg,
                                    hv_i);
                                //********判断真实焊点是否存在：是-启用真实焊点，否-启用虚拟焊点
                                HOperatorSet.AreaCenter(ho_tmprealStopReg, out hv_StopRegArea, out hv_Row,
                                    out hv_Column);
                                if ((int)(new HTuple(hv_StopRegArea.TupleEqual(0))) != 0)
                                {
                                    //启用虚拟焊点
                                    {
                                        HObject ExpTmpOutVar_0;
                                        HOperatorSet.ConcatObj(ho__LineStopRegs, ho_tmpvirtualStopreg, out ExpTmpOutVar_0
                                            );
                                        ho__LineStopRegs.Dispose();
                                        ho__LineStopRegs = ExpTmpOutVar_0;
                                    }
                                }
                                else
                                {
                                    //启用真实焊点
                                    {
                                        HObject ExpTmpOutVar_0;
                                        HOperatorSet.ConcatObj(ho__LineStopRegs, ho_tmprealStopReg, out ExpTmpOutVar_0
                                            );
                                        ho__LineStopRegs.Dispose();
                                        ho__LineStopRegs = ExpTmpOutVar_0;
                                    }
                                }
                            }
                        }
                    }

                    //获取金线检测区域
                    ho__InspectRegs.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho__InspectRegs = hvec__InspectObj[2].O.CopyObj(1, -1);
                    }
                    //
                    //------------获取金线检测参数
                    //获取金线检测区域个数数组
                    hv__InspectRegNum = hvec__InspectModel[3].T.Clone();
                    //
                    //-------------获取金线检测区域内检测参数
                    hvec__WireInspect_Paras = hvec_i_WireInspectParas[1][hv_objIdx];
                    //
                    //**********************************金线检测***************************************
                    ho__Wires.Dispose(); hvec__FailWireRegs.Dispose();
                    HTV_Wire_Inspect_MVP(ho_i_Imgs, ho__LineStartRegs, ho__LineStopRegs, ho__StartRegs,
                        ho__StopRegs, ho__InspectRegs, out ho__Wires, out hvec__FailWireRegs,
                        hv__InspectRegNum, hvec__WireInspect_Paras, hvec_i_DefectValueWire, out hvec__DefectWireType,
                        out hvec__DefectWireImgIdx, out hvec__DefectValueWire, out hvec__RefValueWire,
                        out hv__ErrInspectCode, out hv__ErrInspectStr);
                    //
                    //整合多wire区域检测结果
                    hvec_o_FailRegs[hv_objIdx] = hvec__FailWireRegs.Clone();
                    hvec_o_Wires[hv_objIdx] = new HObjectVector(ho__Wires.CopyObj(1, -1));
                    hvec_o_DefectTypes[hv_objIdx] = hvec__DefectWireType.Clone();
                    hvec_o_DefectValue[hv_objIdx] = hvec__DefectValueWire.Clone();
                    hvec_o_DefectImgIdx[hv_objIdx] = hvec__DefectWireImgIdx.Clone();
                    hvec_o_RefValue[hv_objIdx] = hvec__RefValueWire.Clone();
                    //
                }
                //
                hv_o_ErrCode = 0;
                hv_o_ErrStr = "Wires inspect successful";
                ho_EmptyObject.Dispose();
                ho_realStartBall.Dispose();
                ho_tmp_realStartBall.Dispose();
                ho_realStopBall.Dispose();
                ho_tmp_realStopBall.Dispose();
                ho__StartRegs.Dispose();
                ho__StopRegs.Dispose();
                ho_realStartBall_sort.Dispose();
                ho_realStopBall_sort.Dispose();
                ho_tmp_reg.Dispose();
                ho_virtualStartBall1.Dispose();
                ho_virtualStopBall1.Dispose();
                ho_virtualStartBall2.Dispose();
                ho_virtualStopBall2.Dispose();
                ho_virtualStartBall3.Dispose();
                ho_virtualStopBall3.Dispose();
                ho__LineStartRegs.Dispose();
                ho__LineStopRegs.Dispose();
                ho__tmp_reg_aff.Dispose();
                ho_tmpvirtualStartreg.Dispose();
                ho_tmprealStartReg.Dispose();
                ho_tmpvirtualStopreg.Dispose();
                ho_tmprealStopReg.Dispose();
                ho__InspectRegs.Dispose();
                ho__Wires.Dispose();
                hvec__InspectObj.Dispose();
                hvec__FailWireRegs.Dispose();

                return;

            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_EmptyObject.Dispose();
                ho_realStartBall.Dispose();
                ho_tmp_realStartBall.Dispose();
                ho_realStopBall.Dispose();
                ho_tmp_realStopBall.Dispose();
                ho__StartRegs.Dispose();
                ho__StopRegs.Dispose();
                ho_realStartBall_sort.Dispose();
                ho_realStopBall_sort.Dispose();
                ho_tmp_reg.Dispose();
                ho_virtualStartBall1.Dispose();
                ho_virtualStopBall1.Dispose();
                ho_virtualStartBall2.Dispose();
                ho_virtualStopBall2.Dispose();
                ho_virtualStartBall3.Dispose();
                ho_virtualStopBall3.Dispose();
                ho__LineStartRegs.Dispose();
                ho__LineStopRegs.Dispose();
                ho__tmp_reg_aff.Dispose();
                ho_tmpvirtualStartreg.Dispose();
                ho_tmprealStartReg.Dispose();
                ho_tmpvirtualStopreg.Dispose();
                ho_tmprealStopReg.Dispose();
                ho__InspectRegs.Dispose();
                ho__Wires.Dispose();
                hvec__InspectObj.Dispose();
                hvec__FailWireRegs.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public static void HTV_aroundBalls_inspect(HObject ho_i_Imgs, HObjectVector/*{eObjectVector,Dim=1}*/ hvec_i_RealBalls,
            HObjectVector/*{eObjectVector,Dim=1}*/ hvec_i_RefPads, HObject ho_i_RejectReg,
            out HObjectVector/*{eObjectVector,Dim=2}*/ hvec_o_FailRegs, out HObjectVector/*{eObjectVector,Dim=1}*/ hvec_o_BondContours,
            out HObjectVector/*{eObjectVector,Dim=1}*/ hvec_o_PadContours, HTuple hv_i_ObjNum,
            HTupleVector/*{eTupleVector,Dim=3}*/ hvec_i_AroundBallRegInspectParas, HTupleVector/*{eTupleVector,Dim=4}*/ hvec_i_DefectValue,
            out HTupleVector/*{eTupleVector,Dim=2}*/ hvec_o_DefectTypes, out HTupleVector/*{eTupleVector,Dim=4}*/ hvec_o_DefectValue,
            out HTupleVector/*{eTupleVector,Dim=2}*/ hvec_o_DefectImgIdx, out HTupleVector/*{eTupleVector,Dim=4}*/ hvec_o_RefValue,
            out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {




            // Local iconic variables 

            HObject ho_EmptyObject, ho_EmptyRegion, ho__InspectObj = null;
            HObject ho__RefPadObj = null, ho_i_Image = null, ho__BondContours = null;
            HObject ho__PadContours = null, ho__TailReg = null, ho_ObjectsConcat = null;
            HObject ho__FailRegConcat = null;

            HObjectVector hvec__shiftFailReg = new HObjectVector(1);
            HObjectVector hvec__tailFailReg = new HObjectVector(1), hvec__surfFailReg = new HObjectVector(1);
            HObjectVector hvec__FailReg = new HObjectVector(1);

            // Local control variables 

            HTuple hv_objIdx = null, hv_objNum = new HTuple();
            HTuple hv__IsInspect = new HTuple(), hv__IsBallShiftInspect = new HTuple();
            HTuple hv__ShiftInspectMethodIndex = new HTuple(), hv__shiftImgIndex = new HTuple();
            HTuple hv__isMeasurePad = new HTuple(), hv__padMeasureType = new HTuple();
            HTuple hv__padMeasureSize = new HTuple(), hv__padMeasureGrayThr = new HTuple();
            HTuple hv__padMeasureTrans = new HTuple(), hv__padGrayThresh = new HTuple();
            HTuple hv__isMeasureBall = new HTuple(), hv__ballGrayThresh = new HTuple();
            HTuple hv__ballMeasureType = new HTuple(), hv__ballMeasureSize = new HTuple();
            HTuple hv__ballMeasureGrayThr = new HTuple(), hv__ballMeasureTrans = new HTuple();
            HTuple hv__ballShiftRatioThr = new HTuple(), hv_Idx = new HTuple();
            HTuple hv__shiftErrCode = new HTuple(), hv__shiftErrStr = new HTuple();
            HTuple hv__IsTailInspect = new HTuple(), hv__TailInspectMethodIndex = new HTuple();
            HTuple hv__tailImgIndex = new HTuple(), hv__tailDilationSize = new HTuple();
            HTuple hv__tailwireWidth = new HTuple(), hv__tailwireContrast = new HTuple();
            HTuple hv__tailselMetric = new HTuple(), hv__taillightOrDark = new HTuple();
            HTuple hv__tailselMin = new HTuple(), hv__tailselMax = new HTuple();
            HTuple hv__tailmaxWireGap = new HTuple(), hv__TailGrayThresh = new HTuple();
            HTuple hv__TailLenTh = new HTuple(), hv__IsWireJudgeAgain = new HTuple();
            HTuple hv__tailErrCode = new HTuple(), hv__tailErrStr = new HTuple();
            HTuple hv__IsSurfaceInspect = new HTuple(), hv__surfImgIndex = new HTuple();
            HTuple hv__ballDilationSize = new HTuple(), hv__surfadaptiveMethod = new HTuple();
            HTuple hv__surfblockSize = new HTuple(), hv__surfcontrast = new HTuple();
            HTuple hv__surflightOrDark = new HTuple(), hv__surfcloseSize = new HTuple();
            HTuple hv__surfminLength = new HTuple(), hv__surfminWidth = new HTuple();
            HTuple hv__surfminArea = new HTuple(), hv__surfselOperation = new HTuple();
            HTuple hv__surfErrCode = new HTuple(), hv__surfErrStr = new HTuple();
            HTuple hv__surfDilationSize = new HTuple(), hv__surfthreshGray = new HTuple();
            HTuple hv__surfthreshGrayInOrOut = new HTuple(), hv__surfmorphSize = new HTuple();
            HTuple hv_DefectTypeTup = null, hv__VecErrCode = null;
            HTuple hv__VecErrStr = null, hv_TupSum = null;

            HTupleVector hvec_AroundBallPara = new HTupleVector(2);
            HTupleVector hvec__DefectValue = new HTupleVector(3), hvec__RefValue = new HTupleVector(3);
            HTupleVector hvec__shiftDefectType = new HTupleVector(1), hvec__shiftDefectImgIdx = new HTupleVector(1);
            HTupleVector hvec__tailDefectType = new HTupleVector(1), hvec__tailDefectImgIdx = new HTupleVector(1);
            HTupleVector hvec__surfDefectType = new HTupleVector(1), hvec__surfDefectImgIdx = new HTupleVector(1);
            HTupleVector hvec__DefectType = new HTupleVector(1), hvec__DefectImgIdx = new HTupleVector(1);
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_EmptyObject);
            HOperatorSet.GenEmptyObj(out ho_EmptyRegion);
            HOperatorSet.GenEmptyObj(out ho__InspectObj);
            HOperatorSet.GenEmptyObj(out ho__RefPadObj);
            HOperatorSet.GenEmptyObj(out ho_i_Image);
            HOperatorSet.GenEmptyObj(out ho__BondContours);
            HOperatorSet.GenEmptyObj(out ho__PadContours);
            HOperatorSet.GenEmptyObj(out ho__TailReg);
            HOperatorSet.GenEmptyObj(out ho_ObjectsConcat);
            HOperatorSet.GenEmptyObj(out ho__FailRegConcat);
            hvec_o_FailRegs = new HObjectVector(2);
            hvec_o_BondContours = new HObjectVector(1);
            hvec_o_PadContours = new HObjectVector(1);
            try
            {
                //**************************************************************************************************
                //---函数：HTV_around_ball_regions_inspect
                //---功能：焊点周围异常检测：所有Ball周围
                //===图标参数
                //  i_Imgs：检测所需图像集合
                //  i_RealBalls：需要检测的焊点区域
                //  i_RejectRegs：影响焊点周围检测的免检测区域
                //  o_FailRegs：检测具有缺陷的区域
                //===控制参数
                //  i_AroundBallRegInspectParas：焊点周围检测参数
                //  o_DefectTypes：缺陷区域的输出的缺陷按类型
                //  o_DefectImgIdx:缺陷所在的图像索引
                //  o_DefectValue：缺陷输出的参考缺陷信息
                //  o_ErrCode：函数执行的错误码
                //  o_ErrStr：函数执行错误描述
                //**************************************************************************************************

                //初始化
                //
                ho_EmptyObject.Dispose();
                HOperatorSet.GenEmptyObj(out ho_EmptyObject);
                ho_EmptyRegion.Dispose();
                HOperatorSet.GenEmptyRegion(out ho_EmptyRegion);
                //
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hvec_o_FailRegs = dh.Take((
                        dh.Add(new HObjectVector(2)).Insert(0, (dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho_EmptyObject)))))));
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hvec_o_PadContours = dh.Take((
                        dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho_EmptyObject)))));
                }
                //
                hvec_o_DefectTypes = (new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))));
                hvec_o_DefectImgIdx = (new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))));
                hvec_o_DefectValue = (new HTupleVector(4).Insert(0, (new HTupleVector(3).Insert(0, (
                    new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))))));
                hvec_o_RefValue = (new HTupleVector(4).Insert(0, (new HTupleVector(3).Insert(0, (
                    new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))))));

                //更新BondContours
                hvec_o_BondContours = hvec_i_RealBalls.Clone();
                //
                HTuple end_val33 = hv_i_ObjNum - 1;
                HTuple step_val33 = 1;
                for (hv_objIdx = 0; hv_objIdx.Continue(end_val33, step_val33); hv_objIdx = hv_objIdx.TupleAdd(step_val33))
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hvec_o_FailRegs[hv_objIdx] = dh.Take((
                            dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho_EmptyObject)))));
                    }
                    hvec_o_PadContours[hv_objIdx] = new HObjectVector(ho_EmptyObject.CopyObj(1, -1));
                    //
                    hvec_o_DefectTypes[hv_objIdx] = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())));
                    hvec_o_DefectImgIdx[hv_objIdx] = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())));
                    hvec_o_DefectValue[hv_objIdx] = (new HTupleVector(3).Insert(0, (new HTupleVector(2).Insert(0, (
                        new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))));
                }
                //
                hv_o_ErrCode = -2;
                hv_o_ErrStr = "initializing";
                //输入合法性测试
                //
                //*********************************----inspect------***********************
                //免检测区域获取:检测到的金线区域
                //
                HTuple end_val49 = hv_i_ObjNum - 1;
                HTuple step_val49 = 1;
                for (hv_objIdx = 0; hv_objIdx.Continue(end_val49, step_val49); hv_objIdx = hv_objIdx.TupleAdd(step_val49))
                {
                    //获取检测对象
                    ho__InspectObj.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho__InspectObj = hvec_i_RealBalls[hv_objIdx].O.CopyObj(1, -1);
                    }
                    HOperatorSet.CountObj(ho__InspectObj, out hv_objNum);
                    //获取焊盘参考对象
                    ho__RefPadObj.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho__RefPadObj = hvec_i_RefPads[hv_objIdx].O.CopyObj(1, -1);
                    }
                    //获取对象检测参数
                    hvec_AroundBallPara = hvec_i_AroundBallRegInspectParas[hv_objIdx];
                    //接收bond检测的defectValue
                    hvec__DefectValue = hvec_i_DefectValue[hv_objIdx];
                    //是否进行对象检测:0-不检测，1-检测
                    hv__IsInspect = hvec_AroundBallPara[0][0].T.Clone();
                    //
                    if ((int)(hv__IsInspect) != 0)
                    {
                        //分项目进行AroundBond周围检测
                        //1 ------焊点偏移及焊盘异物检测
                        //获取焊点是否偏移检测
                        hv__IsBallShiftInspect = hvec_AroundBallPara[1][0].T.Clone();

                        if ((int)(hv__IsBallShiftInspect) != 0)
                        {
                            //进行焊点偏移、焊盘异物检测
                            //获取焊点偏移检测算法索引号，0-match_mearsure，1---，2---，等等
                            hv__ShiftInspectMethodIndex = hvec_AroundBallPara[1][1].T.Clone();
                            //
                            switch (hv__ShiftInspectMethodIndex.I)
                            {
                                case 0:
                                    //match_measure方法
                                    hv__shiftImgIndex = hvec_AroundBallPara[1][2].T.Clone();
                                    //检测图层
                                    ho_i_Image.Dispose();
                                    HOperatorSet.SelectObj(ho_i_Imgs, out ho_i_Image, hv__shiftImgIndex);
                                    //
                                    hv__isMeasurePad = hvec_AroundBallPara[1][3].T.Clone();
                                    //
                                    hv__padMeasureType = hvec_AroundBallPara[1][4].T.Clone();
                                    hv__padMeasureSize = hvec_AroundBallPara[1][5].T.Clone();
                                    hv__padMeasureGrayThr = hvec_AroundBallPara[1][6].T.Clone();
                                    hv__padMeasureTrans = hvec_AroundBallPara[1][7].T.Clone();
                                    hv__padGrayThresh = hvec_AroundBallPara[1][8].T.Clone();
                                    //
                                    hv__isMeasureBall = hvec_AroundBallPara[1][9].T.Clone();
                                    //
                                    hv__ballGrayThresh = hvec_AroundBallPara[1][10].T.Clone();
                                    hv__ballMeasureType = hvec_AroundBallPara[1][11].T.Clone();
                                    hv__ballMeasureSize = hvec_AroundBallPara[1][12].T.Clone();
                                    hv__ballMeasureGrayThr = hvec_AroundBallPara[1][13].T.Clone();
                                    hv__ballMeasureTrans = hvec_AroundBallPara[1][14].T.Clone();
                                    //
                                    hv__ballShiftRatioThr = hvec_AroundBallPara[1][15].T.Clone();
                                    //
                                    //参考设置值
                                    HTuple end_val99 = hv_objNum - 1;
                                    HTuple step_val99 = 1;
                                    for (hv_Idx = 0; hv_Idx.Continue(end_val99, step_val99); hv_Idx = hv_Idx.TupleAdd(step_val99))
                                    {
                                        hvec__RefValue[hv_Idx][1] = (new HTupleVector(1).Insert(0, new HTupleVector(hv__ballShiftRatioThr)));
                                    }
                                    //
                                    //AroundBond 二焊点偏移检测
                                    hvec__shiftFailReg.Dispose(); ho__BondContours.Dispose(); ho__PadContours.Dispose();
                                    HTV_AroundBallSeg_Inspect_MatchMeasure(ho_i_Image, ho__InspectObj,
                                        ho__RefPadObj, out hvec__shiftFailReg, out ho__BondContours, out ho__PadContours,
                                        hv__isMeasurePad, hv__padMeasureType, hv__padMeasureSize, hv__padMeasureGrayThr,
                                        hv__padMeasureTrans, hv__padGrayThresh, hv__isMeasureBall, hv__ballGrayThresh,
                                        hv__ballMeasureType, hv__ballMeasureSize, hv__ballMeasureGrayThr,
                                        hv__ballMeasureTrans, hv__ballShiftRatioThr, hv__shiftImgIndex,
                                        hvec__DefectValue, out hvec__shiftDefectType, out hvec__DefectValue,
                                        out hvec__shiftDefectImgIdx, out hv__shiftErrCode, out hv__shiftErrStr);
                                    //更新焊点输出
                                    hvec_o_BondContours[hv_objIdx] = new HObjectVector(ho__BondContours.CopyObj(1, -1));
                                    //输出焊盘区域
                                    hvec_o_PadContours[hv_objIdx] = new HObjectVector(ho__PadContours.CopyObj(1, -1));
                                    //更新Bond区域
                                    ho__InspectObj.Dispose();
                                    ho__InspectObj = ho__BondContours.CopyObj(1, -1);
                                    //
                                    break;
                                default:
                                    break;
                            }
                        }
                        else
                        {
                            //该项不检测输出结果
                            HTuple end_val118 = hv_objNum - 1;
                            HTuple step_val118 = 1;
                            for (hv_Idx = 0; hv_Idx.Continue(end_val118, step_val118); hv_Idx = hv_Idx.TupleAdd(step_val118))
                            {
                                hvec__shiftFailReg[hv_Idx] = new HObjectVector(ho_EmptyObject.CopyObj(1, -1));
                                hvec__shiftDefectType[hv_Idx] = new HTupleVector(new HTuple());
                                hvec__shiftDefectImgIdx[hv_Idx] = new HTupleVector(new HTuple());
                                hvec__DefectValue[hv_Idx][1] = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(-2))));
                                hvec__RefValue[hv_Idx][1] = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(-2))));
                            }
                        }
                        //2-------焊点尾丝及焊盘周围异物检测
                        //获取焊点是否尾丝检测
                        hv__IsTailInspect = hvec_AroundBallPara[2][0].T.Clone();
                        if ((int)(hv__IsTailInspect) != 0)
                        {
                            //进行尾丝、焊盘异物检测
                            //获取尾丝检测算法索引号，0-Line_Gauss，1---，2---，等等
                            hv__TailInspectMethodIndex = hvec_AroundBallPara[2][1].T.Clone();
                            //
                            switch (hv__TailInspectMethodIndex.I)
                            {
                                case 0:
                                    //
                                    //'Line_Gauss'方法参数
                                    hv__tailImgIndex = hvec_AroundBallPara[2][2].T.Clone();
                                    //检测图层
                                    ho_i_Image.Dispose();
                                    HOperatorSet.SelectObj(ho_i_Imgs, out ho_i_Image, hv__tailImgIndex);
                                    //
                                    hv__tailDilationSize = hvec_AroundBallPara[2][3].T.Clone();
                                    hv__tailwireWidth = hvec_AroundBallPara[2][4].T.Clone();
                                    hv__tailwireContrast = hvec_AroundBallPara[2][5].T.Clone();
                                    hv__tailselMetric = hvec_AroundBallPara[2][6].T.Clone();
                                    hv__taillightOrDark = hvec_AroundBallPara[2][7].T.Clone();
                                    hv__tailselMin = hvec_AroundBallPara[2][8].T.Clone();
                                    hv__tailselMax = hvec_AroundBallPara[2][9].T.Clone();
                                    hv__tailmaxWireGap = hvec_AroundBallPara[2][10].T.Clone();
                                    hv__TailGrayThresh = hvec_AroundBallPara[2][11].T.Clone();
                                    hv__TailLenTh = hvec_AroundBallPara[2][12].T.Clone();
                                    //是否开启断线再检
                                    hv__IsWireJudgeAgain = hvec_AroundBallPara[2][13].T.Clone();
                                    //
                                    //参考设置值
                                    HTuple end_val156 = hv_objNum - 1;
                                    HTuple step_val156 = 1;
                                    for (hv_Idx = 0; hv_Idx.Continue(end_val156, step_val156); hv_Idx = hv_Idx.TupleAdd(step_val156))
                                    {
                                        hvec__RefValue[hv_Idx][2] = (new HTupleVector(1).Insert(0, new HTupleVector(hv__TailLenTh)));
                                    }
                                    //
                                    //AroundBond周围尾丝检测
                                    hvec__tailFailReg.Dispose(); ho__TailReg.Dispose();
                                    HTV_AroundBallSeg_Inspect_LineGauss(ho_i_Image, ho__InspectObj, ho_i_RejectReg,
                                        out hvec__tailFailReg, out ho__TailReg, hv__tailDilationSize, hv__tailwireWidth,
                                        hv__tailwireContrast, hv__taillightOrDark, hv__tailselMetric, hv__tailselMin,
                                        hv__tailselMax, hv__tailmaxWireGap, hv__TailGrayThresh, hv__TailLenTh,
                                        hv__tailImgIndex, hv__IsWireJudgeAgain, hvec__DefectValue, out hvec__tailDefectType,
                                        out hvec__DefectValue, out hvec__tailDefectImgIdx, out hv__tailErrCode,
                                        out hv__tailErrStr);
                                    break;
                                default:
                                    break;

                            }
                        }
                        else
                        {
                            //该项不检测输出结果
                            ho__TailReg.Dispose();
                            HOperatorSet.GenEmptyObj(out ho__TailReg);
                            //
                            HTuple end_val171 = hv_objNum - 1;
                            HTuple step_val171 = 1;
                            for (hv_Idx = 0; hv_Idx.Continue(end_val171, step_val171); hv_Idx = hv_Idx.TupleAdd(step_val171))
                            {
                                hvec__tailFailReg[hv_Idx] = new HObjectVector(ho_EmptyObject.CopyObj(1, -1));
                                hvec__tailDefectType[hv_Idx] = new HTupleVector(new HTuple());
                                hvec__tailDefectImgIdx[hv_Idx] = new HTupleVector(new HTuple());
                                hvec__DefectValue[hv_Idx][2] = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(-2))));
                                hvec__RefValue[hv_Idx][2] = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(-2))));
                            }
                        }

                        //3-------焊点焊盘周围异物检测
                        //获取焊盘是否尾丝检测
                        hv__IsSurfaceInspect = hvec_AroundBallPara[3][0].T.Clone();

                        if ((int)(hv__IsSurfaceInspect) != 0)
                        {
                            //进行焊盘异物检测
                            //获取焊盘异物检测算法索引号，0-Adaptive，1-Global，2---，等等
                            hv__ShiftInspectMethodIndex = hvec_AroundBallPara[3][1].T.Clone();
                            //
                            switch (hv__ShiftInspectMethodIndex.I)
                            {
                                case 0:
                                    //
                                    //'Adative'方法检测参数
                                    hv__surfImgIndex = hvec_AroundBallPara[3][2].T.Clone();
                                    //检测图层
                                    ho_i_Image.Dispose();
                                    HOperatorSet.SelectObj(ho_i_Imgs, out ho_i_Image, hv__surfImgIndex);
                                    //
                                    hv__ballDilationSize = hvec_AroundBallPara[3][3].T.Clone();
                                    //
                                    hv__surfadaptiveMethod = hvec_AroundBallPara[3][4].T.Clone();
                                    hv__surfblockSize = hvec_AroundBallPara[3][5].T.Clone();
                                    hv__surfcontrast = hvec_AroundBallPara[3][6].T.Clone();
                                    hv__surflightOrDark = hvec_AroundBallPara[3][7].T.Clone();
                                    hv__surfcloseSize = hvec_AroundBallPara[3][8].T.Clone();
                                    hv__surfminLength = hvec_AroundBallPara[3][9].T.Clone();
                                    hv__surfminWidth = hvec_AroundBallPara[3][10].T.Clone();
                                    hv__surfminArea = hvec_AroundBallPara[3][11].T.Clone();
                                    hv__surfselOperation = hvec_AroundBallPara[3][12].T.Clone();
                                    //
                                    //参考设置值
                                    HTuple end_val210 = hv_objNum - 1;
                                    HTuple step_val210 = 1;
                                    for (hv_Idx = 0; hv_Idx.Continue(end_val210, step_val210); hv_Idx = hv_Idx.TupleAdd(step_val210))
                                    {
                                        hvec__RefValue[hv_Idx][3] = (((new HTupleVector(1).Insert(0, new HTupleVector(hv__surfminArea))).Insert(
                                            1, new HTupleVector(new HTuple(0)))).Insert(2, new HTupleVector(new HTuple(0))));
                                    }
                                    //
                                    //Aroundball周围外来物缺陷检测
                                    hvec__surfFailReg.Dispose();
                                    HTV_ArondBallSeg_Inspect_Adative(ho_i_Image, ho__PadContours, ho__BondContours,
                                        ho_i_RejectReg, ho__TailReg, out hvec__surfFailReg, hv__ballDilationSize,
                                        hv__surfadaptiveMethod, hv__surfblockSize, hv__surfcontrast, hv__surflightOrDark,
                                        hv__surfcloseSize, hv__surfminLength, hv__surfminWidth, hv__surfminArea,
                                        hv__surfselOperation, hv__surfImgIndex, hvec__DefectValue, out hvec__surfDefectType,
                                        out hvec__DefectValue, out hvec__surfDefectImgIdx, out hv__surfErrCode,
                                        out hv__surfErrStr);
                                    break;
                                case 1:
                                    //
                                    //'Gloal'方法检测参数
                                    hv__surfImgIndex = hvec_AroundBallPara[3][2].T.Clone();
                                    //检测图层
                                    ho_i_Image.Dispose();
                                    HOperatorSet.SelectObj(ho_i_Imgs, out ho_i_Image, hv__surfImgIndex);
                                    //
                                    hv__surfDilationSize = hvec_AroundBallPara[3][3].T.Clone();
                                    //
                                    hv__surfthreshGray = hvec_AroundBallPara[3][4].T.Clone();
                                    hv__surfthreshGrayInOrOut = hvec_AroundBallPara[3][5].T.Clone();
                                    hv__surfmorphSize = hvec_AroundBallPara[3][6].T.Clone();
                                    hv__surfcloseSize = hvec_AroundBallPara[3][7].T.Clone();
                                    hv__surfminLength = hvec_AroundBallPara[3][8].T.Clone();
                                    hv__surfminWidth = hvec_AroundBallPara[3][9].T.Clone();
                                    hv__surfminArea = hvec_AroundBallPara[3][10].T.Clone();
                                    hv__surfselOperation = hvec_AroundBallPara[3][11].T.Clone();
                                    //
                                    //参考设置值
                                    HTuple end_val236 = hv_objNum - 1;
                                    HTuple step_val236 = 1;
                                    for (hv_Idx = 0; hv_Idx.Continue(end_val236, step_val236); hv_Idx = hv_Idx.TupleAdd(step_val236))
                                    {
                                        hvec__RefValue[hv_Idx][3] = (((new HTupleVector(1).Insert(0, new HTupleVector(hv__surfminArea))).Insert(
                                            1, new HTupleVector(new HTuple(0)))).Insert(2, new HTupleVector(new HTuple(0))));
                                    }
                                    //
                                    //AroundBond周围外来物缺陷检测
                                    hvec__surfFailReg.Dispose();
                                    HTV_AroundBallSeg_Inspect_Global(ho_i_Image, ho__PadContours, ho__BondContours,
                                        ho_i_RejectReg, ho__TailReg, out hvec__surfFailReg, hv__surfDilationSize,
                                        hv__surfthreshGray, hv__surfthreshGrayInOrOut, hv__surfmorphSize,
                                        hv__surfcloseSize, hv__surfminLength, hv__surfminWidth, hv__surfminArea,
                                        hv__surfselOperation, hv__surfImgIndex, hvec__DefectValue, out hvec__surfDefectType,
                                        out hvec__DefectValue, out hvec__surfDefectImgIdx, out hv__surfErrCode,
                                        out hv__surfErrStr);
                                    break;
                                default:
                                    break;
                            }
                        }
                        else
                        {
                            //该项不检测输出结果
                            HTuple end_val248 = hv_objNum - 1;
                            HTuple step_val248 = 1;
                            for (hv_Idx = 0; hv_Idx.Continue(end_val248, step_val248); hv_Idx = hv_Idx.TupleAdd(step_val248))
                            {
                                hvec__surfFailReg[hv_Idx] = new HObjectVector(ho_EmptyObject.CopyObj(1, -1));
                                hvec__surfDefectType[hv_Idx] = new HTupleVector(new HTuple());
                                hvec__surfDefectImgIdx[hv_Idx] = new HTupleVector(new HTuple());
                                hvec__DefectValue[hv_Idx][3] = (((new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(0)))).Insert(
                                    1, new HTupleVector(new HTuple(0)))).Insert(2, new HTupleVector(new HTuple(0))));
                                hvec__RefValue[hv_Idx][3] = (((new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(-2)))).Insert(
                                    1, new HTupleVector(new HTuple(0)))).Insert(2, new HTupleVector(new HTuple(0))));
                            }
                        }
                        //
                        //整合检测结果
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hvec__FailReg = dh.Add(new HObjectVector(1));
                        }
                        hvec__DefectType = new HTupleVector(1);
                        hvec__DefectImgIdx = new HTupleVector(1);
                        HTuple end_val261 = hv_objNum - 1;
                        HTuple step_val261 = 1;
                        for (hv_Idx = 0; hv_Idx.Continue(end_val261, step_val261); hv_Idx = hv_Idx.TupleAdd(step_val261))
                        {
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                ho_ObjectsConcat.Dispose();
                                HOperatorSet.ConcatObj(hvec__shiftFailReg[hv_Idx].O, hvec__tailFailReg[hv_Idx].O,
                                    out ho_ObjectsConcat);
                            }
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                ho__FailRegConcat.Dispose();
                                HOperatorSet.ConcatObj(hvec__surfFailReg[hv_Idx].O, ho_ObjectsConcat,
                                    out ho__FailRegConcat);
                            }
                            hvec__FailReg[hv_Idx] = new HObjectVector(ho__FailRegConcat.CopyObj(1, -1));
                            hvec__DefectType[hv_Idx] = new HTupleVector((((hvec__shiftDefectType[hv_Idx].T).TupleConcat(
                                hvec__tailDefectType[hv_Idx].T))).TupleConcat(hvec__surfDefectType[hv_Idx].T));
                            hvec__DefectImgIdx[hv_Idx] = new HTupleVector((((hvec__shiftDefectImgIdx[hv_Idx].T).TupleConcat(
                                hvec__tailDefectImgIdx[hv_Idx].T))).TupleConcat(hvec__surfDefectImgIdx[hv_Idx].T));
                        }
                        //
                    }
                    else
                    {
                        //
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hvec__FailReg = dh.Add(new HObjectVector(1));
                        }
                        hvec__DefectType = new HTupleVector(1);
                        hvec__DefectImgIdx = new HTupleVector(1);
                        HTuple end_val274 = hv_objNum - 1;
                        HTuple step_val274 = 1;
                        for (hv_Idx = 0; hv_Idx.Continue(end_val274, step_val274); hv_Idx = hv_Idx.TupleAdd(step_val274))
                        {
                            hvec__FailReg[hv_Idx] = new HObjectVector(ho_EmptyObject.CopyObj(1, -1));
                            hvec__DefectType[hv_Idx] = new HTupleVector(new HTuple());
                            hvec__DefectImgIdx[hv_Idx] = new HTupleVector(new HTuple());

                            hvec__DefectValue[hv_Idx][1] = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(-2))));
                            hvec__DefectValue[hv_Idx][2] = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(-2))));
                            hvec__DefectValue[hv_Idx][3] = (((new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(0)))).Insert(
                                1, new HTupleVector(new HTuple(0)))).Insert(2, new HTupleVector(new HTuple(0))));

                            hvec__RefValue[hv_Idx][1] = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(-2))));
                            hvec__RefValue[hv_Idx][2] = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(-2))));
                            hvec__RefValue[hv_Idx][3] = (((new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(-2)))).Insert(
                                1, new HTupleVector(new HTuple(0)))).Insert(2, new HTupleVector(new HTuple(0))));
                        }
                    }
                    //
                    //整合AroundBond周围检测结果
                    hvec_o_FailRegs[hv_objIdx] = hvec__FailReg.Clone();
                    hvec_o_DefectTypes[hv_objIdx] = hvec__DefectType.Clone();
                    hvec_o_DefectValue[hv_objIdx] = hvec__DefectValue.Clone();
                    hvec_o_DefectImgIdx[hv_objIdx] = hvec__DefectImgIdx.Clone();
                    hvec_o_RefValue[hv_objIdx] = hvec__RefValue.Clone();
                    //
                }
                //
                HTV_Vector_to_Tuple_2d(hvec_o_DefectTypes, out hv_DefectTypeTup, out hv__VecErrCode,
                    out hv__VecErrStr);
                HOperatorSet.TupleSum(hv_DefectTypeTup, out hv_TupSum);

                if ((int)(new HTuple(hv_TupSum.TupleGreater(0))) != 0)
                {
                    hv_o_ErrCode = 1;
                    hv_o_ErrStr = "aroundBond has defcet";
                }
                else
                {
                    hv_o_ErrCode = 0;
                    hv_o_ErrStr = "Success to inspect aroundBond";
                }

                ho_EmptyObject.Dispose();
                ho_EmptyRegion.Dispose();
                ho__InspectObj.Dispose();
                ho__RefPadObj.Dispose();
                ho_i_Image.Dispose();
                ho__BondContours.Dispose();
                ho__PadContours.Dispose();
                ho__TailReg.Dispose();
                ho_ObjectsConcat.Dispose();
                ho__FailRegConcat.Dispose();
                hvec__shiftFailReg.Dispose();
                hvec__tailFailReg.Dispose();
                hvec__surfFailReg.Dispose();
                hvec__FailReg.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_EmptyObject.Dispose();
                ho_EmptyRegion.Dispose();
                ho__InspectObj.Dispose();
                ho__RefPadObj.Dispose();
                ho_i_Image.Dispose();
                ho__BondContours.Dispose();
                ho__PadContours.Dispose();
                ho__TailReg.Dispose();
                ho_ObjectsConcat.Dispose();
                ho__FailRegConcat.Dispose();
                hvec__shiftFailReg.Dispose();
                hvec__tailFailReg.Dispose();
                hvec__surfFailReg.Dispose();
                hvec__FailReg.Dispose();

                throw HDevExpDefaultException;
            }
        }

        #region aroundBall检测引用算法

        public static void HTV_ArondBallSeg_Inspect_Adative(HObject ho_i_Image, HObject ho_i_PadContours,
            HObject ho_i_BondContours, HObject ho_i_RejectReg, HObject ho_i_TailReg, out HObjectVector/*{eObjectVector,Dim=1}*/ hvec_o_FailReg,
            HTuple hv_i_ballDilationSize, HTuple hv_i_AdaptiveMethod, HTuple hv_i_BlockSize,
            HTuple hv_i_Contrast, HTuple hv_i_LightOrDark, HTuple hv_i_CloseSize, HTuple hv_i_MinLength,
            HTuple hv_i_MinWidth, HTuple hv_i_MinArea, HTuple hv_i_SelOperation, HTuple hv_i_ImgIdx,
            HTupleVector/*{eTupleVector,Dim=3}*/ hvec_i_DefectValue, out HTupleVector/*{eTupleVector,Dim=1}*/ hvec_o_DefectType,
            out HTupleVector/*{eTupleVector,Dim=3}*/ hvec_o_DefectValue, out HTupleVector/*{eTupleVector,Dim=1}*/ hvec_o_DefectImgIdx,
            out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {




            // Local iconic variables 

            HObject ho_EmptyRegion, ho_EmptyObj, ho_refBallReg = null;
            HObject ho_refPadReg = null, ho_RegionDilation = null, ho__TailRejectReg = null;
            HObject ho_RegionDifference1 = null, ho_RegionDifference = null;
            HObject ho_AroundBondReg = null, ho__AroundBallImage = null;
            HObject ho__SegImage = null, ho__SubReg = null, ho_o_TargetRegs = null;
            HObject ho_RegionUnion = null;

            // Local control variables 

            HTuple hv_PadNum = null, hv_ballNum = null;
            HTuple hv_regIdx = new HTuple(), hv_Area1 = new HTuple();
            HTuple hv_Row1 = new HTuple(), hv_Column1 = new HTuple();
            HTuple hv__ThresholdErrCode = new HTuple(), hv__ThresholdErrStr = new HTuple();
            HTuple hv__BlobErrCode = new HTuple(), hv__BlobErrStr = new HTuple();
            HTuple hv_Number = new HTuple(), hv_AreaPad = new HTuple();
            HTuple hv_RowPad = new HTuple(), hv_ColumnPad = new HTuple();
            HTuple hv_TypeSum = null, hv_i = null, hv_TypeTup = new HTuple();
            HTuple hv_TmpSum = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_EmptyRegion);
            HOperatorSet.GenEmptyObj(out ho_EmptyObj);
            HOperatorSet.GenEmptyObj(out ho_refBallReg);
            HOperatorSet.GenEmptyObj(out ho_refPadReg);
            HOperatorSet.GenEmptyObj(out ho_RegionDilation);
            HOperatorSet.GenEmptyObj(out ho__TailRejectReg);
            HOperatorSet.GenEmptyObj(out ho_RegionDifference1);
            HOperatorSet.GenEmptyObj(out ho_RegionDifference);
            HOperatorSet.GenEmptyObj(out ho_AroundBondReg);
            HOperatorSet.GenEmptyObj(out ho__AroundBallImage);
            HOperatorSet.GenEmptyObj(out ho__SegImage);
            HOperatorSet.GenEmptyObj(out ho__SubReg);
            HOperatorSet.GenEmptyObj(out ho_o_TargetRegs);
            HOperatorSet.GenEmptyObj(out ho_RegionUnion);
            hvec_o_FailReg = new HObjectVector(1);
            try
            {
                //**************************************************************************************************
                //---函数：HTV_ArondBallSeg_Inspect_Adative
                //---功能：使用自适应阈值分割的方法进行Bond周围检测验证
                //---参数：
                //===图标参数
                //  i_Image：输入图像，Object类型
                //  i_InspectReg：检测参考区域，使用该区域通过膨胀生成周围检测区域
                //  i_RejectReg：拒绝区，一般指检测得到的Wire区域
                //  o_FailReg：检测到的具有缺陷的区域
                //===控制参数
                //  i_RegDilationSize ：参考Bond区域膨胀尺寸
                //  i_AdaptiveMethod：局部阈值分割方法，取值为'mean'  'median'
                //  i_BlockSize: 邻域大小，即局部阈值分割的尺寸
                //  i_Contrast: 灰度对比度，即超过阈值多大的范围视为感兴趣的目标
                //  i_LightOrDark：感兴趣的目标的“亮”or“暗”
                //  i_CloseSize：闭运算尺寸
                //  i_MinLength：缺陷最小外接矩形半长,为一个向量，针对各重点检测区和非重点检测区分别设置不同参数
                //　 i_MinWidth：缺陷最小外接矩形半宽,为一个向量，针对各重点检测区和非重点检测区分别设置不同参数
                //  i_MinArea：缺陷最小面积,为一个向量，针对各重点检测区和非重点检测区分别设置不同参数
                //  i_SelOperation：形状选择算子and或or等
                //  o_DefectType：输出的检测得到的异常区域的缺陷类型
                //  o_ErrCode: 错误码，代表该算子执行过程中产生的错误，0-代表正常执行，-1-代表异常，-2-代表未执行
                //  o_ErrStr: 错误信息，对各种错误的具体描述
                //**************************************************************************************************
                //初始化
                ho_EmptyRegion.Dispose();
                HOperatorSet.GenEmptyRegion(out ho_EmptyRegion);
                ho_EmptyObj.Dispose();
                HOperatorSet.GenEmptyObj(out ho_EmptyObj);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hvec_o_FailReg = dh.Take((
                        dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho_EmptyObj)))));
                }
                hvec_o_DefectType = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())));
                hvec_o_DefectImgIdx = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())));
                hvec_o_DefectValue = hvec_i_DefectValue.Clone();

                hv_o_ErrCode = -2;
                hv_o_ErrStr = "initializing";
                //
                //参数有效性测试

                //-------------------------*****---Inspect---******-----------------------
                //
                //获取检测bond周围检测数量
                HOperatorSet.CountObj(ho_i_PadContours, out hv_PadNum);
                HOperatorSet.CountObj(ho_i_BondContours, out hv_ballNum);

                if ((int)(new HTuple(hv_ballNum.TupleEqual(hv_PadNum))) != 0)
                {
                    //
                    //bond周围逐一检测
                    HTuple end_val46 = hv_PadNum - 1;
                    HTuple step_val46 = 1;
                    for (hv_regIdx = 0; hv_regIdx.Continue(end_val46, step_val46); hv_regIdx = hv_regIdx.TupleAdd(step_val46))
                    {
                        //获取Ball区域
                        ho_refBallReg.Dispose();
                        HOperatorSet.SelectObj(ho_i_BondContours, out ho_refBallReg, hv_regIdx + 1);
                        HOperatorSet.AreaCenter(ho_refBallReg, out hv_Area1, out hv_Row1, out hv_Column1);
                        //判断焊点是否有缺陷，如果有则不检测焊盘上异物
                        if ((int)(new HTuple(hv_Area1.TupleNotEqual(0))) != 0)
                        {
                            //进行焊盘外来物检测
                            //获取Pad区域
                            ho_refPadReg.Dispose();
                            HOperatorSet.SelectObj(ho_i_PadContours, out ho_refPadReg, hv_regIdx + 1);
                            //对焊点/尾丝区域进行膨胀,作为免检测区域
                            ho_RegionDilation.Dispose();
                            HOperatorSet.DilationCircle(ho_refBallReg, out ho_RegionDilation, hv_i_ballDilationSize);
                            ho__TailRejectReg.Dispose();
                            HOperatorSet.DilationCircle(ho_i_TailReg, out ho__TailRejectReg, 3.5);
                            //-------获取Bond周围检测区域
                            //焊盘区域去掉免检区域集合 mod by lw 1217
                            ho_RegionDifference1.Dispose();
                            HOperatorSet.Difference(ho_refPadReg, ho__TailRejectReg, out ho_RegionDifference1
                                );
                            ho_RegionDifference.Dispose();
                            HOperatorSet.Difference(ho_RegionDifference1, ho_i_RejectReg, out ho_RegionDifference
                                );
                            //去掉免检焊点区域
                            ho_AroundBondReg.Dispose();
                            HOperatorSet.Difference(ho_RegionDifference, ho_RegionDilation, out ho_AroundBondReg
                                );
                            //获取AroundBond检测图像
                            ho__AroundBallImage.Dispose();
                            HOperatorSet.ReduceDomain(ho_i_Image, ho_AroundBondReg, out ho__AroundBallImage
                                );
                            //
                            ho__SegImage.Dispose();
                            HTV_Adaptive_Threshold_Opt(ho__AroundBallImage, out ho__SegImage, hv_i_AdaptiveMethod,
                                hv_i_BlockSize, hv_i_Contrast, hv_i_LightOrDark, out hv__ThresholdErrCode,
                                out hv__ThresholdErrStr);

                            if ((int)(new HTuple(hv__ThresholdErrCode.TupleEqual(0))) != 0)
                            {
                                //对阈值分割后的目标区域图像进行BLOB分析
                                ho__SubReg.Dispose();
                                HOperatorSet.GenEmptyObj(out ho__SubReg);
                                ho_o_TargetRegs.Dispose();
                                HTV_BLOB_Extract(ho__SegImage, ho_AroundBondReg, ho__SubReg, out ho_o_TargetRegs,
                                    hv_i_CloseSize, hv_i_MinLength, hv_i_MinWidth, hv_i_MinArea, hv_i_SelOperation,
                                    out hv__BlobErrCode, out hv__BlobErrStr);

                                //对Blob分析后的结果进行缺陷判断
                                HOperatorSet.CountObj(ho_o_TargetRegs, out hv_Number);
                                if ((int)((new HTuple(hv__BlobErrCode.TupleEqual(0))).TupleAnd(new HTuple(hv_Number.TupleGreaterEqual(
                                    1)))) != 0)
                                {
                                    //缺陷区域Concat
                                    ho_RegionUnion.Dispose();
                                    HOperatorSet.Union1(ho_o_TargetRegs, out ho_RegionUnion);
                                    hvec_o_FailReg[hv_regIdx] = new HObjectVector(ho_RegionUnion.CopyObj(1, -1));
                                    //缺陷Type
                                    hvec_o_DefectType[hv_regIdx] = new HTupleVector(new HTuple(31));
                                    hvec_o_DefectImgIdx[hv_regIdx] = new HTupleVector(hv_i_ImgIdx).Clone();
                                    //
                                    //异物信息独立统计 lw
                                    HOperatorSet.AreaCenter(ho_o_TargetRegs, out hv_AreaPad, out hv_RowPad,
                                        out hv_ColumnPad);
                                    hvec_o_DefectValue[hv_regIdx][3] = (((new HTupleVector(1).Insert(0, new HTupleVector(hv_AreaPad))).Insert(
                                        1, new HTupleVector(hv_RowPad))).Insert(2, new HTupleVector(hv_ColumnPad)));
                                    //
                                }
                                else if ((int)((new HTuple(hv__BlobErrCode.TupleEqual(
                                    0))).TupleAnd(new HTuple(hv_Number.TupleEqual(0)))) != 0)
                                {
                                    //无缺陷
                                    hvec_o_FailReg[hv_regIdx] = new HObjectVector(ho_EmptyObj.CopyObj(1, -1));
                                    hvec_o_DefectType[hv_regIdx] = new HTupleVector(new HTuple());
                                    hvec_o_DefectImgIdx[hv_regIdx] = new HTupleVector(new HTuple());
                                    hvec_o_DefectValue[hv_regIdx][3] = (((new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(0)))).Insert(
                                        1, new HTupleVector(new HTuple(0)))).Insert(2, new HTupleVector(new HTuple(0))));
                                }
                                else
                                {
                                    //异常处理
                                    hv_o_ErrCode = -1;
                                    hv_o_ErrStr = "Fail to Surface Blob_Extract--" + hv__BlobErrStr;
                                    ho_EmptyRegion.Dispose();
                                    ho_EmptyObj.Dispose();
                                    ho_refBallReg.Dispose();
                                    ho_refPadReg.Dispose();
                                    ho_RegionDilation.Dispose();
                                    ho__TailRejectReg.Dispose();
                                    ho_RegionDifference1.Dispose();
                                    ho_RegionDifference.Dispose();
                                    ho_AroundBondReg.Dispose();
                                    ho__AroundBallImage.Dispose();
                                    ho__SegImage.Dispose();
                                    ho__SubReg.Dispose();
                                    ho_o_TargetRegs.Dispose();
                                    ho_RegionUnion.Dispose();

                                    return;
                                }
                            }
                            else
                            {
                                //异常处理
                                hv_o_ErrCode = -1;
                                hv_o_ErrStr = "Fail to Surface threshold" + hv__ThresholdErrStr;
                                ho_EmptyRegion.Dispose();
                                ho_EmptyObj.Dispose();
                                ho_refBallReg.Dispose();
                                ho_refPadReg.Dispose();
                                ho_RegionDilation.Dispose();
                                ho__TailRejectReg.Dispose();
                                ho_RegionDifference1.Dispose();
                                ho_RegionDifference.Dispose();
                                ho_AroundBondReg.Dispose();
                                ho__AroundBallImage.Dispose();
                                ho__SegImage.Dispose();
                                ho__SubReg.Dispose();
                                ho_o_TargetRegs.Dispose();
                                ho_RegionUnion.Dispose();

                                return;
                            }
                        }
                        else
                        {
                            //无缺陷
                            hvec_o_FailReg[hv_regIdx] = new HObjectVector(ho_EmptyObj.CopyObj(1, -1));
                            hvec_o_DefectType[hv_regIdx] = new HTupleVector(new HTuple());
                            hvec_o_DefectImgIdx[hv_regIdx] = new HTupleVector(new HTuple());
                            hvec_o_DefectValue[hv_regIdx][3] = (((new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(0)))).Insert(
                                1, new HTupleVector(new HTuple(0)))).Insert(2, new HTupleVector(new HTuple(0))));
                        }
                    }
                }
                else
                {
                    //
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "ball number is not equal to pad number";
                    ho_EmptyRegion.Dispose();
                    ho_EmptyObj.Dispose();
                    ho_refBallReg.Dispose();
                    ho_refPadReg.Dispose();
                    ho_RegionDilation.Dispose();
                    ho__TailRejectReg.Dispose();
                    ho_RegionDifference1.Dispose();
                    ho_RegionDifference.Dispose();
                    ho_AroundBondReg.Dispose();
                    ho__AroundBallImage.Dispose();
                    ho__SegImage.Dispose();
                    ho__SubReg.Dispose();
                    ho_o_TargetRegs.Dispose();
                    ho_RegionUnion.Dispose();

                    return;
                }
                //
                hv_TypeSum = new HTuple();
                HTuple end_val122 = new HTuple(hvec_o_DefectType.Length) - 1;
                HTuple step_val122 = 1;
                for (hv_i = 0; hv_i.Continue(end_val122, step_val122); hv_i = hv_i.TupleAdd(step_val122))
                {
                    hv_TypeTup = hvec_o_DefectType[hv_i].T.Clone();
                    HOperatorSet.TupleSum(hv_TypeTup, out hv_TmpSum);
                    hv_TypeSum = hv_TypeSum + hv_TmpSum;
                }

                if ((int)(new HTuple(hv_TypeSum.TupleGreater(0))) != 0)
                {
                    hv_o_ErrCode = 1;
                    hv_o_ErrStr = "AroundBond is dirty";
                    ho_EmptyRegion.Dispose();
                    ho_EmptyObj.Dispose();
                    ho_refBallReg.Dispose();
                    ho_refPadReg.Dispose();
                    ho_RegionDilation.Dispose();
                    ho__TailRejectReg.Dispose();
                    ho_RegionDifference1.Dispose();
                    ho_RegionDifference.Dispose();
                    ho_AroundBondReg.Dispose();
                    ho__AroundBallImage.Dispose();
                    ho__SegImage.Dispose();
                    ho__SubReg.Dispose();
                    ho_o_TargetRegs.Dispose();
                    ho_RegionUnion.Dispose();

                    return;
                }
                else
                {
                    //
                    hv_o_ErrCode = 0;
                    hv_o_ErrStr = "AroundBond is clear";
                    ho_EmptyRegion.Dispose();
                    ho_EmptyObj.Dispose();
                    ho_refBallReg.Dispose();
                    ho_refPadReg.Dispose();
                    ho_RegionDilation.Dispose();
                    ho__TailRejectReg.Dispose();
                    ho_RegionDifference1.Dispose();
                    ho_RegionDifference.Dispose();
                    ho_AroundBondReg.Dispose();
                    ho__AroundBallImage.Dispose();
                    ho__SegImage.Dispose();
                    ho__SubReg.Dispose();
                    ho_o_TargetRegs.Dispose();
                    ho_RegionUnion.Dispose();

                    return;
                }
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_EmptyRegion.Dispose();
                ho_EmptyObj.Dispose();
                ho_refBallReg.Dispose();
                ho_refPadReg.Dispose();
                ho_RegionDilation.Dispose();
                ho__TailRejectReg.Dispose();
                ho_RegionDifference1.Dispose();
                ho_RegionDifference.Dispose();
                ho_AroundBondReg.Dispose();
                ho__AroundBallImage.Dispose();
                ho__SegImage.Dispose();
                ho__SubReg.Dispose();
                ho_o_TargetRegs.Dispose();
                ho_RegionUnion.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public static void HTV_AroundBallSeg_Inspect_Global(HObject ho_i_Image, HObject ho_i_PadContours,
            HObject ho_i_BondContours, HObject ho_i_RejectReg, HObject ho_i_TailReg, out HObjectVector/*{eObjectVector,Dim=1}*/ hvec_o_FailReg,
            HTuple hv_i_ballDilationSize, HTuple hv_i_ThreshGray, HTuple hv_i_ThresholdInorOut,
            HTuple hv_i_MorphSize, HTuple hv_i_CloseSize, HTuple hv_i_MinLength, HTuple hv_i_MinWidth,
            HTuple hv_i_MinArea, HTuple hv_i_SelOperation, HTuple hv_i_ImgIdx, HTupleVector/*{eTupleVector,Dim=3}*/ hvec_i_DefectValue,
            out HTupleVector/*{eTupleVector,Dim=1}*/ hvec_o_DefectType, out HTupleVector/*{eTupleVector,Dim=3}*/ hvec_o_DefectValue,
            out HTupleVector/*{eTupleVector,Dim=1}*/ hvec_o_DefectImgIdx, out HTuple hv_o_ErrCode,
            out HTuple hv_o_ErrStr)
        {




            // Local iconic variables 

            HObject ho_EmptyRegion, ho_EmptyObj, ho_refBallReg = null;
            HObject ho_refPadReg = null, ho_RegionDilation = null, ho__TailRejectReg = null;
            HObject ho_RegionDifference1 = null, ho_RegionDifference = null;
            HObject ho_AroundBondReg = null, ho__AroundBallImage = null;
            HObject ho__SegImage = null, ho__SubReg = null, ho_o_Targets = null;
            HObject ho_RegionUnion = null;

            // Local control variables 

            HTuple hv_PadNum = null, hv_ballNum = null;
            HTuple hv_regIdx = new HTuple(), hv_Area1 = new HTuple();
            HTuple hv_Row1 = new HTuple(), hv_Column1 = new HTuple();
            HTuple hv__ThresholdErrCode = new HTuple(), hv__ThresholdErrStr = new HTuple();
            HTuple hv__BlobErrCode = new HTuple(), hv__BlobErrStr = new HTuple();
            HTuple hv_Number = new HTuple(), hv_AreaPad = new HTuple();
            HTuple hv_RowPad = new HTuple(), hv_ColumnPad = new HTuple();
            HTuple hv_TypeSum = null, hv_i = null, hv_TypeTup = new HTuple();
            HTuple hv_TmpSum = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_EmptyRegion);
            HOperatorSet.GenEmptyObj(out ho_EmptyObj);
            HOperatorSet.GenEmptyObj(out ho_refBallReg);
            HOperatorSet.GenEmptyObj(out ho_refPadReg);
            HOperatorSet.GenEmptyObj(out ho_RegionDilation);
            HOperatorSet.GenEmptyObj(out ho__TailRejectReg);
            HOperatorSet.GenEmptyObj(out ho_RegionDifference1);
            HOperatorSet.GenEmptyObj(out ho_RegionDifference);
            HOperatorSet.GenEmptyObj(out ho_AroundBondReg);
            HOperatorSet.GenEmptyObj(out ho__AroundBallImage);
            HOperatorSet.GenEmptyObj(out ho__SegImage);
            HOperatorSet.GenEmptyObj(out ho__SubReg);
            HOperatorSet.GenEmptyObj(out ho_o_Targets);
            HOperatorSet.GenEmptyObj(out ho_RegionUnion);
            hvec_o_FailReg = new HObjectVector(1);
            try
            {
                //****************************************************************
                //---函数：HTV_AroundBallSeg_Inspect_Global
                //---功能：使用全局阈值分割的方法进行Bond周围检测验证
                //---参数：
                //===图标参数
                //  i_Image：输入图像，Object类型
                //  i_RefInspectReg：检测参考区域，使用该区域通过膨胀生成周围检测区域
                //  i_RejectReg：拒绝区，一般指检测得到的Wire区域
                //  o_FailReg：检测到的具有缺陷的区域
                //===控制参数
                //  i_RegDilationSize ：参考Bond区域膨胀尺寸
                //  i_ThreshGray：设定阈值灰度大小
                //  i_ThresholdInorOut: 区分是阈值大小内是感兴趣区域还是之外是感兴趣区域
                //  i_MorphSize: 开运算大小
                //  i_CloseSize：闭运算尺寸
                //  i_MinLength：缺陷最小外接矩形半长,为一个向量，针对各重点检测区和非重点检测区分别设置不同参数
                //　 i_MinWidth：缺陷最小外接矩形半宽,为一个向量，针对各重点检测区和非重点检测区分别设置不同参数
                //  i_MinArea：缺陷最小面积,为一个向量，针对各重点检测区和非重点检测区分别设置不同参数
                //  i_SelOperation：形状选择算子and或or等
                //  o_DefectType：输出的检测得到的异常区域的缺陷类型
                //  o_ErrCode: 错误码，代表该算子执行过程中产生的错误，0-代表正常执行，-1-代表异常，-2-代表未执行
                //  o_ErrStr: 错误信息，对各种错误的具体描述
                //********************************************************************
                //初始化
                ho_EmptyRegion.Dispose();
                HOperatorSet.GenEmptyRegion(out ho_EmptyRegion);
                ho_EmptyObj.Dispose();
                HOperatorSet.GenEmptyObj(out ho_EmptyObj);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hvec_o_FailReg = dh.Take((
                        dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho_EmptyObj)))));
                }
                hvec_o_DefectType = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())));
                hvec_o_DefectImgIdx = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())));
                hvec_o_DefectValue = hvec_i_DefectValue.Clone();

                hv_o_ErrCode = -2;
                hv_o_ErrStr = "initializing";
                //
                //参数有效性测试

                //-------------------------*****---Inspect---******-----------------------
                //
                //获取检测bond周围检测数量
                HOperatorSet.CountObj(ho_i_PadContours, out hv_PadNum);
                HOperatorSet.CountObj(ho_i_BondContours, out hv_ballNum);

                if ((int)(new HTuple(hv_ballNum.TupleEqual(hv_PadNum))) != 0)
                {
                    //
                    //bond周围逐一检测
                    HTuple end_val45 = hv_PadNum;
                    HTuple step_val45 = 1;
                    for (hv_regIdx = 1; hv_regIdx.Continue(end_val45, step_val45); hv_regIdx = hv_regIdx.TupleAdd(step_val45))
                    {
                        //获取Ball区域
                        ho_refBallReg.Dispose();
                        HOperatorSet.SelectObj(ho_i_BondContours, out ho_refBallReg, hv_regIdx);
                        HOperatorSet.AreaCenter(ho_refBallReg, out hv_Area1, out hv_Row1, out hv_Column1);
                        //判断焊点是否有缺陷，如果有则不检测焊盘上异物
                        if ((int)(new HTuple(hv_Area1.TupleNotEqual(0))) != 0)
                        {
                            //进行焊盘外来物检测
                            //获取Pad区域
                            ho_refPadReg.Dispose();
                            HOperatorSet.SelectObj(ho_i_PadContours, out ho_refPadReg, hv_regIdx);
                            //对焊点/尾丝区域进行膨胀
                            ho_RegionDilation.Dispose();
                            HOperatorSet.DilationCircle(ho_refBallReg, out ho_RegionDilation, hv_i_ballDilationSize);
                            ho__TailRejectReg.Dispose();
                            HOperatorSet.DilationCircle(ho_i_TailReg, out ho__TailRejectReg, 3.5);
                            //-------获取Bond周围检测区域
                            //焊盘区域去掉免检区域集合 mod by lw 1217
                            ho_RegionDifference1.Dispose();
                            HOperatorSet.Difference(ho_refPadReg, ho__TailRejectReg, out ho_RegionDifference1
                                );
                            ho_RegionDifference.Dispose();
                            HOperatorSet.Difference(ho_RegionDifference1, ho_i_RejectReg, out ho_RegionDifference
                                );
                            //焊盘去掉免检焊点区域
                            ho_AroundBondReg.Dispose();
                            HOperatorSet.Difference(ho_RegionDifference, ho_RegionDilation, out ho_AroundBondReg
                                );
                            //获取AroundBond检测图像
                            ho__AroundBallImage.Dispose();
                            HOperatorSet.ReduceDomain(ho_i_Image, ho_AroundBondReg, out ho__AroundBallImage
                                );
                            //
                            ho__SegImage.Dispose();
                            HTV_Global_Threshold(ho__AroundBallImage, out ho__SegImage, hv_i_ThreshGray,
                                hv_i_ThresholdInorOut, hv_i_MorphSize, out hv__ThresholdErrCode,
                                out hv__ThresholdErrStr);
                            if ((int)(new HTuple(hv__ThresholdErrCode.TupleEqual(0))) != 0)
                            {
                                //对阈值分割后的目标区域图像进行BLOB分析
                                ho__SubReg.Dispose();
                                HOperatorSet.GenEmptyObj(out ho__SubReg);
                                ho_o_Targets.Dispose();
                                HTV_BLOB_Extract(ho__SegImage, ho_AroundBondReg, ho__SubReg, out ho_o_Targets,
                                    hv_i_CloseSize, hv_i_MinLength, hv_i_MinWidth, hv_i_MinArea, hv_i_SelOperation,
                                    out hv__BlobErrCode, out hv__BlobErrStr);

                                //对Blob分析后的结果进行缺陷判断
                                HOperatorSet.CountObj(ho_o_Targets, out hv_Number);
                                if ((int)((new HTuple(hv__BlobErrCode.TupleEqual(0))).TupleAnd(new HTuple(hv_Number.TupleGreaterEqual(
                                    1)))) != 0)
                                {
                                    //缺陷区域Concat
                                    ho_RegionUnion.Dispose();
                                    HOperatorSet.Union1(ho_o_Targets, out ho_RegionUnion);
                                    hvec_o_FailReg[hv_regIdx] = new HObjectVector(ho_RegionUnion.CopyObj(1, -1));
                                    //缺陷Type
                                    hvec_o_DefectType[hv_regIdx] = new HTupleVector(new HTuple(31));
                                    hvec_o_DefectImgIdx[hv_regIdx] = new HTupleVector(hv_i_ImgIdx).Clone();
                                    //
                                    //异物信息独立统计 lw
                                    HOperatorSet.AreaCenter(ho_o_Targets, out hv_AreaPad, out hv_RowPad,
                                        out hv_ColumnPad);
                                    hvec_o_DefectValue[hv_regIdx - 1][3] = (((new HTupleVector(1).Insert(0, new HTupleVector(hv_AreaPad))).Insert(
                                        1, new HTupleVector(hv_RowPad))).Insert(2, new HTupleVector(hv_ColumnPad)));

                                }
                                else if ((int)((new HTuple(hv__BlobErrCode.TupleEqual(
                                    0))).TupleAnd(new HTuple(hv_Number.TupleEqual(0)))) != 0)
                                {
                                    //无缺陷
                                    hvec_o_FailReg[hv_regIdx] = new HObjectVector(ho_EmptyObj.CopyObj(1, -1));
                                    hvec_o_DefectType[hv_regIdx] = new HTupleVector(new HTuple());
                                    hvec_o_DefectImgIdx[hv_regIdx] = new HTupleVector(new HTuple());
                                    hvec_o_DefectValue[hv_regIdx - 1][3] = (((new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(0)))).Insert(
                                        1, new HTupleVector(new HTuple(0)))).Insert(2, new HTupleVector(new HTuple(0))));
                                }
                                else
                                {
                                    //异常处理
                                    hv_o_ErrCode = -1;
                                    hv_o_ErrStr = "Fail to Surface Blob_Extract--" + hv__BlobErrStr;
                                }
                            }
                            else
                            {
                                //异常处理
                                hv_o_ErrCode = -1;
                                hv_o_ErrStr = "Fail to Surface threshold" + hv__ThresholdErrStr;
                                ho_EmptyRegion.Dispose();
                                ho_EmptyObj.Dispose();
                                ho_refBallReg.Dispose();
                                ho_refPadReg.Dispose();
                                ho_RegionDilation.Dispose();
                                ho__TailRejectReg.Dispose();
                                ho_RegionDifference1.Dispose();
                                ho_RegionDifference.Dispose();
                                ho_AroundBondReg.Dispose();
                                ho__AroundBallImage.Dispose();
                                ho__SegImage.Dispose();
                                ho__SubReg.Dispose();
                                ho_o_Targets.Dispose();
                                ho_RegionUnion.Dispose();

                                return;
                            }
                        }
                        else
                        {
                            //无缺陷
                            hvec_o_FailReg[hv_regIdx] = new HObjectVector(ho_EmptyObj.CopyObj(1, -1));
                            hvec_o_DefectType[hv_regIdx] = new HTupleVector(new HTuple());
                            hvec_o_DefectImgIdx[hv_regIdx] = new HTupleVector(new HTuple());
                            hvec_o_DefectValue[hv_regIdx - 1][3] = (((new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(0)))).Insert(
                                1, new HTupleVector(new HTuple(0)))).Insert(2, new HTupleVector(new HTuple(0))));
                        }

                    }
                }
                else
                {
                    //
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "ball number is not equal to pad number";
                    ho_EmptyRegion.Dispose();
                    ho_EmptyObj.Dispose();
                    ho_refBallReg.Dispose();
                    ho_refPadReg.Dispose();
                    ho_RegionDilation.Dispose();
                    ho__TailRejectReg.Dispose();
                    ho_RegionDifference1.Dispose();
                    ho_RegionDifference.Dispose();
                    ho_AroundBondReg.Dispose();
                    ho__AroundBallImage.Dispose();
                    ho__SegImage.Dispose();
                    ho__SubReg.Dispose();
                    ho_o_Targets.Dispose();
                    ho_RegionUnion.Dispose();

                    return;
                }
                //
                hv_TypeSum = new HTuple();
                HTuple end_val120 = new HTuple(hvec_o_DefectType.Length) - 1;
                HTuple step_val120 = 1;
                for (hv_i = 0; hv_i.Continue(end_val120, step_val120); hv_i = hv_i.TupleAdd(step_val120))
                {
                    hv_TypeTup = hvec_o_DefectType[hv_i].T.Clone();
                    HOperatorSet.TupleSum(hv_TypeTup, out hv_TmpSum);
                    hv_TypeSum = hv_TypeSum + hv_TmpSum;
                }

                if ((int)(new HTuple(hv_TypeSum.TupleGreater(0))) != 0)
                {
                    hv_o_ErrCode = 1;
                    hv_o_ErrStr = "AroundBond is dirty";
                    ho_EmptyRegion.Dispose();
                    ho_EmptyObj.Dispose();
                    ho_refBallReg.Dispose();
                    ho_refPadReg.Dispose();
                    ho_RegionDilation.Dispose();
                    ho__TailRejectReg.Dispose();
                    ho_RegionDifference1.Dispose();
                    ho_RegionDifference.Dispose();
                    ho_AroundBondReg.Dispose();
                    ho__AroundBallImage.Dispose();
                    ho__SegImage.Dispose();
                    ho__SubReg.Dispose();
                    ho_o_Targets.Dispose();
                    ho_RegionUnion.Dispose();

                    return;
                }
                else
                {
                    //
                    hv_o_ErrCode = 0;
                    hv_o_ErrStr = "AroundBond is clear";
                    ho_EmptyRegion.Dispose();
                    ho_EmptyObj.Dispose();
                    ho_refBallReg.Dispose();
                    ho_refPadReg.Dispose();
                    ho_RegionDilation.Dispose();
                    ho__TailRejectReg.Dispose();
                    ho_RegionDifference1.Dispose();
                    ho_RegionDifference.Dispose();
                    ho_AroundBondReg.Dispose();
                    ho__AroundBallImage.Dispose();
                    ho__SegImage.Dispose();
                    ho__SubReg.Dispose();
                    ho_o_Targets.Dispose();
                    ho_RegionUnion.Dispose();

                    return;
                }

            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_EmptyRegion.Dispose();
                ho_EmptyObj.Dispose();
                ho_refBallReg.Dispose();
                ho_refPadReg.Dispose();
                ho_RegionDilation.Dispose();
                ho__TailRejectReg.Dispose();
                ho_RegionDifference1.Dispose();
                ho_RegionDifference.Dispose();
                ho_AroundBondReg.Dispose();
                ho__AroundBallImage.Dispose();
                ho__SegImage.Dispose();
                ho__SubReg.Dispose();
                ho_o_Targets.Dispose();
                ho_RegionUnion.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public static void HTV_AroundBallSeg_Inspect_LineGauss(HObject ho_i_Image, HObject ho_i_RefInspectReg,
            HObject ho_i_RejectReg, out HObjectVector/*{eObjectVector,Dim=1}*/ hvec_o_FailReg,
            out HObject ho_o_TailReg, HTuple hv_i_RegDilationSize, HTuple hv_i_LineWidth,
            HTuple hv_i_LineContrast, HTuple hv_i_Transition, HTuple hv_i_SelMetric, HTuple hv_i_SelMin,
            HTuple hv_i_SelMax, HTuple hv_i_LineGap, HTuple hv_i_TailGrayThresh, HTuple hv_i_TailLenTh,
            HTuple hv_i_ImgIdx, HTuple hv_i_WireJudgeAgain, HTupleVector/*{eTupleVector,Dim=3}*/ hvec_i_DefectValue,
            out HTupleVector/*{eTupleVector,Dim=1}*/ hvec_o_DefectType, out HTupleVector/*{eTupleVector,Dim=3}*/ hvec_o_DefectValue,
            out HTupleVector/*{eTupleVector,Dim=1}*/ hvec_o_DefectImgIdx, out HTuple hv_o_ErrCode,
            out HTuple hv_o_ErrStr)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_EmptyRegion, ho_EmptyObj, ho_refBallReg = null;
            HObject ho_refBallReg1 = null, ho_refBallReg2 = null, ho_refBallGroup = null;
            HObject ho_refBallGroupUnion = null, ho_refBallGroupUnionDilation = null;
            HObject ho_RegionDilation = null, ho_RegionDifference = null;
            HObject ho_AroundBondReg = null, ho_RegionDilation2 = null;
            HObject ho_CurWireReg = null, ho_CurWireRegConnection = null;
            HObject ho_AroundBondReg0 = null, ho__WireReg = null, ho__WireInspectReg = null;
            HObject ho_ImageReduced = null, ho__WireRegConnection = null;
            HObject ho__TailReg = null;

            // Local control variables 

            HTuple hv_refNum = null, hv_regIdx = null;
            HTuple hv_WiresArea = new HTuple(), hv_WiresRow = new HTuple();
            HTuple hv_WiresCol = new HTuple(), hv_WireArea = new HTuple();
            HTuple hv_MaxIndex = new HTuple(), hv_BallArea = new HTuple();
            HTuple hv_BallRow = new HTuple(), hv_BallCol = new HTuple();
            HTuple hv_WireRow = new HTuple(), hv_WireCol = new HTuple();
            HTuple hv_WireRefDirection = new HTuple(), hv__WireErrCode = new HTuple();
            HTuple hv__WireErrStr = new HTuple(), hv_WireRegArea = new HTuple();
            HTuple hv_WireRegRow = new HTuple(), hv_WireRegCol = new HTuple();
            HTuple hv_RegRow = new HTuple(), hv_RegCol = new HTuple();
            HTuple hv_RegPhi = new HTuple(), hv_RegLen1 = new HTuple();
            HTuple hv_RegLen2 = new HTuple(), hv_GrayMean = new HTuple();
            HTuple hv_GrayDev = new HTuple(), hv_AreaList = new HTuple();
            HTuple hv_RowList = new HTuple(), hv_ColList = new HTuple();
            HTuple hv_AreaMax = new HTuple(), hv_MaxIdx = new HTuple();
            HTuple hv_TailRefDirection = new HTuple(), hv__TailLength = new HTuple();
            HTuple hv__TailErrCode = new HTuple(), hv__TailErrStr = new HTuple();
            HTuple hv_TypeSum = null, hv_i = null, hv_TypeTup = new HTuple();
            HTuple hv_TmpSum = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_TailReg);
            HOperatorSet.GenEmptyObj(out ho_EmptyRegion);
            HOperatorSet.GenEmptyObj(out ho_EmptyObj);
            HOperatorSet.GenEmptyObj(out ho_refBallReg);
            HOperatorSet.GenEmptyObj(out ho_refBallReg1);
            HOperatorSet.GenEmptyObj(out ho_refBallReg2);
            HOperatorSet.GenEmptyObj(out ho_refBallGroup);
            HOperatorSet.GenEmptyObj(out ho_refBallGroupUnion);
            HOperatorSet.GenEmptyObj(out ho_refBallGroupUnionDilation);
            HOperatorSet.GenEmptyObj(out ho_RegionDilation);
            HOperatorSet.GenEmptyObj(out ho_RegionDifference);
            HOperatorSet.GenEmptyObj(out ho_AroundBondReg);
            HOperatorSet.GenEmptyObj(out ho_RegionDilation2);
            HOperatorSet.GenEmptyObj(out ho_CurWireReg);
            HOperatorSet.GenEmptyObj(out ho_CurWireRegConnection);
            HOperatorSet.GenEmptyObj(out ho_AroundBondReg0);
            HOperatorSet.GenEmptyObj(out ho__WireReg);
            HOperatorSet.GenEmptyObj(out ho__WireInspectReg);
            HOperatorSet.GenEmptyObj(out ho_ImageReduced);
            HOperatorSet.GenEmptyObj(out ho__WireRegConnection);
            HOperatorSet.GenEmptyObj(out ho__TailReg);
            hvec_o_FailReg = new HObjectVector(1);
            try
            {
                //**************************************************************************************************
                //---函数：HTV_AroundBallSeg_Inspect_LineGauss
                //---功能：使用自适应阈值分割的方法进行Bond周围检测验证
                //---参数：
                //===图标参数
                //  i_Image：输入图像，Object类型
                //  i_InspectReg：检测参考区域，使用该区域通过膨胀生成周围检测区域
                //  i_RejectReg：拒绝区，一般指检测得到的Wire区域
                //  o_FailReg：检测到的具有缺陷的区域
                //===控制参数
                //  i_RegDilationSize ：参考Bond区域膨胀尺寸
                //  i_AdaptiveMethod：局部阈值分割方法，取值为'mean'  'median'
                //  i_BlockSize: 邻域大小，即局部阈值分割的尺寸
                //  i_Contrast: 灰度对比度，即超过阈值多大的范围视为感兴趣的目标
                //  i_LightOrDark：感兴趣的目标的“亮”or“暗”
                //  i_CloseSize：闭运算尺寸
                //  i_MinLength：缺陷最小外接矩形半长,为一个向量，针对各重点检测区和非重点检测区分别设置不同参数
                //　 i_MinWidth：缺陷最小外接矩形半宽,为一个向量，针对各重点检测区和非重点检测区分别设置不同参数
                //  i_MinArea：缺陷最小面积,为一个向量，针对各重点检测区和非重点检测区分别设置不同参数
                //  i_SelOperation：形状选择算子and或or等
                //  o_DefectType：输出的检测得到的异常区域的缺陷类型
                //  o_ErrCode: 错误码，代表该算子执行过程中产生的错误，0-代表正常执行，-1-代表异常，-2-代表未执行
                //  o_ErrStr: 错误信息，对各种错误的具体描述
                //**************************************************************************************************
                //初始化
                ho_o_TailReg.Dispose();
                HOperatorSet.GenEmptyObj(out ho_o_TailReg);
                ho_EmptyRegion.Dispose();
                HOperatorSet.GenEmptyRegion(out ho_EmptyRegion);
                ho_EmptyObj.Dispose();
                HOperatorSet.GenEmptyObj(out ho_EmptyObj);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hvec_o_FailReg = dh.Take((
                        dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho_EmptyObj)))));
                }
                hvec_o_DefectType = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())));
                hvec_o_DefectImgIdx = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())));
                hvec_o_DefectValue = hvec_i_DefectValue.Clone();

                hv_o_ErrCode = -2;
                hv_o_ErrStr = "initializing";
                //
                //参数有效性测试
                //
                //-------------------------*****---Inspect---******-----------------------
                //
                //获取检测bond周围检测数量
                HOperatorSet.CountObj(ho_i_RefInspectReg, out hv_refNum);
                //bond周围逐一检测
                HTuple end_val43 = hv_refNum - 1;
                HTuple step_val43 = 1;
                for (hv_regIdx = 0; hv_regIdx.Continue(end_val43, step_val43); hv_regIdx = hv_regIdx.TupleAdd(step_val43))
                {
                    //获取参考Bond
                    ho_refBallReg.Dispose();
                    HOperatorSet.SelectObj(ho_i_RefInspectReg, out ho_refBallReg, hv_regIdx + 1);

                    //取前后参考Bond组, cut此部分作为选取金线cutReg依据 0105 - lw
                    if ((int)(new HTuple(hv_refNum.TupleGreater(2))) != 0)
                    {
                        if ((int)(new HTuple(hv_regIdx.TupleEqual(0))) != 0)
                        {
                            ho_refBallReg1.Dispose();
                            HOperatorSet.SelectObj(ho_i_RefInspectReg, out ho_refBallReg1, hv_refNum);
                            ho_refBallReg2.Dispose();
                            HOperatorSet.SelectObj(ho_i_RefInspectReg, out ho_refBallReg2, 2);
                        }
                        else if ((int)(new HTuple(hv_regIdx.TupleEqual(hv_refNum - 1))) != 0)
                        {
                            ho_refBallReg1.Dispose();
                            HOperatorSet.SelectObj(ho_i_RefInspectReg, out ho_refBallReg1, hv_refNum - 1);
                            ho_refBallReg2.Dispose();
                            HOperatorSet.SelectObj(ho_i_RefInspectReg, out ho_refBallReg2, 1);
                        }
                        else
                        {
                            ho_refBallReg1.Dispose();
                            HOperatorSet.SelectObj(ho_i_RefInspectReg, out ho_refBallReg1, hv_regIdx);
                            ho_refBallReg2.Dispose();
                            HOperatorSet.SelectObj(ho_i_RefInspectReg, out ho_refBallReg2, hv_regIdx + 2);
                        }

                        ho_refBallGroup.Dispose();
                        HOperatorSet.GenEmptyObj(out ho_refBallGroup);
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(ho_refBallGroup, ho_refBallReg1, out ExpTmpOutVar_0
                                );
                            ho_refBallGroup.Dispose();
                            ho_refBallGroup = ExpTmpOutVar_0;
                        }
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(ho_refBallGroup, ho_refBallReg2, out ExpTmpOutVar_0
                                );
                            ho_refBallGroup.Dispose();
                            ho_refBallGroup = ExpTmpOutVar_0;
                        }
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(ho_refBallGroup, ho_refBallReg, out ExpTmpOutVar_0
                                );
                            ho_refBallGroup.Dispose();
                            ho_refBallGroup = ExpTmpOutVar_0;
                        }
                        ho_refBallGroupUnion.Dispose();
                        HOperatorSet.Union1(ho_refBallGroup, out ho_refBallGroupUnion);
                        ho_refBallGroupUnionDilation.Dispose();
                        HOperatorSet.DilationCircle(ho_refBallGroupUnion, out ho_refBallGroupUnionDilation,
                            hv_i_RegDilationSize);
                    }
                    else
                    {
                        ho_refBallGroupUnionDilation.Dispose();
                        HOperatorSet.DilationCircle(ho_refBallReg, out ho_refBallGroupUnionDilation,
                            hv_i_RegDilationSize);
                    }

                    //对参考区域进行膨胀
                    ho_RegionDilation.Dispose();
                    HOperatorSet.DilationCircle(ho_refBallReg, out ho_RegionDilation, hv_i_RegDilationSize);
                    //获取Bond周围检测区域
                    ho_RegionDifference.Dispose();
                    HOperatorSet.Difference(ho_RegionDilation, ho_i_RejectReg, out ho_RegionDifference
                        );
                    ho_AroundBondReg.Dispose();
                    HOperatorSet.Difference(ho_RegionDifference, ho_refBallReg, out ho_AroundBondReg
                        );
                    //
                    //计算金线反弧参考方向
                    ho_RegionDilation2.Dispose();
                    HOperatorSet.DilationCircle(ho_refBallReg, out ho_RegionDilation2, 3 * hv_i_RegDilationSize);
                    ho_CurWireReg.Dispose();
                    HOperatorSet.Intersection(ho_RegionDilation2, ho_i_RejectReg, out ho_CurWireReg
                        );

                    //选择面积最大cutReg作为金线区 0105 -lw
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.Difference(ho_CurWireReg, ho_refBallGroupUnionDilation, out ExpTmpOutVar_0
                            );
                        ho_CurWireReg.Dispose();
                        ho_CurWireReg = ExpTmpOutVar_0;
                    }
                    ho_CurWireRegConnection.Dispose();
                    HOperatorSet.Connection(ho_CurWireReg, out ho_CurWireRegConnection);
                    HOperatorSet.AreaCenter(ho_CurWireRegConnection, out hv_WiresArea, out hv_WiresRow,
                        out hv_WiresCol);
                    HOperatorSet.TupleMax(hv_WiresArea, out hv_WireArea);
                    HOperatorSet.TupleFind(hv_WiresArea, hv_WireArea, out hv_MaxIndex);
                    ho_CurWireReg.Dispose();
                    HOperatorSet.SelectObj(ho_CurWireRegConnection, out ho_CurWireReg, hv_MaxIndex + 1);

                    //
                    //金线区域中点至焊点中心方向即为反弧参考方向
                    HOperatorSet.AreaCenter(ho_refBallReg, out hv_BallArea, out hv_BallRow, out hv_BallCol);
                    HOperatorSet.AreaCenter(ho_CurWireReg, out hv_WireArea, out hv_WireRow, out hv_WireCol);

                    //焊点周围金线区没有线，认为异常
                    if ((int)((new HTuple(hv_i_WireJudgeAgain.TupleEqual(1))).TupleAnd(new HTuple(hv_WireArea.TupleGreater(
                        0)))) != 0)
                    {

                        ho_AroundBondReg0.Dispose();
                        HOperatorSet.Difference(ho_RegionDilation, ho_refBallReg, out ho_AroundBondReg0
                            );
                        HOperatorSet.AngleLx(hv_BallRow, hv_BallCol, hv_WireRow, hv_WireCol, out hv_WireRefDirection);

                        ho__WireReg.Dispose(); ho__WireInspectReg.Dispose();
                        HTV_AroundBond_Wire_Inspect(ho_i_Image, ho_AroundBondReg0, ho_refBallReg,
                            out ho__WireReg, out ho__WireInspectReg, hv_WireRefDirection, hv_i_LineWidth,
                            hv_i_LineContrast, hv_i_Transition, hv_i_SelMetric, hv_i_SelMin, hv_i_SelMax,
                            hv_i_LineGap, hv_i_TailGrayThresh, out hv__WireErrCode, out hv__WireErrStr);

                        if ((int)(new HTuple(hv__WireErrCode.TupleLess(0))) != 0)
                        {
                            //异常处理
                            hv_o_ErrCode = -1;
                            hv_o_ErrStr = "HTV_AroundBond_Wire_Inspect--" + hv__WireErrCode;
                            ho_EmptyRegion.Dispose();
                            ho_EmptyObj.Dispose();
                            ho_refBallReg.Dispose();
                            ho_refBallReg1.Dispose();
                            ho_refBallReg2.Dispose();
                            ho_refBallGroup.Dispose();
                            ho_refBallGroupUnion.Dispose();
                            ho_refBallGroupUnionDilation.Dispose();
                            ho_RegionDilation.Dispose();
                            ho_RegionDifference.Dispose();
                            ho_AroundBondReg.Dispose();
                            ho_RegionDilation2.Dispose();
                            ho_CurWireReg.Dispose();
                            ho_CurWireRegConnection.Dispose();
                            ho_AroundBondReg0.Dispose();
                            ho__WireReg.Dispose();
                            ho__WireInspectReg.Dispose();
                            ho_ImageReduced.Dispose();
                            ho__WireRegConnection.Dispose();
                            ho__TailReg.Dispose();

                            return;
                        }

                        HOperatorSet.AreaCenter(ho__WireReg, out hv_WireRegArea, out hv_WireRegRow,
                            out hv_WireRegCol);
                        if ((int)(new HTuple(hv_WireRegArea.TupleEqual(0))) != 0)
                        {
                            //缺陷区域Concat
                            HOperatorSet.SmallestRectangle2(ho__WireInspectReg, out hv_RegRow, out hv_RegCol,
                                out hv_RegPhi, out hv_RegLen1, out hv_RegLen2);
                            ho__WireInspectReg.Dispose();
                            HOperatorSet.GenRectangle2(out ho__WireInspectReg, hv_RegRow, hv_RegCol,
                                hv_RegPhi, hv_RegLen1, hv_RegLen2);
                            //断线
                            hvec_o_FailReg[hv_regIdx] = new HObjectVector(ho__WireInspectReg.CopyObj(1, -1));
                            hvec_o_DefectType[hv_regIdx] = new HTupleVector(new HTuple(12));
                            hvec_o_DefectImgIdx[hv_regIdx] = new HTupleVector(hv_i_ImgIdx).Clone();
                        }
                    }

                    if ((int)(new HTuple(hv_WireArea.TupleEqual(0))) != 0)
                    {
                        //若断线，金线cutReg为空，阈值分割金线区找方向 lw
                        HOperatorSet.Intensity(ho_refBallReg, ho_i_Image, out hv_GrayMean, out hv_GrayDev);
                        ho_ImageReduced.Dispose();
                        HOperatorSet.ReduceDomain(ho_i_Image, ho_AroundBondReg, out ho_ImageReduced
                            );
                        ho__WireReg.Dispose();
                        HOperatorSet.Threshold(ho_ImageReduced, out ho__WireReg, hv_GrayMean - hv_GrayDev,
                            hv_GrayMean + hv_GrayDev);
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ErosionCircle(ho__WireReg, out ExpTmpOutVar_0, hv_i_LineWidth / 3);
                            ho__WireReg.Dispose();
                            ho__WireReg = ExpTmpOutVar_0;
                        }
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.DilationCircle(ho__WireReg, out ExpTmpOutVar_0, hv_i_LineWidth / 3);
                            ho__WireReg.Dispose();
                            ho__WireReg = ExpTmpOutVar_0;
                        }
                        ho__WireRegConnection.Dispose();
                        HOperatorSet.Connection(ho__WireReg, out ho__WireRegConnection);
                        HOperatorSet.AreaCenter(ho__WireRegConnection, out hv_AreaList, out hv_RowList,
                            out hv_ColList);
                        HOperatorSet.TupleMax(hv_AreaList, out hv_AreaMax);
                        HOperatorSet.TupleFind(hv_AreaList, hv_AreaMax, out hv_MaxIdx);
                        ho_CurWireReg.Dispose();
                        HOperatorSet.SelectObj(ho__WireRegConnection, out ho_CurWireReg, hv_MaxIdx + 1);
                        HOperatorSet.AreaCenter(ho_CurWireReg, out hv_WireArea, out hv_WireRow,
                            out hv_WireCol);
                    }

                    // 0114 lw
                    HOperatorSet.AngleLx(hv_WireRow.TupleSelect(0), hv_WireCol.TupleSelect(0),
                       hv_BallRow, hv_BallCol, out hv_TailRefDirection);
                    //
                    //1-----使用line_gauss方法进行尾丝检测
                    ho__TailReg.Dispose();
                    HTV_Tail_Inspect_gauss(ho_i_Image, ho_AroundBondReg, ho_refBallReg, out ho__TailReg,
                        hv_TailRefDirection, hv_i_LineWidth, hv_i_LineContrast, hv_i_Transition,
                        hv_i_SelMetric, hv_i_SelMin, hv_i_SelMax, hv_i_LineGap, hv_i_TailGrayThresh,
                        out hv__TailLength, out hv__TailErrCode, out hv__TailErrStr);
                    //输出检测出结果值
                    hvec_o_DefectValue[hv_regIdx][2] = (new HTupleVector(1).Insert(0, new HTupleVector(hv__TailLength)));
                    //输出尾丝区域
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_o_TailReg, ho__TailReg, out ExpTmpOutVar_0);
                        ho_o_TailReg.Dispose();
                        ho_o_TailReg = ExpTmpOutVar_0;
                    }
                    //
                    if ((int)(new HTuple(hv__TailErrCode.TupleGreater(0))) != 0)
                    {
                        //过滤长度不超过外部阈值的尾丝  1206 lw_mod
                        if ((int)(new HTuple(hv__TailLength.TupleGreater(hv_i_TailLenTh))) != 0)
                        {
                            //缺陷区域
                            hvec_o_FailReg[hv_regIdx] = new HObjectVector(ho_AroundBondReg.CopyObj(1, -1));
                            hvec_o_DefectType[hv_regIdx] = new HTupleVector(new HTuple(24));
                            hvec_o_DefectImgIdx[hv_regIdx] = new HTupleVector(hv_i_ImgIdx).Clone();
                            //
                        }
                        else
                        {
                            //正常区域
                            hvec_o_FailReg[hv_regIdx] = new HObjectVector(ho_EmptyObj.CopyObj(1, -1));
                            hvec_o_DefectType[hv_regIdx] = new HTupleVector(new HTuple());
                            hvec_o_DefectImgIdx[hv_regIdx] = new HTupleVector(new HTuple());
                            //
                        }
                        //
                    }
                    else if ((int)(new HTuple(hv__TailErrCode.TupleLess(0))) != 0)
                    {
                        //异常处理
                        hv_o_ErrCode = -1;
                        hv_o_ErrStr = "HTV_Tail_Inspect_gauss--" + hv__TailErrCode;
                        ho_EmptyRegion.Dispose();
                        ho_EmptyObj.Dispose();
                        ho_refBallReg.Dispose();
                        ho_refBallReg1.Dispose();
                        ho_refBallReg2.Dispose();
                        ho_refBallGroup.Dispose();
                        ho_refBallGroupUnion.Dispose();
                        ho_refBallGroupUnionDilation.Dispose();
                        ho_RegionDilation.Dispose();
                        ho_RegionDifference.Dispose();
                        ho_AroundBondReg.Dispose();
                        ho_RegionDilation2.Dispose();
                        ho_CurWireReg.Dispose();
                        ho_CurWireRegConnection.Dispose();
                        ho_AroundBondReg0.Dispose();
                        ho__WireReg.Dispose();
                        ho__WireInspectReg.Dispose();
                        ho_ImageReduced.Dispose();
                        ho__WireRegConnection.Dispose();
                        ho__TailReg.Dispose();

                        return;
                    }
                    else
                    {
                        //无尾丝
                        hvec_o_FailReg[hv_regIdx] = new HObjectVector(ho_EmptyObj.CopyObj(1, -1));
                        hvec_o_DefectType[hv_regIdx] = new HTupleVector(new HTuple());
                        hvec_o_DefectImgIdx[hv_regIdx] = new HTupleVector(new HTuple());
                    }
                }
                //
                hv_TypeSum = new HTuple();
                HTuple end_val174 = new HTuple(hvec_o_DefectType.Length) - 1;
                HTuple step_val174 = 1;
                for (hv_i = 0; hv_i.Continue(end_val174, step_val174); hv_i = hv_i.TupleAdd(step_val174))
                {
                    hv_TypeTup = hvec_o_DefectType[hv_i].T.Clone();
                    HOperatorSet.TupleSum(hv_TypeTup, out hv_TmpSum);
                    hv_TypeSum = hv_TypeSum + hv_TmpSum;
                }

                if ((int)(new HTuple(hv_TypeSum.TupleGreater(0))) != 0)
                {
                    hv_o_ErrCode = 1;
                    hv_o_ErrStr = "tail exist";
                    ho_EmptyRegion.Dispose();
                    ho_EmptyObj.Dispose();
                    ho_refBallReg.Dispose();
                    ho_refBallReg1.Dispose();
                    ho_refBallReg2.Dispose();
                    ho_refBallGroup.Dispose();
                    ho_refBallGroupUnion.Dispose();
                    ho_refBallGroupUnionDilation.Dispose();
                    ho_RegionDilation.Dispose();
                    ho_RegionDifference.Dispose();
                    ho_AroundBondReg.Dispose();
                    ho_RegionDilation2.Dispose();
                    ho_CurWireReg.Dispose();
                    ho_CurWireRegConnection.Dispose();
                    ho_AroundBondReg0.Dispose();
                    ho__WireReg.Dispose();
                    ho__WireInspectReg.Dispose();
                    ho_ImageReduced.Dispose();
                    ho__WireRegConnection.Dispose();
                    ho__TailReg.Dispose();

                    return;
                }
                else
                {
                    //
                    hv_o_ErrCode = 0;
                    hv_o_ErrStr = "no tail exist";
                    ho_EmptyRegion.Dispose();
                    ho_EmptyObj.Dispose();
                    ho_refBallReg.Dispose();
                    ho_refBallReg1.Dispose();
                    ho_refBallReg2.Dispose();
                    ho_refBallGroup.Dispose();
                    ho_refBallGroupUnion.Dispose();
                    ho_refBallGroupUnionDilation.Dispose();
                    ho_RegionDilation.Dispose();
                    ho_RegionDifference.Dispose();
                    ho_AroundBondReg.Dispose();
                    ho_RegionDilation2.Dispose();
                    ho_CurWireReg.Dispose();
                    ho_CurWireRegConnection.Dispose();
                    ho_AroundBondReg0.Dispose();
                    ho__WireReg.Dispose();
                    ho__WireInspectReg.Dispose();
                    ho_ImageReduced.Dispose();
                    ho__WireRegConnection.Dispose();
                    ho__TailReg.Dispose();

                    return;
                }
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_EmptyRegion.Dispose();
                ho_EmptyObj.Dispose();
                ho_refBallReg.Dispose();
                ho_refBallReg1.Dispose();
                ho_refBallReg2.Dispose();
                ho_refBallGroup.Dispose();
                ho_refBallGroupUnion.Dispose();
                ho_refBallGroupUnionDilation.Dispose();
                ho_RegionDilation.Dispose();
                ho_RegionDifference.Dispose();
                ho_AroundBondReg.Dispose();
                ho_RegionDilation2.Dispose();
                ho_CurWireReg.Dispose();
                ho_CurWireRegConnection.Dispose();
                ho_AroundBondReg0.Dispose();
                ho__WireReg.Dispose();
                ho__WireInspectReg.Dispose();
                ho_ImageReduced.Dispose();
                ho__WireRegConnection.Dispose();
                ho__TailReg.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public static void HTV_AroundBallSeg_Inspect_MatchMeasure(HObject ho_i_Image, HObject ho_i_RefBondRegs,
            HObject ho_i_RefPadRegs, out HObjectVector/*{eObjectVector,Dim=1}*/ hvec_o_FailReg,
            out HObject ho_o_BondContours, out HObject ho_o_PadContours, HTuple hv_i_isPadMeasure,
            HTuple hv_i_padMeasureType, HTuple hv_i_padMeasureSize, HTuple hv_i_padMeasureGrayThr,
            HTuple hv_i_padMeasureTrans, HTuple hv_i_padGrayThresh, HTuple hv_i_isBallMeasure,
            HTuple hv_i_ballGrayThresh, HTuple hv_i_ballMeasureType, HTuple hv_i_ballMeasureSize,
            HTuple hv_i_ballMeasureGrayThr, HTuple hv_i_ballMeasureTrans, HTuple hv_i_ballShiftRatioThr,
            HTuple hv_i_ImgIdx, HTupleVector/*{eTupleVector,Dim=3}*/ hvec_i_DefectValue,
            out HTupleVector/*{eTupleVector,Dim=1}*/ hvec_o_DefectType, out HTupleVector/*{eTupleVector,Dim=3}*/ hvec_o_DefectValue,
            out HTupleVector/*{eTupleVector,Dim=1}*/ hvec_o_DefectImgIdx, out HTuple hv_o_ErrCode,
            out HTuple hv_o_ErrStr)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_EmptyObj, ho_EmptyRegion, ho__RefBondReg = null;
            HObject ho__RefPadReg = null, ho__PadContourM = null, ho_ImageReduced = null;
            HObject ho_Region = null, ho__PadContour = null, ho__BallContour = null;

            // Local control variables 

            HTuple hv_objNum = null, hv_objIdx = null;
            HTuple hv_refArea = new HTuple(), hv_Row = new HTuple();
            HTuple hv_Column = new HTuple(), hv__PadSize = new HTuple();
            HTuple hv__PadErrCode = new HTuple(), hv__PadErrStr = new HTuple();
            HTuple hv_Row2 = new HTuple(), hv_Column2 = new HTuple();
            HTuple hv_Phi1 = new HTuple(), hv_Length11 = new HTuple();
            HTuple hv_Length21 = new HTuple(), hv_o_BallShiftRatio = new HTuple();
            HTuple hv_o_BallRadius = new HTuple(), hv__shiftErrCode = new HTuple();
            HTuple hv__shiftErrStr = new HTuple(), hv_TypeSum = null;
            HTuple hv_i = null, hv_TypeTup = new HTuple(), hv_TmpSum = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_BondContours);
            HOperatorSet.GenEmptyObj(out ho_o_PadContours);
            HOperatorSet.GenEmptyObj(out ho_EmptyObj);
            HOperatorSet.GenEmptyObj(out ho_EmptyRegion);
            HOperatorSet.GenEmptyObj(out ho__RefBondReg);
            HOperatorSet.GenEmptyObj(out ho__RefPadReg);
            HOperatorSet.GenEmptyObj(out ho__PadContourM);
            HOperatorSet.GenEmptyObj(out ho_ImageReduced);
            HOperatorSet.GenEmptyObj(out ho_Region);
            HOperatorSet.GenEmptyObj(out ho__PadContour);
            HOperatorSet.GenEmptyObj(out ho__BallContour);
            hvec_o_FailReg = new HObjectVector(1);
            try
            {
                //**************************************************************************************************
                //---函数：HTV_AroundBallSeg_Inspect_MatchMeasure
                //---作用：计算焊球偏移
                //===图标参数
                //  i_Image：检测所需图像
                //  i_RefInspectReg：检测区
                //  i_RejectReg：拒绝区
                //  o_FailReg：检出失败的区域
                //  o_BondFailReg：焊点周围异物的区域
                //===控制参数
                //  i_padMeasureGrayThr：焊盘测量对比度
                //  i_padMeasureTrans：焊盘测量极性
                //  i_ballGrayThresh：焊点灰度阈值
                //  i_ballSize：焊点半径
                //  i_ballMeasureGrayThr：焊点测量对比度
                //  i_ballMeasureTrans：焊点测量极性
                //  i_ballShiftRatioThr：焊点偏移阈值
                //  i_ImgIdx：图像索引
                //  o_DefectType：缺陷类型
                //  o_DefectValue：缺陷信息
                //  o_DefectImgIdx：缺陷所检图像索引
                //  o_ErrCode：错误码
                //  o_ErrStr：错误信息
                //**************************************************************************************************
                //初始化
                ho_EmptyObj.Dispose();
                HOperatorSet.GenEmptyObj(out ho_EmptyObj);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hvec_o_FailReg = dh.Take((
                        dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho_EmptyObj)))));
                }
                hvec_o_DefectType = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())));
                hvec_o_DefectImgIdx = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())));
                hvec_o_DefectValue = hvec_i_DefectValue.Clone();
                //
                //更新Bonds结果输出
                ho_o_BondContours.Dispose();
                HOperatorSet.GenEmptyObj(out ho_o_BondContours);
                //焊盘区域输出
                ho_o_PadContours.Dispose();
                HOperatorSet.GenEmptyObj(out ho_o_PadContours);
                //
                ho_EmptyRegion.Dispose();
                HOperatorSet.GenEmptyRegion(out ho_EmptyRegion);
                //
                hv_o_ErrCode = -2;
                hv_o_ErrStr = "initializing";
                //
                //参数有效性测试

                //-------------------------*****---Inspect---******-----------------------
                //
                //
                HOperatorSet.CountObj(ho_i_RefBondRegs, out hv_objNum);
                //
                HTuple end_val48 = hv_objNum - 1;
                HTuple step_val48 = 1;
                for (hv_objIdx = 0; hv_objIdx.Continue(end_val48, step_val48); hv_objIdx = hv_objIdx.TupleAdd(step_val48))
                {
                    //
                    ho__RefBondReg.Dispose();
                    HOperatorSet.SelectObj(ho_i_RefBondRegs, out ho__RefBondReg, hv_objIdx + 1);
                    //判断初始焊点参考位置有无
                    HOperatorSet.AreaCenter(ho__RefBondReg, out hv_refArea, out hv_Row, out hv_Column);
                    if ((int)(new HTuple(hv_refArea.TupleNotEqual(0))) != 0)
                    {
                        //
                        //选择参考焊盘或焊点检测区域
                        ho__RefPadReg.Dispose();
                        HOperatorSet.SelectObj(ho_i_RefPadRegs, out ho__RefPadReg, hv_objIdx + 1);
                        //生成缺陷输出显示区域
                        //smallest_rectangle2 (_RefBondReg, Row1, Column1, Phi, Length1, Length2)
                        //*         gen_rectangle2 (RefFailReg, Row1, Column1, 0, Length1, Length1)
                        //判断是否进行焊盘测量定位
                        if ((int)(hv_i_isPadMeasure) != 0)
                        {
                            //1------焊盘精确定位
                            ho__PadContourM.Dispose();
                            HTV_pad_measure_location(ho_i_Image, ho__RefBondReg, out ho__PadContourM,
                                hv_i_padMeasureType, hv_i_padMeasureSize, hv_i_padMeasureGrayThr,
                                hv_i_padMeasureTrans, out hv__PadSize, out hv__PadErrCode, out hv__PadErrStr);
                            //
                        }
                        else
                        {
                            //使用参考的焊盘区域
                            ho__PadContourM.Dispose();
                            ho__PadContourM = ho__RefPadReg.CopyObj(1, -1);
                            HOperatorSet.SmallestRectangle2(ho__PadContourM, out hv_Row2, out hv_Column2,
                                out hv_Phi1, out hv_Length11, out hv_Length21);
                            hv__PadSize = (hv_Length11 + hv_Length21) / 2;
                        }

                        //精确----阈值分割出测量到的焊盘区域
                        ho_ImageReduced.Dispose();
                        HOperatorSet.ReduceDomain(ho_i_Image, ho__PadContourM, out ho_ImageReduced
                            );
                        ho_Region.Dispose();
                        HOperatorSet.Threshold(ho_ImageReduced, out ho_Region, hv_i_padGrayThresh.TupleSelect(
                            0), hv_i_padGrayThresh.TupleSelect(1));
                        if ((int)(new HTuple(hv_i_padMeasureType.TupleEqual("rectangle2"))) != 0)
                        {
                            ho__PadContour.Dispose();
                            HOperatorSet.Closing(ho_Region, ho__RefPadReg, out ho__PadContour);
                        }
                        else
                        {
                            ho__PadContour.Dispose();
                            HOperatorSet.Closing(ho_Region, ho__RefBondReg, out ho__PadContour);
                        }
                        //2----焊点精定位并偏移检测
                        ho__BallContour.Dispose();
                        HTV_ball_measure_lacation_shift(ho_i_Image, ho__PadContour, ho__RefBondReg,
                            out ho__BallContour, hv_i_isBallMeasure, hv_i_ballGrayThresh, hv_i_ballMeasureType,
                            hv_i_ballMeasureSize, hv_i_ballMeasureGrayThr, hv_i_ballMeasureTrans,
                            hv_i_ballShiftRatioThr, hv__PadSize, out hv_o_BallShiftRatio, out hv_o_BallRadius,
                            out hv__shiftErrCode, out hv__shiftErrStr);
                        //输出结果值
                        //一个Bond一个检测ID
                        if ((int)(hv_i_isBallMeasure) != 0)
                        {
                            //重新测量焊点更新DefectValue
                            hvec_o_DefectValue[hv_objIdx][0] = (new HTupleVector(1).Insert(0, new HTupleVector(hv_o_BallRadius)));
                        }
                        hvec_o_DefectValue[hv_objIdx][1] = (new HTupleVector(1).Insert(0, new HTupleVector(hv_o_BallShiftRatio)));
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(ho_o_PadContours, ho__PadContour, out ExpTmpOutVar_0
                                );
                            ho_o_PadContours.Dispose();
                            ho_o_PadContours = ExpTmpOutVar_0;
                        }
                        //
                        if ((int)(new HTuple(hv__shiftErrCode.TupleGreater(0))) != 0)
                        {
                            //
                            hvec_o_FailReg[hv_objIdx] = new HObjectVector(ho__RefPadReg.CopyObj(1, -1));
                            hvec_o_DefectType[hv_objIdx] = new HTupleVector(hv__shiftErrCode).Clone();
                            hvec_o_DefectImgIdx[hv_objIdx] = new HTupleVector(hv_i_ImgIdx).Clone();
                            //更新Bonds
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.ConcatObj(ho_o_BondContours, ho_EmptyRegion, out ExpTmpOutVar_0
                                    );
                                ho_o_BondContours.Dispose();
                                ho_o_BondContours = ExpTmpOutVar_0;
                            }
                        }
                        else
                        {
                            hvec_o_FailReg[hv_objIdx] = new HObjectVector(ho_EmptyObj.CopyObj(1, -1));
                            hvec_o_DefectType[hv_objIdx] = new HTupleVector(new HTuple());
                            hvec_o_DefectImgIdx[hv_objIdx] = new HTupleVector(new HTuple());
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.ConcatObj(ho_o_BondContours, ho__BallContour, out ExpTmpOutVar_0
                                    );
                                ho_o_BondContours.Dispose();
                                ho_o_BondContours = ExpTmpOutVar_0;
                            }
                        }
                    }
                }
                //******************************************************************************************************
                //
                hv_TypeSum = new HTuple();
                HTuple end_val109 = new HTuple(hvec_o_DefectType.Length) - 1;
                HTuple step_val109 = 1;
                for (hv_i = 0; hv_i.Continue(end_val109, step_val109); hv_i = hv_i.TupleAdd(step_val109))
                {
                    hv_TypeTup = hvec_o_DefectType[hv_i].T.Clone();
                    HOperatorSet.TupleSum(hv_TypeTup, out hv_TmpSum);
                    hv_TypeSum = hv_TypeSum + hv_TmpSum;
                }

                if ((int)(new HTuple(hv_TypeSum.TupleGreater(0))) != 0)
                {
                    hv_o_ErrCode = 1;
                    hv_o_ErrStr = "around Bond region has defect";
                    ho_EmptyObj.Dispose();
                    ho_EmptyRegion.Dispose();
                    ho__RefBondReg.Dispose();
                    ho__RefPadReg.Dispose();
                    ho__PadContourM.Dispose();
                    ho_ImageReduced.Dispose();
                    ho_Region.Dispose();
                    ho__PadContour.Dispose();
                    ho__BallContour.Dispose();

                    return;
                }
                else
                {
                    //
                    hv_o_ErrCode = 0;
                    hv_o_ErrStr = "around Bond region is ok";
                    ho_EmptyObj.Dispose();
                    ho_EmptyRegion.Dispose();
                    ho__RefBondReg.Dispose();
                    ho__RefPadReg.Dispose();
                    ho__PadContourM.Dispose();
                    ho_ImageReduced.Dispose();
                    ho_Region.Dispose();
                    ho__PadContour.Dispose();
                    ho__BallContour.Dispose();

                    return;
                }
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_EmptyObj.Dispose();
                ho_EmptyRegion.Dispose();
                ho__RefBondReg.Dispose();
                ho__RefPadReg.Dispose();
                ho__PadContourM.Dispose();
                ho_ImageReduced.Dispose();
                ho_Region.Dispose();
                ho__PadContour.Dispose();
                ho__BallContour.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public static void HTV_pad_measure_location(HObject ho_i_Image, HObject ho_i_MeasureReg,
            out HObject ho_o_PadContour, HTuple hv_i_padMeasureType, HTuple hv_i_padMeasureSize,
            HTuple hv_i_padMeasureGrayThr, HTuple hv_i_padMeasureTrans, out HTuple hv_o_PadSize,
            out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {




            // Local iconic variables 

            HObject ho_ImageReduced;

            // Local control variables 

            HTuple hv_IsString = null, hv_RefRow = null;
            HTuple hv_RefColumn = null, hv_RefRadius = null, hv_MetrologyHandle = null;
            HTuple hv_Index = new HTuple(), hv__parameters = null;
            HTuple hv_Parameter = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_PadContour);
            HOperatorSet.GenEmptyObj(out ho_ImageReduced);
            try
            {
                //***********************************************


                //write by wj 2020-12-02
                //***********************************************
                //
                //初始化
                ho_o_PadContour.Dispose();
                HOperatorSet.GenEmptyObj(out ho_o_PadContour);
                //
                hv_o_PadSize = -2;
                //
                hv_o_ErrCode = -2;
                hv_o_ErrStr = "initializing";
                //
                //参数合理性判断
                if ((int)((new HTuple((new HTuple(hv_i_padMeasureGrayThr.TupleLength())).TupleEqual(
                    0))).TupleOr(new HTuple(hv_i_padMeasureGrayThr.TupleLess(0)))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "para i_padMeasureGrayThr is illegal";
                    ho_ImageReduced.Dispose();

                    return;
                }
                //
                HOperatorSet.TupleIsString(hv_i_padMeasureTrans, out hv_IsString);
                if ((int)((new HTuple((new HTuple(hv_i_padMeasureTrans.TupleLength())).TupleEqual(
                    0))).TupleOr(new HTuple(hv_IsString.TupleEqual(0)))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "para i_padMeasureTrans is illegal";
                    ho_ImageReduced.Dispose();

                    return;
                }
                //
                HOperatorSet.SmallestCircle(ho_i_MeasureReg, out hv_RefRow, out hv_RefColumn,
                    out hv_RefRadius);
                //1精确定位焊盘，使用匹配到的圆作为测量圆模板的中心
                HOperatorSet.CreateMetrologyModel(out hv_MetrologyHandle);

                //选定测量句柄类型
                if ((int)(new HTuple(hv_i_padMeasureType.TupleEqual("line"))) != 0)
                {

                }
                else if ((int)(new HTuple(hv_i_padMeasureType.TupleEqual("rectangle2"))) != 0)
                {

                    //gen_circle (Circle, RefRow, RefColumn, RefRadius)
                    //smallest_rectangle2 (Circle, Row, Column, Phi, Length1, Length2)
                    //gen_rectangle2 (Rectangle, Row, Column, 0, Length1, Length2)

                    //
                    HOperatorSet.AddMetrologyObjectRectangle2Measure(hv_MetrologyHandle, hv_RefRow,
                        hv_RefColumn, 0, hv_i_padMeasureSize.TupleSelect(0), hv_i_padMeasureSize.TupleSelect(
                        1), (hv_i_padMeasureSize.TupleSelect(0)) * 0.5, 2, 1, hv_i_padMeasureGrayThr,
                        ((new HTuple("measure_transition")).TupleConcat("measure_distance")).TupleConcat(
                        "min_score"), hv_i_padMeasureTrans.TupleConcat((new HTuple(2)).TupleConcat(
                        0.5)), out hv_Index);
                }
                else if ((int)(new HTuple(hv_i_padMeasureType.TupleEqual("circle"))) != 0)
                {
                    //
                    HOperatorSet.AddMetrologyObjectCircleMeasure(hv_MetrologyHandle, hv_RefRow,
                        hv_RefColumn, hv_i_padMeasureSize, hv_i_padMeasureSize * 0.5, 2, 1, hv_i_padMeasureGrayThr,
                        ((new HTuple("measure_transition")).TupleConcat("measure_distance")).TupleConcat(
                        "min_score"), hv_i_padMeasureTrans.TupleConcat((new HTuple(2)).TupleConcat(
                        0.5)), out hv_Index);
                }
                else if ((int)(new HTuple(hv_i_padMeasureType.TupleEqual("ellipse"))) != 0)
                {
                    //

                }
                //
                ho_ImageReduced.Dispose();
                HOperatorSet.ReduceDomain(ho_i_Image, ho_i_MeasureReg, out ho_ImageReduced);
                HOperatorSet.ApplyMetrologyModel(ho_ImageReduced, hv_MetrologyHandle);
                HOperatorSet.GetMetrologyObjectResult(hv_MetrologyHandle, hv_Index, "all",
                    "result_type", "all_param", out hv__parameters);

                HOperatorSet.ClearMetrologyModel(hv_MetrologyHandle);
                //判断焊盘是否测量准确
                if ((int)((new HTuple(hv_i_padMeasureType.TupleEqual("rectangle2"))).TupleAnd(
                    new HTuple((new HTuple(hv__parameters.TupleLength())).TupleEqual(5)))) != 0)
                {
                    //生成焊盘区域
                    hv_Parameter = hv__parameters.Clone();
                    ho_o_PadContour.Dispose();
                    HOperatorSet.GenRectangle2(out ho_o_PadContour, hv_Parameter.TupleSelect(
                        0), hv_Parameter.TupleSelect(1), hv_Parameter.TupleSelect(2), hv_Parameter.TupleSelect(
                        3), hv_Parameter.TupleSelect(4));
                    //
                    hv_o_PadSize = ((hv_Parameter.TupleSelect(3)) + (hv_Parameter.TupleSelect(4))) / 2;
                }
                else if ((int)((new HTuple(hv_i_padMeasureType.TupleEqual("circle"))).TupleAnd(
                    new HTuple((new HTuple(hv__parameters.TupleLength())).TupleEqual(3)))) != 0)
                {
                    //
                    hv_Parameter = hv__parameters.Clone();
                    ho_o_PadContour.Dispose();
                    HOperatorSet.GenCircle(out ho_o_PadContour, hv_Parameter.TupleSelect(0),
                        hv_Parameter.TupleSelect(1), hv_Parameter.TupleSelect(2));
                    hv_o_PadSize = hv_Parameter[2];
                }
                else
                {
                    ho_o_PadContour.Dispose();
                    ho_o_PadContour = ho_i_MeasureReg.CopyObj(1, -1);
                    hv_o_PadSize = hv_RefRadius.Clone();
                }
                //
                hv_o_ErrCode = 0;
                hv_o_ErrStr = "measure pad is ok";
                ho_ImageReduced.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_ImageReduced.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public static void HTV_ball_measure_lacation_shift(HObject ho_i_Image, HObject ho_i_InspectReg,
            HObject ho_i_RefBall, out HObject ho_o_BallContour, HTuple hv_i_isBallMeasure,
            HTuple hv_i_ballGrayThresh, HTuple hv_i_ballMeasureType, HTuple hv_i_ballMeasureSize,
            HTuple hv_i_ballMeasureGrayThr, HTuple hv_i_ballMeasureTrans, HTuple hv_i_ballShiftRatioThr,
            HTuple hv_i_PadSize, out HTuple hv_o_BallShiftRatio, out HTuple hv_o_BallRadius,
            out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {




            // Local iconic variables 

            HObject ho_BondImage = null, ho_SecBondRegs = null;
            HObject ho_SecBondRegFillup = null, ho_SecBondRegMorph = null;
            HObject ho_ConnectedSecBondRegs = null, ho_MaxSecBondReg = null;
            HObject ho__BallContour = null;

            // Local control variables 

            HTuple hv_IsString = null, hv_SecBondRegArea = new HTuple();
            HTuple hv_SecBondRegRow = new HTuple(), hv_SecBondCol = new HTuple();
            HTuple hv_MaxArea = new HTuple(), hv_MaxIndice = new HTuple();
            HTuple hv_SecBondArea = new HTuple(), hv_SecBondRow = new HTuple();
            HTuple hv_MetrologyHandle = new HTuple(), hv_Index = new HTuple();
            HTuple hv_Row = new HTuple(), hv_Column = new HTuple();
            HTuple hv_refPhi = new HTuple(), hv_Length1 = new HTuple();
            HTuple hv_Length2 = new HTuple(), hv__parameters = new HTuple();
            HTuple hv_Parameter = new HTuple(), hv_Exception = new HTuple();
            HTuple hv_RowReg = new HTuple(), hv_ColReg = new HTuple();
            HTuple hv_RadiusReg = new HTuple(), hv_ColPhi = new HTuple();
            HTuple hv_Len1Reg = new HTuple(), hv_Len2Reg = new HTuple();
            HTuple hv_PadArea = new HTuple(), hv_PadRow = new HTuple();
            HTuple hv_PadCol = new HTuple(), hv_BondArea = new HTuple();
            HTuple hv_BondRow = new HTuple(), hv_BondCol = new HTuple();
            HTuple hv_BondDist = new HTuple(), hv_DistTh = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_BallContour);
            HOperatorSet.GenEmptyObj(out ho_BondImage);
            HOperatorSet.GenEmptyObj(out ho_SecBondRegs);
            HOperatorSet.GenEmptyObj(out ho_SecBondRegFillup);
            HOperatorSet.GenEmptyObj(out ho_SecBondRegMorph);
            HOperatorSet.GenEmptyObj(out ho_ConnectedSecBondRegs);
            HOperatorSet.GenEmptyObj(out ho_MaxSecBondReg);
            HOperatorSet.GenEmptyObj(out ho__BallContour);
            try
            {
                //******************************

                //******************************
                //初始化输出
                ho_o_BallContour.Dispose();
                HOperatorSet.GenEmptyRegion(out ho_o_BallContour);

                hv_o_BallShiftRatio = -2;
                hv_o_BallRadius = -1;
                //
                hv_o_ErrCode = -2;
                hv_o_ErrStr = "initializing";
                //
                //参数合理性判断
                if ((int)((new HTuple((new HTuple(hv_i_ballGrayThresh.TupleLength())).TupleEqual(
                    0))).TupleOr(new HTuple(((hv_i_ballGrayThresh.TupleSelect(0))).TupleLess(
                    0)))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "para i_ballGrayThresh is illegal";
                    ho_BondImage.Dispose();
                    ho_SecBondRegs.Dispose();
                    ho_SecBondRegFillup.Dispose();
                    ho_SecBondRegMorph.Dispose();
                    ho_ConnectedSecBondRegs.Dispose();
                    ho_MaxSecBondReg.Dispose();
                    ho__BallContour.Dispose();

                    return;
                }
                if ((int)((new HTuple((new HTuple(hv_i_ballMeasureSize.TupleLength())).TupleEqual(
                    0))).TupleOr(new HTuple(hv_i_ballMeasureSize.TupleLess(0)))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "para i_ballSize is illegal";
                    ho_BondImage.Dispose();
                    ho_SecBondRegs.Dispose();
                    ho_SecBondRegFillup.Dispose();
                    ho_SecBondRegMorph.Dispose();
                    ho_ConnectedSecBondRegs.Dispose();
                    ho_MaxSecBondReg.Dispose();
                    ho__BallContour.Dispose();

                    return;
                }
                if ((int)((new HTuple((new HTuple(hv_i_ballMeasureGrayThr.TupleLength())).TupleEqual(
                    0))).TupleOr(new HTuple(hv_i_ballMeasureGrayThr.TupleLess(0)))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "para i_ballMeasureGrayThr is illegal";
                    ho_BondImage.Dispose();
                    ho_SecBondRegs.Dispose();
                    ho_SecBondRegFillup.Dispose();
                    ho_SecBondRegMorph.Dispose();
                    ho_ConnectedSecBondRegs.Dispose();
                    ho_MaxSecBondReg.Dispose();
                    ho__BallContour.Dispose();

                    return;
                }
                //
                HOperatorSet.TupleIsString(hv_i_ballMeasureTrans, out hv_IsString);
                if ((int)((new HTuple((new HTuple(hv_i_ballMeasureTrans.TupleLength())).TupleEqual(
                    0))).TupleOr(new HTuple(hv_IsString.TupleEqual(0)))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "para i_ballMeasureTrans is illegal";
                    ho_BondImage.Dispose();
                    ho_SecBondRegs.Dispose();
                    ho_SecBondRegFillup.Dispose();
                    ho_SecBondRegMorph.Dispose();
                    ho_ConnectedSecBondRegs.Dispose();
                    ho_MaxSecBondReg.Dispose();
                    ho__BallContour.Dispose();

                    return;
                }
                //
                if ((int)((new HTuple((new HTuple(hv_i_ballShiftRatioThr.TupleLength())).TupleEqual(
                    0))).TupleOr(new HTuple(hv_i_ballShiftRatioThr.TupleLess(0)))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "para i_ballShiftRatioThr is illegal";
                    ho_BondImage.Dispose();
                    ho_SecBondRegs.Dispose();
                    ho_SecBondRegFillup.Dispose();
                    ho_SecBondRegMorph.Dispose();
                    ho_ConnectedSecBondRegs.Dispose();
                    ho_MaxSecBondReg.Dispose();
                    ho__BallContour.Dispose();

                    return;
                }
                //

                //*********************************进行焊点偏移检测***************************************88888
                //
                //判断是否重新测量焊点
                if ((int)(hv_i_isBallMeasure) != 0)
                {
                    //
                    //精确定位2焊点：在测量到的焊盘区域内阈值分割出焊点位置
                    //-------阈值分割出圆区域：阈值分割出有则进行偏移检测，否则输出
                    ho_BondImage.Dispose();
                    HOperatorSet.ReduceDomain(ho_i_Image, ho_i_InspectReg, out ho_BondImage);
                    ho_SecBondRegs.Dispose();
                    HOperatorSet.Threshold(ho_BondImage, out ho_SecBondRegs, hv_i_ballGrayThresh.TupleSelect(
                        0), hv_i_ballGrayThresh.TupleSelect(1));
                    ho_SecBondRegFillup.Dispose();
                    HOperatorSet.FillUp(ho_SecBondRegs, out ho_SecBondRegFillup);
                    ho_SecBondRegMorph.Dispose();
                    HOperatorSet.OpeningCircle(ho_SecBondRegFillup, out ho_SecBondRegMorph, 2.5);
                    ho_ConnectedSecBondRegs.Dispose();
                    HOperatorSet.Connection(ho_SecBondRegMorph, out ho_ConnectedSecBondRegs);
                    HOperatorSet.AreaCenter(ho_ConnectedSecBondRegs, out hv_SecBondRegArea, out hv_SecBondRegRow,
                        out hv_SecBondCol);
                    HOperatorSet.TupleMax(hv_SecBondRegArea, out hv_MaxArea);
                    HOperatorSet.TupleFind(hv_SecBondRegArea, hv_MaxArea, out hv_MaxIndice);
                    ho_MaxSecBondReg.Dispose();
                    HOperatorSet.SelectObj(ho_ConnectedSecBondRegs, out ho_MaxSecBondReg, (hv_MaxIndice.TupleSelect(
                        0)) + 1);
                    //
                    HOperatorSet.AreaCenter(ho_MaxSecBondReg, out hv_SecBondArea, out hv_SecBondRow,
                        out hv_SecBondCol);
                    //判断是否漏检焊点脱落
                    if ((int)(new HTuple(hv_SecBondArea.TupleNotEqual(0))) != 0)
                    {
                        //--------创建圆测量句柄进行二焊点精准定位
                        HOperatorSet.CreateMetrologyModel(out hv_MetrologyHandle);

                        //选定测量句柄类型
                        if ((int)(new HTuple(hv_i_ballMeasureType.TupleEqual("circle"))) != 0)
                        {
                            //
                            HOperatorSet.AddMetrologyObjectCircleMeasure(hv_MetrologyHandle, hv_SecBondRow,
                                hv_SecBondCol, hv_i_ballMeasureSize, hv_i_ballMeasureSize * 0.5, 2,
                                1, hv_i_ballMeasureGrayThr, ((new HTuple("measure_transition")).TupleConcat(
                                "measure_distance")).TupleConcat("min_score"), hv_i_ballMeasureTrans.TupleConcat(
                                (new HTuple(2)).TupleConcat(0.5)), out hv_Index);
                        }
                        else if ((int)(new HTuple(hv_i_ballMeasureType.TupleEqual("ellipse"))) != 0)
                        {
                            //确定测量椭圆方向
                            HOperatorSet.SmallestRectangle2(ho_MaxSecBondReg, out hv_Row, out hv_Column,
                                out hv_refPhi, out hv_Length1, out hv_Length2);
                            //
                            HOperatorSet.AddMetrologyObjectEllipseMeasure(hv_MetrologyHandle, hv_SecBondRow,
                                hv_SecBondCol, hv_refPhi, hv_i_ballMeasureSize.TupleSelect(0), hv_i_ballMeasureSize.TupleSelect(
                                1), (hv_i_ballMeasureSize.TupleSelect(1)) * 0.5, 2, 1, hv_i_ballMeasureGrayThr,
                                ((new HTuple("measure_transition")).TupleConcat("measure_distance")).TupleConcat(
                                "min_score"), hv_i_ballMeasureTrans.TupleConcat((new HTuple(3)).TupleConcat(
                                0.5)), out hv_Index);
                        }
                        //防呆：防止测量出现无法拟合的状况
                        try
                        {
                            HOperatorSet.ApplyMetrologyModel(ho_i_Image, hv_MetrologyHandle);
                            HOperatorSet.GetMetrologyObjectResult(hv_MetrologyHandle, hv_Index, "all",
                                "result_type", "all_param", out hv__parameters);
                            HOperatorSet.ClearMetrologyModel(hv_MetrologyHandle);
                            //
                            if ((int)(new HTuple((new HTuple(hv__parameters.TupleLength())).TupleEqual(
                                3))) != 0)
                            {
                                //
                                hv_Parameter = hv__parameters.Clone();
                                //生成圆
                                ho__BallContour.Dispose();
                                HOperatorSet.GenCircle(out ho__BallContour, hv_Parameter.TupleSelect(
                                    0), hv_Parameter.TupleSelect(1), hv_Parameter.TupleSelect(2));
                                ho_o_BallContour.Dispose();
                                ho_o_BallContour = ho__BallContour.CopyObj(1, -1);
                                hv_o_BallRadius = hv_Parameter[2];
                            }
                            else if ((int)(new HTuple((new HTuple(hv__parameters.TupleLength()
                                )).TupleEqual(5))) != 0)
                            {
                                hv_Parameter = hv__parameters.Clone();
                                //生成椭圆
                                ho__BallContour.Dispose();
                                HOperatorSet.GenEllipse(out ho__BallContour, hv_Parameter.TupleSelect(
                                    0), hv_Parameter.TupleSelect(1), hv_Parameter.TupleSelect(2), hv_Parameter.TupleSelect(
                                    3), hv_Parameter.TupleSelect(4));
                                ho_o_BallContour.Dispose();
                                ho_o_BallContour = ho__BallContour.CopyObj(1, -1);
                                hv_o_BallRadius = new HTuple();
                                hv_o_BallRadius = hv_o_BallRadius.TupleConcat(hv_Parameter.TupleSelect(
                                    3));
                                hv_o_BallRadius = hv_o_BallRadius.TupleConcat(hv_Parameter.TupleSelect(
                                    4));
                            }
                            else
                            {
                                ho__BallContour.Dispose();
                                ho__BallContour = ho_MaxSecBondReg.CopyObj(1, -1);
                            }
                        }
                        // catch (Exception) 
                        catch (HalconException HDevExpDefaultException1)
                        {
                            HDevExpDefaultException1.ToHTuple(out hv_Exception);
                            if ((int)((new HTuple(((hv_Exception.TupleSelect(0))).TupleEqual(9101))).TupleAnd(
                                new HTuple(hv_i_ballMeasureType.TupleEqual("ellipse")))) != 0)
                            {
                                ho__BallContour.Dispose();
                                ho__BallContour = ho_MaxSecBondReg.CopyObj(1, -1);
                                ho_o_BallContour.Dispose();
                                ho_o_BallContour = ho__BallContour.CopyObj(1, -1);
                                if ((int)(new HTuple(hv_i_ballMeasureType.TupleEqual("circle"))) != 0)
                                {
                                    HOperatorSet.SmallestCircle(ho__BallContour, out hv_RowReg, out hv_ColReg,
                                        out hv_RadiusReg);
                                    hv_o_BallRadius = hv_RadiusReg.Clone();
                                }
                                else if ((int)(new HTuple(hv_i_ballMeasureType.TupleEqual(
                                    "ellipse"))) != 0)
                                {
                                    HOperatorSet.SmallestRectangle2(ho__BallContour, out hv_RowReg, out hv_ColReg,
                                        out hv_ColPhi, out hv_Len1Reg, out hv_Len2Reg);
                                    hv_o_BallRadius = new HTuple();
                                    hv_o_BallRadius = hv_o_BallRadius.TupleConcat(hv_Len1Reg);
                                    hv_o_BallRadius = hv_o_BallRadius.TupleConcat(hv_Len2Reg);
                                }
                            }
                        }
                        //计算焊点偏移
                        HOperatorSet.AreaCenter(ho_i_InspectReg, out hv_PadArea, out hv_PadRow,
                            out hv_PadCol);
                        HOperatorSet.AreaCenter(ho__BallContour, out hv_BondArea, out hv_BondRow,
                            out hv_BondCol);
                        //偏移距离
                        HOperatorSet.DistancePp(hv_PadRow, hv_PadCol, hv_BondRow, hv_BondCol, out hv_BondDist);
                        //阈值暂定焊盘半径一半，应由外部设置
                        hv_DistTh = hv_i_PadSize * hv_i_ballShiftRatioThr;
                        //输出偏移比例
                        hv_o_BallShiftRatio = hv_BondDist / hv_i_PadSize;
                        //
                        if ((int)(new HTuple(hv_BondDist.TupleGreater(hv_DistTh))) != 0)
                        {
                            //aroundbond输出焊点偏移
                            hv_o_ErrCode = 15;
                            hv_o_ErrStr = "Ball is shift";
                            ho_BondImage.Dispose();
                            ho_SecBondRegs.Dispose();
                            ho_SecBondRegFillup.Dispose();
                            ho_SecBondRegMorph.Dispose();
                            ho_ConnectedSecBondRegs.Dispose();
                            ho_MaxSecBondReg.Dispose();
                            ho__BallContour.Dispose();

                            return;
                        }
                    }
                    else
                    {
                        //aroundbond输出焊点脱落
                        hv_o_BallShiftRatio = 1.0;
                        hv_o_ErrCode = 14;
                        hv_o_ErrStr = "Ball is not exist";
                        ho_BondImage.Dispose();
                        ho_SecBondRegs.Dispose();
                        ho_SecBondRegFillup.Dispose();
                        ho_SecBondRegMorph.Dispose();
                        ho_ConnectedSecBondRegs.Dispose();
                        ho_MaxSecBondReg.Dispose();
                        ho__BallContour.Dispose();

                        return;
                    }
                }
                else
                {
                    //已有精确的焊点区域
                    ho_o_BallContour.Dispose();
                    ho_o_BallContour = ho_i_RefBall.CopyObj(1, -1);
                    //计算焊点偏移
                    HOperatorSet.AreaCenter(ho_i_InspectReg, out hv_PadArea, out hv_PadRow, out hv_PadCol);
                    HOperatorSet.AreaCenter(ho_i_RefBall, out hv_BondArea, out hv_BondRow, out hv_BondCol);
                    //偏移距离
                    HOperatorSet.DistancePp(hv_PadRow, hv_PadCol, hv_BondRow, hv_BondCol, out hv_BondDist);
                    //阈值暂定焊盘半径一半，应由外部设置
                    hv_DistTh = hv_i_PadSize * hv_i_ballShiftRatioThr;
                    //输出偏移比例
                    hv_o_BallShiftRatio = hv_BondDist / hv_i_PadSize;
                    //
                    if ((int)(new HTuple(hv_BondDist.TupleGreater(hv_DistTh))) != 0)
                    {
                        //aroundbond输出焊点偏移
                        hv_o_ErrCode = 15;
                        hv_o_ErrStr = "Ball is shift";
                        ho_BondImage.Dispose();
                        ho_SecBondRegs.Dispose();
                        ho_SecBondRegFillup.Dispose();
                        ho_SecBondRegMorph.Dispose();
                        ho_ConnectedSecBondRegs.Dispose();
                        ho_MaxSecBondReg.Dispose();
                        ho__BallContour.Dispose();

                        return;
                    }
                }
                //
                hv_o_ErrCode = 0;
                hv_o_ErrStr = "Ball is ok";
                ho_BondImage.Dispose();
                ho_SecBondRegs.Dispose();
                ho_SecBondRegFillup.Dispose();
                ho_SecBondRegMorph.Dispose();
                ho_ConnectedSecBondRegs.Dispose();
                ho_MaxSecBondReg.Dispose();
                ho__BallContour.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_BondImage.Dispose();
                ho_SecBondRegs.Dispose();
                ho_SecBondRegFillup.Dispose();
                ho_SecBondRegMorph.Dispose();
                ho_ConnectedSecBondRegs.Dispose();
                ho_MaxSecBondReg.Dispose();
                ho__BallContour.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public static void HTV_around_ball_dirty_inspect(HObject ho_i_Image, HObject ho_i_InspectReg,
            out HObject ho_o_FailReg, HTuple hv_i_adaptiveMethod, HTuple hv_i_blockSize,
            HTuple hv_i_contrast, HTuple hv_i_lightOrDark, HTuple hv_i_closeSize, HTuple hv_i_minLength,
            HTuple hv_i_minWidth, HTuple hv_i_minArea, HTuple hv_i_selOperation, out HTuple hv_o_DirtyArea,
            out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho__AroundBallImage, ho__SegImage;
            HObject ho__SubReg = null, ho_o_TargetRegs = null, ho_RegionUnion = null;

            // Local control variables 

            HTuple hv__ThresholdErrCode = null, hv__ThresholdErrStr = null;
            HTuple hv__BlobErrCode = new HTuple(), hv__BlobErrStr = new HTuple();
            HTuple hv_Number = new HTuple(), hv_Row = new HTuple();
            HTuple hv_Column = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_FailReg);
            HOperatorSet.GenEmptyObj(out ho__AroundBallImage);
            HOperatorSet.GenEmptyObj(out ho__SegImage);
            HOperatorSet.GenEmptyObj(out ho__SubReg);
            HOperatorSet.GenEmptyObj(out ho_o_TargetRegs);
            HOperatorSet.GenEmptyObj(out ho_RegionUnion);
            try
            {
                //************************************
                //write by wj 2020-12-02
                //***********************************
                //初始化输出

                ho_o_FailReg.Dispose();
                HOperatorSet.GenEmptyObj(out ho_o_FailReg);
                hv_o_DirtyArea = -2;
                //
                hv_o_ErrCode = -2;
                hv_o_ErrStr = "initializing";
                //
                //参数合理性判断
                //
                //*****************************Inspection*******************************

                //获取AroundBond检测图像
                ho__AroundBallImage.Dispose();
                HOperatorSet.ReduceDomain(ho_i_Image, ho_i_InspectReg, out ho__AroundBallImage
                    );
                //
                ho__SegImage.Dispose();
                HTV_Adaptive_Threshold(ho__AroundBallImage, out ho__SegImage, hv_i_adaptiveMethod,
                    hv_i_blockSize, hv_i_contrast, hv_i_lightOrDark, out hv__ThresholdErrCode,
                    out hv__ThresholdErrStr);

                if ((int)(new HTuple(hv__ThresholdErrCode.TupleEqual(0))) != 0)
                {
                    //对阈值分割后的目标区域图像进行BLOB分析
                    ho__SubReg.Dispose();
                    HOperatorSet.GenEmptyObj(out ho__SubReg);
                    ho_o_TargetRegs.Dispose();
                    HTV_BLOB_Extract(ho__SegImage, ho_i_InspectReg, ho__SubReg, out ho_o_TargetRegs,
                        hv_i_closeSize, hv_i_minLength, hv_i_minWidth, hv_i_minArea, hv_i_selOperation,
                        out hv__BlobErrCode, out hv__BlobErrStr);

                    //对Blob分析后的结果进行缺陷判断
                    HOperatorSet.CountObj(ho_o_TargetRegs, out hv_Number);
                    if ((int)((new HTuple(hv__BlobErrCode.TupleEqual(0))).TupleAnd(new HTuple(hv_Number.TupleGreaterEqual(
                        1)))) != 0)
                    {
                        //缺陷区域Concat
                        ho_RegionUnion.Dispose();
                        HOperatorSet.Union1(ho_o_TargetRegs, out ho_RegionUnion);
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(ho_o_FailReg, ho_RegionUnion, out ExpTmpOutVar_0
                                );
                            ho_o_FailReg.Dispose();
                            ho_o_FailReg = ExpTmpOutVar_0;
                        }
                        //
                        HOperatorSet.AreaCenter(ho_RegionUnion, out hv_o_DirtyArea, out hv_Row,
                            out hv_Column);

                        hv_o_ErrCode = 31;
                        hv_o_ErrStr = "around ball region is dirty";
                        ho__AroundBallImage.Dispose();
                        ho__SegImage.Dispose();
                        ho__SubReg.Dispose();
                        ho_o_TargetRegs.Dispose();
                        ho_RegionUnion.Dispose();

                        return;

                    }
                    else if ((int)((new HTuple(hv__BlobErrCode.TupleEqual(0))).TupleAnd(
                        new HTuple(hv_Number.TupleEqual(0)))) != 0)
                    {
                        hv_o_DirtyArea = 0;
                        hv_o_ErrCode = 0;
                        hv_o_ErrStr = "around ball region is clear";
                        ho__AroundBallImage.Dispose();
                        ho__SegImage.Dispose();
                        ho__SubReg.Dispose();
                        ho_o_TargetRegs.Dispose();
                        ho_RegionUnion.Dispose();

                        return;
                    }
                    else
                    {
                        //异常处理
                        hv_o_ErrCode = -1;
                        hv_o_ErrStr = "Fail to Surface Blob_Extract--" + hv__BlobErrStr;
                        ho__AroundBallImage.Dispose();
                        ho__SegImage.Dispose();
                        ho__SubReg.Dispose();
                        ho_o_TargetRegs.Dispose();
                        ho_RegionUnion.Dispose();

                        return;
                    }
                }
                else
                {
                    //异常处理
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "Fail to Surface threshold" + hv__ThresholdErrStr;
                    ho__AroundBallImage.Dispose();
                    ho__SegImage.Dispose();
                    ho__SubReg.Dispose();
                    ho_o_TargetRegs.Dispose();
                    ho_RegionUnion.Dispose();

                    return;
                }

            }
            catch (HalconException HDevExpDefaultException)
            {
                ho__AroundBallImage.Dispose();
                ho__SegImage.Dispose();
                ho__SubReg.Dispose();
                ho_o_TargetRegs.Dispose();
                ho_RegionUnion.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public static void HTV_Tail_Inspect_gauss(HObject ho_i_Image, HObject ho_i_InspectReg,
            HObject ho_i_RefBall, out HObject ho_o_TailReg, HTuple hv_i_RefDirection, HTuple hv_i_LineWidth,
            HTuple hv_i_LineContrast, HTuple hv_i_Transition, HTuple hv_i_SelMetric, HTuple hv_i_SelMin,
            HTuple hv_i_SelMax, HTuple hv_i_LineGap, HTuple hv_i_GrayThresh, out HTuple hv_o_TailLength,
            out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_TailLineReg, ho_LineRegDilation;
            HObject ho_TailInspectRegTmp, ho_TailInspectReg, ho_linesImage;
            HObject ho_Lines = null, ho_Lines1 = null, ho_ContoursSplit;
            HObject ho__Lines, ho_ImageReduced = null, ho_TailReg = null;
            HObject ho_EmptyReg = null;

            // Local control variables 

            HTuple hv_o_ErrString = null, hv_imgNum = null;
            HTuple hv_regNum = null, hv_BallRow = null, hv_BallCol = null;
            HTuple hv_Phi = null, hv_Len1 = null, hv_Len2 = null, hv_Length = null;
            HTuple hv_Sigma = null, hv_Low = null, hv_High = null;
            HTuple hv_lineSegNum = null, hv_MinDistance = null, hv_IdxWire = null;
            HTuple hv_RowBegin = new HTuple(), hv_ColBegin = new HTuple();
            HTuple hv_RowEnd = new HTuple(), hv_ColEnd = new HTuple();
            HTuple hv_Nr = new HTuple(), hv_Nc = new HTuple(), hv_Dist = new HTuple();
            HTuple hv_Distance1Min = new HTuple(), hv_Distance1Max = new HTuple();
            HTuple hv_Distance2Min = new HTuple(), hv_Distance2Max = new HTuple();
            HTuple hv_Min = new HTuple(), hv_TailLineArea = new HTuple();
            HTuple hv_TailLineRow = new HTuple(), hv_TailLineCol = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_TailReg);
            HOperatorSet.GenEmptyObj(out ho_TailLineReg);
            HOperatorSet.GenEmptyObj(out ho_LineRegDilation);
            HOperatorSet.GenEmptyObj(out ho_TailInspectRegTmp);
            HOperatorSet.GenEmptyObj(out ho_TailInspectReg);
            HOperatorSet.GenEmptyObj(out ho_linesImage);
            HOperatorSet.GenEmptyObj(out ho_Lines);
            HOperatorSet.GenEmptyObj(out ho_Lines1);
            HOperatorSet.GenEmptyObj(out ho_ContoursSplit);
            HOperatorSet.GenEmptyObj(out ho__Lines);
            HOperatorSet.GenEmptyObj(out ho_ImageReduced);
            HOperatorSet.GenEmptyObj(out ho_TailReg);
            HOperatorSet.GenEmptyObj(out ho_EmptyReg);
            hv_o_ErrStr = new HTuple();
            try
            {
                //********************************************************************************************************************
                // 高斯剖面曲线法提取区域内的线目标（如：金线、划痕等）
                // i_Image: 输入图像，待处理图像
                // i_LinesReg: 线目标提取区域
                // o_Wire: 提取的线目标对象
                // i_LineWidth: 线目标的宽度
                // i_LineContrast: 线目标的对比度，一般大于20
                // i_SelMetric: 筛选目标时的特征量，为一个字符串序列，见select_shape的特征取值
                // i_SelMin: 筛选特征时满足的最小值，每个特征对应一个最小值
                // i_SelMax: 筛选特征时满足的最大值，每个特征对应一个最大值
                // i_LineGap: 检测过程允许的最大断线间隔
                // i_LineWidthMax: 最大允许线宽
                // o_LineWidth: 实际检测线宽
                // o_ErrCode: 错误码，代表该算子执行过程中产生的错误，0-代表正常执行，自然数-代表错误类型，-1-代表异常，-2-代表未执行
                // o_ErrStr: 错误信息，对各种错误的具体描述
                //********************************************************************************************************************

                //初始化
                hv_o_ErrCode = -2;
                hv_o_ErrString = "Initializing";
                hv_o_TailLength = 0;
                ho_o_TailReg.Dispose();
                HOperatorSet.GenEmptyObj(out ho_o_TailReg);
                //输入合法性检测
                HOperatorSet.CountObj(ho_i_Image, out hv_imgNum);
                if ((int)(new HTuple(hv_imgNum.TupleEqual(0))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrString = "input image is empty!";
                    ho_TailLineReg.Dispose();
                    ho_LineRegDilation.Dispose();
                    ho_TailInspectRegTmp.Dispose();
                    ho_TailInspectReg.Dispose();
                    ho_linesImage.Dispose();
                    ho_Lines.Dispose();
                    ho_Lines1.Dispose();
                    ho_ContoursSplit.Dispose();
                    ho__Lines.Dispose();
                    ho_ImageReduced.Dispose();
                    ho_TailReg.Dispose();
                    ho_EmptyReg.Dispose();

                    return;
                }
                HOperatorSet.CountObj(ho_i_InspectReg, out hv_regNum);
                if ((int)(new HTuple(hv_regNum.TupleEqual(0))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrString = "inspect region is empty!";
                    ho_TailLineReg.Dispose();
                    ho_LineRegDilation.Dispose();
                    ho_TailInspectRegTmp.Dispose();
                    ho_TailInspectReg.Dispose();
                    ho_linesImage.Dispose();
                    ho_Lines.Dispose();
                    ho_Lines1.Dispose();
                    ho_ContoursSplit.Dispose();
                    ho__Lines.Dispose();
                    ho_ImageReduced.Dispose();
                    ho_TailReg.Dispose();
                    ho_EmptyReg.Dispose();

                    return;
                }

                if ((int)((new HTuple((new HTuple(hv_i_LineWidth.TupleLength())).TupleEqual(
                    0))).TupleOr(new HTuple(hv_i_LineWidth.TupleLess(1)))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrString = "inspect coef i_LineWidth must be above zero!";
                    ho_TailLineReg.Dispose();
                    ho_LineRegDilation.Dispose();
                    ho_TailInspectRegTmp.Dispose();
                    ho_TailInspectReg.Dispose();
                    ho_linesImage.Dispose();
                    ho_Lines.Dispose();
                    ho_Lines1.Dispose();
                    ho_ContoursSplit.Dispose();
                    ho__Lines.Dispose();
                    ho_ImageReduced.Dispose();
                    ho_TailReg.Dispose();
                    ho_EmptyReg.Dispose();

                    return;
                }
                if ((int)((new HTuple((new HTuple(hv_i_LineContrast.TupleLength())).TupleEqual(
                    0))).TupleOr(new HTuple(hv_i_LineContrast.TupleLess(1)))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrString = "inspect coef i_LineContrast must be above 1!";
                    ho_TailLineReg.Dispose();
                    ho_LineRegDilation.Dispose();
                    ho_TailInspectRegTmp.Dispose();
                    ho_TailInspectReg.Dispose();
                    ho_linesImage.Dispose();
                    ho_Lines.Dispose();
                    ho_Lines1.Dispose();
                    ho_ContoursSplit.Dispose();
                    ho__Lines.Dispose();
                    ho_ImageReduced.Dispose();
                    ho_TailReg.Dispose();
                    ho_EmptyReg.Dispose();

                    return;
                }
                if ((int)(new HTuple((new HTuple(hv_i_GrayThresh.TupleLength())).TupleNotEqual(
                    2))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrString = "inspect coef i_GrayThresh is error!";
                    ho_TailLineReg.Dispose();
                    ho_LineRegDilation.Dispose();
                    ho_TailInspectRegTmp.Dispose();
                    ho_TailInspectReg.Dispose();
                    ho_linesImage.Dispose();
                    ho_Lines.Dispose();
                    ho_Lines1.Dispose();
                    ho_ContoursSplit.Dispose();
                    ho__Lines.Dispose();
                    ho_ImageReduced.Dispose();
                    ho_TailReg.Dispose();
                    ho_EmptyReg.Dispose();

                    return;
                }
                //**********************************************************************
                //提取尾丝检测区
                HOperatorSet.SmallestRectangle2(ho_i_RefBall, out hv_BallRow, out hv_BallCol,
                    out hv_Phi, out hv_Len1, out hv_Len2);
                hv_Length = hv_Len1 * 3;
                ho_TailLineReg.Dispose();
                HOperatorSet.GenRegionLine(out ho_TailLineReg, hv_BallRow, hv_BallCol, hv_BallRow - (hv_Length * (hv_i_RefDirection.TupleSin()
                    )), hv_BallCol + (hv_Length * (hv_i_RefDirection.TupleCos())));
                ho_LineRegDilation.Dispose();
                HOperatorSet.DilationCircle(ho_TailLineReg, out ho_LineRegDilation, (hv_i_LineWidth / 2) + 1);
                ho_TailInspectRegTmp.Dispose();
                HOperatorSet.Intersection(ho_LineRegDilation, ho_i_InspectReg, out ho_TailInspectRegTmp
                    );
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.DilationCircle(ho_TailInspectRegTmp, out ExpTmpOutVar_0, (hv_i_LineWidth / 4) + 1);
                    ho_TailInspectRegTmp.Dispose();
                    ho_TailInspectRegTmp = ExpTmpOutVar_0;
                }
                ho_TailInspectReg.Dispose();
                HOperatorSet.Intersection(ho_TailInspectRegTmp, ho_i_InspectReg, out ho_TailInspectReg
                    );
                //
                // 高斯剖面曲线法提取区域内的线目标轮廓
                ho_linesImage.Dispose();
                HOperatorSet.ReduceDomain(ho_i_Image, ho_TailInspectReg, out ho_linesImage);
                //高斯滤波
                //gauss_filter (linesImage, ImageGauss, 3)
                calculate_lines_gauss_parameters(hv_i_LineWidth, hv_i_LineContrast, out hv_Sigma,
                    out hv_Low, out hv_High);
                if ((int)(new HTuple(((hv_i_Transition.TupleSelect(0))).TupleEqual("all"))) != 0)
                {
                    ho_Lines.Dispose();
                    HOperatorSet.LinesGauss(ho_linesImage, out ho_Lines, hv_Sigma, hv_Low, hv_High,
                        "dark", "true", "bar-shaped", "true");
                    ho_Lines1.Dispose();
                    HOperatorSet.LinesGauss(ho_linesImage, out ho_Lines1, hv_Sigma, hv_Low, hv_High,
                        "light", "true", "bar-shaped", "true");
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_Lines, ho_Lines1, out ExpTmpOutVar_0);
                        ho_Lines.Dispose();
                        ho_Lines = ExpTmpOutVar_0;
                    }
                }
                else
                {
                    ho_Lines.Dispose();
                    HOperatorSet.LinesGauss(ho_linesImage, out ho_Lines, hv_Sigma, hv_Low, hv_High,
                        hv_i_Transition.TupleSelect(0), "true", "bar-shaped", "true");
                }
                //
                ho_ContoursSplit.Dispose();
                HOperatorSet.SegmentContoursXld(ho_Lines, out ho_ContoursSplit, "lines", 2,
                    1, 1);

                //**************筛选轮廓线
                //按照最小线长度初步筛选线段
                ho__Lines.Dispose();
                HOperatorSet.SelectContoursXld(ho_ContoursSplit, out ho__Lines, hv_i_SelMetric.TupleSelect(
                    0), hv_i_SelMin.TupleSelect(0), hv_i_SelMax.TupleSelect(0), -0.5, 0.5);
                //
                //分析检测结果
                HOperatorSet.CountObj(ho__Lines, out hv_lineSegNum);
                if ((int)(new HTuple(hv_lineSegNum.TupleEqual(0))) != 0)
                {
                    hv_o_ErrCode = 0;
                    hv_o_ErrStr = "No Tail or No defect area!";
                    ho_TailLineReg.Dispose();
                    ho_LineRegDilation.Dispose();
                    ho_TailInspectRegTmp.Dispose();
                    ho_TailInspectReg.Dispose();
                    ho_linesImage.Dispose();
                    ho_Lines.Dispose();
                    ho_Lines1.Dispose();
                    ho_ContoursSplit.Dispose();
                    ho__Lines.Dispose();
                    ho_ImageReduced.Dispose();
                    ho_TailReg.Dispose();
                    ho_EmptyReg.Dispose();

                    return;
                }
                //
                //判断是否为尾丝
                hv_MinDistance = new HTuple();
                HTuple end_val90 = hv_lineSegNum - 1;
                HTuple step_val90 = 1;
                for (hv_IdxWire = 0; hv_IdxWire.Continue(end_val90, step_val90); hv_IdxWire = hv_IdxWire.TupleAdd(step_val90))
                {
                    HOperatorSet.FitLineContourXld(ho__Lines, "huber", -1, 0, 5, 2, out hv_RowBegin,
                        out hv_ColBegin, out hv_RowEnd, out hv_ColEnd, out hv_Nr, out hv_Nc,
                        out hv_Dist);
                    //检测出的线段端点到参考区域的距离
                    HOperatorSet.DistancePr(ho_i_RefBall, hv_RowBegin.TupleSelect(hv_IdxWire),
                        hv_ColBegin.TupleSelect(hv_IdxWire), out hv_Distance1Min, out hv_Distance1Max);
                    HOperatorSet.DistancePr(ho_i_RefBall, hv_RowEnd.TupleSelect(hv_IdxWire),
                        hv_ColEnd.TupleSelect(hv_IdxWire), out hv_Distance2Min, out hv_Distance2Max);
                    //
                    hv_Min = hv_Distance1Min.TupleMin2(hv_Distance2Min);
                    //
                    hv_MinDistance = hv_MinDistance.TupleConcat(hv_Min);
                }

                //满足距离阈值输出尾丝长 -- mod by lw
                if ((int)(new HTuple(((hv_MinDistance.TupleMin())).TupleLess(hv_i_LineGap))) != 0)
                {

                    ho_ImageReduced.Dispose();
                    HOperatorSet.ReduceDomain(ho_i_Image, ho_TailInspectReg, out ho_ImageReduced
                        );
                    ho_TailReg.Dispose();
                    HOperatorSet.Threshold(ho_ImageReduced, out ho_TailReg, hv_i_GrayThresh.TupleSelect(
                        0), hv_i_GrayThresh.TupleSelect(1));
                    //开运算去毛刺
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.OpeningCircle(ho_TailReg, out ExpTmpOutVar_0, 1);
                        ho_TailReg.Dispose();
                        ho_TailReg = ExpTmpOutVar_0;
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.DilationCircle(ho_TailReg, out ExpTmpOutVar_0, 1);
                        ho_TailReg.Dispose();
                        ho_TailReg = ExpTmpOutVar_0;
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.Intersection(ho_TailReg, ho_TailLineReg, out ExpTmpOutVar_0);
                        ho_TailLineReg.Dispose();
                        ho_TailLineReg = ExpTmpOutVar_0;
                    }
                    //以单像素面积为尾丝长
                    HOperatorSet.AreaCenter(ho_TailLineReg, out hv_TailLineArea, out hv_TailLineRow,
                        out hv_TailLineCol);
                    //输出尾丝区域和长度
                    ho_o_TailReg.Dispose();
                    ho_o_TailReg = ho_TailReg.CopyObj(1, -1);
                    hv_o_TailLength = hv_TailLineArea + 0.5;
                    hv_o_ErrCode = 1;
                    hv_o_ErrStr = "Tail is exist!";
                    ho_TailLineReg.Dispose();
                    ho_LineRegDilation.Dispose();
                    ho_TailInspectRegTmp.Dispose();
                    ho_TailInspectReg.Dispose();
                    ho_linesImage.Dispose();
                    ho_Lines.Dispose();
                    ho_Lines1.Dispose();
                    ho_ContoursSplit.Dispose();
                    ho__Lines.Dispose();
                    ho_ImageReduced.Dispose();
                    ho_TailReg.Dispose();
                    ho_EmptyReg.Dispose();

                    return;
                }
                else
                {
                    ho_EmptyReg.Dispose();
                    HOperatorSet.GenEmptyRegion(out ho_EmptyReg);
                    ho_o_TailReg.Dispose();
                    ho_o_TailReg = ho_EmptyReg.CopyObj(1, -1);
                    hv_o_TailLength = 0;
                }

                hv_o_ErrCode = 0;
                hv_o_ErrStr = "No Tail or No defect area!";
                ho_TailLineReg.Dispose();
                ho_LineRegDilation.Dispose();
                ho_TailInspectRegTmp.Dispose();
                ho_TailInspectReg.Dispose();
                ho_linesImage.Dispose();
                ho_Lines.Dispose();
                ho_Lines1.Dispose();
                ho_ContoursSplit.Dispose();
                ho__Lines.Dispose();
                ho_ImageReduced.Dispose();
                ho_TailReg.Dispose();
                ho_EmptyReg.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_TailLineReg.Dispose();
                ho_LineRegDilation.Dispose();
                ho_TailInspectRegTmp.Dispose();
                ho_TailInspectReg.Dispose();
                ho_linesImage.Dispose();
                ho_Lines.Dispose();
                ho_Lines1.Dispose();
                ho_ContoursSplit.Dispose();
                ho__Lines.Dispose();
                ho_ImageReduced.Dispose();
                ho_TailReg.Dispose();
                ho_EmptyReg.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public static void HTV_AroundBond_Wire_Inspect(HObject ho_i_Image, HObject ho_i_InspectReg,
            HObject ho_i_RefBall, out HObject ho_o_WireReg, out HObject ho_o_WireInspectReg,
            HTuple hv_i_RefDirection, HTuple hv_i_LineWidth, HTuple hv_i_LineContrast, HTuple hv_i_Transition,
            HTuple hv_i_SelMetric, HTuple hv_i_SelMin, HTuple hv_i_SelMax, HTuple hv_i_LineGap,
            HTuple hv_i_GrayThresh, out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_WireLineReg, ho_LineRegDilation;
            HObject ho_WireInspectRegTmp, ho_WireInspectReg, ho_linesImage;
            HObject ho_Lines = null, ho_Lines1 = null, ho_ContoursSplit;
            HObject ho_SelectedContours, ho__Lines, ho_EmptyReg = null;
            HObject ho_ImageReduced, ho_WireReg;

            // Local control variables 

            HTuple hv_o_ErrString = null, hv_imgNum = null;
            HTuple hv_regNum = null, hv_BallRow = null, hv_BallCol = null;
            HTuple hv_Phi = null, hv_Len1 = null, hv_Len2 = null, hv_Length = null;
            HTuple hv_Sigma = null, hv_Low = null, hv_High = null;
            HTuple hv_pos = null, hv_selGE = null, hv_selIndices = null;
            HTuple hv_MinPhi = new HTuple(), hv_MaxPhi = new HTuple();
            HTuple hv_lineSegNum = null;
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_WireReg);
            HOperatorSet.GenEmptyObj(out ho_o_WireInspectReg);
            HOperatorSet.GenEmptyObj(out ho_WireLineReg);
            HOperatorSet.GenEmptyObj(out ho_LineRegDilation);
            HOperatorSet.GenEmptyObj(out ho_WireInspectRegTmp);
            HOperatorSet.GenEmptyObj(out ho_WireInspectReg);
            HOperatorSet.GenEmptyObj(out ho_linesImage);
            HOperatorSet.GenEmptyObj(out ho_Lines);
            HOperatorSet.GenEmptyObj(out ho_Lines1);
            HOperatorSet.GenEmptyObj(out ho_ContoursSplit);
            HOperatorSet.GenEmptyObj(out ho_SelectedContours);
            HOperatorSet.GenEmptyObj(out ho__Lines);
            HOperatorSet.GenEmptyObj(out ho_EmptyReg);
            HOperatorSet.GenEmptyObj(out ho_ImageReduced);
            HOperatorSet.GenEmptyObj(out ho_WireReg);
            hv_o_ErrStr = new HTuple();
            try
            {
                //********************************************************************************************************************
                // 高斯剖面曲线法提取区域内的线目标（如：金线、划痕等）
                // i_Image: 输入图像，待处理图像
                // i_LinesReg: 线目标提取区域
                // o_Wire: 提取的线目标对象
                // i_LineWidth: 线目标的宽度
                // i_LineContrast: 线目标的对比度，一般大于20
                // i_SelMetric: 筛选目标时的特征量，为一个字符串序列，见select_shape的特征取值
                // i_SelMin: 筛选特征时满足的最小值，每个特征对应一个最小值
                // i_SelMax: 筛选特征时满足的最大值，每个特征对应一个最大值
                // i_LineGap: 检测过程允许的最大断线间隔
                // i_LineWidthMax: 最大允许线宽
                // o_LineWidth: 实际检测线宽
                // o_ErrCode: 错误码，代表该算子执行过程中产生的错误，0-代表正常执行，自然数-代表错误类型，-1-代表异常，-2-代表未执行
                // o_ErrStr: 错误信息，对各种错误的具体描述
                //********************************************************************************************************************

                //初始化
                hv_o_ErrCode = -2;
                hv_o_ErrString = "Initializing";
                ho_o_WireReg.Dispose();
                HOperatorSet.GenEmptyObj(out ho_o_WireReg);
                //输入合法性检测
                HOperatorSet.CountObj(ho_i_Image, out hv_imgNum);
                if ((int)(new HTuple(hv_imgNum.TupleEqual(0))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrString = "input image is empty!";
                    ho_WireLineReg.Dispose();
                    ho_LineRegDilation.Dispose();
                    ho_WireInspectRegTmp.Dispose();
                    ho_WireInspectReg.Dispose();
                    ho_linesImage.Dispose();
                    ho_Lines.Dispose();
                    ho_Lines1.Dispose();
                    ho_ContoursSplit.Dispose();
                    ho_SelectedContours.Dispose();
                    ho__Lines.Dispose();
                    ho_EmptyReg.Dispose();
                    ho_ImageReduced.Dispose();
                    ho_WireReg.Dispose();

                    return;
                }
                HOperatorSet.CountObj(ho_i_InspectReg, out hv_regNum);
                if ((int)(new HTuple(hv_regNum.TupleEqual(0))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrString = "inspect region is empty!";
                    ho_WireLineReg.Dispose();
                    ho_LineRegDilation.Dispose();
                    ho_WireInspectRegTmp.Dispose();
                    ho_WireInspectReg.Dispose();
                    ho_linesImage.Dispose();
                    ho_Lines.Dispose();
                    ho_Lines1.Dispose();
                    ho_ContoursSplit.Dispose();
                    ho_SelectedContours.Dispose();
                    ho__Lines.Dispose();
                    ho_EmptyReg.Dispose();
                    ho_ImageReduced.Dispose();
                    ho_WireReg.Dispose();

                    return;
                }

                if ((int)((new HTuple((new HTuple(hv_i_LineWidth.TupleLength())).TupleEqual(
                    0))).TupleOr(new HTuple(hv_i_LineWidth.TupleLess(1)))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrString = "inspect coef i_LineWidth must be above zero!";
                    ho_WireLineReg.Dispose();
                    ho_LineRegDilation.Dispose();
                    ho_WireInspectRegTmp.Dispose();
                    ho_WireInspectReg.Dispose();
                    ho_linesImage.Dispose();
                    ho_Lines.Dispose();
                    ho_Lines1.Dispose();
                    ho_ContoursSplit.Dispose();
                    ho_SelectedContours.Dispose();
                    ho__Lines.Dispose();
                    ho_EmptyReg.Dispose();
                    ho_ImageReduced.Dispose();
                    ho_WireReg.Dispose();

                    return;
                }
                if ((int)((new HTuple((new HTuple(hv_i_LineContrast.TupleLength())).TupleEqual(
                    0))).TupleOr(new HTuple(hv_i_LineContrast.TupleLess(1)))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrString = "inspect coef i_LineContrast must be above 1!";
                    ho_WireLineReg.Dispose();
                    ho_LineRegDilation.Dispose();
                    ho_WireInspectRegTmp.Dispose();
                    ho_WireInspectReg.Dispose();
                    ho_linesImage.Dispose();
                    ho_Lines.Dispose();
                    ho_Lines1.Dispose();
                    ho_ContoursSplit.Dispose();
                    ho_SelectedContours.Dispose();
                    ho__Lines.Dispose();
                    ho_EmptyReg.Dispose();
                    ho_ImageReduced.Dispose();
                    ho_WireReg.Dispose();

                    return;
                }
                if ((int)(new HTuple((new HTuple(hv_i_GrayThresh.TupleLength())).TupleNotEqual(
                    2))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrString = "inspect coef i_GrayThresh is error!";
                    ho_WireLineReg.Dispose();
                    ho_LineRegDilation.Dispose();
                    ho_WireInspectRegTmp.Dispose();
                    ho_WireInspectReg.Dispose();
                    ho_linesImage.Dispose();
                    ho_Lines.Dispose();
                    ho_Lines1.Dispose();
                    ho_ContoursSplit.Dispose();
                    ho_SelectedContours.Dispose();
                    ho__Lines.Dispose();
                    ho_EmptyReg.Dispose();
                    ho_ImageReduced.Dispose();
                    ho_WireReg.Dispose();

                    return;
                }
                //**********************************************************************
                //提取尾丝检测区
                HOperatorSet.SmallestRectangle2(ho_i_RefBall, out hv_BallRow, out hv_BallCol,
                    out hv_Phi, out hv_Len1, out hv_Len2);
                hv_Length = hv_Len1 * 3;
                ho_WireLineReg.Dispose();
                HOperatorSet.GenRegionLine(out ho_WireLineReg, hv_BallRow, hv_BallCol, hv_BallRow - (hv_Length * (hv_i_RefDirection.TupleSin()
                    )), hv_BallCol + (hv_Length * (hv_i_RefDirection.TupleCos())));
                ho_LineRegDilation.Dispose();
                HOperatorSet.DilationCircle(ho_WireLineReg, out ho_LineRegDilation, (hv_i_LineWidth / 2) + 1);
                ho_WireInspectRegTmp.Dispose();
                HOperatorSet.Intersection(ho_LineRegDilation, ho_i_InspectReg, out ho_WireInspectRegTmp
                    );
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.DilationCircle(ho_WireInspectRegTmp, out ExpTmpOutVar_0, (hv_i_LineWidth / 4) + 1);
                    ho_WireInspectRegTmp.Dispose();
                    ho_WireInspectRegTmp = ExpTmpOutVar_0;
                }
                ho_WireInspectReg.Dispose();
                HOperatorSet.Intersection(ho_WireInspectRegTmp, ho_i_InspectReg, out ho_WireInspectReg
                    );
                //输出金线检测区
                ho_o_WireInspectReg.Dispose();
                ho_o_WireInspectReg = ho_WireInspectReg.CopyObj(1, -1);
                //
                // 高斯剖面曲线法提取区域内的线目标轮廓
                ho_linesImage.Dispose();
                HOperatorSet.ReduceDomain(ho_i_Image, ho_WireInspectReg, out ho_linesImage);
                calculate_lines_gauss_parameters(hv_i_LineWidth, hv_i_LineContrast, out hv_Sigma,
                    out hv_Low, out hv_High);
                if ((int)(new HTuple(((hv_i_Transition.TupleSelect(0))).TupleEqual("all"))) != 0)
                {
                    ho_Lines.Dispose();
                    HOperatorSet.LinesGauss(ho_linesImage, out ho_Lines, hv_Sigma, hv_Low, hv_High,
                        "dark", "true", "bar-shaped", "true");
                    ho_Lines1.Dispose();
                    HOperatorSet.LinesGauss(ho_linesImage, out ho_Lines1, hv_Sigma, hv_Low, hv_High,
                        "light", "true", "bar-shaped", "true");
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_Lines, ho_Lines1, out ExpTmpOutVar_0);
                        ho_Lines.Dispose();
                        ho_Lines = ExpTmpOutVar_0;
                    }
                }
                else
                {
                    ho_Lines.Dispose();
                    HOperatorSet.LinesGauss(ho_linesImage, out ho_Lines, hv_Sigma, hv_Low, hv_High,
                        hv_i_Transition.TupleSelect(0), "true", "bar-shaped", "true");
                }
                //
                ho_ContoursSplit.Dispose();
                HOperatorSet.SegmentContoursXld(ho_Lines, out ho_ContoursSplit, "lines", 2,
                    1, 1);


                //如果进行角度筛选，需要参考检测区域的方向
                HOperatorSet.TupleStrstr(hv_i_SelMetric, "direction", out hv_pos);
                HOperatorSet.TupleGreaterEqualElem(hv_pos, 0, out hv_selGE);
                HOperatorSet.TupleFind(hv_selGE, 1, out hv_selIndices);
                //根据参考方向确定方向范围
                if ((int)(new HTuple(hv_selIndices.TupleGreaterEqual(0))) != 0)
                {
                    hv_MinPhi = hv_i_RefDirection + (hv_i_SelMin.TupleSelect(hv_selIndices));
                    hv_MaxPhi = hv_i_RefDirection + (hv_i_SelMax.TupleSelect(hv_selIndices));
                }

                //按照最小线长度、方向角度初步筛选线段
                ho_SelectedContours.Dispose();
                HOperatorSet.SelectContoursXld(ho_ContoursSplit, out ho_SelectedContours, hv_i_SelMetric.TupleSelect(
                    0), hv_i_SelMin.TupleSelect(0), hv_i_SelMax.TupleSelect(0), -0.5, 0.5);
                ho__Lines.Dispose();
                HOperatorSet.SelectContoursXld(ho_SelectedContours, out ho__Lines, hv_i_SelMetric.TupleSelect(
                    1), hv_MinPhi, hv_MaxPhi, -0.5, 0.5);

                //
                //分析检测结果
                HOperatorSet.CountObj(ho__Lines, out hv_lineSegNum);
                if ((int)(new HTuple(hv_lineSegNum.TupleEqual(0))) != 0)
                {

                    ho_EmptyReg.Dispose();
                    HOperatorSet.GenEmptyRegion(out ho_EmptyReg);
                    ho_o_WireReg.Dispose();
                    ho_o_WireReg = ho_EmptyReg.CopyObj(1, -1);

                    hv_o_ErrCode = 0;
                    hv_o_ErrStr = "No Wire area!";
                    ho_WireLineReg.Dispose();
                    ho_LineRegDilation.Dispose();
                    ho_WireInspectRegTmp.Dispose();
                    ho_WireInspectReg.Dispose();
                    ho_linesImage.Dispose();
                    ho_Lines.Dispose();
                    ho_Lines1.Dispose();
                    ho_ContoursSplit.Dispose();
                    ho_SelectedContours.Dispose();
                    ho__Lines.Dispose();
                    ho_EmptyReg.Dispose();
                    ho_ImageReduced.Dispose();
                    ho_WireReg.Dispose();

                    return;
                }
                //
                //判断是否为金线
                //MinDistance := []
                //for IdxWire := 0 to lineSegNum -1 by 1
                //fit_line_contour_xld (_Lines, 'huber', -1, 0, 5, 2, RowBegin, ColBegin, RowEnd, ColEnd, Nr, Nc, Dist)
                //检测出的线段端点到参考区域的距离
                //distance_pr (i_RefBall, RowBegin[IdxWire], ColBegin[IdxWire], Distance1Min, Distance1Max)
                //distance_pr (i_RefBall, RowEnd[IdxWire], ColEnd[IdxWire], Distance2Min, Distance2Max)
                //
                //Min := min2(Distance1Min,Distance2Min)
                //
                //MinDistance := [MinDistance,Min]
                //endfor

                ho_ImageReduced.Dispose();
                HOperatorSet.ReduceDomain(ho_i_Image, ho_WireInspectReg, out ho_ImageReduced
                    );
                ho_WireReg.Dispose();
                HOperatorSet.Threshold(ho_ImageReduced, out ho_WireReg, hv_i_GrayThresh.TupleSelect(
                    0), hv_i_GrayThresh.TupleSelect(1));
                //开运算去毛刺
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.OpeningCircle(ho_WireReg, out ExpTmpOutVar_0, hv_i_LineWidth / 3);
                    ho_WireReg.Dispose();
                    ho_WireReg = ExpTmpOutVar_0;
                }
                //输出金线区域
                ho_o_WireReg.Dispose();
                ho_o_WireReg = ho_WireReg.CopyObj(1, -1);

                hv_o_ErrCode = 0;
                hv_o_ErrStr = "inspect success";
                ho_WireLineReg.Dispose();
                ho_LineRegDilation.Dispose();
                ho_WireInspectRegTmp.Dispose();
                ho_WireInspectReg.Dispose();
                ho_linesImage.Dispose();
                ho_Lines.Dispose();
                ho_Lines1.Dispose();
                ho_ContoursSplit.Dispose();
                ho_SelectedContours.Dispose();
                ho__Lines.Dispose();
                ho_EmptyReg.Dispose();
                ho_ImageReduced.Dispose();
                ho_WireReg.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_WireLineReg.Dispose();
                ho_LineRegDilation.Dispose();
                ho_WireInspectRegTmp.Dispose();
                ho_WireInspectReg.Dispose();
                ho_linesImage.Dispose();
                ho_Lines.Dispose();
                ho_Lines1.Dispose();
                ho_ContoursSplit.Dispose();
                ho_SelectedContours.Dispose();
                ho__Lines.Dispose();
                ho_EmptyReg.Dispose();
                ho_ImageReduced.Dispose();
                ho_WireReg.Dispose();

                throw HDevExpDefaultException;
            }
        }
        #endregion
        public static void HTV_dilation_avoid_region(HObjectVector/*{eObjectVector,Dim=1}*/ hvec_i_IcInspectRegs,
            HObjectVector/*{eObjectVector,Dim=1}*/ hvec_i_EpoxyRegs, HObjectVector/*{eObjectVector,Dim=1}*/ hvec_i_BondContours,
            HObjectVector/*{eObjectVector,Dim=1}*/ hvec_i_WireContours, out HObject ho_o_IcReg,
            out HObject ho_o_EpoxyReg, out HObject ho_o_BondReg, out HObject ho_o_WireReg,
            HTuple hv_i_InspectItemNum, HTuple hv_i_IcDilation, HTuple hv_i_EpoxyDilation,
            HTuple hv_i_BondDilation, HTuple hv_i_WireDilation, out HTuple hv_o_ErrCode,
            out HTuple hv_o_ErrStr)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_EmptyObject, ho__IcReg = null, ho__icReg = null;
            HObject ho__EpoxyReg = null, ho__epoxyReg = null, ho__BondReg = null;
            HObject ho__bondReg = null, ho__WireContour = null, ho__wireReg = null;

            // Local control variables 

            HTuple hv__IcNum = null, hv_icIdx = null, hv_icNum = new HTuple();
            HTuple hv__EpoxyNum = null, hv_epoxyIdx = null, hv_epoxyNum = new HTuple();
            HTuple hv__BondNum = null, hv_bondIdx = null, hv_bondNum = new HTuple();
            HTuple hv__WireNum = null, hv_wireIdx = null, hv_wireNum = new HTuple();
            HTuple hv__ErrCode = new HTuple(), hv__ErrStr = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_IcReg);
            HOperatorSet.GenEmptyObj(out ho_o_EpoxyReg);
            HOperatorSet.GenEmptyObj(out ho_o_BondReg);
            HOperatorSet.GenEmptyObj(out ho_o_WireReg);
            HOperatorSet.GenEmptyObj(out ho_EmptyObject);
            HOperatorSet.GenEmptyObj(out ho__IcReg);
            HOperatorSet.GenEmptyObj(out ho__icReg);
            HOperatorSet.GenEmptyObj(out ho__EpoxyReg);
            HOperatorSet.GenEmptyObj(out ho__epoxyReg);
            HOperatorSet.GenEmptyObj(out ho__BondReg);
            HOperatorSet.GenEmptyObj(out ho__bondReg);
            HOperatorSet.GenEmptyObj(out ho__WireContour);
            HOperatorSet.GenEmptyObj(out ho__wireReg);
            //*******对免检区域进行膨胀
            //-----图标参数
            // i_Lead1WireContours：焊点1处引线轮廓
            // i_Lead2WireContours：焊点2处引线轮廓
            // i_Bond1Regs：焊点1区域
            // i_Bond2Regs：焊点2区域
            // i_EpoxyRegs：银胶区域
            // i_IcInspectReg：Ic检测区域
            // o_WireReg：膨胀后金线区域
            // o_BondReg：膨胀后焊点区域
            // o_EpoxyReg：膨胀后银胶区域
            // o_IcReg：膨胀后Ic区域
            //----控制参数
            // i_WireDilation：金线膨胀系数
            // i_BondDilation：焊点膨胀系数
            // i_EpoxyDilation：银胶膨胀系数
            // i_HomMatMod2Img: Ic模板到图像的映射矩阵--从模板到检测图像的映射关系
            // i_IcDilation：芯片膨胀系数
            // o_ErrCode：错误码，0-执行OK，-1-出现异常，-2-未执行
            // o_ErrStr：错误描述

            //初始化
            ho_EmptyObject.Dispose();
            HOperatorSet.GenEmptyObj(out ho_EmptyObject);
            ho_o_IcReg.Dispose();
            ho_o_IcReg = ho_EmptyObject.CopyObj(1, -1);
            ho_o_EpoxyReg.Dispose();
            ho_o_EpoxyReg = ho_EmptyObject.CopyObj(1, -1);
            ho_o_BondReg.Dispose();
            ho_o_BondReg = ho_EmptyObject.CopyObj(1, -1);
            ho_o_WireReg.Dispose();
            ho_o_WireReg = ho_EmptyObject.CopyObj(1, -1);
            //
            hv_o_ErrCode = -2;
            hv_o_ErrStr = "initializing";
            //
            //输入有效性测试
            if ((int)((new HTuple((new HTuple(hv_i_IcDilation.TupleLength())).TupleLess(1))).TupleOr(
                new HTuple(hv_i_IcDilation.TupleLess(1)))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "the para i_IcDilation must greater than 0";
                ho_EmptyObject.Dispose();
                ho__IcReg.Dispose();
                ho__icReg.Dispose();
                ho__EpoxyReg.Dispose();
                ho__epoxyReg.Dispose();
                ho__BondReg.Dispose();
                ho__bondReg.Dispose();
                ho__WireContour.Dispose();
                ho__wireReg.Dispose();

                return;
            }
            //
            if ((int)((new HTuple((new HTuple(hv_i_EpoxyDilation.TupleLength())).TupleLess(
                1))).TupleOr(new HTuple(hv_i_EpoxyDilation.TupleLess(1)))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "the para i_EpoxyDilation must greater than 0";
                ho_EmptyObject.Dispose();
                ho__IcReg.Dispose();
                ho__icReg.Dispose();
                ho__EpoxyReg.Dispose();
                ho__epoxyReg.Dispose();
                ho__BondReg.Dispose();
                ho__bondReg.Dispose();
                ho__WireContour.Dispose();
                ho__wireReg.Dispose();

                return;
            }
            //
            if ((int)((new HTuple((new HTuple(hv_i_BondDilation.TupleLength())).TupleLess(
                1))).TupleOr(new HTuple(hv_i_BondDilation.TupleLess(1)))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "the para i_BondDilation must greater than 0";
                ho_EmptyObject.Dispose();
                ho__IcReg.Dispose();
                ho__icReg.Dispose();
                ho__EpoxyReg.Dispose();
                ho__epoxyReg.Dispose();
                ho__BondReg.Dispose();
                ho__bondReg.Dispose();
                ho__WireContour.Dispose();
                ho__wireReg.Dispose();

                return;
            }
            //
            if ((int)((new HTuple((new HTuple(hv_i_WireDilation.TupleLength())).TupleLess(
                1))).TupleOr(new HTuple(hv_i_WireDilation.TupleLess(1)))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "the para i_WireDilation must greater than 0";
                ho_EmptyObject.Dispose();
                ho__IcReg.Dispose();
                ho__icReg.Dispose();
                ho__EpoxyReg.Dispose();
                ho__epoxyReg.Dispose();
                ho__BondReg.Dispose();
                ho__bondReg.Dispose();
                ho__WireContour.Dispose();
                ho__wireReg.Dispose();

                return;
            }


            //1----Ic膨胀
            hv__IcNum = hv_i_InspectItemNum[1];
            //
            HTuple end_val60 = hv__IcNum - 1;
            HTuple step_val60 = 1;
            for (hv_icIdx = 0; hv_icIdx.Continue(end_val60, step_val60); hv_icIdx = hv_icIdx.TupleAdd(step_val60))
            {
                ho__IcReg.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    ho__IcReg = hvec_i_IcInspectRegs[hv_icIdx].O.CopyObj(1, -1);
                }
                //
                HOperatorSet.CountObj(ho__IcReg, out hv_icNum);
                if ((int)(hv_icNum) != 0)
                {
                    ho__icReg.Dispose();
                    HOperatorSet.DilationCircle(ho__IcReg, out ho__icReg, hv_i_IcDilation);
                }
                else
                {
                    ho__icReg.Dispose();
                    HOperatorSet.GenEmptyRegion(out ho__icReg);
                }
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.ConcatObj(ho_o_IcReg, ho__icReg, out ExpTmpOutVar_0);
                    ho_o_IcReg.Dispose();
                    ho_o_IcReg = ExpTmpOutVar_0;
                }
            }

            //
            //2----Epoxy膨胀
            hv__EpoxyNum = hv_i_InspectItemNum[2];
            //
            HTuple end_val76 = hv__EpoxyNum - 1;
            HTuple step_val76 = 1;
            for (hv_epoxyIdx = 0; hv_epoxyIdx.Continue(end_val76, step_val76); hv_epoxyIdx = hv_epoxyIdx.TupleAdd(step_val76))
            {
                ho__EpoxyReg.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    ho__EpoxyReg = hvec_i_EpoxyRegs[hv_epoxyIdx].O.CopyObj(1, -1);
                }
                //
                HOperatorSet.CountObj(ho__EpoxyReg, out hv_epoxyNum);
                if ((int)(hv_epoxyNum) != 0)
                {
                    ho__epoxyReg.Dispose();
                    HOperatorSet.DilationCircle(ho__EpoxyReg, out ho__epoxyReg, hv_i_EpoxyDilation);
                }
                else
                {
                    ho__epoxyReg.Dispose();
                    HOperatorSet.GenEmptyRegion(out ho__epoxyReg);
                }
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.ConcatObj(ho_o_EpoxyReg, ho__epoxyReg, out ExpTmpOutVar_0);
                    ho_o_EpoxyReg.Dispose();
                    ho_o_EpoxyReg = ExpTmpOutVar_0;
                }
            }
            //
            //3----Bond膨胀
            hv__BondNum = hv_i_InspectItemNum[3];
            //
            HTuple end_val91 = hv__BondNum - 1;
            HTuple step_val91 = 1;
            for (hv_bondIdx = 0; hv_bondIdx.Continue(end_val91, step_val91); hv_bondIdx = hv_bondIdx.TupleAdd(step_val91))
            {
                ho__BondReg.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    ho__BondReg = hvec_i_BondContours[hv_bondIdx].O.CopyObj(1, -1);
                }
                //
                HOperatorSet.CountObj(ho__BondReg, out hv_bondNum);
                if ((int)(hv_bondNum) != 0)
                {
                    ho__bondReg.Dispose();
                    HOperatorSet.DilationCircle(ho__BondReg, out ho__bondReg, hv_i_BondDilation);
                }
                else
                {
                    ho__bondReg.Dispose();
                    HOperatorSet.GenEmptyRegion(out ho__bondReg);
                }
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.ConcatObj(ho_o_BondReg, ho__bondReg, out ExpTmpOutVar_0);
                    ho_o_BondReg.Dispose();
                    ho_o_BondReg = ExpTmpOutVar_0;
                }
            }
            //
            //4----Wire膨胀
            hv__WireNum = hv_i_InspectItemNum[4];
            //
            HTuple end_val106 = hv__WireNum - 1;
            HTuple step_val106 = 1;
            for (hv_wireIdx = 0; hv_wireIdx.Continue(end_val106, step_val106); hv_wireIdx = hv_wireIdx.TupleAdd(step_val106))
            {
                ho__WireContour.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    ho__WireContour = hvec_i_WireContours[hv_wireIdx].O.CopyObj(1, -1);
                }
                //
                HOperatorSet.CountObj(ho__WireContour, out hv_wireNum);
                //将contour转换为region
                if ((int)(hv_wireNum) != 0)
                {
                    ho__wireReg.Dispose();
                    HTV_contours_to_region(ho__WireContour, out ho__wireReg, hv_i_WireDilation,
                        out hv__ErrCode, out hv__ErrStr);
                }
                else
                {
                    ho__wireReg.Dispose();
                    HOperatorSet.GenEmptyRegion(out ho__wireReg);
                }
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.ConcatObj(ho_o_WireReg, ho__wireReg, out ExpTmpOutVar_0);
                    ho_o_WireReg.Dispose();
                    ho_o_WireReg = ExpTmpOutVar_0;
                }
            }
            //
            hv_o_ErrCode = 0;
            hv_o_ErrStr = "dilation region successful";
            ho_EmptyObject.Dispose();
            ho__IcReg.Dispose();
            ho__icReg.Dispose();
            ho__EpoxyReg.Dispose();
            ho__epoxyReg.Dispose();
            ho__BondReg.Dispose();
            ho__bondReg.Dispose();
            ho__WireContour.Dispose();
            ho__wireReg.Dispose();

            return;
        }

        public static void HTV_Select_DieInspect_Result(HObjectVector/*{eObjectVector,Dim=2}*/ hvec_i_FrameFailRegs,
            HObjectVector/*{eObjectVector,Dim=2}*/ hvec_i_IcFailRegs, HObjectVector/*{eObjectVector,Dim=2}*/ hvec_i_EpoxyFailRegs,
            HObjectVector/*{eObjectVector,Dim=2}*/ hvec_i_BondFailRegs, HObjectVector/*{eObjectVector,Dim=2}*/ hvec_i_WireFailRegs,
            HObjectVector/*{eObjectVector,Dim=1}*/ hvec_i_Balls, HObjectVector/*{eObjectVector,Dim=1}*/ hvec_i_Wires,
            out HObjectVector/*{eObjectVector,Dim=3}*/ hvec_o_FailRegs, out HObject ho_o_Balls,
            out HObject ho_o_Wires, HTuple hv_i_InspectItemNum, HTupleVector/*{eTupleVector,Dim=2}*/ hvec_i_FrameDefectType,
            HTupleVector/*{eTupleVector,Dim=2}*/ hvec_i_FrameDefectImgIdx, HTupleVector/*{eTupleVector,Dim=2}*/ hvec_i_IcDefectType,
            HTupleVector/*{eTupleVector,Dim=2}*/ hvec_i_IcDefectImgIdx, HTupleVector/*{eTupleVector,Dim=2}*/ hvec_i_EpoxyDefectType,
            HTupleVector/*{eTupleVector,Dim=2}*/ hvec_i_EpoxyDefectImgIdx, HTupleVector/*{eTupleVector,Dim=2}*/ hvec_i_BondDefectType,
            HTupleVector/*{eTupleVector,Dim=2}*/ hvec_i_BondDefectImgIdx, HTupleVector/*{eTupleVector,Dim=2}*/ hvec_i_WireDefectType,
            HTupleVector/*{eTupleVector,Dim=2}*/ hvec_i_WireDefectImgIdx, HTupleVector/*{eTupleVector,Dim=4}*/ hvec_i_RefValueFrame,
            HTupleVector/*{eTupleVector,Dim=4}*/ hvec_i_RefValueIc, HTupleVector/*{eTupleVector,Dim=4}*/ hvec_i_RefValueEpoxy,
            HTupleVector/*{eTupleVector,Dim=4}*/ hvec_i_RefValueBond, HTupleVector/*{eTupleVector,Dim=4}*/ hvec_i_RefValueWire,
            out HTupleVector/*{eTupleVector,Dim=3}*/ hvec_o_DefectType, out HTupleVector/*{eTupleVector,Dim=3}*/ hvec_o_DefectImgIdx,
            out HTupleVector/*{eTupleVector,Dim=5}*/ hvec_o_RefValue, out HTuple hv_o_OKorNG,
            out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_EmptyObj, ho__Ball = null, ho__Wire = null;
            HObject ho__WireReg = null;

            // Local control variables 

            HTuple hv__bondNum = null, hv_bondIdx = null;
            HTuple hv__wireNum = null, hv_wireIdx = null, hv__ErrContCode = new HTuple();
            HTuple hv__ErrContStr = new HTuple(), hv_DefectTypeTup = null;
            HTuple hv__ErrVecCode = null, hv__ErrVecStr = null, hv_TupSum = null;
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_Balls);
            HOperatorSet.GenEmptyObj(out ho_o_Wires);
            HOperatorSet.GenEmptyObj(out ho_EmptyObj);
            HOperatorSet.GenEmptyObj(out ho__Ball);
            HOperatorSet.GenEmptyObj(out ho__Wire);
            HOperatorSet.GenEmptyObj(out ho__WireReg);
            hvec_o_FailRegs = new HObjectVector(3);
            try
            {
                //*****************************************
                //i_FailRegsFrame ：输入的Frame检测项目的异常区域
                //i_FailRegsPegRack ：输入的PegRack检测项目的异常区域
                //i_FailRegsIc：输入的Ic检测项目的异常区域
                //i_FailRegsEpoxy：输入的Epoxy检测项目的异常区域
                //i_FailRegsBond：输入的Bond检测项目的异常区域
                //i_FailRegsWire：输入的Wire检测项目的异常区域
                //o_FailRegs输出的经过整合后的异常区域
                //i_DefectTypeFrame：输入的Frame检测项目的缺陷类型
                //i_DefectTypePegRack：输入的PegRack检测项目的缺陷类型
                //i_DefectTypeIc：输入的MIc检测项目的缺陷类型
                //i_DefectTypeEpoxy：输入的Epoxy检测项目的缺陷类型
                //i_DefectTypeBond：输入的Bond检测项目的缺陷类型
                //i_DefectTypeWire：输入的Wire检测项目的缺陷类型
                //o_DefectType：输出的经过整合对应的缺陷类型
                //o_OKorNG整个芯片检测后是否okorng的标志
                //o_ErrCode该函数实际执行过程中的异常标志 0-OK,-1-异常，-2-未执行，自然数-错误类型
                //o_ErrStr该函数实际执行过程中的异常信息
                //******************************************************

                //初始化
                hv_o_ErrCode = -2;
                hv_o_ErrStr = "initializing";
                ho_o_Balls.Dispose();
                HOperatorSet.GenEmptyObj(out ho_o_Balls);
                ho_o_Wires.Dispose();
                HOperatorSet.GenEmptyObj(out ho_o_Wires);
                ho_EmptyObj.Dispose();
                HOperatorSet.GenEmptyObj(out ho_EmptyObj);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hvec_o_FailRegs = dh.Take((
                        dh.Add(new HObjectVector(3)).Insert(0, (dh.Add(new HObjectVector(2)).Insert(0, (
                        dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho_EmptyObj)))))))));
                }
                hvec_o_DefectType = (new HTupleVector(3).Insert(0, (new HTupleVector(2).Insert(0, (
                    new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))));
                hvec_o_DefectImgIdx = (new HTupleVector(3).Insert(0, (new HTupleVector(2).Insert(0, (
                    new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))));
                hvec_o_RefValue = (new HTupleVector(5).Insert(0, (new HTupleVector(4).Insert(0, (
                    new HTupleVector(3).Insert(0, (new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))))))));
                hv_o_OKorNG = new HTuple();

                //-------整合检测结果：
                //第1维：固定检测任务：Frames, ICs, Epoxys, Bonds, Wires
                //第2维：检测项组数，即每个检测任务有几组检测项
                //第3维：检测ID对应错误码和FailReg

                //
                hvec_o_FailRegs[0] = hvec_i_FrameFailRegs.Clone();
                hvec_o_FailRegs[1] = hvec_i_IcFailRegs.Clone();
                hvec_o_FailRegs[2] = hvec_i_EpoxyFailRegs.Clone();
                hvec_o_FailRegs[3] = hvec_i_BondFailRegs.Clone();
                hvec_o_FailRegs[4] = hvec_i_WireFailRegs.Clone();
                //
                hvec_o_DefectType[0] = hvec_i_FrameDefectType.Clone();
                hvec_o_DefectType[1] = hvec_i_IcDefectType.Clone();
                hvec_o_DefectType[2] = hvec_i_EpoxyDefectType.Clone();
                hvec_o_DefectType[3] = hvec_i_BondDefectType.Clone();
                hvec_o_DefectType[4] = hvec_i_WireDefectType.Clone();
                //
                hvec_o_DefectImgIdx[0] = hvec_i_FrameDefectImgIdx.Clone();
                hvec_o_DefectImgIdx[1] = hvec_i_IcDefectImgIdx.Clone();
                hvec_o_DefectImgIdx[2] = hvec_i_EpoxyDefectImgIdx.Clone();
                hvec_o_DefectImgIdx[3] = hvec_i_BondDefectImgIdx.Clone();
                hvec_o_DefectImgIdx[4] = hvec_i_WireDefectImgIdx.Clone();

                //-------整合参考值结果：
                hvec_o_RefValue[0] = hvec_i_RefValueFrame.Clone();
                hvec_o_RefValue[1] = hvec_i_RefValueIc.Clone();
                hvec_o_RefValue[2] = hvec_i_RefValueEpoxy.Clone();
                hvec_o_RefValue[3] = hvec_i_RefValueBond.Clone();
                hvec_o_RefValue[4] = hvec_i_RefValueWire.Clone();

                //-------输出Bond检测结果
                hv__bondNum = hv_i_InspectItemNum[3];
                HTuple end_val65 = hv__bondNum - 1;
                HTuple step_val65 = 1;
                for (hv_bondIdx = 0; hv_bondIdx.Continue(end_val65, step_val65); hv_bondIdx = hv_bondIdx.TupleAdd(step_val65))
                {
                    ho__Ball.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho__Ball = hvec_i_Balls[hv_bondIdx].O.CopyObj(1, -1);
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_o_Balls, ho__Ball, out ExpTmpOutVar_0);
                        ho_o_Balls.Dispose();
                        ho_o_Balls = ExpTmpOutVar_0;
                    }
                }

                //-------输出Wire检测结果
                hv__wireNum = hv_i_InspectItemNum[4];
                //金线输出区域
                HTuple end_val73 = hv__wireNum - 1;
                HTuple step_val73 = 1;
                for (hv_wireIdx = 0; hv_wireIdx.Continue(end_val73, step_val73); hv_wireIdx = hv_wireIdx.TupleAdd(step_val73))
                {
                    ho__Wire.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho__Wire = hvec_i_Wires[hv_wireIdx].O.CopyObj(1, -1);
                    }
                    ho__WireReg.Dispose();
                    HTV_contours_to_region(ho__Wire, out ho__WireReg, 1, out hv__ErrContCode,
                        out hv__ErrContStr);
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_o_Wires, ho__WireReg, out ExpTmpOutVar_0);
                        ho_o_Wires.Dispose();
                        ho_o_Wires = ExpTmpOutVar_0;
                    }
                }

                //-------整合Die区域检测结果:1-Die区域有缺陷，0-Die区域无缺陷
                //
                HTV_Vector_to_Tuple_3d(hvec_o_DefectType, out hv_DefectTypeTup, out hv__ErrVecCode,
                    out hv__ErrVecStr);
                HOperatorSet.TupleSum(hv_DefectTypeTup, out hv_TupSum);
                if ((int)(new HTuple(hv_TupSum.TupleEqual(0))) != 0)
                {
                    hv_o_OKorNG = 0;
                }
                else
                {
                    hv_o_OKorNG = 1;
                }

                hv_o_ErrCode = 0;
                hv_o_ErrStr = "integrate results successful";
                ho_EmptyObj.Dispose();
                ho__Ball.Dispose();
                ho__Wire.Dispose();
                ho__WireReg.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_EmptyObj.Dispose();
                ho__Ball.Dispose();
                ho__Wire.Dispose();
                ho__WireReg.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public static void HTV_Select_Result(HObjectVector/*{eObjectVector,Dim=1}*/ hvec_i_FailRegs,
            out HObject ho_o_FailRegs, HTuple hv_i_ObjNum, HTupleVector/*{eTupleVector,Dim=1}*/ hvec_i_DefectType,
            HTupleVector/*{eTupleVector,Dim=1}*/ hvec_i_DefectImgIdx, out HTuple hv_o_DefectType,
            out HTuple hv_o_DefectImgIdx, out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho__FailRegs = null, ho__FailReg = null;

            // Local control variables 

            HTuple hv_Idx = null, hv__DefectType = new HTuple();
            HTuple hv__DefectImgIdx = new HTuple(), hv_defectIdx = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_FailRegs);
            HOperatorSet.GenEmptyObj(out ho__FailRegs);
            HOperatorSet.GenEmptyObj(out ho__FailReg);
            try
            {
                //***************************各项目检测结果筛选并输出
                // i_FailRegs：检测结果错误区域 ：向量类型
                // o_FailRegs：筛选后的错误区域整合
                // i_DefectType：错误类型
                // o_DefectType：筛选后的错误类型
                // o_ErrCode：错误码，显示函数执行结果
                // o_ErrStr：错误描述
                //*********************************
                //初始化
                hv_o_ErrCode = -2;
                hv_o_ErrStr = "initailizing";
                ho_o_FailRegs.Dispose();
                HOperatorSet.GenEmptyObj(out ho_o_FailRegs);
                hv_o_DefectType = new HTuple();
                hv_o_DefectImgIdx = new HTuple();
                //开始筛选错误区域

                HTuple end_val16 = hv_i_ObjNum - 1;
                HTuple step_val16 = 1;
                for (hv_Idx = 0; hv_Idx.Continue(end_val16, step_val16); hv_Idx = hv_Idx.TupleAdd(step_val16))
                {
                    hv__DefectType = hvec_i_DefectType[hv_Idx].T.Clone();
                    hv__DefectImgIdx = hvec_i_DefectImgIdx[hv_Idx].T.Clone();
                    ho__FailRegs.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho__FailRegs = hvec_i_FailRegs[hv_Idx].O.CopyObj(1, -1);
                    }
                    for (hv_defectIdx = 0; (int)hv_defectIdx <= (int)((new HTuple(hv__DefectType.TupleLength()
                        )) - 1); hv_defectIdx = (int)hv_defectIdx + 1)
                    {
                        if ((int)(new HTuple(((hv__DefectType.TupleSelect(hv_defectIdx))).TupleGreater(
                            0))) != 0)
                        {
                            ho__FailReg.Dispose();
                            HOperatorSet.SelectObj(ho__FailRegs, out ho__FailReg, hv_defectIdx + 1);
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.ConcatObj(ho_o_FailRegs, ho__FailReg, out ExpTmpOutVar_0
                                    );
                                ho_o_FailRegs.Dispose();
                                ho_o_FailRegs = ExpTmpOutVar_0;
                            }
                        }
                    }
                    hv_o_DefectType = hv_o_DefectType.TupleConcat(hv__DefectType);
                    hv_o_DefectImgIdx = hv_o_DefectImgIdx.TupleConcat(hv__DefectImgIdx);
                }
                //
                hv_o_ErrCode = 0;
                hv_o_ErrStr = "select result successful";
                ho__FailRegs.Dispose();
                ho__FailReg.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho__FailRegs.Dispose();
                ho__FailReg.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public static void HTV_contours_to_region(HObject ho_i_Contours, out HObject ho_o_Region,
            HTuple hv_i_DilationSize, out HTuple hv_o_ErrCode, out HTuple hv_o_ErrString)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_NeighborRegions = null, ho_ClippedContours = null;
            HObject ho_EmptyObject = null, ho_ObjectSelected = null, ho_Region = null;
            HObject ho_RegionDilation = null;

            // Local control variables 

            HTuple hv_Number = new HTuple(), hv_I = new HTuple();
            HTuple hv_Rows = new HTuple(), hv_Columns = new HTuple();
            HTuple hv_Exception = null;
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_Region);
            HOperatorSet.GenEmptyObj(out ho_NeighborRegions);
            HOperatorSet.GenEmptyObj(out ho_ClippedContours);
            HOperatorSet.GenEmptyObj(out ho_EmptyObject);
            HOperatorSet.GenEmptyObj(out ho_ObjectSelected);
            HOperatorSet.GenEmptyObj(out ho_Region);
            HOperatorSet.GenEmptyObj(out ho_RegionDilation);
            //i_Contours输入的待膨胀的Contours变量
            //o_Region输出的膨胀后的Region
            //i_DilationSize膨胀大小的膨胀系数
            //o_ErrCode该函数执行过程中的异常标志
            //o_ErrString该函数执行过程中的异常信息
            hv_o_ErrCode = 0;
            hv_o_ErrString = "";
            try
            {
                ho_NeighborRegions.Dispose();
                HOperatorSet.GenEmptyObj(out ho_NeighborRegions);
                ho_ClippedContours.Dispose();
                HOperatorSet.ClipEndPointsContoursXld(ho_i_Contours, out ho_ClippedContours,
                    "num_points", 0);
                HOperatorSet.CountObj(ho_ClippedContours, out hv_Number);
                ho_EmptyObject.Dispose();
                HOperatorSet.GenEmptyObj(out ho_EmptyObject);
                HTuple end_val12 = hv_Number;
                HTuple step_val12 = 1;
                for (hv_I = 1; hv_I.Continue(end_val12, step_val12); hv_I = hv_I.TupleAdd(step_val12))
                {
                    ho_ObjectSelected.Dispose();
                    HOperatorSet.SelectObj(ho_ClippedContours, out ho_ObjectSelected, hv_I);
                    HOperatorSet.GetContourXld(ho_ObjectSelected, out hv_Rows, out hv_Columns);
                    ho_Region.Dispose();
                    HOperatorSet.GenRegionPolygon(out ho_Region, hv_Rows, hv_Columns);
                    //2019.11.03金线膨胀区域缩小
                    ho_RegionDilation.Dispose();
                    HOperatorSet.DilationCircle(ho_Region, out ho_RegionDilation, hv_i_DilationSize);
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_EmptyObject, ho_RegionDilation, out ExpTmpOutVar_0
                            );
                        ho_EmptyObject.Dispose();
                        ho_EmptyObject = ExpTmpOutVar_0;
                    }
                }
                ho_o_Region.Dispose();
                HOperatorSet.Union1(ho_EmptyObject, out ho_o_Region);
            }
            // catch (Exception) 
            catch (HalconException HDevExpDefaultException1)
            {
                HDevExpDefaultException1.ToHTuple(out hv_Exception);
                hv_o_ErrCode = -1;
                hv_o_ErrString = hv_Exception.Clone();
                ho_NeighborRegions.Dispose();
                ho_ClippedContours.Dispose();
                ho_EmptyObject.Dispose();
                ho_ObjectSelected.Dispose();
                ho_Region.Dispose();
                ho_RegionDilation.Dispose();

                return;
            }
            ho_NeighborRegions.Dispose();
            ho_ClippedContours.Dispose();
            ho_EmptyObject.Dispose();
            ho_ObjectSelected.Dispose();
            ho_Region.Dispose();
            ho_RegionDilation.Dispose();

            return;
        }

        public static void HTV_cut_region(HObject ho_i_RawFailReg, HObject ho_i_BondReg, HObject ho_i_PadReg,
            HObject ho_i_WireReg, out HObject ho_o_FailReg, HTuple hv_i_MinLength, HTuple hv_i_MinWidth,
            HTuple hv_i_MinArea, HTuple hv_i_SelOperation, out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_ConnectedRegions, ho__FailRegsOut;
            HObject ho_RegionUnion = null, ho_EmptyRegion = null;

            // Local copy input parameter variables 
            HObject ho_i_RawFailReg_COPY_INP_TMP;
            ho_i_RawFailReg_COPY_INP_TMP = ho_i_RawFailReg.CopyObj(1, -1);



            // Local control variables 

            HTuple hv_Number = null;
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_FailReg);
            HOperatorSet.GenEmptyObj(out ho_ConnectedRegions);
            HOperatorSet.GenEmptyObj(out ho__FailRegsOut);
            HOperatorSet.GenEmptyObj(out ho_RegionUnion);
            HOperatorSet.GenEmptyObj(out ho_EmptyRegion);
            try
            {
                //******************************************************
                // i_RawFailRegs输入的检测到的异常区域，里面可能包含了金线和焊球，所以传进来经行difference
                // i_WireReg输入的检测得到的金线区域
                // i_BondReg输入的检测得到的焊点区域
                // i_EpoxyRegs输入的检测得到的银胶区域
                // i_IcReg：输入Ic区域
                // o_FailReg输出的实际对应检测项的实际异常区域
                // i_MinArea筛选异常区域的最小面积
                // o_ErrCode该函数执行过程中的异常标志
                // o_ErrString该函数执行过程中的异常信息
                //**************************************************

                //初始化
                hv_o_ErrCode = -2;
                hv_o_ErrStr = "initializing";
                ho_o_FailReg.Dispose();
                HOperatorSet.GenEmptyObj(out ho_o_FailReg);

                //输入有效性测试
                if ((int)((new HTuple((new HTuple(hv_i_MinArea.TupleLength())).TupleEqual(0))).TupleOr(
                    new HTuple(((hv_i_MinArea.TupleSelect(0))).TupleLess(1)))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "the para i_MinWidth must greater than 0";
                    ho_i_RawFailReg_COPY_INP_TMP.Dispose();
                    ho_ConnectedRegions.Dispose();
                    ho__FailRegsOut.Dispose();
                    ho_RegionUnion.Dispose();
                    ho_EmptyRegion.Dispose();

                    return;
                }

                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.Difference(ho_i_RawFailReg_COPY_INP_TMP, ho_i_WireReg, out ExpTmpOutVar_0
                        );
                    ho_i_RawFailReg_COPY_INP_TMP.Dispose();
                    ho_i_RawFailReg_COPY_INP_TMP = ExpTmpOutVar_0;
                }
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.Difference(ho_i_RawFailReg_COPY_INP_TMP, ho_i_PadReg, out ExpTmpOutVar_0
                        );
                    ho_i_RawFailReg_COPY_INP_TMP.Dispose();
                    ho_i_RawFailReg_COPY_INP_TMP = ExpTmpOutVar_0;
                }
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.Difference(ho_i_RawFailReg_COPY_INP_TMP, ho_i_BondReg, out ExpTmpOutVar_0
                        );
                    ho_i_RawFailReg_COPY_INP_TMP.Dispose();
                    ho_i_RawFailReg_COPY_INP_TMP = ExpTmpOutVar_0;
                }
                //
                ho_ConnectedRegions.Dispose();
                HOperatorSet.Connection(ho_i_RawFailReg_COPY_INP_TMP, out ho_ConnectedRegions
                    );
                ho__FailRegsOut.Dispose();
                HOperatorSet.SelectShape(ho_ConnectedRegions, out ho__FailRegsOut, ((new HTuple("rect2_len1")).TupleConcat(
                    "rect2_len2")).TupleConcat("area"), hv_i_SelOperation, ((((hv_i_MinLength - 0.5)).TupleConcat(
                    hv_i_MinWidth - 0.5))).TupleConcat(hv_i_MinArea), ((new HTuple(99999)).TupleConcat(
                    99999)).TupleConcat(99999));

                HOperatorSet.CountObj(ho__FailRegsOut, out hv_Number);
                if ((int)(hv_Number) != 0)
                {
                    ho_RegionUnion.Dispose();
                    HOperatorSet.Union1(ho__FailRegsOut, out ho_RegionUnion);
                    ho_o_FailReg.Dispose();
                    ho_o_FailReg = ho_RegionUnion.CopyObj(1, -1);
                    hv_o_ErrCode = 1;
                    hv_o_ErrStr = "something is dirty";
                    ho_i_RawFailReg_COPY_INP_TMP.Dispose();
                    ho_ConnectedRegions.Dispose();
                    ho__FailRegsOut.Dispose();
                    ho_RegionUnion.Dispose();
                    ho_EmptyRegion.Dispose();

                    return;
                }
                else
                {
                    ho_EmptyRegion.Dispose();
                    HOperatorSet.GenEmptyRegion(out ho_EmptyRegion);
                    ho_o_FailReg.Dispose();
                    ho_o_FailReg = ho_EmptyRegion.CopyObj(1, -1);
                    hv_o_ErrCode = 0;
                    hv_o_ErrStr = "something is clear";
                    ho_i_RawFailReg_COPY_INP_TMP.Dispose();
                    ho_ConnectedRegions.Dispose();
                    ho__FailRegsOut.Dispose();
                    ho_RegionUnion.Dispose();
                    ho_EmptyRegion.Dispose();

                    return;
                }
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_i_RawFailReg_COPY_INP_TMP.Dispose();
                ho_ConnectedRegions.Dispose();
                ho__FailRegsOut.Dispose();
                ho_RegionUnion.Dispose();
                ho_EmptyRegion.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public static void HTV_ics_cut_region(HObjectVector/*{eObjectVector,Dim=1}*/ hvec_i_IcRegs,
            HObjectVector/*{eObjectVector,Dim=2}*/ hvec_i_FailRegsIc, HObjectVector/*{eObjectVector,Dim=1}*/ hvec_i_RejectRegs,
            HObjectVector/*{eObjectVector,Dim=1}*/ hvec_i_PadContours, out HObjectVector/*{eObjectVector,Dim=2}*/ hvec_o_FailRegsIc,
            HTuple hv_i_icObjNum, HTupleVector/*{eTupleVector,Dim=2}*/ hvec_i_DefectTypeIc,
            HTupleVector/*{eTupleVector,Dim=2}*/ hvec_i_DefectImgIdxIc, HTupleVector/*{eTupleVector,Dim=4}*/ hvec_i_DefectValueIc,
            HTupleVector/*{eTupleVector,Dim=3}*/ hvec_i_IcInspectParas, out HTupleVector/*{eTupleVector,Dim=2}*/ hvec_o_DefectTypeIc,
            out HTupleVector/*{eTupleVector,Dim=2}*/ hvec_o_DefectImgIdxIc, out HTupleVector/*{eTupleVector,Dim=4}*/ hvec_o_DefectValueIc,
            out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_EmptyObject, ho_i_BondReg = null;
            HObject ho_i_WireReg = null, ho_i_PadReg, ho__PadReg = null;
            HObject ho__FailRegsIc = null, ho__ICReg = null, ho__icFailRegs = null;
            HObject ho__failReg = null, ho__icFailReg = null, ho_SubFailRegConnection = null;
            HObject ho_ChippingFailRegConnection = null;

            // Local control variables 

            HTuple hv_objIdx = null, hv_padNum = null;
            HTuple hv_padIdx = null, hv_icIdx = null, hv__MinLengthIc = new HTuple();
            HTuple hv__MinWidthIc = new HTuple(), hv__MinAreaIc = new HTuple();
            HTuple hv__SelOperation = new HTuple(), hv__Rect2Len1 = new HTuple();
            HTuple hv__Rect2Len2 = new HTuple(), hv__DefectTypeIc = new HTuple();
            HTuple hv__DefectImgIdx = new HTuple(), hv__icDefectType = new HTuple();
            HTuple hv__icDefectImgIdx = new HTuple(), hv_failNum = new HTuple();
            HTuple hv_defectIdx = new HTuple(), hv__defectType = new HTuple();
            HTuple hv__defectImgIdx = new HTuple(), hv__icErrCode = new HTuple();
            HTuple hv__icErrStr = new HTuple(), hv_AreaSub = new HTuple();
            HTuple hv_RowSub = new HTuple(), hv_ColumnSub = new HTuple();
            HTuple hv_AreaChipping = new HTuple(), hv_RowChipping = new HTuple();
            HTuple hv_ColumnChipping = new HTuple();

            HTupleVector hvec__InspectIcPara = new HTupleVector(1);
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_EmptyObject);
            HOperatorSet.GenEmptyObj(out ho_i_BondReg);
            HOperatorSet.GenEmptyObj(out ho_i_WireReg);
            HOperatorSet.GenEmptyObj(out ho_i_PadReg);
            HOperatorSet.GenEmptyObj(out ho__PadReg);
            HOperatorSet.GenEmptyObj(out ho__FailRegsIc);
            HOperatorSet.GenEmptyObj(out ho__ICReg);
            HOperatorSet.GenEmptyObj(out ho__icFailRegs);
            HOperatorSet.GenEmptyObj(out ho__failReg);
            HOperatorSet.GenEmptyObj(out ho__icFailReg);
            HOperatorSet.GenEmptyObj(out ho_SubFailRegConnection);
            HOperatorSet.GenEmptyObj(out ho_ChippingFailRegConnection);
            hvec_o_FailRegsIc = new HObjectVector(2);
            try
            {
                //**************************************************************************************************
                //---函数：HTV_ics_cut_region
                //---作用：IC缺陷区修正
                //---参数：
                //===图标参数
                //  i_FailRegsIc：IC检出缺陷区
                //  i_RejectRegs：IC检测拒绝区
                //  o_FailRegsIc：IC实际检出缺陷区
                //===控制参数
                //  i_icObjNum：框架数目
                //  i_DefectTypeIc：异常区域的缺陷类型
                //  i_MinAreaIc：裁剪后区缺陷最小面积阈值
                //  o_DefectTypeIc：异常区域的缺陷类型
                //  o_ErrCode：错误码
                //  o_ErrStr：错误信息
                //**************************************************************************************************
                //
                //初始化
                hvec_o_DefectTypeIc = (new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))));
                hvec_o_DefectImgIdxIc = (new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))));
                hvec_o_DefectValueIc = hvec_i_DefectValueIc.Clone();
                ho_EmptyObject.Dispose();
                HOperatorSet.GenEmptyObj(out ho_EmptyObject);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hvec_o_FailRegsIc = dh.Take((
                        dh.Add(new HObjectVector(2)).Insert(0, (dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho_EmptyObject)))))));
                }
                //
                HTuple end_val24 = hv_i_icObjNum - 1;
                HTuple step_val24 = 1;
                for (hv_objIdx = 0; hv_objIdx.Continue(end_val24, step_val24); hv_objIdx = hv_objIdx.TupleAdd(step_val24))
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hvec_o_FailRegsIc[hv_objIdx] = dh.Take((
                            dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho_EmptyObject)))));
                    }
                    hvec_o_DefectTypeIc[hv_objIdx] = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())));
                    hvec_o_DefectImgIdxIc[hv_objIdx] = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())));
                }
                hv_o_ErrCode = -2;
                hv_o_ErrStr = "initializing";

                //---------------Ic区域剪切免测区域
                ho_i_BondReg.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    ho_i_BondReg = hvec_i_RejectRegs[2].O.CopyObj(1, -1);
                }
                ho_i_WireReg.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    ho_i_WireReg = hvec_i_RejectRegs[3].O.CopyObj(1, -1);
                }
                //pad免检测区域
                ho_i_PadReg.Dispose();
                HOperatorSet.GenEmptyObj(out ho_i_PadReg);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_padNum = new HTuple(hvec_i_PadContours.Length);
                }
                HTuple end_val38 = hv_padNum - 1;
                HTuple step_val38 = 1;
                for (hv_padIdx = 0; hv_padIdx.Continue(end_val38, step_val38); hv_padIdx = hv_padIdx.TupleAdd(step_val38))
                {
                    ho__PadReg.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho__PadReg = hvec_i_PadContours[hv_padIdx].O.CopyObj(1, -1);
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_i_PadReg, ho__PadReg, out ExpTmpOutVar_0);
                        ho_i_PadReg.Dispose();
                        ho_i_PadReg = ExpTmpOutVar_0;
                    }
                }
                //将焊盘区域膨胀作为免检测区域
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.DilationCircle(ho_i_PadReg, out ExpTmpOutVar_0, 3.5);
                    ho_i_PadReg.Dispose();
                    ho_i_PadReg = ExpTmpOutVar_0;
                }
                //
                HTuple end_val45 = hv_i_icObjNum - 1;
                HTuple step_val45 = 1;
                for (hv_icIdx = 0; hv_icIdx.Continue(end_val45, step_val45); hv_icIdx = hv_icIdx.TupleAdd(step_val45))
                {
                    //获取ic表面检测参数
                    hvec__InspectIcPara = hvec_i_IcInspectParas[1][hv_icIdx];
                    //获取ic表面检测面积阈值
                    hv__MinLengthIc = hvec__InspectIcPara[13].T.Clone();
                    hv__MinWidthIc = hvec__InspectIcPara[14].T.Clone();
                    hv__MinAreaIc = hvec__InspectIcPara[15].T.Clone();
                    hv__SelOperation = hvec__InspectIcPara[16].T.Clone();
                    hv__Rect2Len1 = hv__MinLengthIc / 2.0;
                    hv__Rect2Len2 = hv__MinWidthIc / 2.0;
                    //
                    hv__DefectTypeIc = hvec_i_DefectTypeIc[hv_icIdx][0].T.Clone();
                    hv__DefectImgIdx = hvec_i_DefectImgIdxIc[hv_icIdx][0].T.Clone();
                    //
                    ho__FailRegsIc.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho__FailRegsIc = hvec_i_FailRegsIc[hv_icIdx][0].O.CopyObj(1, -1);
                    }
                    //
                    ho__ICReg.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho__ICReg = hvec_i_IcRegs[hv_icIdx].O.CopyObj(1, -1);
                    }
                    //
                    hv__icDefectType = new HTuple();
                    hv__icDefectImgIdx = new HTuple();
                    ho__icFailRegs.Dispose();
                    HOperatorSet.GenEmptyObj(out ho__icFailRegs);
                    HOperatorSet.CountObj(ho__FailRegsIc, out hv_failNum);
                    //
                    if ((int)(hv_failNum) != 0)
                    {
                        //
                        for (hv_defectIdx = 0; (int)hv_defectIdx <= (int)((new HTuple(hv__DefectTypeIc.TupleLength()
                            )) - 1); hv_defectIdx = (int)hv_defectIdx + 1)
                        {
                            //选择Ic缺陷区域
                            ho__failReg.Dispose();
                            HOperatorSet.SelectObj(ho__FailRegsIc, out ho__failReg, hv_defectIdx + 1);
                            hv__defectType = hv__DefectTypeIc.TupleSelect(hv_defectIdx);
                            hv__defectImgIdx = hv__DefectImgIdx.TupleSelect(hv_defectIdx);
                            //
                            if ((int)(new HTuple(hv__defectType.TupleEqual(7))) != 0)
                            {
                                //Ic重点检测区域
                                ho__icFailReg.Dispose();
                                HTV_cut_region(ho__failReg, ho_i_BondReg, ho_i_PadReg, ho_i_WireReg,
                                    out ho__icFailReg, hv__Rect2Len1.TupleSelect(1), hv__Rect2Len2.TupleSelect(
                                    1), hv__MinAreaIc.TupleSelect(1), hv__SelOperation, out hv__icErrCode,
                                    out hv__icErrStr);
                                if ((int)(hv__icErrCode) != 0)
                                {
                                    //
                                    hv__icDefectType = hv__icDefectType.TupleConcat(hv__defectType);
                                    hv__icDefectImgIdx = hv__icDefectImgIdx.TupleConcat(hv__defectImgIdx);
                                    {
                                        HObject ExpTmpOutVar_0;
                                        HOperatorSet.ConcatObj(ho__icFailRegs, ho__icFailReg, out ExpTmpOutVar_0
                                            );
                                        ho__icFailRegs.Dispose();
                                        ho__icFailRegs = ExpTmpOutVar_0;
                                    }
                                    //
                                    //异物信息独立统计 lw
                                    ho_SubFailRegConnection.Dispose();
                                    HOperatorSet.Connection(ho__icFailReg, out ho_SubFailRegConnection
                                        );
                                    HOperatorSet.AreaCenter(ho_SubFailRegConnection, out hv_AreaSub,
                                        out hv_RowSub, out hv_ColumnSub);
                                    hvec_o_DefectValueIc[hv_icIdx][0][3] = (((new HTupleVector(1).Insert(0, new HTupleVector(hv_AreaSub))).Insert(
                                        1, new HTupleVector(hv_RowSub))).Insert(2, new HTupleVector(hv_ColumnSub)));
                                }
                                else
                                {
                                    //if (|_icDefectType|>0)
                                    //_icDefectType := [_icDefectType,0]
                                    //_icDefectImgIdx := [_icDefectImgIdx,_defectImgIdx]
                                    //concat_obj (_icFailRegs, _ICReg, _icFailRegs)
                                    //endif
                                    hvec_o_DefectValueIc[hv_icIdx][0][3] = (((new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(0)))).Insert(
                                        1, new HTupleVector(new HTuple(0)))).Insert(2, new HTupleVector(new HTuple(0))));
                                }
                            }
                            else if ((int)(new HTuple(hv__defectType.TupleEqual(8))) != 0)
                            {
                                //Ic崩边检测区域
                                ho__icFailReg.Dispose();
                                HTV_cut_region(ho__failReg, ho_i_BondReg, ho_i_PadReg, ho_i_WireReg,
                                    out ho__icFailReg, hv__Rect2Len1.TupleSelect(0), hv__Rect2Len2.TupleSelect(
                                    0), hv__MinAreaIc.TupleSelect(0), hv__SelOperation, out hv__icErrCode,
                                    out hv__icErrStr);
                                if ((int)(hv__icErrCode) != 0)
                                {
                                    //
                                    hv__icDefectType = hv__icDefectType.TupleConcat(hv__defectType);
                                    hv__icDefectImgIdx = hv__icDefectImgIdx.TupleConcat(hv__defectImgIdx);
                                    {
                                        HObject ExpTmpOutVar_0;
                                        HOperatorSet.ConcatObj(ho__icFailRegs, ho__icFailReg, out ExpTmpOutVar_0
                                            );
                                        ho__icFailRegs.Dispose();
                                        ho__icFailRegs = ExpTmpOutVar_0;
                                    }
                                    //
                                    //异物信息独立统计 lw
                                    ho_ChippingFailRegConnection.Dispose();
                                    HOperatorSet.Connection(ho__icFailRegs, out ho_ChippingFailRegConnection
                                        );
                                    HOperatorSet.AreaCenter(ho_ChippingFailRegConnection, out hv_AreaChipping,
                                        out hv_RowChipping, out hv_ColumnChipping);
                                    hvec_o_DefectValueIc[hv_icIdx][0][4] = (((new HTupleVector(1).Insert(0, new HTupleVector(hv_AreaChipping))).Insert(
                                        1, new HTupleVector(hv_RowChipping))).Insert(2, new HTupleVector(hv_ColumnChipping)));
                                }
                                else
                                {
                                    //if (|_icDefectType|>0)
                                    //_icDefectType := [_icDefectType,0]
                                    //_icDefectImgIdx := [_icDefectImgIdx,_defectImgIdx]
                                    //concat_obj (_icFailRegs, _ICReg, _icFailRegs)
                                    //endif
                                    hvec_o_DefectValueIc[hv_icIdx][0][4] = (((new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(0)))).Insert(
                                        1, new HTupleVector(new HTuple(0)))).Insert(2, new HTupleVector(new HTuple(0))));
                                }
                            }
                            else
                            {
                                hv__icDefectType = hv__icDefectType.TupleConcat(hv__defectType);
                                hv__icDefectImgIdx = hv__icDefectImgIdx.TupleConcat(hv__defectImgIdx);
                                {
                                    HObject ExpTmpOutVar_0;
                                    HOperatorSet.ConcatObj(ho__icFailRegs, ho__failReg, out ExpTmpOutVar_0
                                        );
                                    ho__icFailRegs.Dispose();
                                    ho__icFailRegs = ExpTmpOutVar_0;
                                }
                            }
                        }
                        //
                        if ((int)(new HTuple((new HTuple(hv__icDefectType.TupleLength())).TupleEqual(
                            0))) != 0)
                        {
                            hv__icDefectType = hv__icDefectType.TupleConcat(0);
                            hv__icDefectImgIdx = hv__icDefectImgIdx.TupleConcat(hv__defectImgIdx);
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.ConcatObj(ho__icFailRegs, ho__ICReg, out ExpTmpOutVar_0);
                                ho__icFailRegs.Dispose();
                                ho__icFailRegs = ExpTmpOutVar_0;
                            }
                        }
                        //
                        hvec_o_DefectTypeIc[hv_icIdx] = (new HTupleVector(1).Insert(0, new HTupleVector(hv__icDefectType)));
                        hvec_o_DefectImgIdxIc[hv_icIdx] = (new HTupleVector(1).Insert(0, new HTupleVector(hv__icDefectImgIdx)));
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hvec_o_FailRegsIc[hv_icIdx] = dh.Take((
                                dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho__icFailRegs)))));
                        }
                    }
                    else
                    {
                        hvec_o_DefectTypeIc[hv_icIdx] = (new HTupleVector(1).Insert(0, new HTupleVector(hv__DefectTypeIc)));
                        hvec_o_DefectImgIdxIc[hv_icIdx] = (new HTupleVector(1).Insert(0, new HTupleVector(hv__DefectImgIdx)));
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hvec_o_FailRegsIc[hv_icIdx] = dh.Take((
                                dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho__FailRegsIc)))));
                        }
                    }
                }

                hv_o_ErrCode = 0;
                hv_o_ErrStr = "cut avoid region suceessful";
                ho_EmptyObject.Dispose();
                ho_i_BondReg.Dispose();
                ho_i_WireReg.Dispose();
                ho_i_PadReg.Dispose();
                ho__PadReg.Dispose();
                ho__FailRegsIc.Dispose();
                ho__ICReg.Dispose();
                ho__icFailRegs.Dispose();
                ho__failReg.Dispose();
                ho__icFailReg.Dispose();
                ho_SubFailRegConnection.Dispose();
                ho_ChippingFailRegConnection.Dispose();

                return;

            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_EmptyObject.Dispose();
                ho_i_BondReg.Dispose();
                ho_i_WireReg.Dispose();
                ho_i_PadReg.Dispose();
                ho__PadReg.Dispose();
                ho__FailRegsIc.Dispose();
                ho__ICReg.Dispose();
                ho__icFailRegs.Dispose();
                ho__failReg.Dispose();
                ho__icFailReg.Dispose();
                ho_SubFailRegConnection.Dispose();
                ho_ChippingFailRegConnection.Dispose();

                throw HDevExpDefaultException;
            }
        }
        #endregion


        #region CutRegion
        //替换接口 2020-08-17
        //public static void JSCC_AOI_Inspect_Unit_4cutreg(HObject ho_i_Imgs, HObject ho_i_SearchReg,
        //HObjectVector/*{eObjectVector,Dim=2}*/ hvec_i_FrameObjs, HObjectVector/*{eObjectVector,Dim=2}*/ hvec_i_IcObjs,
        //HObjectVector/*{eObjectVector,Dim=2}*/ hvec_i_EpoxyObjs, HObjectVector/*{eObjectVector,Dim=1}*/ hvec_i_BondObjs,
        //HObjectVector/*{eObjectVector,Dim=2}*/ hvec_i_WireObjs, out HObjectVector/*{eObjectVector,Dim=1}*/ hvec_o_Ics,
        //out HObjectVector/*{eObjectVector,Dim=1}*/ hvec_o_Epoxys, out HObjectVector/*{eObjectVector,Dim=1}*/ hvec_o_Ballregs,
        //out HObjectVector/*{eObjectVector,Dim=1}*/ hvec_o_Wireregs, out HObject ho_o_FailRegs,
        //HTuple hv_i_InspectItemNum, HTupleVector/*{eTupleVector,Dim=3}*/ hvec_i_FrameInspectParas,
        //HTupleVector/*{eTupleVector,Dim=3}*/ hvec_i_IcInspectParas, HTupleVector/*{eTupleVector,Dim=2}*/ hvec_i_EpoxyInspectParas,
        //HTupleVector/*{eTupleVector,Dim=2}*/ hvec_i_BondInspectParas, HTupleVector/*{eTupleVector,Dim=4}*/ hvec_i_WireInspectParas,
        //out HTuple hv_o_OKorNG, out HTuple hv_o_DefectType, out HTuple hv_o_ErrCode,
        //out HTuple hv_o_ErrStr)
        /*
    {




        // Local iconic variables 

        HObject ho__WireContour = null, ho__wireReg = null;

        HObjectVector hvec__frameFailRegs = new HObjectVector(1);
        HObjectVector hvec__icFailRegs = new HObjectVector(1), hvec__Ics = new HObjectVector(1);
        HObjectVector hvec__Epoxys = new HObjectVector(1), hvec_o_epoxyFailRegs = new HObjectVector(1);
        HObjectVector hvec__BallContours = new HObjectVector(1), hvec_o_bondFailRegs = new HObjectVector(1);
        HObjectVector hvec__Lines = new HObjectVector(1), hvec_o_wireFailRegs = new HObjectVector(1);

        // Local control variables 

        HTuple hv_i_frameObjNum = null, hv__frameErrCode = null;
        HTuple hv__frameErrStr = null, hv_i_icObjNum = null, hv__icErrCode = null;
        HTuple hv__icErrStr = null, hv_i_epoxyObjNum = null, hv__epoxyErrCode = null;
        HTuple hv__epoxyErrStr = null, hv_i_BondObjNum = null;
        HTuple hv__bondErrCode = null, hv__bondErrStr = null, hv_i_WireObjNum = null;
        HTuple hv__wireErrCode = null, hv__wireErrStr = null, hv__WireDilation = null;
        HTuple hv__BondDilation = null, hv__EpoxyDilation = null;
        HTuple hv__IcDilation = null, hv__WireNum = null, hv_wireIdx = null;
        HTuple hv_wireNum = new HTuple(), hv__ErrCode = new HTuple();
        HTuple hv__ErrStr = new HTuple();

        HTupleVector hvec__frameHomMat2D = new HTupleVector(1);
        HTupleVector hvec__frameDefectType = new HTupleVector(1), hvec__icHomMat2D = new HTupleVector(1);
        HTupleVector hvec__icDefectType = new HTupleVector(1), hvec_o_epoxyDefectType = new HTupleVector(1);
        HTupleVector hvec_o_bondDefectType = new HTupleVector(1), hvec_o_wireDefectType = new HTupleVector(1);
        // Initialize local and output iconic variables 
        HOperatorSet.GenEmptyObj(out ho_o_FailRegs);
        HOperatorSet.GenEmptyObj(out ho__WireContour);
        HOperatorSet.GenEmptyObj(out ho__wireReg);
        hvec_o_Ics = new HObjectVector(1);
        hvec_o_Epoxys = new HObjectVector(1);
        hvec_o_Ballregs = new HObjectVector(1);
        hvec_o_Wireregs = new HObjectVector(1);
        try
        {
            //***************************






            //****************************************************************************
            //初始化
            hv_o_OKorNG = new HTuple();
            hv_o_DefectType = new HTuple();
            hv_o_ErrCode = -2;
            hv_o_ErrStr = "initializing";
            //
            //* gen_empty_obj (o_Ballregs)
            //* gen_empty_obj (o_Wireregs)
            ho_o_FailRegs.Dispose();
            HOperatorSet.GenEmptyObj(out ho_o_FailRegs);


            //输入合法性测试

            //
            //***************************对Die区域进行分区域检测****************************
            //
            //--------Frame检测：Frame定位，表面、钉架\交接表面检测
            //
            //检测frame项目数量
            hv_i_frameObjNum = hv_i_InspectItemNum[0];
            //
            hvec__frameFailRegs.Dispose();
            HTV_frames_inspect(ho_i_Imgs, ho_i_SearchReg, hvec_i_FrameObjs, out hvec__frameFailRegs,
                hv_i_frameObjNum, hvec_i_FrameInspectParas, out hvec__frameHomMat2D, out hvec__frameDefectType,
                out hv__frameErrCode, out hv__frameErrStr);
            //
            //--------Ic检测：Ic定位，表面，旋转、偏移检测
            //
            //检测ic项目数量
            hv_i_icObjNum = hv_i_InspectItemNum[1];
            //
            hvec__icFailRegs.Dispose(); hvec__Ics.Dispose();
            HTV_ics_inspect(ho_i_Imgs, hvec_i_IcObjs, out hvec__icFailRegs, out hvec__Ics,
                hv_i_icObjNum, hvec__frameHomMat2D, hvec_i_IcInspectParas, out hvec__icHomMat2D,
                out hvec__icDefectType, out hv__icErrCode, out hv__icErrStr);
            hvec_o_Ics = hvec__Ics.Clone();
            //
            //-------Epoxy检测：是否有银胶
            //
            //检测epoxy项目数量
            hv_i_epoxyObjNum = hv_i_InspectItemNum[2];
            //
            hvec__Epoxys.Dispose(); hvec_o_epoxyFailRegs.Dispose();
            HTV_epoxys_inspect(ho_i_Imgs, hvec_i_EpoxyObjs, out hvec__Epoxys, out hvec_o_epoxyFailRegs,
                hv_i_epoxyObjNum, hvec__icHomMat2D, hvec_i_EpoxyInspectParas, out hvec_o_epoxyDefectType,
                out hv__epoxyErrCode, out hv__epoxyErrStr);
            hvec_o_Epoxys = hvec__Epoxys.Clone();
            //
            //----------Bond检测：Bond定位
            //
            //检测bond项目数量
            hv_i_BondObjNum = hv_i_InspectItemNum[3];
            //

            hvec__BallContours.Dispose(); hvec_o_bondFailRegs.Dispose();
            HTV_bonds_inspect(ho_i_Imgs, hvec_i_BondObjs, out hvec__BallContours, out hvec_o_bondFailRegs,
                hv_i_BondObjNum, hvec__frameHomMat2D, hvec__icHomMat2D, hvec_i_BondInspectParas,
                out hvec_o_bondDefectType, out hv__bondErrCode, out hv__bondErrStr);
            hvec_o_Ballregs = hvec__BallContours.Clone();
            //
            //-----------Wire检测：断线、弯曲线，双丝、塌丝
            //
            //检测wire项目数量
            hv_i_WireObjNum = hv_i_InspectItemNum[4];
            //
            hvec__Lines.Dispose(); hvec_o_wireFailRegs.Dispose();
            HTV_wires_inspect(ho_i_Imgs, hvec_i_WireObjs, out hvec__Lines, out hvec_o_wireFailRegs,
                hv_i_WireObjNum, hvec__frameHomMat2D, hvec__icHomMat2D, hvec_i_WireInspectParas,
                out hvec_o_wireDefectType, out hv__wireErrCode, out hv__wireErrStr);

            //
            //------------膨胀Frames、Ics免检测区域
            //
            //膨胀参数
            hv__WireDilation = 1;
            hv__BondDilation = 3;
            hv__EpoxyDilation = 7;
            hv__IcDilation = 8;
            //
            //4----Wire膨胀
            hv__WireNum = hv_i_InspectItemNum[4];
            //
            HTuple end_val75 = hv__WireNum - 1;
            HTuple step_val75 = 1;
            for (hv_wireIdx = 0; hv_wireIdx.Continue(end_val75, step_val75); hv_wireIdx = hv_wireIdx.TupleAdd(step_val75))
            {
                ho__WireContour.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    ho__WireContour = hvec__Lines[hv_wireIdx].O.CopyObj(1, -1);
                }
                //
                HOperatorSet.CountObj(ho__WireContour, out hv_wireNum);
                //将contour转换为region
                if ((int)(hv_wireNum) != 0)
                {
                    ho__wireReg.Dispose();
                    HTV_contours_to_region(ho__WireContour, out ho__wireReg, hv__WireDilation,
                        out hv__ErrCode, out hv__ErrStr);
                }
                else
                {
                    ho__wireReg.Dispose();
                    HOperatorSet.GenEmptyRegion(out ho__wireReg);
                }
                //concat_obj (o_WireReg, _wireReg, o_WireReg)

                hvec_o_Wireregs[hv_wireIdx] = new HObjectVector(ho__wireReg);

            }



            //HTV_dilation_avoid_region (_Ics, _Epoxys, _BallContours, _Lines, _IcReg, _EpoxyReg, _BondReg, _WireReg, i_InspectItemNum, _IcDilation, _EpoxyDilation, _BondDilation, _WireDilation, _dilationErrCode, _dilationErrStr)

            //
            //----------剪切Frame区域免检测区域
            //剪切后缺陷区域选择参数
            //_MinAreaFrame := 25
            //_MinAreaIc := 10
            //
            //* HTV_cut_avoid_region (_frameFailRegs, _icFailRegs, _IcReg, _EpoxyReg, _BondReg, _WireReg, o_frameFailRegs, o_icFailRegs, i_InspectItemNum, _frameDefectType, _icDefectType, _MinAreaFrame, _MinAreaIc, o_frameDefectType, o_icDefectType, _cutErrCode1, _cutErrStr)
            //
            //------------Die区域各检测项目检测结果帅选
            //
            //* HTV_Select_DieInspect_Result (o_frameFailRegs, o_icFailRegs, o_epoxyFailRegs, o_bondFailRegs, o_wireFailRegs, _BallContours, _Lines, o_FailRegs, o_Ballregs, o_Wireregs, i_InspectItemNum, o_frameDefectType, o_icDefectType, o_epoxyDefectType, o_bondDefectType, o_wireDefectType, o_DefectType, o_OKorNG, _DieErrCode, _DieErrStr)


            hv_o_ErrCode = 0;
            hv_o_ErrStr = "inspect all items suceessful";
            ho__WireContour.Dispose();
            ho__wireReg.Dispose();
            hvec__frameFailRegs.Dispose();
            hvec__icFailRegs.Dispose();
            hvec__Ics.Dispose();
            hvec__Epoxys.Dispose();
            hvec_o_epoxyFailRegs.Dispose();
            hvec__BallContours.Dispose();
            hvec_o_bondFailRegs.Dispose();
            hvec__Lines.Dispose();
            hvec_o_wireFailRegs.Dispose();

            return;
        }
        catch (HalconException HDevExpDefaultException)
        {
            ho__WireContour.Dispose();
            ho__wireReg.Dispose();
            hvec__frameFailRegs.Dispose();
            hvec__icFailRegs.Dispose();
            hvec__Ics.Dispose();
            hvec__Epoxys.Dispose();
            hvec_o_epoxyFailRegs.Dispose();
            hvec__BallContours.Dispose();
            hvec_o_bondFailRegs.Dispose();
            hvec__Lines.Dispose();
            hvec_o_wireFailRegs.Dispose();

            throw HDevExpDefaultException;
        }
    }
    */

        public static void JSCC_AOI_Inspect_Gen_InspectReg_Unit(HObject ho_i_Imgs, HObject ho_i_SearchReg,
            HObjectVector/*{eObjectVector,Dim=2}*/ hvec_i_FrameObjs, HObjectVector/*{eObjectVector,Dim=2}*/ hvec_i_IcObjs,
            HObjectVector/*{eObjectVector,Dim=2}*/ hvec_i_EpoxyObjs, HObjectVector/*{eObjectVector,Dim=2}*/ hvec_i_BondObjs,
            HObjectVector/*{eObjectVector,Dim=2}*/ hvec_i_WireObjs, out HObjectVector/*{eObjectVector,Dim=1}*/ hvec_o_IcRegs,
            out HObjectVector/*{eObjectVector,Dim=1}*/ hvec_o_EpoxyRegs, out HObjectVector/*{eObjectVector,Dim=1}*/ hvec_o_BondRegs,
            out HObjectVector/*{eObjectVector,Dim=1}*/ hvec_o_WireRes, out HObject ho_o_FailRegs,
            HTuple hv_i_InspectItemNum, HTupleVector/*{eTupleVector,Dim=3}*/ hvec_i_FrameInspectParas,
            HTupleVector/*{eTupleVector,Dim=3}*/ hvec_i_IcInspectParas, HTupleVector/*{eTupleVector,Dim=4}*/ hvec_i_EpoxyInspectParas,
            HTupleVector/*{eTupleVector,Dim=4}*/ hvec_i_BondInspectParas, HTupleVector/*{eTupleVector,Dim=4}*/ hvec_i_WireInspectParas,
            HTupleVector/*{eTupleVector,Dim=1}*/ hvec_i_CutRegionParas, out HTuple hv_o_DefectType,
            out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {




            // Local iconic variables 

            HObject ho_WireContour = null, ho_DilationReg = null;

            HObjectVector hvec__frameLocFailRegs = new HObjectVector(2);
            HObjectVector hvec__icFailRegs = new HObjectVector(2), hvec__Ics = new HObjectVector(1);
            HObjectVector hvec__Epoxys = new HObjectVector(1), hvec_o_epoxyFailRegs = new HObjectVector(2);
            HObjectVector hvec__BallContours = new HObjectVector(1), hvec_o_PadRegions = new HObjectVector(1);
            HObjectVector hvec__bondFailRegs = new HObjectVector(2), hvec__WireContours = new HObjectVector(1);
            HObjectVector hvec_o_wireFailRegs = new HObjectVector(2);

            // Local control variables 

            HTuple hv_o_DefectImgIdx = null, hv_objIdx = null;
            HTuple hv_i_frameObjNum = null, hv__frameErrCode = null;
            HTuple hv__frameErrStr = null, hv_i_icObjNum = null, hv__icErrCode = null;
            HTuple hv__icErrStr = null, hv_i_epoxyObjNum = null, hv__epoxyErrCode = null;
            HTuple hv__epoxyErrStr = null, hv_i_BondObjNum = null;
            HTuple hv__bondErrCode = null, hv__bondErrStr = null, hv_i_WireObjNum = null;
            HTuple hv__wireErrCode = null, hv__wireErrStr = null, hv_Idx = null;
            HTuple hv_ContNum = new HTuple(), hv__ErrDilateCode = new HTuple();
            HTuple hv__ErrDilateStr = new HTuple();

            HTupleVector hvec_o_DefectValueFrame = new HTupleVector(4);
            HTupleVector hvec_o_DefectValueIc = new HTupleVector(4), hvec_o_DefectValueEpoxy = new HTupleVector(4);
            HTupleVector hvec_o_DefectValueBond = new HTupleVector(4), hvec_o_DefectValueWire = new HTupleVector(4);
            HTupleVector hvec__frameLocPara = new HTupleVector(1), hvec__frameHomMat2D = new HTupleVector(1);
            HTupleVector hvec__frameLocDefectType = new HTupleVector(2), hvec__LocDefectValueFrame = new HTupleVector(3);
            HTupleVector hvec__frameLocDefectImgIdx = new HTupleVector(2);
            HTupleVector hvec__LocRefValueFrame = new HTupleVector(3), hvec__icHomMat2D = new HTupleVector(1);
            HTupleVector hvec__icDefectType = new HTupleVector(2), hvec__DefectValueIc = new HTupleVector(4);
            HTupleVector hvec__icDefectImgIdx = new HTupleVector(2), hvec_o_RefValueIc = new HTupleVector(4);
            HTupleVector hvec__epoxyDefectType = new HTupleVector(2), hvec__epoxyDefectImgIdx = new HTupleVector(2);
            HTupleVector hvec_o_RefValueEpoxy = new HTupleVector(4), hvec__BallType = new HTupleVector(1);
            HTupleVector hvec__bondDefectType = new HTupleVector(2), hvec__DefectValueBond = new HTupleVector(4);
            HTupleVector hvec__bondDefectImgIdx = new HTupleVector(2), hvec__RefValueBond = new HTupleVector(4);
            HTupleVector hvec__wireDefectType = new HTupleVector(2), hvec__wireDefectImgIdx = new HTupleVector(2);
            HTupleVector hvec_o_RefValueWire = new HTupleVector(4);
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_FailRegs);
            HOperatorSet.GenEmptyObj(out ho_WireContour);
            HOperatorSet.GenEmptyObj(out ho_DilationReg);
            hvec_o_IcRegs = new HObjectVector(1);
            hvec_o_EpoxyRegs = new HObjectVector(1);
            hvec_o_BondRegs = new HObjectVector(1);
            hvec_o_WireRes = new HObjectVector(1);
            try
            {
                //**************************************************************************************************
                //---函数：JSCC_AOI_Inspect_Gen_InspectReg_Unit
                //---作用：执行各检测项
                //---参数：
                //===图标参数
                //  i_Imgs：检测所需图像集合
                //  i_SearchRegs：搜索区
                //  i_FrameObjs：Frame检测区域对象
                //  i_IcObjs：Ic检测区域对象
                //  i_EpoxyObjs：Epoxy检测区域对象
                //  i_BondObjs：Bond检测区域对象
                //  i_WireObjs：Wire检测区域对象
                //  o_Balls:检出的Bond区域
                //  o_Epoxys:检出的Bond区域
                //  o_Balls:检出的Bond区域
                //  o_Wires：检出的Wire区域
                //  o_FailRegs：检出失败的区域
                //===控制参数
                //  i_InspectItemNum：各检测项数目
                //  i_FrameInspectParas：Frame检测参数
                //  i_IcInspectParas：Ic检测参数
                //  i_EpoxyInspectParas：Epoxy检测参数
                //  i_BondInspectParas：Bond检测参数
                //  i_WireInspectParas：Wire检测参数
                //  o_DefectType：输出的检测得到的异常区域的缺陷类型
                //  o_ErrCode：错误码
                //  o_ErrStr：错误信息
                //**************************************************************************************************

                //初始化
                hv_o_DefectType = new HTuple();
                hv_o_DefectImgIdx = new HTuple();
                hv_o_ErrCode = -2;
                hv_o_ErrStr = "initializing";
                //
                //Frame检测结果初值
                //[定位Score, frame检测缺陷信息,  PegRack检测缺陷信息,  Bridge检测缺陷信息]
                hvec_o_DefectValueFrame = (new HTupleVector(4).Insert(0, (new HTupleVector(3).Insert(0, (
                    new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))))));
                HTuple end_val38 = (hv_i_InspectItemNum.TupleSelect(
                    0)) - 1;
                HTuple step_val38 = 1;
                for (hv_objIdx = 0; hv_objIdx.Continue(end_val38, step_val38); hv_objIdx = hv_objIdx.TupleAdd(step_val38))
                {
                    hvec_o_DefectValueFrame[hv_objIdx] = (new HTupleVector(3).Insert(0, ((((new HTupleVector(2).Insert(0, (
                        new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(-2)))))).Insert(
                        1, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple()))))).Insert(
                        2, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple()))))).Insert(
                        3, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))));
                }

                //Ic检测结果初值
                //[定位Score, IC偏移量, IC旋转角度, 重点区异物信息, 崩边区异物信息]
                hvec_o_DefectValueIc = (new HTupleVector(4).Insert(0, (new HTupleVector(3).Insert(0, (
                    new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))))));
                HTuple end_val45 = (hv_i_InspectItemNum.TupleSelect(
                    1)) - 1;
                HTuple step_val45 = 1;
                for (hv_objIdx = 0; hv_objIdx.Continue(end_val45, step_val45); hv_objIdx = hv_objIdx.TupleAdd(step_val45))
                {
                    hvec_o_DefectValueIc[hv_objIdx] = (new HTupleVector(3).Insert(0, (((((new HTupleVector(2).Insert(0, (
                        new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(-2)))))).Insert(
                        1, (new HTupleVector(1).Insert(0, new HTupleVector((new HTuple(-2)).TupleConcat(
                        -2)))))).Insert(2, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(-2)))))).Insert(
                        3, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple()))))).Insert(
                        4, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))));
                }

                //Epoxy检测结果初值
                //[银胶区长度比, 银胶区高度]
                hvec_o_DefectValueEpoxy = (new HTupleVector(4).Insert(0, (new HTupleVector(3).Insert(0, (
                    new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))))));
                HTuple end_val52 = (hv_i_InspectItemNum.TupleSelect(
                    2)) - 1;
                HTuple step_val52 = 1;
                for (hv_objIdx = 0; hv_objIdx.Continue(end_val52, step_val52); hv_objIdx = hv_objIdx.TupleAdd(step_val52))
                {
                    hvec_o_DefectValueEpoxy[hv_objIdx] = (new HTupleVector(3).Insert(0, (new HTupleVector(2).Insert(0, (
                        new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))));
                }

                //Bond检测结果初值
                //[焊球半径,偏移量, 尾丝长, 焊盘异物信息]
                hvec_o_DefectValueBond = (new HTupleVector(4).Insert(0, (new HTupleVector(3).Insert(0, (
                    new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))))));
                HTuple end_val59 = (hv_i_InspectItemNum.TupleSelect(
                    3)) - 1;
                HTuple step_val59 = 1;
                for (hv_objIdx = 0; hv_objIdx.Continue(end_val59, step_val59); hv_objIdx = hv_objIdx.TupleAdd(step_val59))
                {
                    hvec_o_DefectValueBond[hv_objIdx] = (new HTupleVector(3).Insert(0, (new HTupleVector(2).Insert(0, (
                        new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))));
                }

                //Wire检测结果初值
                //[断线距离]
                hvec_o_DefectValueWire = (new HTupleVector(4).Insert(0, (new HTupleVector(3).Insert(0, (
                    new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))))));
                HTuple end_val66 = (hv_i_InspectItemNum.TupleSelect(
                    4)) - 1;
                HTuple step_val66 = 1;
                for (hv_objIdx = 0; hv_objIdx.Continue(end_val66, step_val66); hv_objIdx = hv_objIdx.TupleAdd(step_val66))
                {
                    hvec_o_DefectValueWire[hv_objIdx] = (new HTupleVector(3).Insert(0, (new HTupleVector(2).Insert(0, (
                        new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))));
                }

                //
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hvec_o_IcRegs = dh.Add(new HObjectVector(1));
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hvec_o_EpoxyRegs = dh.Add(new HObjectVector(1));
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hvec_o_BondRegs = dh.Add(new HObjectVector(1));
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hvec_o_WireRes = dh.Add(new HObjectVector(1));
                }
                ho_o_FailRegs.Dispose();
                HOperatorSet.GenEmptyObj(out ho_o_FailRegs);

                //
                //***************************对Die区域进行分区域检测****************************
                //
                //--------Frame定位
                //
                //检测frame项目数量

                hv_i_frameObjNum = hv_i_InspectItemNum[0];
                //
                hvec__frameLocFailRegs.Dispose();
                HTV_frames_locate(ho_i_Imgs, ho_i_SearchReg, hvec_i_FrameObjs, out hvec__frameLocFailRegs,
                    hv_i_frameObjNum, hvec_i_FrameInspectParas, out hvec__frameLocPara, out hvec__frameHomMat2D,
                    out hvec__frameLocDefectType, out hvec__LocDefectValueFrame, out hvec__frameLocDefectImgIdx,
                    out hvec__LocRefValueFrame, out hv__frameErrCode, out hv__frameErrStr);

                //
                //--------Ic检测：Ic定位，表面，旋转、偏移检测
                //
                //检测ic项目数量
                hv_i_icObjNum = hv_i_InspectItemNum[1];
                //
                hvec__icFailRegs.Dispose(); hvec__Ics.Dispose();
                HTV_ics_inspect(ho_i_Imgs, hvec_i_IcObjs, out hvec__icFailRegs, out hvec__Ics,
                    hv_i_icObjNum, hvec__frameHomMat2D, hvec__frameLocPara, hvec_i_IcInspectParas,
                    out hvec__icHomMat2D, out hvec__icDefectType, out hvec__DefectValueIc,
                    out hvec__icDefectImgIdx, out hvec_o_RefValueIc, out hv__icErrCode, out hv__icErrStr);

                hvec_o_IcRegs = hvec__Ics.Clone();
                //
                //--------Epoxy检测：是否有银胶
                //
                //检测epoxy项目数量
                hv_i_epoxyObjNum = hv_i_InspectItemNum[2];
                //
                hvec__Epoxys.Dispose(); hvec_o_epoxyFailRegs.Dispose();
                HTV_epoxys_inspect(ho_i_Imgs, hvec_i_EpoxyObjs, out hvec__Epoxys, out hvec_o_epoxyFailRegs,
                    hv_i_epoxyObjNum, hvec__icHomMat2D, hvec_i_EpoxyInspectParas, out hvec__epoxyDefectType,
                    out hvec_o_DefectValueEpoxy, out hvec__epoxyDefectImgIdx, out hvec_o_RefValueEpoxy,
                    out hv__epoxyErrCode, out hv__epoxyErrStr);

                hvec_o_EpoxyRegs = hvec__Epoxys.Clone();
                //
                //--------Bond检测：Bond定位
                //
                //检测bond项目数量
                hv_i_BondObjNum = hv_i_InspectItemNum[3];
                //
                hvec__BallContours.Dispose(); hvec_o_PadRegions.Dispose(); hvec__bondFailRegs.Dispose();
                HTV_bonds_inspect(ho_i_Imgs, hvec_i_BondObjs, out hvec__BallContours, out hvec_o_PadRegions,
                    out hvec__bondFailRegs, hv_i_BondObjNum, hvec__frameHomMat2D, hvec__icHomMat2D,
                    hvec_i_BondInspectParas, out hvec__BallType, out hvec__bondDefectType,
                    out hvec__DefectValueBond, out hvec__bondDefectImgIdx, out hvec__RefValueBond,
                    out hv__bondErrCode, out hv__bondErrStr);

                hvec_o_BondRegs = hvec__BallContours.Clone();
                //
                //--------Wire检测：断线、弯曲线，双丝、塌丝
                //
                //检测wire项目数量
                hv_i_WireObjNum = hv_i_InspectItemNum[4];
                //
                hvec__WireContours.Dispose(); hvec_o_wireFailRegs.Dispose();
                HTV_wires_inspect(ho_i_Imgs, hvec_i_WireObjs, hvec__BallContours, out hvec__WireContours,
                    out hvec_o_wireFailRegs, hv_i_WireObjNum, hvec__frameHomMat2D, hvec__icHomMat2D,
                    hvec_i_WireInspectParas, hvec__BallType, out hvec__wireDefectType, out hvec_o_DefectValueWire,
                    out hvec__wireDefectImgIdx, out hvec_o_RefValueWire, out hv__wireErrCode,
                    out hv__wireErrStr);

                //wire转成Region
                HTuple end_val124 = hv_i_WireObjNum - 1;
                HTuple step_val124 = 1;
                for (hv_Idx = 0; hv_Idx.Continue(end_val124, step_val124); hv_Idx = hv_Idx.TupleAdd(step_val124))
                {

                    ho_WireContour.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_WireContour = hvec__WireContours[hv_Idx].O.CopyObj(1, -1);
                    }
                    //
                    HOperatorSet.CountObj(ho_WireContour, out hv_ContNum);
                    //将contour转换为region
                    if ((int)(hv_ContNum) != 0)
                    {
                        ho_DilationReg.Dispose();
                        HTV_contours_to_region(ho_WireContour, out ho_DilationReg, 1, out hv__ErrDilateCode,
                            out hv__ErrDilateStr);
                    }
                    else
                    {
                        ho_DilationReg.Dispose();
                        HOperatorSet.GenEmptyRegion(out ho_DilationReg);
                    }

                    hvec_o_WireRes[hv_Idx] = new HObjectVector(ho_DilationReg.CopyObj(1, -1));
                }
                //

                hv_o_ErrCode = 0;
                hv_o_ErrStr = "inspect all items suceessful";
                ho_WireContour.Dispose();
                ho_DilationReg.Dispose();
                hvec__frameLocFailRegs.Dispose();
                hvec__icFailRegs.Dispose();
                hvec__Ics.Dispose();
                hvec__Epoxys.Dispose();
                hvec_o_epoxyFailRegs.Dispose();
                hvec__BallContours.Dispose();
                hvec_o_PadRegions.Dispose();
                hvec__bondFailRegs.Dispose();
                hvec__WireContours.Dispose();
                hvec_o_wireFailRegs.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_WireContour.Dispose();
                ho_DilationReg.Dispose();
                hvec__frameLocFailRegs.Dispose();
                hvec__icFailRegs.Dispose();
                hvec__Ics.Dispose();
                hvec__Epoxys.Dispose();
                hvec_o_epoxyFailRegs.Dispose();
                hvec__BallContours.Dispose();
                hvec_o_PadRegions.Dispose();
                hvec__bondFailRegs.Dispose();
                hvec__WireContours.Dispose();
                hvec_o_wireFailRegs.Dispose();

                throw HDevExpDefaultException;
            }
        }
        #endregion

        #region AroundBallRegion

        public static void JSCC_AOI_Inspect_Gen_AroundBallReg_Unit(HObject ho_i_Imgs, HObject ho_i_SearchReg,
            HObjectVector/*{eObjectVector,Dim=2}*/ hvec_i_FrameObjs, HObjectVector/*{eObjectVector,Dim=2}*/ hvec_i_IcObjs,
            HObjectVector/*{eObjectVector,Dim=2}*/ hvec_i_EpoxyObjs, HObjectVector/*{eObjectVector,Dim=2}*/ hvec_i_BondObjs,
            HObjectVector/*{eObjectVector,Dim=2}*/ hvec_i_WireObjs, out HObjectVector/*{eObjectVector,Dim=1}*/ hvec_o_RefBondRegs,
            out HObjectVector/*{eObjectVector,Dim=1}*/ hvec_o_RefPadRegs, out HObject ho_o_RejectReg,
            HTuple hv_i_InspectItemNum, HTupleVector/*{eTupleVector,Dim=3}*/ hvec_i_FrameInspectParas,
            HTupleVector/*{eTupleVector,Dim=3}*/ hvec_i_IcInspectParas, HTupleVector/*{eTupleVector,Dim=4}*/ hvec_i_EpoxyInspectParas,
            HTupleVector/*{eTupleVector,Dim=4}*/ hvec_i_BondInspectParas, HTupleVector/*{eTupleVector,Dim=4}*/ hvec_i_WireInspectParas,
            HTupleVector/*{eTupleVector,Dim=1}*/ hvec_i_CutRegionParas, out HTuple hv_o_ErrCode,
            out HTuple hv_o_ErrStr)
        {




            // Local iconic variables 

            HObject ho_EmptyObject;

            HObjectVector hvec__frameLocFailRegs = new HObjectVector(2);
            HObjectVector hvec__icFailRegs = new HObjectVector(2), hvec__Ics = new HObjectVector(1);
            HObjectVector hvec__Epoxys = new HObjectVector(1), hvec_o_epoxyFailRegs = new HObjectVector(2);
            HObjectVector hvec__BallContours = new HObjectVector(1), hvec_o_PadRegions = new HObjectVector(1);
            HObjectVector hvec__bondFailRegs = new HObjectVector(2), hvec__WireContours = new HObjectVector(1);
            HObjectVector hvec_o_wireFailRegs = new HObjectVector(2);

            // Local control variables 

            HTuple hv_i_frameObjNum = null, hv__frameErrCode = null;
            HTuple hv__frameErrStr = null, hv_i_icObjNum = null, hv__icErrCode = null;
            HTuple hv__icErrStr = null, hv_i_epoxyObjNum = null, hv__epoxyErrCode = null;
            HTuple hv__epoxyErrStr = null, hv_i_BondObjNum = null;
            HTuple hv__bondErrCode = null, hv__bondErrStr = null, hv_i_WireObjNum = null;
            HTuple hv__wireErrCode = null, hv__wireErrStr = null, hv__editErrCode = null;
            HTuple hv__editErrStr = null;

            HTupleVector hvec__frameLocPara = new HTupleVector(1);
            HTupleVector hvec__frameHomMat2D = new HTupleVector(1), hvec__frameLocDefectType = new HTupleVector(2);
            HTupleVector hvec__LocDefectValueFrame = new HTupleVector(3);
            HTupleVector hvec__frameLocDefectImgIdx = new HTupleVector(2);
            HTupleVector hvec__LocRefValueFrame = new HTupleVector(3), hvec__icHomMat2D = new HTupleVector(1);
            HTupleVector hvec__icDefectType = new HTupleVector(2), hvec__DefectValueIc = new HTupleVector(4);
            HTupleVector hvec__icDefectImgIdx = new HTupleVector(2), hvec_o_RefValueIc = new HTupleVector(4);
            HTupleVector hvec__epoxyDefectType = new HTupleVector(2), hvec_o_DefectValueEpoxy = new HTupleVector(4);
            HTupleVector hvec__epoxyDefectImgIdx = new HTupleVector(2), hvec_o_RefValueEpoxy = new HTupleVector(4);
            HTupleVector hvec__BallType = new HTupleVector(1), hvec__bondDefectType = new HTupleVector(2);
            HTupleVector hvec__DefectValueBond = new HTupleVector(4), hvec__bondDefectImgIdx = new HTupleVector(2);
            HTupleVector hvec__RefValueBond = new HTupleVector(4), hvec__wireDefectType = new HTupleVector(2);
            HTupleVector hvec_o_DefectValueWire = new HTupleVector(4), hvec__wireDefectImgIdx = new HTupleVector(2);
            HTupleVector hvec_o_RefValueWire = new HTupleVector(4);
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_RejectReg);
            HOperatorSet.GenEmptyObj(out ho_EmptyObject);
            hvec_o_RefBondRegs = new HObjectVector(1);
            hvec_o_RefPadRegs = new HObjectVector(1);
            try
            {
                //**************************************************************************************************
                //---函数：JSCC_AOI_Inspect_Gen_CutReg_Unit
                //---作用：执行各检测项,获取CutReg
                //---参数：
                //===图标参数
                //  i_Imgs：检测所需图像集合
                //  i_SearchRegs：搜索区
                //  i_FrameObjs：Frame检测区域对象
                //  i_IcObjs：Ic检测区域对象
                //  i_EpoxyObjs：Epoxy检测区域对象
                //  i_BondObjs：Bond检测区域对象
                //  i_WireObjs：Wire检测区域对象
                //  o_RefBondRegs：参考Bond区域
                //  o_RejectReg：Bond周围检测免检测区域
                //===控制参数
                //  i_InspectItemNum：各检测项数目
                //  i_FrameInspectParas：Frame检测参数
                //  i_IcInspectParas：Ic检测参数
                //  i_EpoxyInspectParas：Epoxy检测参数
                //  i_BondInspectParas：Bond检测参数
                //  i_WireInspectParas：Wire检测参数
                //  i_CutRegionParas：膨胀参数
                //  o_ErrCode：错误码
                //  o_ErrStr：错误信息
                //**************************************************************************************************

                //初始化
                hv_o_ErrCode = -2;
                hv_o_ErrStr = "initializing";
                //
                ho_EmptyObject.Dispose();
                HOperatorSet.GenEmptyObj(out ho_EmptyObject);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hvec_o_RefBondRegs = dh.Take((
                        dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho_EmptyObject)))));
                }
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hvec_o_RefPadRegs = dh.Take((
                        dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho_EmptyObject)))));
                }
                ho_o_RejectReg.Dispose();
                ho_o_RejectReg = ho_EmptyObject.CopyObj(1, -1);
                //
                //***************************对Die区域进行分区域检测****************************
                //
                //--------Frame定位
                //
                //检测frame项目数量

                hv_i_frameObjNum = hv_i_InspectItemNum[0];
                //
                hvec__frameLocFailRegs.Dispose();
                HTV_frames_locate(ho_i_Imgs, ho_i_SearchReg, hvec_i_FrameObjs, out hvec__frameLocFailRegs,
                    hv_i_frameObjNum, hvec_i_FrameInspectParas, out hvec__frameLocPara, out hvec__frameHomMat2D,
                    out hvec__frameLocDefectType, out hvec__LocDefectValueFrame, out hvec__frameLocDefectImgIdx,
                    out hvec__LocRefValueFrame, out hv__frameErrCode, out hv__frameErrStr);
                //
                //--------Ic检测：Ic定位，表面，旋转、偏移检测
                //
                //检测ic项目数量
                hv_i_icObjNum = hv_i_InspectItemNum[1];
                //
                hvec__icFailRegs.Dispose(); hvec__Ics.Dispose();
                HTV_ics_inspect(ho_i_Imgs, hvec_i_IcObjs, out hvec__icFailRegs, out hvec__Ics,
                    hv_i_icObjNum, hvec__frameHomMat2D, hvec__frameLocPara, hvec_i_IcInspectParas,
                    out hvec__icHomMat2D, out hvec__icDefectType, out hvec__DefectValueIc,
                    out hvec__icDefectImgIdx, out hvec_o_RefValueIc, out hv__icErrCode, out hv__icErrStr);
                //
                //-------—-Epoxy检测：是否有银胶
                //
                //检测epoxy项目数量
                hv_i_epoxyObjNum = hv_i_InspectItemNum[2];
                //
                hvec__Epoxys.Dispose(); hvec_o_epoxyFailRegs.Dispose();
                HTV_epoxys_inspect(ho_i_Imgs, hvec_i_EpoxyObjs, out hvec__Epoxys, out hvec_o_epoxyFailRegs,
                    hv_i_epoxyObjNum, hvec__icHomMat2D, hvec_i_EpoxyInspectParas, out hvec__epoxyDefectType,
                    out hvec_o_DefectValueEpoxy, out hvec__epoxyDefectImgIdx, out hvec_o_RefValueEpoxy,
                    out hv__epoxyErrCode, out hv__epoxyErrStr);
                //
                //---------Bond检测：Bond定位
                //
                //检测bond项目数量
                hv_i_BondObjNum = hv_i_InspectItemNum[3];
                //
                hvec__BallContours.Dispose(); hvec_o_PadRegions.Dispose(); hvec__bondFailRegs.Dispose();
                HTV_bonds_inspect(ho_i_Imgs, hvec_i_BondObjs, out hvec__BallContours, out hvec_o_PadRegions,
                    out hvec__bondFailRegs, hv_i_BondObjNum, hvec__frameHomMat2D, hvec__icHomMat2D,
                    hvec_i_BondInspectParas, out hvec__BallType, out hvec__bondDefectType,
                    out hvec__DefectValueBond, out hvec__bondDefectImgIdx, out hvec__RefValueBond,
                    out hv__bondErrCode, out hv__bondErrStr);
                //
                //---------Wire检测：断线、弯曲线，双丝、塌丝
                //检测wire项目数量
                hv_i_WireObjNum = hv_i_InspectItemNum[4];
                //
                hvec__WireContours.Dispose(); hvec_o_wireFailRegs.Dispose();
                HTV_wires_inspect(ho_i_Imgs, hvec_i_WireObjs, hvec__BallContours, out hvec__WireContours,
                    out hvec_o_wireFailRegs, hv_i_WireObjNum, hvec__frameHomMat2D, hvec__icHomMat2D,
                    hvec_i_WireInspectParas, hvec__BallType, out hvec__wireDefectType, out hvec_o_DefectValueWire,
                    out hvec__wireDefectImgIdx, out hvec_o_RefValueWire, out hv__wireErrCode,
                    out hv__wireErrStr);
                //
                //-------- AroundBallRegs获取
                //
                hvec_o_RefBondRegs.Dispose(); ho_o_RejectReg.Dispose();
                HTV_gen_inspect_AroundBallReg(hvec__Ics, hvec__Epoxys, hvec__BallContours,
                    hvec__WireContours, out hvec_o_RefBondRegs, out ho_o_RejectReg, hvec_i_CutRegionParas,
                    out hv__editErrCode, out hv__editErrStr);
                //输出参考焊盘区域
                hvec_o_RefPadRegs = hvec_o_PadRegions.Clone();
                //
                hv_o_ErrCode = 0;
                hv_o_ErrStr = "inspect all items suceessful";
                ho_EmptyObject.Dispose();
                hvec__frameLocFailRegs.Dispose();
                hvec__icFailRegs.Dispose();
                hvec__Ics.Dispose();
                hvec__Epoxys.Dispose();
                hvec_o_epoxyFailRegs.Dispose();
                hvec__BallContours.Dispose();
                hvec_o_PadRegions.Dispose();
                hvec__bondFailRegs.Dispose();
                hvec__WireContours.Dispose();
                hvec_o_wireFailRegs.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_EmptyObject.Dispose();
                hvec__frameLocFailRegs.Dispose();
                hvec__icFailRegs.Dispose();
                hvec__Ics.Dispose();
                hvec__Epoxys.Dispose();
                hvec_o_epoxyFailRegs.Dispose();
                hvec__BallContours.Dispose();
                hvec_o_PadRegions.Dispose();
                hvec__bondFailRegs.Dispose();
                hvec__WireContours.Dispose();
                hvec_o_wireFailRegs.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public static void HTV_gen_inspect_AroundBallReg(HObjectVector/*{eObjectVector,Dim=1}*/ hvec_i_IcInspectRegs,
            HObjectVector/*{eObjectVector,Dim=1}*/ hvec_i_EpoxyRegs, HObjectVector/*{eObjectVector,Dim=1}*/ hvec_i_BondRegs,
            HObjectVector/*{eObjectVector,Dim=1}*/ hvec_i_WireContours, out HObjectVector/*{eObjectVector,Dim=1}*/ hvec_o_AroundBallRegs,
            out HObject ho_o_AvoidReg, HTupleVector/*{eTupleVector,Dim=1}*/ hvec_i_CutRegionParas,
            out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {




            // Local iconic variables 

            HObject ho_EmptyObject, ho_BondReg = null, ho_DilationReg = null;

            // Local control variables 

            HTuple hv__BondDilationSize = null, hv__WireDilationSize = null;
            HTuple hv_bondNum = null, hv_Idx = null, hv_RegNum = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_AvoidReg);
            HOperatorSet.GenEmptyObj(out ho_EmptyObject);
            HOperatorSet.GenEmptyObj(out ho_BondReg);
            HOperatorSet.GenEmptyObj(out ho_DilationReg);
            hvec_o_AroundBallRegs = new HObjectVector(1);
            try
            {
                //**************************************************************************************************
                //---函数：HTV_gen_inspect_cutReg
                //---作用：获取表面检测免检区
                //---参数：
                //===图标参数
                //  i_IcInspectRegs：Ic检测区
                //  i_EpoxyRegs：Epoxy检测区
                //  i_BondRegs：Bond检测区
                //  i_WireContours：Wire检测区
                //  o_AvoidReg：免检区域
                //  o_RejectRegs：免检区域向量
                //===控制参数
                //  i_FrameNum：框架数目
                //  i_CutRegionParas：膨胀系数
                //  o_ErrCode：错误码
                //  o_ErrStr：错误信息
                //**************************************************************************************************
                //
                //初始化
                hv_o_ErrCode = -2;
                hv_o_ErrStr = "initializing";

                ho_EmptyObject.Dispose();
                HOperatorSet.GenEmptyObj(out ho_EmptyObject);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hvec_o_AroundBallRegs = dh.Take((
                        dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho_EmptyObject)))));
                }
                ho_o_AvoidReg.Dispose();
                ho_o_AvoidReg = ho_EmptyObject.CopyObj(1, -1);
                //输入合法性测试

                //膨胀参数
                hv__BondDilationSize = hvec_i_CutRegionParas[2].T.Clone();
                hv__WireDilationSize = hvec_i_CutRegionParas[3].T.Clone();
                //
                //--------- 膨胀各免检区
                //bond检测区
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hv_bondNum = new HTuple(hvec_i_BondRegs.Length);
                }

                HTuple end_val35 = hv_bondNum - 1;
                HTuple step_val35 = 1;
                for (hv_Idx = 0; hv_Idx.Continue(end_val35, step_val35); hv_Idx = hv_Idx.TupleAdd(step_val35))
                {
                    //
                    ho_BondReg.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_BondReg = hvec_i_BondRegs[hv_Idx].O.CopyObj(1, -1);
                    }
                    //
                    HOperatorSet.CountObj(ho_BondReg, out hv_RegNum);
                    if ((int)(hv_RegNum) != 0)
                    {
                        ho_DilationReg.Dispose();
                        HOperatorSet.DilationCircle(ho_BondReg, out ho_DilationReg, hv__BondDilationSize.TupleSelect(
                            hv_Idx));
                    }
                    else
                    {
                        ho_DilationReg.Dispose();
                        HOperatorSet.GenEmptyRegion(out ho_DilationReg);
                    }

                    //hvec_o_AroundBallRegs[hv_Idx] = new HObjectVector(ho_DilationReg.CopyObj(1, -1));
                    hvec_o_AroundBallRegs[hv_Idx] = new HObjectVector(ho_BondReg.CopyObj(1, -1));   // 1206 lw mod 和单节点结果保持一致
                }
                //
                //wire检测区
                ho_o_AvoidReg.Dispose();
                HTV_dilation_reject_contour(hvec_i_WireContours, out ho_o_AvoidReg, hv__WireDilationSize);

                //
                hv_o_ErrCode = 0;
                hv_o_ErrStr = "frames edit successful";

                ho_EmptyObject.Dispose();
                ho_BondReg.Dispose();
                ho_DilationReg.Dispose();

                return;

            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_EmptyObject.Dispose();
                ho_BondReg.Dispose();
                ho_DilationReg.Dispose();

                throw HDevExpDefaultException;
            }
        }

        #endregion

        #region 表面检测  

        public static void JSCC_AOI_read_all_model(out HObjectVector/*{eObjectVector,Dim=2}*/ hvec_o_FrameObjs,
            out HObjectVector/*{eObjectVector,Dim=2}*/ hvec_o_IcObjs, out HObjectVector/*{eObjectVector,Dim=2}*/ hvec_o_EpoxyObjs,
            out HObjectVector/*{eObjectVector,Dim=2}*/ hvec_o_BondObjs, out HObjectVector/*{eObjectVector,Dim=2}*/ hvec_o_WireObjs,
            HTuple hv_i_ModelPath, out HTuple hv_o_InspectItemNum, out HTupleVector/*{eTupleVector,Dim=2}*/ hvec_o_FrameModels,
            out HTupleVector/*{eTupleVector,Dim=2}*/ hvec_o_IcModels, out HTupleVector/*{eTupleVector,Dim=2}*/ hvec_o_EpoxyModels,
            out HTupleVector/*{eTupleVector,Dim=2}*/ hvec_o_BondModels, out HTupleVector/*{eTupleVector,Dim=2}*/ hvec_o_WireModels,
            out HTupleVector/*{eTupleVector,Dim=1}*/ hvec_o_CutRegModels, out HTuple hv_o_ErrCode,
            out HTuple hv_o_ErrStr)
        {



            // Local iconic variables 

            HObject ho_EmptyObject;

            // Local control variables 

            HTuple hv_IsString = null, hv_Files = null;
            HTuple hv_Matches = null, hv_ItemFiles = null, hv__FramePath = null;
            HTuple hv__FrameNum = null, hv__FrameErrCode = new HTuple();
            HTuple hv__FrameErrStr = new HTuple(), hv__ICPath = null;
            HTuple hv__IcNum = null, hv__IcErrCode = new HTuple();
            HTuple hv__IcErrStr = new HTuple(), hv__EpoxyPath = null;
            HTuple hv__EpoxyNum = null, hv__EpoxyErrCode = new HTuple();
            HTuple hv__EpoxyErrStr = new HTuple(), hv__BondPath = null;
            HTuple hv__BondNum = null, hv__BondErrCode = new HTuple();
            HTuple hv__BondErrStr = new HTuple(), hv__WirePath = null;
            HTuple hv__WireNum = null, hv__WireErrCode = new HTuple();
            HTuple hv__WireErrStr = new HTuple(), hv__CutRegPath = null;
            HTuple hv_CutRegNum = null, hv__CutErrCode = new HTuple();
            HTuple hv__CutErrStr = new HTuple(), hv__IcdilationSize = new HTuple();
            HTuple hv__EpoxydilationSize = new HTuple(), hv__BonddilationSize = new HTuple();
            HTuple hv__WiredilationSize = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_EmptyObject);
            hvec_o_FrameObjs = new HObjectVector(2);
            hvec_o_IcObjs = new HObjectVector(2);
            hvec_o_EpoxyObjs = new HObjectVector(2);
            hvec_o_BondObjs = new HObjectVector(2);
            hvec_o_WireObjs = new HObjectVector(2);
            hv_o_ErrCode = new HTuple();
            hv_o_ErrStr = new HTuple();
            try
            {
                //**************************************************************************************************
                //---函数：JSCC_AOI_read_all_model
                //---作用：读取Die区域所有检测项目的模板文件
                //---参数：
                //===图标参数
                //  o_FrameObjs：Frame检测所需对象集合：二维集合向量
                //  o_IcObjs：Ic检测所需对象集合：二维集合向量
                //  o_EpoxyObjs：Epoxy检测所需要的对象集合：一维集合向量
                //  o_BondObjs：bond检测所需对象集合：二维集合向量
                //  o_WireObjs：Ic检测所需对象集合：二维集合向量
                //===控制参数
                //  i_ModelPath：存放模板的路径，一般指Moldes下的文件
                //  o_InspectItemNum：各检测项目需要检测数量集合：一维数组
                //  o_FrameModels：Ic检测所需参数集合：一维向量
                //  o_IcModels：Ic检测所需参数集合：一维向量
                //  o_EpoxyModels：Epoxy检测所需要参数集合：一维向量
                //  o_BondModels：Ic检测所需参数集合：一维向量
                //  o_WireModels：Wire检测所需要的模板文件中的参数集合：一维向量
                //  o_ErrCode：错误码，代表该算子在执行过程中产生的错误，0-代表执行正常，-1-代表执行异常，-2-代表未执行
                //  o_ErrStr: 错误信息，对各种错误的具体描述
                //**************************************************************************************************


                //初始化
                //
                ho_EmptyObject.Dispose();
                HOperatorSet.GenEmptyObj(out ho_EmptyObject);
                //
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hvec_o_FrameObjs = dh.Take((
                        dh.Add(new HObjectVector(2)).Insert(0, (dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho_EmptyObject)))))));
                }
                hvec_o_FrameModels = (new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple("none"))))));
                //
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hvec_o_IcObjs = dh.Take((
                        dh.Add(new HObjectVector(2)).Insert(0, (dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho_EmptyObject)))))));
                }
                hvec_o_IcModels = (new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple("none"))))));
                //
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hvec_o_EpoxyObjs = dh.Take((
                        dh.Add(new HObjectVector(2)).Insert(0, (dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho_EmptyObject)))))));
                }
                hvec_o_EpoxyModels = (new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple("none"))))));
                //
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hvec_o_BondObjs = dh.Take((
                        dh.Add(new HObjectVector(2)).Insert(0, (dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho_EmptyObject)))))));
                }
                hvec_o_BondModels = (new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple("none"))))));
                //
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hvec_o_WireObjs = dh.Take((
                        dh.Add(new HObjectVector(2)).Insert(0, (dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho_EmptyObject)))))));
                }
                hvec_o_WireModels = (new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple("none"))))));
                //
                hvec_o_CutRegModels = ((((new HTupleVector(1).Insert(0, new HTupleVector(new HTuple()))).Insert(
                    1, new HTupleVector(new HTuple()))).Insert(2, new HTupleVector(new HTuple()))).Insert(
                    3, new HTupleVector(new HTuple())));
                //
                hv_o_InspectItemNum = new HTuple();
                //传入有效性测试
                HOperatorSet.TupleIsString(hv_i_ModelPath, out hv_IsString);
                if ((int)((new HTuple(hv_IsString.TupleEqual("false"))).TupleOr(new HTuple((new HTuple(hv_i_ModelPath.TupleLength()
                    )).TupleEqual(0)))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "the para i_ModelPath must be a string and the para |i_ModelPath| must greater than 0";
                    ho_EmptyObject.Dispose();

                    return;
                }
                //
                //读物_ModelPath下所有的模板文件
                HOperatorSet.ListFiles(hv_i_ModelPath, "directories", out hv_Files);
                //获取Models下的模板项目数组
                HOperatorSet.TupleRegexpMatch(hv_Files, "Models.*", out hv_Matches);
                HOperatorSet.TupleRegexpReplace(hv_Matches, new HTuple("Models/") + "*", "",
                    out hv_ItemFiles);
                //-----------------------Frame
                //提取Frame的所有文件夹
                HOperatorSet.TupleRegexpSelect(hv_ItemFiles, "Frame.*", out hv__FramePath);
                //
                hv__FrameNum = new HTuple(hv__FramePath.TupleLength());
                //
                if ((int)(hv__FrameNum) != 0)
                {
                    hv__FramePath = hv_i_ModelPath + hv__FramePath;
                    hvec_o_FrameObjs.Dispose();
                    HTV_read_frame_model(out hvec_o_FrameObjs, hv__FramePath, out hvec_o_FrameModels,
                        out hv__FrameErrCode, out hv__FrameErrStr);
                }
                hv_o_InspectItemNum = hv_o_InspectItemNum.TupleConcat(hv__FrameNum);
                //
                //-----------------------Ic
                //提取IC的所有文件夹
                HOperatorSet.TupleRegexpSelect(hv_ItemFiles, "IC.*", out hv__ICPath);
                //
                hv__IcNum = new HTuple(hv__ICPath.TupleLength());
                if ((int)(hv__IcNum) != 0)
                {
                    hv__ICPath = hv_i_ModelPath + hv__ICPath;
                    hvec_o_IcObjs.Dispose();
                    HTV_read_ic_model(out hvec_o_IcObjs, hv__ICPath, out hvec_o_IcModels, out hv__IcErrCode,
                        out hv__IcErrStr);
                }
                hv_o_InspectItemNum = hv_o_InspectItemNum.TupleConcat(hv__IcNum);
                //
                //-----------------------Epoxy
                //提取Epoxy的所有文件夹
                HOperatorSet.TupleRegexpSelect(hv_ItemFiles, "Epoxy.*", out hv__EpoxyPath);
                //
                hv__EpoxyNum = new HTuple(hv__EpoxyPath.TupleLength());
                if ((int)(hv__EpoxyNum) != 0)
                {
                    hv__EpoxyPath = hv_i_ModelPath + hv__EpoxyPath;
                    hvec_o_EpoxyObjs.Dispose();
                    HTV_read_epoxy_model(out hvec_o_EpoxyObjs, hv__EpoxyPath, out hvec_o_EpoxyModels,
                        out hv__EpoxyErrCode, out hv__EpoxyErrStr);
                }
                hv_o_InspectItemNum = hv_o_InspectItemNum.TupleConcat(hv__EpoxyNum);
                //
                //-----------------------Bond
                //提取Bond的所有文件夹
                HOperatorSet.TupleRegexpSelect(hv_ItemFiles, "Bond.*", out hv__BondPath);
                //
                hv__BondNum = new HTuple(hv__BondPath.TupleLength());
                if ((int)(hv__BondNum) != 0)
                {
                    hv__BondPath = hv_i_ModelPath + hv__BondPath;
                    hvec_o_BondObjs.Dispose();
                    HTV_read_bond_model(out hvec_o_BondObjs, hv__BondPath, out hvec_o_BondModels,
                        out hv__BondErrCode, out hv__BondErrStr);
                }
                hv_o_InspectItemNum = hv_o_InspectItemNum.TupleConcat(hv__BondNum);
                //
                //---------------------Wire
                //提取Wire的所有文件夹
                HOperatorSet.TupleRegexpSelect(hv_ItemFiles, "Wire.*", out hv__WirePath);
                //金线类别数量
                hv__WireNum = new HTuple(hv__WirePath.TupleLength());
                if ((int)(hv__WireNum) != 0)
                {
                    hv__WirePath = hv_i_ModelPath + hv__WirePath;
                    hvec_o_WireObjs.Dispose();
                    HTV_read_wire_model(out hvec_o_WireObjs, hv__WirePath, out hvec_o_WireModels,
                        out hv__WireErrCode, out hv__WireErrStr);
                }
                hv_o_InspectItemNum = hv_o_InspectItemNum.TupleConcat(hv__WireNum);
                //
                //--------------------CutReg
                //提取CutRegion文件中的参数
                HOperatorSet.TupleRegexpSelect(hv_ItemFiles, "CutRegion", out hv__CutRegPath);
                hv__CutRegPath = hv_i_ModelPath + hv__CutRegPath;
                //cutReg文件数量
                hv_CutRegNum = new HTuple(hv__CutRegPath.TupleLength());
                if ((int)(hv_CutRegNum) != 0)
                {
                    HTV_read_cutreg_model(hv__CutRegPath, hv_o_InspectItemNum, out hvec_o_CutRegModels,
                        out hv__CutErrCode, out hv__CutErrStr);
                }
                else
                {
                    //没有CutReg时给默认值
                    if ((int)(hv__IcNum) != 0)
                    {
                        HOperatorSet.TupleGenConst(hv__IcNum, 1, out hv__IcdilationSize);
                        hvec_o_CutRegModels[0] = new HTupleVector(hv__IcdilationSize).Clone();
                    }
                    if ((int)(hv__EpoxyNum) != 0)
                    {
                        HOperatorSet.TupleGenConst(hv__EpoxyNum, 1, out hv__EpoxydilationSize);
                        hvec_o_CutRegModels[1] = new HTupleVector(hv__EpoxydilationSize).Clone();
                    }
                    if ((int)(hv__BondNum) != 0)
                    {
                        HOperatorSet.TupleGenConst(hv__BondNum, 1, out hv__BonddilationSize);
                        hvec_o_CutRegModels[2] = new HTupleVector(hv__BonddilationSize).Clone();
                    }
                    if ((int)(hv__WireNum) != 0)
                    {
                        HOperatorSet.TupleGenConst(hv__WireNum, 1, out hv__WiredilationSize);
                        hvec_o_CutRegModels[3] = new HTupleVector(hv__WiredilationSize).Clone();
                    }
                }
                //
                hv_o_ErrCode = 0;
                hv_o_ErrStr = "read all models successful!";
                ho_EmptyObject.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_EmptyObject.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public static void HTV_frames_locate(HObject ho_i_Imgs, HObject ho_i_SearchReg, HObjectVector/*{eObjectVector,Dim=2}*/ hvec_i_FrameObjs,
            out HObjectVector/*{eObjectVector,Dim=2}*/ hvec_o_FailRegs, HTuple hv_i_ObjNum,
            HTupleVector/*{eTupleVector,Dim=3}*/ hvec_i_FrameInspectParas, out HTupleVector/*{eTupleVector,Dim=1}*/ hvec_o_LocPara,
            out HTupleVector/*{eTupleVector,Dim=1}*/ hvec_o_HomMatMod2Img, out HTupleVector/*{eTupleVector,Dim=2}*/ hvec_o_DefectTypes,
            out HTupleVector/*{eTupleVector,Dim=3}*/ hvec_o_DefectValue, out HTupleVector/*{eTupleVector,Dim=2}*/ hvec_o_DefectImgIdx,
            out HTupleVector/*{eTupleVector,Dim=3}*/ hvec_o_RefValue, out HTuple hv_o_ErrCode,
            out HTuple hv_o_ErrStr)
        {




            // Local iconic variables 

            HObject ho_EmptyObject, ho__MatchRegions = null;
            HObject ho__FrameRegion = null, ho_i_Image = null, ho__FailFrameLocReg = null;

            // Local control variables 

            HTuple hv_objIdx = null, hv__DefectFrameTypes = new HTuple();
            HTuple hv__DefectFrameImgIdxs = new HTuple(), hv__DefectFrameLocValues = new HTuple();
            HTuple hv__FrameLocEnable = new HTuple(), hv__ImageIdx = new HTuple();
            HTuple hv__ModelType = new HTuple(), hv__ModelID = new HTuple();
            HTuple hv__LocFramePara = new HTuple(), hv__MatchMinscore = new HTuple();
            HTuple hv__MatchStartAngle = new HTuple(), hv__MatchAngleExt = new HTuple();
            HTuple hv__MatchNum = new HTuple(), hv__DilationSize = new HTuple();
            HTuple hv_MinscoreTup = new HTuple(), hv__LocPara = new HTuple();
            HTuple hv__FrameHomMat2D = new HTuple(), hv__DefectFrameLocType = new HTuple();
            HTuple hv__DefectFrameLocImgIdx = new HTuple(), hv_o_ErrLocCode = new HTuple();
            HTuple hv_o_ErrLocStr = new HTuple();

            HTupleVector hvec__RefValue = new HTupleVector(1);
            HTupleVector hvec__DefectFrameLocValue = new HTupleVector(1);
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_EmptyObject);
            HOperatorSet.GenEmptyObj(out ho__MatchRegions);
            HOperatorSet.GenEmptyObj(out ho__FrameRegion);
            HOperatorSet.GenEmptyObj(out ho_i_Image);
            HOperatorSet.GenEmptyObj(out ho__FailFrameLocReg);
            hvec_o_FailRegs = new HObjectVector(2);
            try
            {
                //**************************************************************************************************
                //---函数：HTV_frames_locate
                //---作用：Frames定位：多框架定位
                //---参数：
                //===图标参数
                //  i_Imgs：检测所需图像集合
                //  i_SearchRegs：搜索区
                //  i_FrameObjs：Frame检测区域对象
                //  o_FailRegs：检出失败的区域
                //===控制参数
                //  i_ObjNum：框架数目
                //  i_FrameInspectParas：Frame检测参数
                //  o_HomMatMod2Img：Frame定位映射矩阵
                //  o_DefectTypes：异常区域的缺陷类型
                //  o_ErrCode：错误码
                //  o_ErrStr：错误信息
                //**************************************************************************************************
                //
                //初始化
                hvec_o_DefectTypes = (new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))));
                hvec_o_DefectImgIdx = (new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))));
                hvec_o_HomMatMod2Img = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())));
                hvec_o_LocPara = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())));
                hvec_o_DefectValue = (new HTupleVector(3).Insert(0, (new HTupleVector(2).Insert(0, (
                    new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))));
                hvec_o_RefValue = (new HTupleVector(3).Insert(0, (new HTupleVector(2).Insert(0, (
                    new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))));
                ho_EmptyObject.Dispose();
                HOperatorSet.GenEmptyObj(out ho_EmptyObject);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hvec_o_FailRegs = dh.Take((
                        dh.Add(new HObjectVector(2)).Insert(0, (dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho_EmptyObject)))))));
                }
                HTuple end_val27 = hv_i_ObjNum - 1;
                HTuple step_val27 = 1;
                for (hv_objIdx = 0; hv_objIdx.Continue(end_val27, step_val27); hv_objIdx = hv_objIdx.TupleAdd(step_val27))
                {
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hvec_o_FailRegs[hv_objIdx] = dh.Take((
                            dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho_EmptyObject)))));
                    }
                    hvec_o_DefectTypes[hv_objIdx] = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())));
                    hvec_o_DefectImgIdx[hv_objIdx] = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())));
                    hvec_o_HomMatMod2Img[hv_objIdx] = new HTupleVector((((((new HTuple(-2)).TupleConcat(
                        -2)).TupleConcat(-2)).TupleConcat(-2)).TupleConcat(-2)).TupleConcat(-2));
                    hvec_o_LocPara[hv_objIdx] = new HTupleVector(((new HTuple(-2)).TupleConcat(
                        -2)).TupleConcat(-2));
                }
                hv_o_ErrCode = -2;
                hv_o_ErrStr = "initializing";
                //输入合法性测试
                //
                //----------------------------------Location------------------------------
                //
                HTuple end_val40 = hv_i_ObjNum - 1;
                HTuple step_val40 = 1;
                for (hv_objIdx = 0; hv_objIdx.Continue(end_val40, step_val40); hv_objIdx = hv_objIdx.TupleAdd(step_val40))
                {
                    //
                    //单frame初始化
                    hv__DefectFrameTypes = new HTuple();
                    hv__DefectFrameImgIdxs = new HTuple();
                    hv__DefectFrameLocValues = new HTuple();
                    //
                    //获取frame检测model参数
                    //定位任务项使能
                    hv__FrameLocEnable = 1;
                    //frame定位使用图层
                    hv__ImageIdx = hvec_i_FrameInspectParas[0][hv_objIdx][0].T.Clone();
                    //frame定位模板type、Id
                    hv__ModelType = hvec_i_FrameInspectParas[0][hv_objIdx][1].T.Clone();
                    hv__ModelID = hvec_i_FrameInspectParas[0][hv_objIdx][2].T.Clone();
                    //
                    //
                    //*******************frame定位*********************
                    if ((int)(new HTuple(hv__FrameLocEnable.TupleEqual(1))) != 0)
                    {
                        //框架匹配区域
                        ho__MatchRegions.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho__MatchRegions = hvec_i_FrameObjs[hv_objIdx][0].O.CopyObj(1, -1);
                        }
                        //框架所在区域
                        ho__FrameRegion.Dispose();
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            ho__FrameRegion = hvec_i_FrameObjs[hv_objIdx][1].O.CopyObj(1, -1);
                        }
                        //获取frame定位参数
                        hv__LocFramePara = hvec_i_FrameInspectParas[1][hv_objIdx][0].T.Clone();
                        //参数设置
                        hv__MatchMinscore = hv__LocFramePara[0];
                        hv__MatchStartAngle = hv__LocFramePara[1];
                        hv__MatchAngleExt = hv__LocFramePara[2];
                        hv__MatchNum = hv__LocFramePara[3];
                        hv__DilationSize = hv__LocFramePara[4];
                        //
                        //参考设置值
                        HOperatorSet.TupleGenConst(new HTuple(hv__ModelID.TupleLength()), hv__MatchMinscore,
                            out hv_MinscoreTup);
                        hvec__RefValue = (new HTupleVector(1).Insert(0, new HTupleVector(hv_MinscoreTup)));
                        //
                        //选择图像
                        ho_i_Image.Dispose();
                        HOperatorSet.SelectObj(ho_i_Imgs, out ho_i_Image, hv__ImageIdx.TupleSelect(
                            0));
                        ho__FailFrameLocReg.Dispose();
                        HTV_Frame_Location(ho_i_Image, ho_i_SearchReg, ho__MatchRegions, ho__FrameRegion,
                            out ho__FailFrameLocReg, hv__ModelType, hv__ModelID, hv__DilationSize,
                            hv__MatchMinscore, hv__MatchStartAngle, hv__MatchAngleExt, hv__MatchNum,
                            hv__ImageIdx.TupleSelect(0), out hv__LocPara, out hv__FrameHomMat2D,
                            out hv__DefectFrameLocType, out hv__DefectFrameLocImgIdx, out hvec__DefectFrameLocValue,
                            out hv_o_ErrLocCode, out hv_o_ErrLocStr);
                    }
                    //
                    //整合多frame区域检测结果
                    //一个Frame只有一个检测ID
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hvec_o_FailRegs[hv_objIdx] = dh.Take((
                            dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho__FailFrameLocReg)))));
                    }
                    hvec_o_DefectTypes[hv_objIdx] = (new HTupleVector(1).Insert(0, new HTupleVector(hv__DefectFrameLocType)));
                    hvec_o_DefectImgIdx[hv_objIdx] = (new HTupleVector(1).Insert(0, new HTupleVector(hv__DefectFrameLocImgIdx)));
                    hvec_o_DefectValue[hv_objIdx] = (new HTupleVector(2).Insert(0, hvec__DefectFrameLocValue));
                    hvec_o_RefValue[hv_objIdx] = (new HTupleVector(2).Insert(0, hvec__RefValue));
                    hvec_o_HomMatMod2Img[hv_objIdx] = new HTupleVector(hv__FrameHomMat2D).Clone();
                    hvec_o_LocPara[hv_objIdx] = new HTupleVector(hv__LocPara).Clone();
                    //
                }
                //
                hv_o_ErrCode = 0;
                hv_o_ErrStr = "frames locate successful";
                ho_EmptyObject.Dispose();
                ho__MatchRegions.Dispose();
                ho__FrameRegion.Dispose();
                ho_i_Image.Dispose();
                ho__FailFrameLocReg.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_EmptyObject.Dispose();
                ho__MatchRegions.Dispose();
                ho__FrameRegion.Dispose();
                ho_i_Image.Dispose();
                ho__FailFrameLocReg.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public static void HTV_Frame_Inspect(HObject ho_i_Image, HObject ho_i_InspectReg, HObject ho_i_RegjectReg,
            out HObject ho_o_FailRegs, HTuple hv_i_HomMatMod2Img, HTupleVector/*{eTupleVector,Dim=1}*/ hvec_i_RegSegParas,
            HTuple hv_i_CloseSize, HTuple hv_i_MinLength, HTuple hv_i_MinWidth, HTuple hv_i_MinArea,
            HTuple hv_i_SelOperation, HTuple hv_i_ImgIdx, out HTuple hv_o_DefectType, out HTuple hv_o_DefectImgIdx,
            out HTuple hv_o_DefectValue, out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho__EmptyFailReg, ho__Targets, ho_RegionUnion = null;

            // Local control variables 

            HTuple hv__ErrInsCode = null, hv__ErrInsStr = null;
            HTuple hv_Area = new HTuple(), hv_Row = new HTuple(), hv_Column = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_FailRegs);
            HOperatorSet.GenEmptyObj(out ho__EmptyFailReg);
            HOperatorSet.GenEmptyObj(out ho__Targets);
            HOperatorSet.GenEmptyObj(out ho_RegionUnion);
            try
            {
                //**************************************************************************************************
                //---函数：HTV_Frame_Inspect
                //---作用：Frame表面检测
                //---参数：
                //===图标参数
                //  i_Image：输入图像，Object类型
                //  i_InspectReg：检测区域，在该区域中进行表面污染检测
                //  i_RejectReg：检测得到的拒绝区
                //  o_FailRegs：输出检测结果的错误区域的HobjectVector
                //===控制参数
                //  i_HomMatMod2Img: 输出模板到图像的映射矩阵
                //  i_RegSegParas：区域分割参数
                //  i_CloseSize：闭运算尺寸
                //  i_MinLength：缺陷最小外接矩形半长,为一个向量，针对各重点检测区和非重点检测区分别设置不同参数
                //　 i_MinWidth：缺陷最小外接矩形半宽,为一个向量，针对各重点检测区和非重点检测区分别设置不同参数
                //  i_MinArea：缺陷最小面积,为一个向量，针对各重点检测区和非重点检测区分别设置不同参数
                //  i_SelOperation：形状选择算子and或or等
                //  o_DefectType：输出的检测得到的异常区域的缺陷类型
                //  o_ErrCode: 错误码，代表该算子执行过程中产生的错误，0-代表正常执行，-1-代表异常，-2-代表未执行
                //  o_ErrStr: 错误信息，对各种错误的具体描述
                //**************************************************************************************************

                //初始化
                ho__EmptyFailReg.Dispose();
                HOperatorSet.GenEmptyObj(out ho__EmptyFailReg);
                ho_o_FailRegs.Dispose();
                ho_o_FailRegs = ho__EmptyFailReg.CopyObj(1, -1);
                hv_o_DefectType = new HTuple();
                hv_o_DefectImgIdx = new HTuple();
                hv_o_DefectValue = -2;
                hv_o_ErrCode = -2;
                hv_o_ErrStr = "initializing";

                //区域表面检测
                ho__Targets.Dispose();
                HTV_Region_Surface_Inspect(ho_i_Image, ho_i_InspectReg, ho_i_RegjectReg, out ho__Targets,
                    hv_i_HomMatMod2Img, hvec_i_RegSegParas, hv_i_CloseSize, hv_i_MinLength,
                    hv_i_MinWidth, hv_i_MinArea, hv_i_SelOperation, out hv__ErrInsCode, out hv__ErrInsStr);

                if ((int)(new HTuple(hv__ErrInsCode.TupleLess(0))) != 0)
                {
                    //参数异常
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "Frame Region " + hv__ErrInsStr;
                }
                else if ((int)(new HTuple(hv__ErrInsCode.TupleGreater(0))) != 0)
                {
                    //表面有缺陷
                    hv_o_DefectType = hv_o_DefectType.TupleConcat(30);
                    hv_o_DefectImgIdx = hv_o_DefectImgIdx.TupleConcat(hv_i_ImgIdx);
                    //
                    ho_RegionUnion.Dispose();
                    HOperatorSet.Union1(ho__Targets, out ho_RegionUnion);
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_o_FailRegs, ho_RegionUnion, out ExpTmpOutVar_0);
                        ho_o_FailRegs.Dispose();
                        ho_o_FailRegs = ExpTmpOutVar_0;
                    }
                    HOperatorSet.AreaCenter(ho_RegionUnion, out hv_Area, out hv_Row, out hv_Column);
                    hv_o_DefectValue = hv_Area.Clone();

                    hv_o_ErrCode = 1;
                    hv_o_ErrStr = "Frame Region is dirty!";
                }
                else
                {
                    //表面正常
                    hv_o_ErrCode = 0;
                    hv_o_ErrStr = "Frame Region is clear!";
                }

                ho__EmptyFailReg.Dispose();
                ho__Targets.Dispose();
                ho_RegionUnion.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho__EmptyFailReg.Dispose();
                ho__Targets.Dispose();
                ho_RegionUnion.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public static void HTV_Region_Surface_Inspect(HObject ho_i_Image, HObject ho_i_InspectReg,
            HObject ho_i_RejectReg, out HObject ho_o_TargetRegs, HTuple hv_i_HomMatMod2Img,
            HTupleVector/*{eTupleVector,Dim=1}*/ hvec_i_RegSegParas, HTuple hv_i_CloseSize,
            HTuple hv_i_MinLength, HTuple hv_i_MinWidth, HTuple hv_i_MinArea, HTuple hv_i_SelOperation,
            out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {




            // Local iconic variables 

            HObject ho__InspectReg, ho__CurInspectReg;
            HObject ho__SurfaceImage, ho__SegImage = null, ho__SubReg = null;

            // Local control variables 

            HTuple hv_HomMatSum = null, hv_SegMethod = null;
            HTuple hv_i_ThresholdGray = new HTuple(), hv_i_ThresholdInorOut = new HTuple();
            HTuple hv_i_MorphSize = new HTuple(), hv__ThresholdErrCode = new HTuple();
            HTuple hv__ThresholdErrStr = new HTuple(), hv_i_AdaptiveMethod = new HTuple();
            HTuple hv_i_BlockSize = new HTuple(), hv_i_Contrast = new HTuple();
            HTuple hv_i_LightOrDark = new HTuple(), hv__BlobErrCode = new HTuple();
            HTuple hv__BlobErrStr = new HTuple(), hv_Number = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_TargetRegs);
            HOperatorSet.GenEmptyObj(out ho__InspectReg);
            HOperatorSet.GenEmptyObj(out ho__CurInspectReg);
            HOperatorSet.GenEmptyObj(out ho__SurfaceImage);
            HOperatorSet.GenEmptyObj(out ho__SegImage);
            HOperatorSet.GenEmptyObj(out ho__SubReg);
            //**************************************************************************************************
            //---函数：HTV_Region_Surface_Inspect
            //---作用：桥接区域表面检测
            //---参数：
            //===图标参数
            //  i_Image：输入图像
            //  i_InspectReg：检测区域
            //  i_RejectReg：检测得到的拒绝区
            //  o_TargetRegs：输出目标缺陷区域
            //===控制参数
            //  i_HomMatMod2Img：定位映射矩阵
            //  i_RegSegParas：区域分割参数
            //  i_CloseSize：闭运算尺寸
            //  i_MinLength：缺陷最小外接矩形半长,为一个向量，针对各重点检测区和非重点检测区分别设置不同参数
            //　 i_MinWidth：缺陷最小外接矩形半宽,为一个向量，针对各重点检测区和非重点检测区分别设置不同参数
            //  i_MinArea：缺陷最小面积,为一个向量，针对各重点检测区和非重点检测区分别设置不同参数
            //  i_SelOperation：形状选择算子and或or等
            //  o_ErrCode：错误码，代表该算子执行过程中产生的错误，0-代表正常执行，-1-代表异常，-2-代表未执行
            //  o_ErrStr：错误信息，对各种错误的具体描述
            //**************************************************************************************************

            //初始化
            ho_o_TargetRegs.Dispose();
            HOperatorSet.GenEmptyObj(out ho_o_TargetRegs);
            hv_o_ErrCode = -2;
            hv_o_ErrStr = "initializing";

            //传入映射矩阵有效性测试
            HOperatorSet.TupleSum(hv_i_HomMatMod2Img, out hv_HomMatSum);
            if ((int)(new HTuple(hv_HomMatSum.TupleEqual(-12))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "mapping matrix is invalid!";
                ho__InspectReg.Dispose();
                ho__CurInspectReg.Dispose();
                ho__SurfaceImage.Dispose();
                ho__SegImage.Dispose();
                ho__SubReg.Dispose();

                return;
            }

            //变换检测区域
            ho__InspectReg.Dispose();
            HOperatorSet.AffineTransRegion(ho_i_InspectReg, out ho__InspectReg, hv_i_HomMatMod2Img,
                "nearest_neighbor");
            //去掉免检区(实际检测得到的区域，不需要映射)
            ho__CurInspectReg.Dispose();
            HOperatorSet.Difference(ho__InspectReg, ho_i_RejectReg, out ho__CurInspectReg
                );
            //检测图像
            ho__SurfaceImage.Dispose();
            HOperatorSet.ReduceDomain(ho_i_Image, ho__CurInspectReg, out ho__SurfaceImage
                );

            //阈值分割方法
            hv_SegMethod = hvec_i_RegSegParas[0].T.Clone();

            if ((int)(new HTuple(hv_SegMethod.TupleEqual(1))) != 0)
            {
                //全局设定阈值分割
                hv_i_ThresholdGray = hvec_i_RegSegParas[1].T.Clone();
                hv_i_ThresholdInorOut = hvec_i_RegSegParas[2].T.Clone();
                hv_i_MorphSize = hvec_i_RegSegParas[3].T.Clone();
                //
                ho__SegImage.Dispose();
                HTV_Global_Threshold(ho__SurfaceImage, out ho__SegImage, hv_i_ThresholdGray,
                    hv_i_ThresholdInorOut, hv_i_MorphSize, out hv__ThresholdErrCode, out hv__ThresholdErrStr);

            }
            else if ((int)(new HTuple(hv_SegMethod.TupleEqual(0))) != 0)
            {
                //自适应阈值分割
                hv_i_AdaptiveMethod = hvec_i_RegSegParas[1].T.Clone();
                hv_i_BlockSize = hvec_i_RegSegParas[2].T.Clone();
                hv_i_Contrast = hvec_i_RegSegParas[3].T.Clone();
                hv_i_LightOrDark = hvec_i_RegSegParas[4].T.Clone();
                //
                ho__SegImage.Dispose();
                HTV_Adaptive_Threshold(ho__SurfaceImage, out ho__SegImage, hv_i_AdaptiveMethod,
                    hv_i_BlockSize, hv_i_Contrast, hv_i_LightOrDark, out hv__ThresholdErrCode,
                    out hv__ThresholdErrStr);
            }

            if ((int)(new HTuple(hv__ThresholdErrCode.TupleEqual(0))) != 0)
            {
                //对阈值分割后的目标区域图像进行BLOB分析
                ho__SubReg.Dispose();
                HOperatorSet.GenEmptyObj(out ho__SubReg);
                ho_o_TargetRegs.Dispose();
                HTV_BLOB_Extract(ho__SegImage, ho__CurInspectReg, ho__SubReg, out ho_o_TargetRegs,
                    hv_i_CloseSize, hv_i_MinLength, hv_i_MinWidth, hv_i_MinArea, hv_i_SelOperation,
                    out hv__BlobErrCode, out hv__BlobErrStr);

                //对Blob分析后的结果进行缺陷判断
                HOperatorSet.CountObj(ho_o_TargetRegs, out hv_Number);
                if ((int)((new HTuple(hv__BlobErrCode.TupleEqual(0))).TupleAnd(new HTuple(hv_Number.TupleGreaterEqual(
                    1)))) != 0)
                {
                    hv_o_ErrCode = 1;
                    hv_o_ErrStr = "Surface is dirty";
                    ho__InspectReg.Dispose();
                    ho__CurInspectReg.Dispose();
                    ho__SurfaceImage.Dispose();
                    ho__SegImage.Dispose();
                    ho__SubReg.Dispose();

                    return;
                }
                else if ((int)((new HTuple(hv__BlobErrCode.TupleEqual(0))).TupleAnd(
                    new HTuple(hv_Number.TupleEqual(0)))) != 0)
                {
                    hv_o_ErrCode = 0;
                    hv_o_ErrStr = "Surface is clear";
                    ho__InspectReg.Dispose();
                    ho__CurInspectReg.Dispose();
                    ho__SurfaceImage.Dispose();
                    ho__SegImage.Dispose();
                    ho__SubReg.Dispose();

                    return;
                }
                else
                {
                    //异常处理
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "Fail to Surface Blob_Extract--" + hv__BlobErrStr;
                }

            }
            else
            {
                //异常处理
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "Fail to Surface threshold" + hv__ThresholdErrStr;
                ho__InspectReg.Dispose();
                ho__CurInspectReg.Dispose();
                ho__SurfaceImage.Dispose();
                ho__SegImage.Dispose();
                ho__SubReg.Dispose();

                return;
            }

            ho__InspectReg.Dispose();
            ho__CurInspectReg.Dispose();
            ho__SurfaceImage.Dispose();
            ho__SegImage.Dispose();
            ho__SubReg.Dispose();

            return;

        }

        public static void HTV_Global_Threshold(HObject ho_i_Image, out HObject ho_o_SegImage,
            HTuple hv_i_ThreshGray, HTuple hv_i_ThresholdInorOut, HTuple hv_i_MorphSize,
            out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {




            // Local iconic variables 

            HObject ho__SegImageTmp = null, ho__SegImage0 = null;
            HObject ho__SegImage1 = null;

            // Local control variables 

            HTuple hv_lowThresh = new HTuple(), hv_highThresh = new HTuple();
            HTuple hv_lowThresh0 = new HTuple(), hv_highThresh0 = new HTuple();
            HTuple hv_lowThresh1 = new HTuple(), hv_highThresh1 = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_SegImage);
            HOperatorSet.GenEmptyObj(out ho__SegImageTmp);
            HOperatorSet.GenEmptyObj(out ho__SegImage0);
            HOperatorSet.GenEmptyObj(out ho__SegImage1);
            //************   全局阈值分割+形态学
            //i_Image: 待处理图像，要求时reduce_domain之后的目标区域图像
            //i_RejectRegs: 拒绝区域，即免检区域，一般在检测区域内部容易造成干扰的区域或不感兴趣的区域
            //o_SegImage: 阈值分割后的目标区域图像，常用于接下来的BLOB分析
            //i_ThreshGray: 设定阈值大小
            //i_MorphSize: 形态学核尺寸
            //o_ErrCode: 错误码，代表该算子执行过程中产生的错误，0-代表正常执行，自然数-代表错误类型，-1-代表异常，-2-代表未执行
            //o_ErrStr: 错误信息，对各种错误的具体描述

            //初始化
            ho_o_SegImage.Dispose();
            HOperatorSet.GenEmptyObj(out ho_o_SegImage);
            hv_o_ErrCode = -2;
            hv_o_ErrStr = "initializing";

            //输入参数有效性测试
            if ((int)(new HTuple((new HTuple(hv_i_ThreshGray.TupleLength())).TupleLess(1))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "i_ThreshGray paras illegal";
                ho__SegImageTmp.Dispose();
                ho__SegImage0.Dispose();
                ho__SegImage1.Dispose();

                return;
            }

            if ((int)((new HTuple(hv_i_ThresholdInorOut.TupleNotEqual(0))).TupleAnd(new HTuple(hv_i_ThresholdInorOut.TupleNotEqual(
                1)))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "i_ThresholdInorOut paras illegal";
                ho__SegImageTmp.Dispose();
                ho__SegImage0.Dispose();
                ho__SegImage1.Dispose();

                return;
            }

            if ((int)((new HTuple((new HTuple(hv_i_MorphSize.TupleLength())).TupleLess(1))).TupleOr(
                new HTuple(hv_i_MorphSize.TupleLess(1)))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "the para i_OpeningSize must greater than 0";
                ho__SegImageTmp.Dispose();
                ho__SegImage0.Dispose();
                ho__SegImage1.Dispose();

                return;
            }

            //全局阈值分割
            if ((int)(new HTuple(hv_i_ThresholdInorOut.TupleEqual(0))) != 0)
            {
                //阈值上下限参数
                hv_lowThresh = hv_i_ThreshGray[0];
                hv_highThresh = hv_i_ThreshGray[1];
                //取阈值区间内区域
                ho__SegImageTmp.Dispose();
                HOperatorSet.Threshold(ho_i_Image, out ho__SegImageTmp, hv_lowThresh, hv_highThresh);
            }
            else
            {
                //阈值上下限参数
                hv_lowThresh0 = 0;
                hv_highThresh0 = hv_i_ThreshGray[0];
                hv_lowThresh1 = hv_i_ThreshGray[1];
                hv_highThresh1 = 255;
                //取阈值区间外区域
                ho__SegImage0.Dispose();
                HOperatorSet.Threshold(ho_i_Image, out ho__SegImage0, hv_lowThresh0, hv_highThresh0);
                ho__SegImage1.Dispose();
                HOperatorSet.Threshold(ho_i_Image, out ho__SegImage1, hv_lowThresh1, hv_highThresh1);
                ho__SegImageTmp.Dispose();
                HOperatorSet.Union2(ho__SegImage0, ho__SegImage1, out ho__SegImageTmp);
            }
            //开运算去除孤立点
            ho_o_SegImage.Dispose();
            HOperatorSet.OpeningCircle(ho__SegImageTmp, out ho_o_SegImage, hv_i_MorphSize);

            hv_o_ErrCode = 0;
            hv_o_ErrStr = "adaptive threshold successful";

            ho__SegImageTmp.Dispose();
            ho__SegImage0.Dispose();
            ho__SegImage1.Dispose();

            return;
        }

        public static void HTV_read_frame_model(out HObjectVector/*{eObjectVector,Dim=2}*/ hvec_o_FrameObjs,
            HTuple hv_i_FrameModelPath, out HTupleVector/*{eTupleVector,Dim=2}*/ hvec_o_FrameModels,
            out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {



            // Local iconic variables 

            HObject ho_EmptyObject, ho_Frame_matchReg = null;
            HObject ho_FrameRegion = null, ho_Frame_Region = null, ho_PegRack_Region = null;
            HObject ho_Bridge_Region = null;

            // Local control variables 

            HTuple hv_IsString = null, hv_fileidx = null;
            HTuple hv__Path = new HTuple(), hv__FrameModel = new HTuple();
            HTuple hv__filePath = new HTuple(), hv_FileExists = new HTuple();
            HTuple hv_Locate_ImageIndex = new HTuple(), hv_Model_Type = new HTuple();
            HTuple hv_PosModel = new HTuple(), hv_ItemFiles = new HTuple();
            HTuple hv__PosModelItem = new HTuple(), hv_idx = new HTuple();
            HTuple hv__PosModel = new HTuple(), hv_Task_Enable = new HTuple();
            HTuple hv_Inspect_ImageIndex = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_EmptyObject);
            HOperatorSet.GenEmptyObj(out ho_Frame_matchReg);
            HOperatorSet.GenEmptyObj(out ho_FrameRegion);
            HOperatorSet.GenEmptyObj(out ho_Frame_Region);
            HOperatorSet.GenEmptyObj(out ho_PegRack_Region);
            HOperatorSet.GenEmptyObj(out ho_Bridge_Region);
            hvec_o_FrameObjs = new HObjectVector(2);
            try
            {
                //***************读取所有Frame的模板文件***************************************************************
                //---输入控制参数
                //i_FrameModelPath ：存放Frame模板的路径，一般指Moldes下的文件
                //---输出图标参数
                //o_FrameObjs：Frame检测所需对象集合：二维集合向量
                //---输出控制参数
                //o_FrameModels：Frame检测所需参数集合：一维向量
                //o_ErrCode：错误码，代表该算子在执行过程中产生的错误，0-代表执行正常，-1-代表执行异常，-2-代表未执行
                //o_ErrStr: 错误信息，对各种错误的具体描述
                //************************************************************************************************
                //
                //初始化
                //
                ho_EmptyObject.Dispose();
                HOperatorSet.GenEmptyObj(out ho_EmptyObject);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hvec_o_FrameObjs = dh.Take((
                        dh.Add(new HObjectVector(2)).Insert(0, (dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho_EmptyObject)))))));
                }
                //
                hvec_o_FrameModels = (new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))));
                //
                hv_o_ErrCode = -2;
                hv_o_ErrStr = "initializing!";

                //传入有效性测试
                HOperatorSet.TupleIsString(hv_i_FrameModelPath, out hv_IsString);
                if ((int)((new HTuple(hv_IsString.TupleEqual("false"))).TupleOr(new HTuple((new HTuple(hv_i_FrameModelPath.TupleLength()
                    )).TupleEqual(0)))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "the para i_FrameModelPath must be a string and the para |i_FrameModelPath|                 must greater than 0";
                    ho_EmptyObject.Dispose();
                    ho_Frame_matchReg.Dispose();
                    ho_FrameRegion.Dispose();
                    ho_Frame_Region.Dispose();
                    ho_PegRack_Region.Dispose();
                    ho_Bridge_Region.Dispose();

                    return;
                }

                //读取各检测所需文件

                for (hv_fileidx = 0; (int)hv_fileidx <= (int)((new HTuple(hv_i_FrameModelPath.TupleLength()
                    )) - 1); hv_fileidx = (int)hv_fileidx + 1)
                {
                    //
                    hv__Path = hv_i_FrameModelPath.TupleSelect(hv_fileidx);
                    hv__FrameModel = new HTuple();
                    //---------------------匹配定位区域-----------------------
                    //框架定位匹配区域
                    hv__filePath = hv__Path + "Match_Region.reg";
                    HOperatorSet.FileExists(hv__filePath, out hv_FileExists);
                    if ((int)(hv_FileExists) != 0)
                    {
                        ho_Frame_matchReg.Dispose();
                        HOperatorSet.ReadRegion(out ho_Frame_matchReg, hv__filePath);
                    }
                    else
                    {
                        ho_Frame_matchReg.Dispose();
                        HOperatorSet.GenEmptyObj(out ho_Frame_matchReg);
                    }
                    //框架所在区域
                    hv__filePath = hv__Path + "FrameRegion.reg";
                    HOperatorSet.FileExists(hv__filePath, out hv_FileExists);
                    if ((int)(hv_FileExists) != 0)
                    {
                        ho_FrameRegion.Dispose();
                        HOperatorSet.ReadRegion(out ho_FrameRegion, hv__filePath);
                    }
                    else
                    {
                        ho_FrameRegion.Dispose();
                        HOperatorSet.GenEmptyObj(out ho_FrameRegion);
                    }
                    //----------------表面检测区域-----------------------------
                    //框架检测区
                    hv__filePath = hv__Path + "Frame_Region.reg";
                    HOperatorSet.FileExists(hv__filePath, out hv_FileExists);
                    if ((int)(hv_FileExists) != 0)
                    {
                        ho_Frame_Region.Dispose();
                        HOperatorSet.ReadRegion(out ho_Frame_Region, hv__filePath);
                    }
                    else
                    {
                        ho_Frame_Region.Dispose();
                        HOperatorSet.GenEmptyObj(out ho_Frame_Region);
                    }
                    //钉架检测区
                    hv__filePath = hv__Path + "PegRack_Region.reg";
                    HOperatorSet.FileExists(hv__filePath, out hv_FileExists);
                    if ((int)(hv_FileExists) != 0)
                    {
                        ho_PegRack_Region.Dispose();
                        HOperatorSet.ReadRegion(out ho_PegRack_Region, hv__filePath);
                    }
                    else
                    {
                        ho_PegRack_Region.Dispose();
                        HOperatorSet.GenEmptyObj(out ho_PegRack_Region);
                    }
                    //桥接检测区
                    hv__filePath = hv__Path + "Bridge_Region.reg";
                    HOperatorSet.FileExists(hv__filePath, out hv_FileExists);
                    if ((int)(hv_FileExists) != 0)
                    {
                        ho_Bridge_Region.Dispose();
                        HOperatorSet.ReadRegion(out ho_Bridge_Region, hv__filePath);
                    }
                    else
                    {
                        ho_Bridge_Region.Dispose();
                        HOperatorSet.GenEmptyObj(out ho_Bridge_Region);
                    }
                    //------------------------------------------------------------
                    //
                    //整合Frame_Object对象
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hvec_o_FrameObjs[hv_fileidx] = dh.Take((((((
                            dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho_Frame_matchReg)))).Insert(
                            1, dh.Add(new HObjectVector(ho_FrameRegion)))).Insert(2, dh.Add(new HObjectVector(ho_Frame_Region)))).Insert(
                            3, dh.Add(new HObjectVector(ho_PegRack_Region)))).Insert(4, dh.Add(new HObjectVector(ho_Bridge_Region)))));
                    }
                    //
                    //读取制作模板所用图序
                    hv__filePath = hv__Path + "Image_Index.tup";
                    HOperatorSet.ReadTuple(hv__filePath, out hv_Locate_ImageIndex);
                    //
                    //读取定位模板参数
                    hv__filePath = hv__Path + "Model_Type.tup";
                    HOperatorSet.ReadTuple(hv__filePath, out hv_Model_Type);
                    //
                    hv_PosModel = new HTuple();
                    //确定posmodel的个数
                    HOperatorSet.ListFiles(hv__Path, "files", out hv_ItemFiles);
                    HOperatorSet.TupleRegexpSelect(hv_ItemFiles, "PosModel.*", out hv__PosModelItem);
                    for (hv_idx = 0; (int)hv_idx <= (int)((new HTuple(hv__PosModelItem.TupleLength()
                        )) - 1); hv_idx = (int)hv_idx + 1)
                    {
                        //
                        hv__filePath = hv__PosModelItem.TupleSelect(hv_idx);
                        //
                        if ((int)(new HTuple(hv_Model_Type.TupleEqual("ncc"))) != 0)
                        {
                            HOperatorSet.ReadNccModel(hv__filePath, out hv__PosModel);
                            hv_PosModel = hv_PosModel.TupleConcat(hv__PosModel);
                        }
                        else if ((int)(new HTuple(hv_Model_Type.TupleEqual("shape"))) != 0)
                        {
                            HOperatorSet.ReadShapeModel(hv__filePath, out hv__PosModel);
                            hv_PosModel = hv_PosModel.TupleConcat(hv__PosModel);
                        }
                    }
                    //
                    //读取检测任务使能
                    hv__filePath = hv__Path + "TaskEnable.tup";
                    HOperatorSet.FileExists(hv__filePath, out hv_FileExists);
                    if ((int)(hv_FileExists) != 0)
                    {
                        HOperatorSet.ReadTuple(hv__filePath, out hv_Task_Enable);
                    }
                    else
                    {
                        hv_Task_Enable = new HTuple();
                        hv_Task_Enable[0] = 0;
                        hv_Task_Enable[1] = 0;
                        hv_Task_Enable[2] = 0;
                    }
                    //
                    //读取制作模板所用图序
                    hv__filePath = hv__Path + "Inspect_ImageIndex.tup";
                    HOperatorSet.FileExists(hv__filePath, out hv_FileExists);
                    if ((int)(hv_FileExists) != 0)
                    {
                        HOperatorSet.ReadTuple(hv__filePath, out hv_Inspect_ImageIndex);
                    }
                    else
                    {
                        hv_Inspect_ImageIndex = new HTuple();
                        hv_Inspect_ImageIndex[0] = 1;
                        hv_Inspect_ImageIndex[1] = 1;
                        hv_Inspect_ImageIndex[2] = 1;
                    }
                    //
                    //整合Frame_Models模板参数
                    hvec_o_FrameModels[hv_fileidx] = (((((new HTupleVector(1).Insert(0, new HTupleVector(hv_Locate_ImageIndex))).Insert(
                        1, new HTupleVector(hv_Model_Type))).Insert(2, new HTupleVector(hv_PosModel))).Insert(
                        3, new HTupleVector(hv_Task_Enable))).Insert(4, new HTupleVector(hv_Inspect_ImageIndex)));
                }

                hv_o_ErrCode = 0;
                hv_o_ErrStr = "read Frame models successful!";
                ho_EmptyObject.Dispose();
                ho_Frame_matchReg.Dispose();
                ho_FrameRegion.Dispose();
                ho_Frame_Region.Dispose();
                ho_PegRack_Region.Dispose();
                ho_Bridge_Region.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_EmptyObject.Dispose();
                ho_Frame_matchReg.Dispose();
                ho_FrameRegion.Dispose();
                ho_Frame_Region.Dispose();
                ho_PegRack_Region.Dispose();
                ho_Bridge_Region.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public static void HTV_read_cutreg_model(HTuple hv_i_CutRegModelPath, HTuple hv_i_InspectItemNum,
            out HTupleVector/*{eTupleVector,Dim=1}*/ hvec_o_CutRegModels, out HTuple hv_o_ErrCode,
            out HTuple hv_o_ErrStr)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_IsString = null, hv__filePath = null;
            HTuple hv_FileExists = null, hv_CutRegionParameters = new HTuple();
            HTuple hv_objNum = null, hv_a = null, hv_icObjNum = null;
            HTuple hv__IcdilationSize = null, hv_icIdx = null, hv_dilationSize = new HTuple();
            HTuple hv_epoxyObjNum = null, hv__EpoxydilationSize = null;
            HTuple hv_epoxyIdx = null, hv_bondObjNum = null, hv__BonddilationSize = null;
            HTuple hv_bondIdx = null, hv_wireObjNum = null, hv__WiredilationSize = null;
            HTuple hv_wireIdx = null;
            // Initialize local and output iconic variables 
            //***************读取CutRegion的模板文件***************************************************************
            //---输入控制参数
            //i_CutRegModelPath ：存放CutRegion模板的路径，一般指Moldes下的文件
            //i_InspectItemNum ：各检测项目需要检测数量集合：一维数组
            //---输出控制参数
            //o_CutRegModels：CutRegion所需的膨胀因子参数集合：一维向量
            //o_ErrCode：错误码，代表该算子在执行过程中产生的错误，0-代表执行正常，-1-代表执行异常，-2-代表未执行
            //o_ErrStr: 错误信息，对各种错误的具体描述
            //************************************************************************************************
            //
            //初始化
            hvec_o_CutRegModels = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())));
            //
            hv_o_ErrCode = -2;
            hv_o_ErrStr = "initializing!";
            //传入有效性测试
            HOperatorSet.TupleIsString(hv_i_CutRegModelPath, out hv_IsString);
            if ((int)((new HTuple(hv_IsString.TupleEqual("false"))).TupleOr(new HTuple((new HTuple(hv_i_CutRegModelPath.TupleLength()
                )).TupleEqual(0)))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "the para i_CutRegModelPath must be a string and the para |i_CutRegModelPath|                 must greater than 0";

                return;
            }

            //读取文件下的膨胀因子参数
            hv__filePath = hv_i_CutRegModelPath + "CutRegionParameters.tup";
            HOperatorSet.FileExists(hv__filePath, out hv_FileExists);
            if ((int)(hv_FileExists) != 0)
            {
                HOperatorSet.ReadTuple(hv__filePath, out hv_CutRegionParameters);
            }
            else
            {

                return;
            }

            //检查参数有效性
            hv_objNum = (((hv_i_InspectItemNum.TupleSelect(1)) + (hv_i_InspectItemNum.TupleSelect(
                2))) + (hv_i_InspectItemNum.TupleSelect(3))) + (hv_i_InspectItemNum.TupleSelect(
                4));
            if ((int)(new HTuple((new HTuple(hv_CutRegionParameters.TupleLength())).TupleNotEqual(
                hv_objNum))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "the para CutRegionParameters is error ";

                return;
            }
            //
            //解析各项膨胀因子
            hv_a = 0;
            //ic数量
            hv_icObjNum = hv_i_InspectItemNum[1];
            //
            hv__IcdilationSize = new HTuple();
            HTuple end_val46 = hv_icObjNum - 1;
            HTuple step_val46 = 1;
            for (hv_icIdx = 0; hv_icIdx.Continue(end_val46, step_val46); hv_icIdx = hv_icIdx.TupleAdd(step_val46))
            {
                hv_dilationSize = hv_CutRegionParameters.TupleSelect(hv_icIdx);
                hv__IcdilationSize = hv__IcdilationSize.TupleConcat(hv_dilationSize);
            }
            hvec_o_CutRegModels[0] = new HTupleVector(hv__IcdilationSize).Clone();
            //
            hv_a = hv_a + hv_icObjNum;
            //
            //epoxy数量
            hv_epoxyObjNum = hv_i_InspectItemNum[2];
            //
            hv__EpoxydilationSize = new HTuple();
            HTuple end_val58 = hv_epoxyObjNum - 1;
            HTuple step_val58 = 1;
            for (hv_epoxyIdx = 0; hv_epoxyIdx.Continue(end_val58, step_val58); hv_epoxyIdx = hv_epoxyIdx.TupleAdd(step_val58))
            {
                hv_dilationSize = hv_CutRegionParameters.TupleSelect(hv_epoxyIdx + hv_a);
                hv__EpoxydilationSize = hv__EpoxydilationSize.TupleConcat(hv_dilationSize);
            }
            hvec_o_CutRegModels[1] = new HTupleVector(hv__EpoxydilationSize).Clone();
            //
            hv_a = hv_a + hv_epoxyObjNum;
            //
            //bond数量
            hv_bondObjNum = hv_i_InspectItemNum[3];
            //
            hv__BonddilationSize = new HTuple();
            HTuple end_val70 = hv_bondObjNum - 1;
            HTuple step_val70 = 1;
            for (hv_bondIdx = 0; hv_bondIdx.Continue(end_val70, step_val70); hv_bondIdx = hv_bondIdx.TupleAdd(step_val70))
            {
                hv_dilationSize = hv_CutRegionParameters.TupleSelect(hv_bondIdx + hv_a);
                hv__BonddilationSize = hv__BonddilationSize.TupleConcat(hv_dilationSize);
            }
            hvec_o_CutRegModels[2] = new HTupleVector(hv__BonddilationSize).Clone();
            //
            hv_a = hv_a + hv_bondObjNum;
            //
            //wire数量
            hv_wireObjNum = hv_i_InspectItemNum[4];
            //
            hv__WiredilationSize = new HTuple();
            HTuple end_val82 = hv_wireObjNum - 1;
            HTuple step_val82 = 1;
            for (hv_wireIdx = 0; hv_wireIdx.Continue(end_val82, step_val82); hv_wireIdx = hv_wireIdx.TupleAdd(step_val82))
            {
                hv_dilationSize = hv_CutRegionParameters.TupleSelect(hv_wireIdx + hv_a);
                hv__WiredilationSize = hv__WiredilationSize.TupleConcat(hv_dilationSize);
            }
            hvec_o_CutRegModels[3] = new HTupleVector(hv__WiredilationSize).Clone();
            //

            hv_o_ErrCode = 0;
            hv_o_ErrStr = "read CutRegion models successful!";

            return;
        }

        public static void JSCC_AOI_Inspect_Gen_CutReg_Unit(HObject ho_i_Imgs, HObject ho_i_SearchReg,
            HObjectVector/*{eObjectVector,Dim=2}*/ hvec_i_FrameObjs, HObjectVector/*{eObjectVector,Dim=2}*/ hvec_i_IcObjs,
            HObjectVector/*{eObjectVector,Dim=2}*/ hvec_i_EpoxyObjs, HObjectVector/*{eObjectVector,Dim=2}*/ hvec_i_BondObjs,
            HObjectVector/*{eObjectVector,Dim=2}*/ hvec_i_WireObjs, out HObject ho_o_RejectReg,
            HTuple hv_i_InspectItemNum, HTupleVector/*{eTupleVector,Dim=3}*/ hvec_i_FrameInspectParas,
            HTupleVector/*{eTupleVector,Dim=3}*/ hvec_i_IcInspectParas, HTupleVector/*{eTupleVector,Dim=4}*/ hvec_i_EpoxyInspectParas,
            HTupleVector/*{eTupleVector,Dim=4}*/ hvec_i_BondInspectParas, HTupleVector/*{eTupleVector,Dim=4}*/ hvec_i_WireInspectParas,
            HTupleVector/*{eTupleVector,Dim=1}*/ hvec_i_CutRegionParas, out HTupleVector/*{eTupleVector,Dim=1}*/ hvec_o_FrameHomMat2D,
            out HTupleVector/*{eTupleVector,Dim=1}*/ hvec_o_IcHomMat2D, out HTuple hv_o_DefectType,
            out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {




            // Local iconic variables 

            HObject ho__RejectRegUnion;

            HObjectVector hvec__frameLocFailRegs = new HObjectVector(2);
            HObjectVector hvec__icFailRegs = new HObjectVector(2), hvec__Ics = new HObjectVector(1);
            HObjectVector hvec__Epoxys = new HObjectVector(1), hvec_o_epoxyFailRegs = new HObjectVector(2);
            HObjectVector hvec__BallContours = new HObjectVector(1), hvec_o_PadRegions = new HObjectVector(1);
            HObjectVector hvec__bondFailRegs = new HObjectVector(2), hvec__WireContours = new HObjectVector(1);
            HObjectVector hvec_o_wireFailRegs = new HObjectVector(2), hvec__RejectRegs = new HObjectVector(1);

            // Local control variables 

            HTuple hv_o_DefectImgIdx = null, hv_objIdx = null;
            HTuple hv_i_frameObjNum = null, hv__frameErrCode = null;
            HTuple hv__frameErrStr = null, hv_i_icObjNum = null, hv__icErrCode = null;
            HTuple hv__icErrStr = null, hv_i_epoxyObjNum = null, hv__epoxyErrCode = null;
            HTuple hv__epoxyErrStr = null, hv_i_BondObjNum = null;
            HTuple hv__bondErrCode = null, hv__bondErrStr = null, hv_i_WireObjNum = null;
            HTuple hv__wireErrCode = null, hv__wireErrStr = null, hv__editErrCode = null;
            HTuple hv__editErrStr = null;

            HTupleVector hvec_o_DefectValueFrame = new HTupleVector(4);
            HTupleVector hvec_o_DefectValueIc = new HTupleVector(4), hvec_o_DefectValueEpoxy = new HTupleVector(4);
            HTupleVector hvec_o_DefectValueBond = new HTupleVector(4), hvec_o_DefectValueWire = new HTupleVector(4);
            HTupleVector hvec__frameLocPara = new HTupleVector(1), hvec__frameHomMat2D = new HTupleVector(1);
            HTupleVector hvec__frameLocDefectType = new HTupleVector(2), hvec__LocDefectValueFrame = new HTupleVector(3);
            HTupleVector hvec__frameLocDefectImgIdx = new HTupleVector(2);
            HTupleVector hvec__LocRefValueFrame = new HTupleVector(3), hvec__icHomMat2D = new HTupleVector(1);
            HTupleVector hvec__icDefectType = new HTupleVector(2), hvec__DefectValueIc = new HTupleVector(4);
            HTupleVector hvec__icDefectImgIdx = new HTupleVector(2), hvec_o_RefValueIc = new HTupleVector(4);
            HTupleVector hvec__epoxyDefectType = new HTupleVector(2), hvec__epoxyDefectImgIdx = new HTupleVector(2);
            HTupleVector hvec_o_RefValueEpoxy = new HTupleVector(4), hvec__BallType = new HTupleVector(1);
            HTupleVector hvec__bondDefectType = new HTupleVector(2), hvec__DefectValueBond = new HTupleVector(4);
            HTupleVector hvec__bondDefectImgIdx = new HTupleVector(2), hvec__RefValueBond = new HTupleVector(4);
            HTupleVector hvec__wireDefectType = new HTupleVector(2), hvec__wireDefectImgIdx = new HTupleVector(2);
            HTupleVector hvec_o_RefValueWire = new HTupleVector(4);
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_RejectReg);
            HOperatorSet.GenEmptyObj(out ho__RejectRegUnion);
            try
            {
                //**************************************************************************************************
                //---函数：JSCC_AOI_Inspect_Gen_CutReg_Unit
                //---作用：执行各检测项,获取CutReg
                //---参数：
                //===图标参数
                //  i_Imgs：检测所需图像集合
                //  i_SearchRegs：搜索区
                //  i_FrameObjs：Frame检测区域对象
                //  i_IcObjs：Ic检测区域对象
                //  i_EpoxyObjs：Epoxy检测区域对象
                //  i_BondObjs：Bond检测区域对象
                //  i_WireObjs：Wire检测区域对象
                //  o_RejectReg：免检区
                //===控制参数
                //  i_InspectItemNum：各检测项数目
                //  i_FrameInspectParas：Frame检测参数
                //  i_IcInspectParas：Ic检测参数
                //  i_EpoxyInspectParas：Epoxy检测参数
                //  i_BondInspectParas：Bond检测参数
                //  i_WireInspectParas：Wire检测参数
                //  i_CutRegionParas：膨胀参数
                //  o_FrameHomMat2D：Frame定位映射矩阵
                //  o_IcHomMat2D：IC定位映射矩阵
                //  o_DefectType：输出的检测得到的异常区域的缺陷类型
                //  o_ErrCode：错误码
                //  o_ErrStr：错误信息
                //**************************************************************************************************

                //初始化
                hvec_o_FrameHomMat2D = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())));
                hvec_o_IcHomMat2D = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())));
                hv_o_DefectType = new HTuple();
                hv_o_DefectImgIdx = new HTuple();
                hv_o_ErrCode = -2;
                hv_o_ErrStr = "initializing";
                //
                //Frame检测结果初值
                //[定位Score, frame检测缺陷信息,  PegRack检测缺陷信息,  Bridge检测缺陷信息]
                hvec_o_DefectValueFrame = (new HTupleVector(4).Insert(0, (new HTupleVector(3).Insert(0, (
                    new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))))));
                HTuple end_val39 = (hv_i_InspectItemNum.TupleSelect(
                    0)) - 1;
                HTuple step_val39 = 1;
                for (hv_objIdx = 0; hv_objIdx.Continue(end_val39, step_val39); hv_objIdx = hv_objIdx.TupleAdd(step_val39))
                {
                    hvec_o_DefectValueFrame[hv_objIdx] = (new HTupleVector(3).Insert(0, ((((new HTupleVector(2).Insert(0, (
                        new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(-2)))))).Insert(
                        1, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple()))))).Insert(
                        2, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple()))))).Insert(
                        3, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))));
                }

                //Ic检测结果初值
                //[定位Score, IC偏移量, IC旋转角度, 重点区异物信息, 崩边区异物信息]
                hvec_o_DefectValueIc = (new HTupleVector(4).Insert(0, (new HTupleVector(3).Insert(0, (
                    new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))))));
                HTuple end_val46 = (hv_i_InspectItemNum.TupleSelect(
                    1)) - 1;
                HTuple step_val46 = 1;
                for (hv_objIdx = 0; hv_objIdx.Continue(end_val46, step_val46); hv_objIdx = hv_objIdx.TupleAdd(step_val46))
                {
                    hvec_o_DefectValueIc[hv_objIdx] = (new HTupleVector(3).Insert(0, (((((new HTupleVector(2).Insert(0, (
                        new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(-2)))))).Insert(
                        1, (new HTupleVector(1).Insert(0, new HTupleVector((new HTuple(-2)).TupleConcat(
                        -2)))))).Insert(2, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(-2)))))).Insert(
                        3, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple()))))).Insert(
                        4, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))));
                }

                //Epoxy检测结果初值
                //[银胶区长度比, 银胶区高度]
                hvec_o_DefectValueEpoxy = (new HTupleVector(4).Insert(0, (new HTupleVector(3).Insert(0, (
                    new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))))));
                HTuple end_val53 = (hv_i_InspectItemNum.TupleSelect(
                    2)) - 1;
                HTuple step_val53 = 1;
                for (hv_objIdx = 0; hv_objIdx.Continue(end_val53, step_val53); hv_objIdx = hv_objIdx.TupleAdd(step_val53))
                {
                    hvec_o_DefectValueEpoxy[hv_objIdx] = (new HTupleVector(3).Insert(0, (new HTupleVector(2).Insert(0, (
                        new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))));
                }

                //Bond检测结果初值
                //[焊球半径,偏移量, 尾丝长, 焊盘异物信息]
                hvec_o_DefectValueBond = (new HTupleVector(4).Insert(0, (new HTupleVector(3).Insert(0, (
                    new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))))));
                HTuple end_val60 = (hv_i_InspectItemNum.TupleSelect(
                    3)) - 1;
                HTuple step_val60 = 1;
                for (hv_objIdx = 0; hv_objIdx.Continue(end_val60, step_val60); hv_objIdx = hv_objIdx.TupleAdd(step_val60))
                {
                    hvec_o_DefectValueBond[hv_objIdx] = (new HTupleVector(3).Insert(0, (new HTupleVector(2).Insert(0, (
                        new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))));
                }

                //Wire检测结果初值
                //[断线距离]
                hvec_o_DefectValueWire = (new HTupleVector(4).Insert(0, (new HTupleVector(3).Insert(0, (
                    new HTupleVector(2).Insert(0, (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))))));
                HTuple end_val67 = (hv_i_InspectItemNum.TupleSelect(
                    4)) - 1;
                HTuple step_val67 = 1;
                for (hv_objIdx = 0; hv_objIdx.Continue(end_val67, step_val67); hv_objIdx = hv_objIdx.TupleAdd(step_val67))
                {
                    hvec_o_DefectValueWire[hv_objIdx] = (new HTupleVector(3).Insert(0, (new HTupleVector(2).Insert(0, (
                        new HTupleVector(1).Insert(0, new HTupleVector(new HTuple())))))));
                }

                //
                ho_o_RejectReg.Dispose();
                HOperatorSet.GenEmptyObj(out ho_o_RejectReg);

                //
                //***************************对Die区域进行分区域检测****************************
                //
                //--------Frame定位
                //
                //检测frame项目数量

                hv_i_frameObjNum = hv_i_InspectItemNum[0];
                //
                hvec__frameLocFailRegs.Dispose();
                HTV_frames_locate(ho_i_Imgs, ho_i_SearchReg, hvec_i_FrameObjs, out hvec__frameLocFailRegs,
                    hv_i_frameObjNum, hvec_i_FrameInspectParas, out hvec__frameLocPara, out hvec__frameHomMat2D,
                    out hvec__frameLocDefectType, out hvec__LocDefectValueFrame, out hvec__frameLocDefectImgIdx,
                    out hvec__LocRefValueFrame, out hv__frameErrCode, out hv__frameErrStr);

                //输出Frame定位映射矩阵
                hvec_o_FrameHomMat2D = hvec__frameHomMat2D.Clone();
                //
                //--------Ic检测：Ic定位，表面，旋转、偏移检测
                //
                //检测ic项目数量
                hv_i_icObjNum = hv_i_InspectItemNum[1];
                //
                hvec__icFailRegs.Dispose(); hvec__Ics.Dispose();
                HTV_ics_inspect(ho_i_Imgs, hvec_i_IcObjs, out hvec__icFailRegs, out hvec__Ics,
                    hv_i_icObjNum, hvec__frameHomMat2D, hvec__frameLocPara, hvec_i_IcInspectParas,
                    out hvec__icHomMat2D, out hvec__icDefectType, out hvec__DefectValueIc,
                    out hvec__icDefectImgIdx, out hvec_o_RefValueIc, out hv__icErrCode, out hv__icErrStr);

                //输出Ic定位映射矩阵
                hvec_o_IcHomMat2D = hvec__icHomMat2D.Clone();
                //
                //-------—-Epoxy检测：是否有银胶
                //
                //检测epoxy项目数量
                hv_i_epoxyObjNum = hv_i_InspectItemNum[2];
                //
                hvec__Epoxys.Dispose(); hvec_o_epoxyFailRegs.Dispose();
                HTV_epoxys_inspect(ho_i_Imgs, hvec_i_EpoxyObjs, out hvec__Epoxys, out hvec_o_epoxyFailRegs,
                    hv_i_epoxyObjNum, hvec__icHomMat2D, hvec_i_EpoxyInspectParas, out hvec__epoxyDefectType,
                    out hvec_o_DefectValueEpoxy, out hvec__epoxyDefectImgIdx, out hvec_o_RefValueEpoxy,
                    out hv__epoxyErrCode, out hv__epoxyErrStr);

                //
                //---------Bond检测：Bond定位
                //
                //检测bond项目数量
                hv_i_BondObjNum = hv_i_InspectItemNum[3];
                //
                hvec__BallContours.Dispose(); hvec_o_PadRegions.Dispose(); hvec__bondFailRegs.Dispose();
                HTV_bonds_inspect(ho_i_Imgs, hvec_i_BondObjs, out hvec__BallContours, out hvec_o_PadRegions,
                    out hvec__bondFailRegs, hv_i_BondObjNum, hvec__frameHomMat2D, hvec__icHomMat2D,
                    hvec_i_BondInspectParas, out hvec__BallType, out hvec__bondDefectType,
                    out hvec__DefectValueBond, out hvec__bondDefectImgIdx, out hvec__RefValueBond,
                    out hv__bondErrCode, out hv__bondErrStr);

                //
                //---------Wire检测：断线、弯曲线，双丝、塌丝
                //检测wire项目数量
                hv_i_WireObjNum = hv_i_InspectItemNum[4];
                //
                hvec__WireContours.Dispose(); hvec_o_wireFailRegs.Dispose();
                HTV_wires_inspect(ho_i_Imgs, hvec_i_WireObjs, hvec__BallContours, out hvec__WireContours,
                    out hvec_o_wireFailRegs, hv_i_WireObjNum, hvec__frameHomMat2D, hvec__icHomMat2D,
                    hvec_i_WireInspectParas, hvec__BallType, out hvec__wireDefectType, out hvec_o_DefectValueWire,
                    out hvec__wireDefectImgIdx, out hvec_o_RefValueWire, out hv__wireErrCode,
                    out hv__wireErrStr);

                //
                //-------- CutReg获取
                //
                ho__RejectRegUnion.Dispose(); hvec__RejectRegs.Dispose();
                HTV_gen_inspect_cutReg(hvec__Ics, hvec__Epoxys, hvec__BallContours, hvec__WireContours,
                    out ho__RejectRegUnion, out hvec__RejectRegs, hvec_i_CutRegionParas, out hv__editErrCode,
                    out hv__editErrStr);

                ho_o_RejectReg.Dispose();
                ho_o_RejectReg = ho__RejectRegUnion.CopyObj(1, -1);

                //
                hv_o_ErrCode = 0;
                hv_o_ErrStr = "inspect all items suceessful";
                ho__RejectRegUnion.Dispose();
                hvec__frameLocFailRegs.Dispose();
                hvec__icFailRegs.Dispose();
                hvec__Ics.Dispose();
                hvec__Epoxys.Dispose();
                hvec_o_epoxyFailRegs.Dispose();
                hvec__BallContours.Dispose();
                hvec_o_PadRegions.Dispose();
                hvec__bondFailRegs.Dispose();
                hvec__WireContours.Dispose();
                hvec_o_wireFailRegs.Dispose();
                hvec__RejectRegs.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho__RejectRegUnion.Dispose();
                hvec__frameLocFailRegs.Dispose();
                hvec__icFailRegs.Dispose();
                hvec__Ics.Dispose();
                hvec__Epoxys.Dispose();
                hvec_o_epoxyFailRegs.Dispose();
                hvec__BallContours.Dispose();
                hvec_o_PadRegions.Dispose();
                hvec__bondFailRegs.Dispose();
                hvec__WireContours.Dispose();
                hvec_o_wireFailRegs.Dispose();
                hvec__RejectRegs.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public static void HTV_Gen_HomMat_onWhat(HTuple hv_i_RegOnWhat, HTupleVector/*{eTupleVector,Dim=1}*/ hvec_i_RefHomMatMod2ImgFrmae,
            HTupleVector/*{eTupleVector,Dim=1}*/ hvec_i_RefHomMatMod2ImgIc, out HTuple hv_o_DstHomMat2D,
            out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_ObjIdxStr = null, hv_ObjIdx = new HTuple();
            // Initialize local and output iconic variables 
            //**************************************************************************************************
            //---函数：HTV_Gen_HomMat_onWhat
            //---作用：获取onwhat对应映射矩阵
            //---参数：
            //===图标参数
            //===控制参数
            //  i_RegOnWhat：区域在哪个对象上
            //  i_RefHomMatMod2ImgFrame：Frame映射矩阵集合
            //  i_RefHomMatMod2ImgIc：Ic映射矩阵集合
            //  o_DstHomMat2D：输出目标映射矩阵
            //  o_ErrCode：错误码
            //  o_ErrStr：错误信息
            //***************************************************************************

            //初始化
            hv_o_DstHomMat2D = new HTuple();
            hv_o_DstHomMat2D[0] = -2;
            hv_o_DstHomMat2D[1] = -2;
            hv_o_DstHomMat2D[2] = -2;
            hv_o_DstHomMat2D[3] = -2;
            hv_o_DstHomMat2D[4] = -2;
            hv_o_DstHomMat2D[5] = -2;
            hv_o_ErrCode = -2;
            hv_o_ErrStr = "initializing";

            HOperatorSet.TupleRegexpMatch(hv_i_RegOnWhat, "Frame(.*)", out hv_ObjIdxStr);
            if ((int)(new HTuple(hv_ObjIdxStr.TupleNotEqual(""))) != 0)
            {
                HOperatorSet.TupleNumber(hv_ObjIdxStr, out hv_ObjIdx);
                hv_ObjIdx = hv_ObjIdx - 1;
                hv_o_DstHomMat2D = hvec_i_RefHomMatMod2ImgFrmae[hv_ObjIdx].T.Clone();
            }
            else
            {
                HOperatorSet.TupleRegexpMatch(hv_i_RegOnWhat, "IC(.*)", out hv_ObjIdxStr);
                if ((int)(new HTuple(hv_ObjIdxStr.TupleNotEqual(""))) != 0)
                {
                    HOperatorSet.TupleNumber(hv_ObjIdxStr, out hv_ObjIdx);
                    hv_ObjIdx = hv_ObjIdx - 1;
                    hv_o_DstHomMat2D = hvec_i_RefHomMatMod2ImgIc[hv_ObjIdx].T.Clone();
                }
                else
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "no mapping matrix";

                    return;
                }
            }

            hv_o_ErrCode = 0;
            hv_o_ErrStr = "match matrix success";

            return;
        }

        public static void HTV_gen_inspect_cutReg(HObjectVector/*{eObjectVector,Dim=1}*/ hvec_i_IcInspectRegs,
            HObjectVector/*{eObjectVector,Dim=1}*/ hvec_i_EpoxyRegs, HObjectVector/*{eObjectVector,Dim=1}*/ hvec_i_BondRegs,
            HObjectVector/*{eObjectVector,Dim=1}*/ hvec_i_WireContours, out HObject ho_o_AvoidReg,
            out HObjectVector/*{eObjectVector,Dim=1}*/ hvec_o_RejectRegs, HTupleVector/*{eTupleVector,Dim=1}*/ hvec_i_CutRegionParas,
            out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_EmptyObj, ho_IcDilateReg, ho_EpoxyDilateReg;
            HObject ho_BondDilateReg, ho_WireDilateReg, ho_RejectRegs;

            // Local control variables 

            HTuple hv__IcDilationSize = null, hv__EpoxyDilationSize = null;
            HTuple hv__BondDilationSize = null, hv__WireDilationSize = null;
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_AvoidReg);
            HOperatorSet.GenEmptyObj(out ho_EmptyObj);
            HOperatorSet.GenEmptyObj(out ho_IcDilateReg);
            HOperatorSet.GenEmptyObj(out ho_EpoxyDilateReg);
            HOperatorSet.GenEmptyObj(out ho_BondDilateReg);
            HOperatorSet.GenEmptyObj(out ho_WireDilateReg);
            HOperatorSet.GenEmptyObj(out ho_RejectRegs);
            hvec_o_RejectRegs = new HObjectVector(1);
            try
            {
                //**************************************************************************************************
                //---函数：HTV_gen_inspect_cutReg
                //---作用：获取表面检测免检区
                //---参数：
                //===图标参数
                //  i_IcInspectRegs：Ic检测区
                //  i_EpoxyRegs：Epoxy检测区
                //  i_BondRegs：Bond检测区
                //  i_WireContours：Wire检测区
                //  o_AvoidReg：免检区域
                //  o_RejectRegs：免检区域向量
                //===控制参数
                //  i_FrameNum：框架数目
                //  i_CutRegionParas：膨胀系数
                //  o_ErrCode：错误码
                //  o_ErrStr：错误信息
                //**************************************************************************************************
                //
                //初始化
                hv_o_ErrCode = -2;
                hv_o_ErrStr = "initializing";

                ho_EmptyObj.Dispose();
                HOperatorSet.GenEmptyObj(out ho_EmptyObj);
                ho_o_AvoidReg.Dispose();
                ho_o_AvoidReg = ho_EmptyObj.CopyObj(1, -1);
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hvec_o_RejectRegs = dh.Take((
                        dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho_EmptyObj)))));
                }

                //输入合法性测试
                if ((int)(new HTuple((new HTuple(hvec_i_CutRegionParas.Length)).TupleNotEqual(
                    4))) != 0)
                {

                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "i_CutRegionParas is error ";

                    ho_EmptyObj.Dispose();
                    ho_IcDilateReg.Dispose();
                    ho_EpoxyDilateReg.Dispose();
                    ho_BondDilateReg.Dispose();
                    ho_WireDilateReg.Dispose();
                    ho_RejectRegs.Dispose();

                    return;
                }

                //膨胀参数
                hv__IcDilationSize = hvec_i_CutRegionParas[0].T.Clone();
                hv__EpoxyDilationSize = hvec_i_CutRegionParas[1].T.Clone();
                hv__BondDilationSize = hvec_i_CutRegionParas[2].T.Clone();
                hv__WireDilationSize = hvec_i_CutRegionParas[3].T.Clone();
                //
                //--------- 膨胀各免检区
                //IC检测区
                ho_IcDilateReg.Dispose();
                HTV_dilation_reject_region(hvec_i_IcInspectRegs, out ho_IcDilateReg, hv__IcDilationSize);
                //银胶检测区
                ho_EpoxyDilateReg.Dispose();
                HTV_dilation_reject_region(hvec_i_EpoxyRegs, out ho_EpoxyDilateReg, hv__EpoxyDilationSize);
                //bond检测区
                ho_BondDilateReg.Dispose();
                HTV_dilation_reject_region(hvec_i_BondRegs, out ho_BondDilateReg, hv__BondDilationSize);
                //wire检测区
                ho_WireDilateReg.Dispose();
                HTV_dilation_reject_contour(hvec_i_WireContours, out ho_WireDilateReg, hv__WireDilationSize);
                //
                //合并免检区
                ho_RejectRegs.Dispose();
                HOperatorSet.GenEmptyObj(out ho_RejectRegs);
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.ConcatObj(ho_RejectRegs, ho_IcDilateReg, out ExpTmpOutVar_0);
                    ho_RejectRegs.Dispose();
                    ho_RejectRegs = ExpTmpOutVar_0;
                }
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.ConcatObj(ho_RejectRegs, ho_EpoxyDilateReg, out ExpTmpOutVar_0
                        );
                    ho_RejectRegs.Dispose();
                    ho_RejectRegs = ExpTmpOutVar_0;
                }
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.ConcatObj(ho_RejectRegs, ho_BondDilateReg, out ExpTmpOutVar_0);
                    ho_RejectRegs.Dispose();
                    ho_RejectRegs = ExpTmpOutVar_0;
                }
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.ConcatObj(ho_RejectRegs, ho_WireDilateReg, out ExpTmpOutVar_0);
                    ho_RejectRegs.Dispose();
                    ho_RejectRegs = ExpTmpOutVar_0;
                }
                ho_o_AvoidReg.Dispose();
                HOperatorSet.Union1(ho_RejectRegs, out ho_o_AvoidReg);

                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    hvec_o_RejectRegs = dh.Take(((((
                        dh.Add(new HObjectVector(1)).Insert(0, dh.Add(new HObjectVector(ho_IcDilateReg)))).Insert(
                        1, dh.Add(new HObjectVector(ho_EpoxyDilateReg)))).Insert(2, dh.Add(new HObjectVector(ho_BondDilateReg)))).Insert(
                        3, dh.Add(new HObjectVector(ho_WireDilateReg)))));
                }
                //
                hv_o_ErrCode = 0;
                hv_o_ErrStr = "frames edit successful";

                ho_EmptyObj.Dispose();
                ho_IcDilateReg.Dispose();
                ho_EpoxyDilateReg.Dispose();
                ho_BondDilateReg.Dispose();
                ho_WireDilateReg.Dispose();
                ho_RejectRegs.Dispose();

                return;

            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_EmptyObj.Dispose();
                ho_IcDilateReg.Dispose();
                ho_EpoxyDilateReg.Dispose();
                ho_BondDilateReg.Dispose();
                ho_WireDilateReg.Dispose();
                ho_RejectRegs.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public static void HTV_dilation_reject_region(HObjectVector/*{eObjectVector,Dim=1}*/ hvec_i_RejectRegs,
            out HObject ho_o_DilateReg, HTuple hv_i_DilationSize)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_EmptyObject, ho_RejectReg = null;
            HObject ho_DilationReg = null;

            // Local control variables 

            HTuple hv_ObjNum = null, hv_Idx = null, hv_RegNum = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_DilateReg);
            HOperatorSet.GenEmptyObj(out ho_EmptyObject);
            HOperatorSet.GenEmptyObj(out ho_RejectReg);
            HOperatorSet.GenEmptyObj(out ho_DilationReg);
            //**************************************************************************************************
            //---函数：HTV_diation_reject_region
            //---作用：区域膨胀
            //---参数：
            //===图标参数
            //  i_RejectRegs：区域集合
            //  o_DilateReg：膨胀后区域
            //===控制参数
            //  i_DilationSize：膨胀系数
            //**************************************************************************************************
            //
            //初始化
            ho_EmptyObject.Dispose();
            HOperatorSet.GenEmptyObj(out ho_EmptyObject);
            ho_o_DilateReg.Dispose();
            ho_o_DilateReg = ho_EmptyObject.CopyObj(1, -1);

            //区域膨胀
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_ObjNum = new HTuple(hvec_i_RejectRegs.Length);
            }

            HTuple end_val18 = hv_ObjNum - 1;
            HTuple step_val18 = 1;
            for (hv_Idx = 0; hv_Idx.Continue(end_val18, step_val18); hv_Idx = hv_Idx.TupleAdd(step_val18))
            {

                ho_RejectReg.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    ho_RejectReg = hvec_i_RejectRegs[hv_Idx].O.CopyObj(1, -1);
                }
                //
                HOperatorSet.CountObj(ho_RejectReg, out hv_RegNum);
                if ((int)(hv_RegNum) != 0)
                {
                    ho_DilationReg.Dispose();
                    HOperatorSet.DilationCircle(ho_RejectReg, out ho_DilationReg, hv_i_DilationSize.TupleSelect(
                        hv_Idx));
                }
                else
                {
                    ho_DilationReg.Dispose();
                    HOperatorSet.GenEmptyRegion(out ho_DilationReg);
                }
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.ConcatObj(ho_o_DilateReg, ho_DilationReg, out ExpTmpOutVar_0);
                    ho_o_DilateReg.Dispose();
                    ho_o_DilateReg = ExpTmpOutVar_0;
                }
            }

            ho_EmptyObject.Dispose();
            ho_RejectReg.Dispose();
            ho_DilationReg.Dispose();

            return;
        }

        public static void HTV_dilation_reject_contour(HObjectVector/*{eObjectVector,Dim=1}*/ hvec_i_RejectContours,
            out HObject ho_o_DilateReg, HTuple hv_i_DilationSize)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_EmptyObject, ho_RejectContour = null;
            HObject ho_DilationReg = null;

            // Local control variables 

            HTuple hv_ObjNum = null, hv_Idx = null, hv_ContNum = new HTuple();
            HTuple hv__ErrCode = new HTuple(), hv__ErrStr = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_DilateReg);
            HOperatorSet.GenEmptyObj(out ho_EmptyObject);
            HOperatorSet.GenEmptyObj(out ho_RejectContour);
            HOperatorSet.GenEmptyObj(out ho_DilationReg);
            //**************************************************************************************************
            //---函数：HTV_diation_reject_contour
            //---作用：轮廓转区域并膨胀
            //---参数：
            //===图标参数
            //  i_RejectContours：区域集合
            //  o_DilateReg：膨胀后区域
            //===控制参数
            //  i_DilationSize：膨胀系数
            //**************************************************************************************************
            //
            //初始化
            ho_EmptyObject.Dispose();
            HOperatorSet.GenEmptyObj(out ho_EmptyObject);
            ho_o_DilateReg.Dispose();
            ho_o_DilateReg = ho_EmptyObject.CopyObj(1, -1);

            //区域膨胀
            using (HDevDisposeHelper dh = new HDevDisposeHelper())
            {
                hv_ObjNum = new HTuple(hvec_i_RejectContours.Length);
            }

            HTuple end_val18 = hv_ObjNum - 1;
            HTuple step_val18 = 1;
            for (hv_Idx = 0; hv_Idx.Continue(end_val18, step_val18); hv_Idx = hv_Idx.TupleAdd(step_val18))
            {

                ho_RejectContour.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    ho_RejectContour = hvec_i_RejectContours[hv_Idx].O.CopyObj(1, -1);
                }
                //
                HOperatorSet.CountObj(ho_RejectContour, out hv_ContNum);
                //将contour转换为region
                if ((int)(hv_ContNum) != 0)
                {
                    ho_DilationReg.Dispose();
                    HTV_contours_to_region(ho_RejectContour, out ho_DilationReg, hv_i_DilationSize.TupleSelect(
                        hv_Idx), out hv__ErrCode, out hv__ErrStr);
                }
                else
                {
                    ho_DilationReg.Dispose();
                    HOperatorSet.GenEmptyRegion(out ho_DilationReg);
                }
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.ConcatObj(ho_o_DilateReg, ho_DilationReg, out ExpTmpOutVar_0);
                    ho_o_DilateReg.Dispose();
                    ho_o_DilateReg = ExpTmpOutVar_0;
                }
            }

            ho_EmptyObject.Dispose();
            ho_RejectContour.Dispose();
            ho_DilationReg.Dispose();

            return;
        }


        #region 清除模板
        public static void HTV_clear_model(HTuple hv_i_ModelID, HTuple hv_i_ModelType)
        {



            // Local control variables 

            HTuple hv_idx = null;
            // Initialize local and output iconic variables 
            //****************
            //modefy by wj 12-05
            //*****************
            //
            for (hv_idx = 0; (int)hv_idx <= (int)((new HTuple(hv_i_ModelID.TupleLength())) - 1); hv_idx = (int)hv_idx + 1)
            {
                //
                if ((int)(new HTuple(hv_i_ModelType.TupleEqual("ncc"))) != 0)
                {
                    HOperatorSet.ClearNccModel(hv_i_ModelID.TupleSelect(hv_idx));
                }
                else if ((int)(new HTuple(hv_i_ModelType.TupleEqual("shape"))) != 0)
                {
                    HOperatorSet.ClearShapeModel(hv_i_ModelID.TupleSelect(hv_idx));
                }
                else
                {
                    throw new HalconException("Wrong argument [modelType]=" + hv_i_ModelType);
                }
            }

            return;
        }

        public static void JSCC_AOI_clear_all_model(HTuple hv_i_InspectItemNum, HTupleVector/*{eTupleVector,Dim=2}*/ hvec_i_FrameModels,
            HTupleVector/*{eTupleVector,Dim=2}*/ hvec_i_IcModels, HTupleVector/*{eTupleVector,Dim=2}*/ hvec_i_BondModels,
            out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_FrameNum = null, hv_ItemIdx = null;
            HTuple hv_FrameModelType = new HTuple(), hv_FrameModelID = new HTuple();
            HTuple hv_IcNum = null, hv_IcModel = new HTuple(), hv_BondNum = null;
            HTuple hv_BondInspectMethod = new HTuple(), hv_BondType = new HTuple();
            HTuple hv_BondId = new HTuple();
            // Initialize local and output iconic variables 
            //**************************************************************************************************
            //---函数：JSCC_AOI_clear_all_model
            //---作用：清除Die区域所有检测项目的模板ID
            //---参数：
            //===控制参数
            //  i_InspectItemNum：各检测项目需要检测数量集合：一维数组
            //  i_FrameModels：Ic检测所需参数集合：一维向量
            //  i_IcModels：Ic检测所需参数集合：一维向量
            //  i_BondModels：Ic检测所需参数集合：一维向量
            //  o_ErrCode：错误码，代表该算子在执行过程中产生的错误，0-代表执行正常，-1-代表执行异常，-2-代表未执行
            //  o_ErrStr: 错误信息，对各种错误的具体描述
            //**************************************************************************************************
            //初始化
            hv_o_ErrCode = -2;
            hv_o_ErrStr = "initiating";

            //
            //--------------清除Frame模板
            hv_FrameNum = hv_i_InspectItemNum[0];
            HTuple end_val19 = hv_FrameNum - 1;
            HTuple step_val19 = 1;
            for (hv_ItemIdx = 0; hv_ItemIdx.Continue(end_val19, step_val19); hv_ItemIdx = hv_ItemIdx.TupleAdd(step_val19))
            {
                //
                hv_FrameModelType = hvec_i_FrameModels[hv_ItemIdx][1].T.Clone();
                hv_FrameModelID = hvec_i_FrameModels[hv_ItemIdx][2].T.Clone();
                //
                HTV_clear_model(hv_FrameModelID, hv_FrameModelType);
            }
            //---------------清除Ic模板
            hv_IcNum = hv_i_InspectItemNum[1];
            HTuple end_val28 = hv_IcNum - 1;
            HTuple step_val28 = 1;
            for (hv_ItemIdx = 0; hv_ItemIdx.Continue(end_val28, step_val28); hv_ItemIdx = hv_ItemIdx.TupleAdd(step_val28))
            {
                hv_IcModel = hvec_i_IcModels[hv_ItemIdx][2].T.Clone();
                HTV_clear_model(hv_IcModel.TupleSelect(2), hv_IcModel.TupleSelect(1));
            }
            //---------------清除Bond模板
            hv_BondNum = hv_i_InspectItemNum[3];
            HTuple end_val34 = hv_BondNum - 1;
            HTuple step_val34 = 1;
            for (hv_ItemIdx = 0; hv_ItemIdx.Continue(end_val34, step_val34); hv_ItemIdx = hv_ItemIdx.TupleAdd(step_val34))
            {
                //方法
                hv_BondInspectMethod = hvec_i_BondModels[hv_ItemIdx][1].T.Clone();
                //ID、Type
                hv_BondType = hvec_i_BondModels[hv_ItemIdx][2].T.Clone();
                hv_BondId = hvec_i_BondModels[hv_ItemIdx][3].T.Clone();
                //
                if ((int)(new HTuple(hv_BondInspectMethod.TupleEqual(1))) != 0)
                {
                    //测量目标那
                    HOperatorSet.ClearMetrologyModel(hv_BondId);
                }
                else
                {
                    //匹配模板
                    HTV_clear_model(hv_BondId, hv_BondType);
                }
            }
            //
            hv_o_ErrCode = 0;
            hv_o_ErrStr = "clear all models successful";

            return;
        }

        #endregion
        #region  表面检测-钉架检测
        public static void HTV_PegRack_Inspect(HObject ho_i_Image, HObject ho_i_PegRackReg, HObject ho_i_RejectReg,
            out HObject ho_o_FailPegRackRegs, HTuple hv_i_FrameHomMat2D, HTupleVector/*{eTupleVector,Dim=1}*/ hvec_i_RegSegParas,
            HTuple hv_i_CloseSize, HTuple hv_i_MinLength, HTuple hv_i_MinWidth, HTuple hv_i_MinArea,
            HTuple hv_i_SelOperation, HTuple hv_i_ImgIdx, out HTuple hv_o_DefectType, out HTuple hv_o_DefectImgIdx,
            out HTupleVector/*{eTupleVector,Dim=1}*/ hvec_o_DefectValue, out HTuple hv_o_ErrCode,
            out HTuple hv_o_ErrStr)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho__EmptyFailReg, ho__PegRacTargets;
            HObject ho_RegionUnion = null;

            // Local control variables 

            HTuple hv__ErrPegRackCode = null, hv__ErrPegRackStr = null;
            HTuple hv_Area = new HTuple(), hv_Row = new HTuple(), hv_Column = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_FailPegRackRegs);
            HOperatorSet.GenEmptyObj(out ho__EmptyFailReg);
            HOperatorSet.GenEmptyObj(out ho__PegRacTargets);
            HOperatorSet.GenEmptyObj(out ho_RegionUnion);
            try
            {
                //**************************************************************************************************
                //---函数：HTV_PegRack_Inspect
                //---作用：钉架区域表面检测
                //---参数：
                //===图标参数
                //  i_Image：输入图像
                //  i_PegRackReg：钉架区域，在该区域中进行表面污染检测
                //  i_RejectReg：检测得到的拒绝区
                //  o_FailPegRacRegs：输出检测结果的错误区域的HobjectVector
                //===控制参数
                //  i_FrameHomMat2D：框架定位映射矩阵
                //  i_RegSegParas：区域分割参数
                //  i_CloseSize：闭运算尺寸
                //  i_MinLength：缺陷最小外接矩形半长,为一个向量，针对各重点检测区和非重点检测区分别设置不同参数
                //　 i_MinWidth：缺陷最小外接矩形半宽,为一个向量，针对各重点检测区和非重点检测区分别设置不同参数
                //  i_MinArea：缺陷最小面积,为一个向量，针对各重点检测区和非重点检测区分别设置不同参数
                //  i_SelOperation：形状选择算子and或or等
                //  o_DefectType：输出的检测得到的异常区域的缺陷类型
                //  o_ErrCode: 错误码，代表该算子执行过程中产生的错误，0-代表正常执行，-1-代表异常，-2-代表未执行
                //  o_ErrStr: 错误信息，对各种错误的具体描述
                //**************************************************************************************************

                //初始化
                ho__EmptyFailReg.Dispose();
                HOperatorSet.GenEmptyObj(out ho__EmptyFailReg);
                ho_o_FailPegRackRegs.Dispose();
                ho_o_FailPegRackRegs = ho__EmptyFailReg.CopyObj(1, -1);
                hv_o_DefectType = new HTuple();
                hv_o_DefectImgIdx = new HTuple();
                hvec_o_DefectValue = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(-2))));
                hv_o_ErrCode = -2;
                hv_o_ErrStr = "initializing";

                //区域表面检测
                ho__PegRacTargets.Dispose();
                HTV_Region_Surface_Inspect(ho_i_Image, ho_i_PegRackReg, ho_i_RejectReg, out ho__PegRacTargets,
                    hv_i_FrameHomMat2D, hvec_i_RegSegParas, hv_i_CloseSize, hv_i_MinLength,
                    hv_i_MinWidth, hv_i_MinArea, hv_i_SelOperation, out hv__ErrPegRackCode,
                    out hv__ErrPegRackStr);

                if ((int)(new HTuple(hv__ErrPegRackCode.TupleLess(0))) != 0)
                {
                    //参数异常
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "PegRack Region " + hv__ErrPegRackStr;
                }
                else if ((int)(new HTuple(hv__ErrPegRackCode.TupleGreater(0))) != 0)
                {
                    //钉架区表面有缺陷
                    hv_o_DefectType = hv_o_DefectType.TupleConcat(17);
                    hv_o_DefectImgIdx = hv_o_DefectImgIdx.TupleConcat(hv_i_ImgIdx);
                    ho_RegionUnion.Dispose();
                    HOperatorSet.Union1(ho__PegRacTargets, out ho_RegionUnion);
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_o_FailPegRackRegs, ho_RegionUnion, out ExpTmpOutVar_0
                            );
                        ho_o_FailPegRackRegs.Dispose();
                        ho_o_FailPegRackRegs = ExpTmpOutVar_0;
                    }
                    //异物信息独立统计 lw
                    HOperatorSet.AreaCenter(ho__PegRacTargets, out hv_Area, out hv_Row, out hv_Column);
                    hvec_o_DefectValue = (((new HTupleVector(1).Insert(0, new HTupleVector(hv_Area))).Insert(
                        1, new HTupleVector(hv_Row))).Insert(2, new HTupleVector(hv_Column)));
                    hv_o_ErrCode = 1;
                    hv_o_ErrStr = "PegRack Region Surface is dirty";
                }
                else
                {
                    //钉架区表面正常
                    hvec_o_DefectValue = (((new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(0)))).Insert(
                        1, new HTupleVector(new HTuple(0)))).Insert(2, new HTupleVector(new HTuple(0))));
                    hv_o_ErrCode = 0;
                    hv_o_ErrStr = "PegRack Region Surface is clear";
                }

                ho__EmptyFailReg.Dispose();
                ho__PegRacTargets.Dispose();
                ho_RegionUnion.Dispose();

                return;


            }
            catch (HalconException HDevExpDefaultException)
            {
                ho__EmptyFailReg.Dispose();
                ho__PegRacTargets.Dispose();
                ho_RegionUnion.Dispose();

                throw HDevExpDefaultException;
            }
        }
        #endregion


        #region 表面检测-桥接检测
        public static void HTV_Bridge_Inspect(HObject ho_i_Image, HObject ho_i_BridgeReg, HObject ho_i_RejectReg,
            out HObject ho_o_FailBridgeRegs, HTuple hv_i_FrameHomMat2D, HTupleVector/*{eTupleVector,Dim=1}*/ hvec_i_RegSegParas,
            HTuple hv_i_CloseSize, HTuple hv_i_MinLength, HTuple hv_i_MinWidth, HTuple hv_i_MinArea,
            HTuple hv_i_SelOperation, HTuple hv_i_ImgIdx, out HTuple hv_o_DefectType, out HTuple hv_o_DefectImgIdx,
            out HTupleVector/*{eTupleVector,Dim=1}*/ hvec_o_DefectValue, out HTuple hv_o_ErrCode,
            out HTuple hv_o_ErrStr)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho__EmptyFailReg, ho__BridgeTargets;
            HObject ho_RegionUnion = null;

            // Local control variables 

            HTuple hv__ErrBridgeCode = null, hv__ErrBridgeStr = null;
            HTuple hv_Area = new HTuple(), hv_Row = new HTuple(), hv_Column = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_FailBridgeRegs);
            HOperatorSet.GenEmptyObj(out ho__EmptyFailReg);
            HOperatorSet.GenEmptyObj(out ho__BridgeTargets);
            HOperatorSet.GenEmptyObj(out ho_RegionUnion);
            try
            {
                //**************************************************************************************************
                //---函数：HTV_Bridge_Inspect
                //---作用：桥接区域表面检测
                //---参数：
                //===图标参数
                //  i_Image：输入图像
                //  i_BridgeReg：桥接区域，在该区域中进行表面污染检测
                //  i_RejectReg：检测得到的拒绝区
                //  o_FailBridgeRegs：输出检测结果的错误区域的HobjectVector
                //===控制参数
                //  i_FrameHomMat2D：框架定位映射矩阵
                //  i_RegSegParas：区域分割参数
                //  i_CloseSize：闭运算尺寸
                //  i_MinLength：缺陷最小外接矩形半长,为一个向量，针对各重点检测区和非重点检测区分别设置不同参数
                //　 i_MinWidth：缺陷最小外接矩形半宽,为一个向量，针对各重点检测区和非重点检测区分别设置不同参数
                //  i_MinArea：缺陷最小面积,为一个向量，针对各重点检测区和非重点检测区分别设置不同参数
                //  i_SelOperation：形状选择算子and或or等
                //  o_DefectType：输出的检测得到的异常区域的缺陷类型
                //  o_ErrCode: 错误码，代表该算子执行过程中产生的错误，0-代表正常执行，-1-代表异常，-2-代表未执行
                //  o_ErrStr: 错误信息，对各种错误的具体描述
                //**************************************************************************************************

                //初始化
                ho__EmptyFailReg.Dispose();
                HOperatorSet.GenEmptyObj(out ho__EmptyFailReg);
                ho_o_FailBridgeRegs.Dispose();
                ho_o_FailBridgeRegs = ho__EmptyFailReg.CopyObj(1, -1);
                hv_o_DefectType = new HTuple();
                hv_o_DefectImgIdx = new HTuple();
                hvec_o_DefectValue = (new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(-2))));
                hv_o_ErrCode = -2;
                hv_o_ErrStr = "initializing";

                //区域表面检测
                ho__BridgeTargets.Dispose();
                HTV_Region_Surface_Inspect(ho_i_Image, ho_i_BridgeReg, ho_i_RejectReg, out ho__BridgeTargets,
                    hv_i_FrameHomMat2D, hvec_i_RegSegParas, hv_i_CloseSize, hv_i_MinLength,
                    hv_i_MinWidth, hv_i_MinArea, hv_i_SelOperation, out hv__ErrBridgeCode,
                    out hv__ErrBridgeStr);

                if ((int)(new HTuple(hv__ErrBridgeCode.TupleLess(0))) != 0)
                {
                    //参数异常
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "Bridge Region " + hv__ErrBridgeStr;
                }
                else if ((int)(new HTuple(hv__ErrBridgeCode.TupleGreater(0))) != 0)
                {
                    //桥接区表面有缺陷
                    hv_o_DefectType = hv_o_DefectType.TupleConcat(29);
                    hv_o_DefectImgIdx = hv_o_DefectImgIdx.TupleConcat(hv_i_ImgIdx);
                    ho_RegionUnion.Dispose();
                    HOperatorSet.Union1(ho__BridgeTargets, out ho_RegionUnion);
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_o_FailBridgeRegs, ho_RegionUnion, out ExpTmpOutVar_0
                            );
                        ho_o_FailBridgeRegs.Dispose();
                        ho_o_FailBridgeRegs = ExpTmpOutVar_0;
                    }
                    //异物信息独立统计 lw
                    HOperatorSet.AreaCenter(ho__BridgeTargets, out hv_Area, out hv_Row, out hv_Column);
                    hvec_o_DefectValue = (((new HTupleVector(1).Insert(0, new HTupleVector(hv_Area))).Insert(
                        1, new HTupleVector(hv_Row))).Insert(2, new HTupleVector(hv_Column)));
                    hv_o_ErrCode = 1;
                    hv_o_ErrStr = "Bridge Region Surface is dirty";
                }
                else
                {
                    //桥接区表面正常
                    hvec_o_DefectValue = (((new HTupleVector(1).Insert(0, new HTupleVector(new HTuple(0)))).Insert(
                        1, new HTupleVector(new HTuple(0)))).Insert(2, new HTupleVector(new HTuple(0))));
                    hv_o_ErrCode = 0;
                    hv_o_ErrStr = "Bridge Region Surface is clear";
                }

                ho__EmptyFailReg.Dispose();
                ho__BridgeTargets.Dispose();
                ho_RegionUnion.Dispose();

                return;

            }
            catch (HalconException HDevExpDefaultException)
            {
                ho__EmptyFailReg.Dispose();
                ho__BridgeTargets.Dispose();
                ho_RegionUnion.Dispose();

                throw HDevExpDefaultException;
            }
        }
        #endregion
        #endregion


        #region  bondMatch  bondMeasure 焊点区域 自动生成
        public static void HTV_Gen_Bond_Region(HObject ho_i_Image, HObject ho_i_InspectRegs,
            out HObject ho_o_BondContours, HTuple hv_i_HomMatMod2Img, HTuple hv_i_BondNum,
            HTuple hv_i_ModelType, HTuple hv_i_ModelID, HTuple hv_i_Score, HTuple hv_i_AngleStart,
            HTuple hv_i_AngleExt, HTuple hv_i_BondSize, out HTuple hv_o_BondRows, out HTuple hv_o_BondCols,
            out HTuple hv_o_BondAngles, out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {




            // Local iconic variables 

            HObject ho_EmptyObject, ho__InspectRegs;

            // Local control variables 

            HTuple hv_HomMatSum = null, hv__BondRegNum = null;
            HTuple hv__BondLocFlags = null, hv__ErrCode = null, hv__ErrStr = null;
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_BondContours);
            HOperatorSet.GenEmptyObj(out ho_EmptyObject);
            HOperatorSet.GenEmptyObj(out ho__InspectRegs);
            try
            {
                //**************************************************************************************************
                //---函数：HTV_Gen_Bond_Region
                //---作用：快速生成焊点区域
                //===图标参数
                //  i_Image：输入图像
                //  i_InspectRegs：Bond检测区域
                //  o_BondContours：检测到的Bond轮廓
                //  o_BondRegs：生成Bond的区域
                //  o_BondLines：Bond区域参考方向
                //===控制参数
                //  i_HomMatMod2Img: 检测区域的映射矩阵
                //  i_BondNum：定位区域内Bond的数量
                //  i_ModelType: 模板类型，一般使用ncc和shape定位模板，该参数为整型类型，0-ncc，1-shape
                //  i_ModelID: 模板ID号，创建匹配模板时返回值，通常由模板文件读入
                //  i_Score: 最小匹配分数
                //  i_AngleStart: 匹配定位起始角度
                //  i_AngleExt: 匹配定位角度范围
                //  i_BondSize：焊点半径大小
                //  o_BondParas：bond位置信息
                //  o_ErrCode: 错误码，代表该算子执行过程中产生的错误
                //  o_ErrStr: 错误信息，对各种错误的具体描述
                //**************************************************************************************************

                //初始化
                ho_EmptyObject.Dispose();
                HOperatorSet.GenEmptyObj(out ho_EmptyObject);
                //

                ho_o_BondContours.Dispose();
                ho_o_BondContours = ho_EmptyObject.CopyObj(1, -1);

                hv_o_BondRows = new HTuple();
                hv_o_BondCols = new HTuple();
                hv_o_BondAngles = new HTuple();
                hv_o_ErrCode = -2;
                hv_o_ErrStr = "Initializing";

                //传入映射矩阵有效性测试
                HOperatorSet.TupleSum(hv_i_HomMatMod2Img, out hv_HomMatSum);
                if ((int)(new HTuple(hv_HomMatSum.TupleEqual(-12))) != 0)
                {
                    hv_o_ErrCode = 1;
                    hv_o_ErrStr = "mapping matrix is invalid!";
                    ho_EmptyObject.Dispose();
                    ho__InspectRegs.Dispose();

                    return;
                }
                //输入有效性测试
                HOperatorSet.CountObj(ho_i_InspectRegs, out hv__BondRegNum);
                if ((int)(new HTuple(hv__BondRegNum.TupleEqual(0))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "bond region is empty";
                    ho_EmptyObject.Dispose();
                    ho__InspectRegs.Dispose();

                    return;
                }

                //检测区域映射
                ho__InspectRegs.Dispose();
                HOperatorSet.AffineTransRegion(ho_i_InspectRegs, out ho__InspectRegs, hv_i_HomMatMod2Img,
                    "nearest_neighbor");
                //bond定位生成区域
                ho_o_BondContours.Dispose();
                HTV_Bond_Region_Location(ho_i_Image, ho__InspectRegs, out ho_o_BondContours,
                    hv_i_BondNum, hv_i_ModelType, hv_i_ModelID, hv_i_Score, hv_i_AngleStart,
                    hv_i_AngleExt, hv_i_BondSize, out hv__BondLocFlags, out hv_o_BondRows,
                    out hv_o_BondCols, out hv_o_BondAngles, out hv__ErrCode, out hv__ErrStr);

                //
                //出现异常
                if ((int)(new HTuple(hv__ErrCode.TupleLess(0))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = hv__ErrStr.Clone();
                    ho_EmptyObject.Dispose();
                    ho__InspectRegs.Dispose();

                    return;
                }
                //
                hv_o_ErrCode = 0;
                hv_o_ErrStr = "Bond Regions gen success ";
                ho_EmptyObject.Dispose();
                ho__InspectRegs.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_EmptyObject.Dispose();
                ho__InspectRegs.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public static void HTV_Bond_Region_Location(HObject ho_i_Image, HObject ho_i_InspectRegs,
            out HObject ho_o_BondContours, HTuple hv_i_BondNum, HTuple hv_i_ModelType, HTuple hv_i_ModelID,
            HTuple hv_i_Score, HTuple hv_i_AngleStart, HTuple hv_i_AngleExt, HTuple hv_i_BondSize,
            out HTuple hv_o_BondLocFlags, out HTuple hv_o_BondRows, out HTuple hv_o_BondCols,
            out HTuple hv_o_BondAngles, out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho__BondReg = null, ho__BondContours = null;

            // Local control variables 

            HTuple hv_BondRows = null, hv_BondCols = null;
            HTuple hv_BondAngles = null, hv_RegNumber = null, hv_RegIdx = null;
            HTuple hv__BondNum = new HTuple(), hv__LocPara = new HTuple();
            HTuple hv_o_Score = new HTuple(), hv__ErrCode = new HTuple();
            HTuple hv__ErrStr = new HTuple(), hv_Indices = new HTuple();
            HTuple hv__BondRows = new HTuple(), hv__BondCols = new HTuple();
            HTuple hv__BondAngles = new HTuple(), hv_idx = new HTuple();
            HTuple hv__BondRow = new HTuple(), hv__BondCol = new HTuple();
            HTuple hv__BondAngle = new HTuple(), hv_IdxBond = null;
            HTuple hv_Index = null;
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_BondContours);
            HOperatorSet.GenEmptyObj(out ho__BondReg);
            HOperatorSet.GenEmptyObj(out ho__BondContours);
            try
            {
                //**************************************************************************************************
                //---函数：HTV_Bond_Region_Location
                //---作用：焊点区域生成
                //===图标参数
                //  i_Image: 输入图像，在图像中寻找匹配对象
                //  i_InspectRegs：Bond所有的定位区域
                //  o_BondContours：定位到Bond轮廓
                //  o_BondRegs：生成Bond的区域
                //  o_BondLines：Bond区域参考方向
                //===控制参数
                //  i_HomMatMod2Img: 检测区域的映射矩阵
                //  i_BondNum：定位区域内Bond的数量
                //  i_ModelType: 模板类型，一般使用ncc和shape定位模板，该参数为整型类型，0-ncc，1-shape
                //  i_ModelID: 模板ID号，创建匹配模板时返回值，通常由模板文件读入
                //  i_Score: 最小匹配分数
                //  i_AngleStart: 匹配定位起始角度
                //  i_AngleExt: 匹配定位角度范围
                //  i_BondSize：焊点半径
                //  o_BondLocFlags：bond定位区域内定位结果
                //  o_BondRows: 匹配对象的横坐标：位置信息
                //  o_BondCols: 匹配对象的纵坐标：位置信息
                //  o_BondAngles：匹配对象的参考方向
                //  o_ErrCode: 错误码，代表该算子执行过程中产生的错误
                //  o_ErrStr: 错误信息，对各种错误的具体描述
                //**************************************************************************************************


                //初始化
                ho_o_BondContours.Dispose();
                HOperatorSet.GenEmptyObj(out ho_o_BondContours);

                hv_o_ErrCode = -2;
                hv_o_ErrStr = "initializing";
                hv_o_BondRows = new HTuple();
                hv_o_BondCols = new HTuple();
                hv_o_BondAngles = new HTuple();
                hv_o_BondLocFlags = new HTuple();

                //定位Bond
                //从模板到图像映射后的所有焊点
                hv_BondRows = new HTuple();
                hv_BondCols = new HTuple();
                hv_BondAngles = new HTuple();

                //
                HOperatorSet.CountObj(ho_i_InspectRegs, out hv_RegNumber);
                HTuple end_val45 = hv_RegNumber - 1;
                HTuple step_val45 = 1;
                for (hv_RegIdx = 0; hv_RegIdx.Continue(end_val45, step_val45); hv_RegIdx = hv_RegIdx.TupleAdd(step_val45))
                {
                    ho__BondReg.Dispose();
                    HOperatorSet.SelectObj(ho_i_InspectRegs, out ho__BondReg, hv_RegIdx + 1);
                    hv__BondNum = hv_i_BondNum.TupleSelect(hv_RegIdx);
                    HTV_Loc_Match(ho_i_Image, ho__BondReg, hv_i_ModelType, hv_i_ModelID, hv_i_Score,
                        hv_i_AngleStart.TupleSelect(hv_RegIdx), hv_i_AngleExt, hv__BondNum, out hv__LocPara,
                        out hv_o_Score, out hv__ErrCode, out hv__ErrStr);
                    //判断异常
                    if ((int)(new HTuple(hv__ErrCode.TupleLess(0))) != 0)
                    {
                        hv_o_ErrCode = -1;
                        hv_o_ErrStr = hv__ErrStr.Clone();
                        ho__BondReg.Dispose();
                        ho__BondContours.Dispose();

                        return;
                    }

                    //删除匹配的焊点_LocPara, 即-2
                    HOperatorSet.TupleFind(hv__LocPara, -2, out hv_Indices);
                    HOperatorSet.TupleRemove(hv__LocPara, hv_Indices, out hv__LocPara);

                    //获取检测区域内所有焊点位置及角度
                    hv__BondRows = new HTuple();
                    hv__BondCols = new HTuple();
                    hv__BondAngles = new HTuple();
                    //
                    if ((int)(new HTuple(hv__ErrCode.TupleGreater(0))) != 0)
                    {
                        hv_o_BondLocFlags = hv_o_BondLocFlags.TupleConcat(1);
                        for (hv_idx = 0; (int)hv_idx <= (int)(((new HTuple(hv__LocPara.TupleLength()
                            )) / 3) - 1); hv_idx = (int)hv_idx + 1)
                        {
                            hv__BondRow = hv__LocPara.TupleSelect(3 * hv_idx);
                            hv__BondCol = hv__LocPara.TupleSelect((3 * hv_idx) + 1);
                            hv__BondAngle = hv__LocPara.TupleSelect((3 * hv_idx) + 2);
                            hv__BondRows = hv__BondRows.TupleConcat(hv__BondRow);
                            hv__BondCols = hv__BondCols.TupleConcat(hv__BondCol);
                            hv__BondAngles = hv__BondAngles.TupleConcat(hv__BondAngle);
                        }
                        //找到焊点进行焊点位置从模板位置映射到图像位置
                        HTV_Arrange_Pos(hv_i_ModelID, hv_i_ModelType, hv__BondRows, hv__BondCols,
                            hv__BondAngles, out hv__BondRows, out hv__BondCols);
                        hv_o_BondRows = hv_o_BondRows.TupleConcat(hv__BondRows);
                        hv_o_BondCols = hv_o_BondCols.TupleConcat(hv__BondCols);
                        hv_o_BondAngles = hv_o_BondAngles.TupleConcat(hv__BondAngles);
                    }
                    else
                    {
                        hv_o_BondLocFlags = hv_o_BondLocFlags.TupleConcat(0);
                        for (hv_idx = 0; (int)hv_idx <= (int)(((new HTuple(hv__LocPara.TupleLength()
                            )) / 3) - 1); hv_idx = (int)hv_idx + 1)
                        {
                            hv__BondRow = hv__LocPara.TupleSelect(3 * hv_idx);
                            hv__BondCol = hv__LocPara.TupleSelect((3 * hv_idx) + 1);
                            hv__BondAngle = hv__LocPara.TupleSelect((3 * hv_idx) + 2);
                            hv__BondRows = hv__BondRows.TupleConcat(hv__BondRow);
                            hv__BondCols = hv__BondCols.TupleConcat(hv__BondCol);
                            hv__BondAngles = hv__BondAngles.TupleConcat(hv__BondAngle);

                        }
                        //找到焊点进行焊点位置从模板位置映射到图像位置
                        HTV_Arrange_Pos(hv_i_ModelID, hv_i_ModelType, hv__BondRows, hv__BondCols,
                            hv__BondAngles, out hv__BondRows, out hv__BondCols);
                        hv_o_BondRows = hv_o_BondRows.TupleConcat(hv__BondRows);
                        hv_o_BondCols = hv_o_BondCols.TupleConcat(hv__BondCols);
                        hv_o_BondAngles = hv_o_BondAngles.TupleConcat(hv__BondAngles);
                    }
                }

                //输出o_BondContours
                for (hv_IdxBond = 0; (int)hv_IdxBond <= (int)((new HTuple(hv_o_BondRows.TupleLength()
                    )) - 1); hv_IdxBond = (int)hv_IdxBond + 1)
                {

                    if ((int)(new HTuple((new HTuple(hv_i_BondSize.TupleLength())).TupleEqual(
                        1))) != 0)
                    {
                        ho__BondContours.Dispose();
                        HOperatorSet.GenCircle(out ho__BondContours, hv_o_BondRows.TupleSelect(
                            hv_IdxBond), hv_o_BondCols.TupleSelect(hv_IdxBond), hv_i_BondSize);
                    }
                    else
                    {
                        ho__BondContours.Dispose();
                        HOperatorSet.GenEllipse(out ho__BondContours, hv_o_BondRows.TupleSelect(
                            hv_IdxBond), hv_o_BondCols.TupleSelect(hv_IdxBond), hv_o_BondAngles.TupleSelect(
                            hv_IdxBond), hv_i_BondSize.TupleSelect(0), hv_i_BondSize.TupleSelect(
                            1));
                    }

                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_o_BondContours, ho__BondContours, out ExpTmpOutVar_0
                            );
                        ho_o_BondContours.Dispose();
                        ho_o_BondContours = ExpTmpOutVar_0;
                    }
                }
                //
                //整合定位结果
                HOperatorSet.TupleFindFirst(hv_o_BondLocFlags, 1, out hv_Index);
                if ((int)(new HTuple(hv_Index.TupleGreaterEqual(0))) != 0)
                {
                    hv_o_ErrCode = 1;
                    hv_o_ErrStr = "Fail to Locate one or more bond";
                    ho__BondReg.Dispose();
                    ho__BondContours.Dispose();

                    return;
                }
                else
                {
                    hv_o_ErrCode = 0;
                    hv_o_ErrStr = "Bond Location success";
                    ho__BondReg.Dispose();
                    ho__BondContours.Dispose();

                    return;
                }
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho__BondReg.Dispose();
                ho__BondContours.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public static void HTV_Clockwise_Sort_Points_Angles(HTuple hv_i_RefCoreRow, HTuple hv_i_RefCoreCol,
      		HTuple hv_i_Rows, HTuple hv_i_Cols, HTuple hv_i_Angles, HTuple hv_i_StartIndex,
      		HTuple hv_i_ClockwiseFlag, out HTuple hv_o_Rows, out HTuple hv_o_Cols, out HTuple hv_o_Angles,
      		out HTuple hv_o_SortIndex)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_SumRows = null, hv_SumCols = null;
            HTuple hv_idx = null, hv_CenterRow = null, hv_CenterCol = null;
            HTuple hv_StartRow = null, hv_StartCol = null, hv_Start_angle = null;
            HTuple hv_ball_angle = null, hv_ball_dis = null, hv_Angle = new HTuple();
            HTuple hv_Distance = new HTuple(), hv_Inverted = new HTuple();
            // Initialize local and output iconic variables 
            hv_o_Rows = new HTuple();
            hv_o_Cols = new HTuple();
            hv_o_Angles = new HTuple();
            hv_o_SortIndex = new HTuple();
            //**************************************************************************************************
            //---函数：HTV_Clockwise_Sort_Points
            //---作用：图像坐标点逆时针方向排序或顺时针方向排序
            //===控制参数
            //  i_Rows：点的Row坐标
            //  i_Cols：点的Col坐标
            //  i_Angles：点的方向
            //  i_StartIndex ：焊点排序起始焊点
            //  i_ClockwiseFlag ：1-逆时针，0-顺时针
            //  o_Rows：点的Row坐标
            //  o_Cols：点的Col坐标
            //  o_Angles：点的方向
            //**************************************************************************************************

            //计算重心
            hv_SumRows = 0;
            hv_SumCols = 0;
            for (hv_idx = 0; (int)hv_idx <= (int)((new HTuple(hv_i_Rows.TupleLength())) - 1); hv_idx = (int)hv_idx + 1)
            {
                hv_SumRows = hv_SumRows + (hv_i_Rows.TupleSelect(hv_idx));
                hv_SumCols = hv_SumCols + (hv_i_Cols.TupleSelect(hv_idx));
            }

            hv_CenterRow = hv_SumRows / (new HTuple(hv_i_Rows.TupleLength()));
            hv_CenterCol = hv_SumCols / (new HTuple(hv_i_Rows.TupleLength()));

            //
            hv_StartRow = hv_i_Rows.TupleSelect(hv_i_StartIndex);
            hv_StartCol = hv_i_Cols.TupleSelect(hv_i_StartIndex);
            HOperatorSet.AngleLx(hv_CenterRow, hv_CenterCol, hv_StartRow, hv_StartCol, out hv_Start_angle);
            if ((int)(new HTuple(hv_i_ClockwiseFlag.TupleEqual(1))) != 0)
            {
                hv_Start_angle = (hv_Start_angle.TupleDeg()) - 0.01;
            }
            else
            {
                hv_Start_angle = (hv_Start_angle.TupleDeg()) + 0.01;
            }
            //
            hv_ball_angle = new HTuple();
            hv_ball_dis = new HTuple();
            //
            if ((int)((new HTuple(hv_i_RefCoreRow.TupleEqual(0))).TupleAnd(new HTuple(hv_i_RefCoreCol.TupleEqual(
                0)))) != 0)
            {
                //使用传入点计算的重心位置作为排序参考点
            }
            else
            {
                //使用传入的参考重心点作为排序参考点
                hv_CenterRow = hv_i_RefCoreRow.Clone();
                hv_CenterCol = hv_i_RefCoreCol.Clone();
            }
            //
            for (hv_idx = 0; (int)hv_idx <= (int)((new HTuple(hv_i_Rows.TupleLength())) - 1); hv_idx = (int)hv_idx + 1)
            {
                HOperatorSet.AngleLx(hv_CenterRow, hv_CenterCol, hv_i_Rows.TupleSelect(hv_idx),
                    hv_i_Cols.TupleSelect(hv_idx), out hv_Angle);
                HOperatorSet.DistancePp(hv_CenterRow, hv_CenterCol, hv_i_Rows.TupleSelect(hv_idx),
                    hv_i_Cols.TupleSelect(hv_idx), out hv_Distance);
                //
                if ((int)((new HTuple(hv_Angle.TupleEqual((new HTuple(180)).TupleRad()))).TupleOr(
                    new HTuple(hv_Angle.TupleEqual(-((new HTuple(180)).TupleRad()))))) != 0)
                {
                    hv_Angle = (new HTuple(180)).TupleRad();
                }
                //
                if ((int)(new HTuple(((hv_Angle.TupleDeg())).TupleGreater(hv_Start_angle))) != 0)
                {
                    if (hv_ball_angle == null)
                        hv_ball_angle = new HTuple();
                    hv_ball_angle[hv_idx] = (-180 + (hv_Angle.TupleDeg())) - hv_Start_angle;
                }
                else
                {
                    if (hv_ball_angle == null)
                        hv_ball_angle = new HTuple();
                    hv_ball_angle[hv_idx] = (180 + (hv_Angle.TupleDeg())) - hv_Start_angle;
                }
                if (hv_ball_dis == null)
                    hv_ball_dis = new HTuple();
                hv_ball_dis[hv_idx] = hv_Distance;
            }
            //
            if ((int)(new HTuple(hv_i_ClockwiseFlag.TupleEqual(1))) != 0)
            {
                //逆时针排序
                HOperatorSet.TupleSortIndex(hv_ball_angle, out hv_o_SortIndex);
                hv_o_Rows = hv_i_Rows.TupleSelect(hv_o_SortIndex);
                hv_o_Cols = hv_i_Cols.TupleSelect(hv_o_SortIndex);
                hv_o_Angles = hv_i_Angles.TupleSelect(hv_o_SortIndex);
            }
            else
            {
                //顺时针排序
                HOperatorSet.TupleSortIndex(hv_ball_angle, out hv_o_SortIndex);
                HOperatorSet.TupleInverse(hv_o_SortIndex, out hv_o_SortIndex);
                hv_o_Rows = hv_i_Rows.TupleSelect(hv_o_SortIndex);
                hv_o_Cols = hv_i_Cols.TupleSelect(hv_o_SortIndex);
                hv_o_Angles = hv_i_Angles.TupleSelect(hv_o_SortIndex);
            }
            //******************************************************
            //冒泡排序
            //_PointRows := i_Rows
            //_PointCols := i_Cols
            //
            //for i := 0 to i_PointNum - 2 by 1
            //for j := 0 to i_PointNum - i - 2 by 1
            //
            //两点逆时针方向判断
            //gen_cross_contour_xld (Cross1, _PointRows[j], _PointCols[j], 16, 0.785398)
            //gen_cross_contour_xld (Cross2, _PointRows[j+1], _PointCols[j+1], 16, 0.785398)

            //HTV_Point_Cmp (_PointRows[j], _PointCols[j], _PointRows[j+1], _PointCols[j+1], CenterRow, CenterCol, ClockwiseFlag)


            //if (ClockwiseFlag = 1)
            //RowTmp := _PointRows[j]
            //ColTmp := _PointCols[j]
            //_PointRows[j] := _PointRows[j + 1]
            //_PointCols[j] := _PointCols[j + 1]
            //_PointRows[j + 1] := RowTmp
            //_PointCols[j + 1] := ColTmp
            //endif
            //endfor
            //endfor

            //o_Rows := _PointRows
            //o_Cols := _PointCols


            return;
        }

        #endregion

        #region Wire 自动生成金线检测起始结束焊点区域
        public static void HTV_Gen_Bond_threshold(HObject ho_i_Imgs, HObject ho_i_InspectReg,
            out HObject ho_o_BondContour, HTuple hv_i_ImgIdx, HTuple hv_i_BallSize, HTuple hv_i_ThreshGray,
            HTuple hv_i_ClosingSize, out HTuple hv_o_BondRow, out HTuple hv_o_BondCol, out HTuple hv_o_ErrCode,
            out HTuple hv_o_ErrStr)
        {




            // Local iconic variables 

            HObject ho_EmptyReg, ho_i_Image, ho__BondContour;
            HObject ho_EmptyRegion, ho_RegionDilation = null, ho_Circle = null;
            HObject ho_RegionErosion = null, ho_Rectangle = null;

            // Local control variables 

            HTuple hv_imgNum = null, hv_regNum = null;
            HTuple hv__ThreErrCode = null, hv__ThreErrStr = null, hv_Row = new HTuple();
            HTuple hv_Column = new HTuple(), hv_Radius = new HTuple();
            HTuple hv_BondRow = new HTuple(), hv_BondCol = new HTuple();
            HTuple hv_Row1 = new HTuple(), hv_Column1 = new HTuple();
            HTuple hv_Phi = new HTuple(), hv_Length1 = new HTuple();
            HTuple hv_Length2 = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_BondContour);
            HOperatorSet.GenEmptyObj(out ho_EmptyReg);
            HOperatorSet.GenEmptyObj(out ho_i_Image);
            HOperatorSet.GenEmptyObj(out ho__BondContour);
            HOperatorSet.GenEmptyObj(out ho_EmptyRegion);
            HOperatorSet.GenEmptyObj(out ho_RegionDilation);
            HOperatorSet.GenEmptyObj(out ho_Circle);
            HOperatorSet.GenEmptyObj(out ho_RegionErosion);
            HOperatorSet.GenEmptyObj(out ho_Rectangle);
            try
            {
                //********************************************************************************************************
                //--函数：HTV_Gen_Bond_threshold
                //--作用：检测区域内使用阈值分割方法获取焊点位置
                //--参数：
                //==图标参数：
                // i_Imgs:输入检测需要的图像集
                // i_BondInspectReg:检测区域
                // o_BondContour:区域内检测到的焊点区域
                //==控制参数：
                // i_ImgIdx:j检测区域内检测需要图集的图像索引号
                // i_BallType:焊点类别：一般为circle或ellipse
                // i_ThreshGray:检测区域内需要的检测阈值
                // i_ClosingSize:分割区域内闭运算尺寸
                // i_BondOverSizeFactor:检测到的焊点区域过大尺度阈值
                // i_BondUnderSizeFactor:检测到的焊点区域过小尺度阈值
                // o_BondRow:焊点行坐标
                // o_BondCol:焊点列坐标
                // o_ErrCode:错误码
                // o_ErrStr:错误信息
                //*******************************************************************************************************
                //初始化
                //
                ho_EmptyReg.Dispose();
                HOperatorSet.GenEmptyRegion(out ho_EmptyReg);
                ho_o_BondContour.Dispose();
                ho_o_BondContour = ho_EmptyReg.CopyObj(1, -1);
                //
                hv_o_BondRow = new HTuple();
                hv_o_BondCol = new HTuple();
                //
                hv_o_ErrCode = -2;
                hv_o_ErrStr = "Initializing";
                //
                //输入有效性测试
                HOperatorSet.CountObj(ho_i_Imgs, out hv_imgNum);
                if ((int)(new HTuple(hv_imgNum.TupleEqual(0))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "input image is null";
                    ho_EmptyReg.Dispose();
                    ho_i_Image.Dispose();
                    ho__BondContour.Dispose();
                    ho_EmptyRegion.Dispose();
                    ho_RegionDilation.Dispose();
                    ho_Circle.Dispose();
                    ho_RegionErosion.Dispose();
                    ho_Rectangle.Dispose();

                    return;
                }
                HOperatorSet.CountObj(ho_i_InspectReg, out hv_regNum);
                if ((int)(new HTuple(hv_regNum.TupleLess(1))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "Bond inspect region empty";
                    ho_EmptyReg.Dispose();
                    ho_i_Image.Dispose();
                    ho__BondContour.Dispose();
                    ho_EmptyRegion.Dispose();
                    ho_RegionDilation.Dispose();
                    ho_Circle.Dispose();
                    ho_RegionErosion.Dispose();
                    ho_Rectangle.Dispose();

                    return;
                }
                if ((int)((new HTuple((new HTuple(hv_i_BallSize.TupleLength())).TupleLess(1))).TupleOr(
                    new HTuple(((hv_i_BallSize.TupleSelect(0))).TupleLess(0)))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "the para i_BallSize must greater than 0";
                    ho_EmptyReg.Dispose();
                    ho_i_Image.Dispose();
                    ho__BondContour.Dispose();
                    ho_EmptyRegion.Dispose();
                    ho_RegionDilation.Dispose();
                    ho_Circle.Dispose();
                    ho_RegionErosion.Dispose();
                    ho_Rectangle.Dispose();

                    return;
                }
                //
                //------------------应用阈值分割进行Bond检测
                //阈值图像选择
                ho_i_Image.Dispose();
                HOperatorSet.SelectObj(ho_i_Imgs, out ho_i_Image, hv_i_ImgIdx);

                ho__BondContour.Dispose();
                HTV_Bond_Threshold(ho_i_Image, ho_i_InspectReg, out ho__BondContour, hv_i_ThreshGray,
                    hv_i_ClosingSize, out hv__ThreErrCode, out hv__ThreErrStr);
                //函数异常
                if ((int)(new HTuple(hv__ThreErrCode.TupleLess(0))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = hv__ThreErrStr.Clone();
                    ho_EmptyReg.Dispose();
                    ho_i_Image.Dispose();
                    ho__BondContour.Dispose();
                    ho_EmptyRegion.Dispose();
                    ho_RegionDilation.Dispose();
                    ho_Circle.Dispose();
                    ho_RegionErosion.Dispose();
                    ho_Rectangle.Dispose();

                    return;
                }
                //
                //获取真实焊点区域
                ho_EmptyRegion.Dispose();
                HOperatorSet.GenEmptyRegion(out ho_EmptyRegion);
                //------确定焊点类型
                //根据焊点类型获取焊点半径
                if ((int)(new HTuple((new HTuple(hv_i_BallSize.TupleLength())).TupleEqual(1))) != 0)
                {
                    ho_RegionDilation.Dispose();
                    HOperatorSet.DilationCircle(ho__BondContour, out ho_RegionDilation, 3.5);
                    //
                    HOperatorSet.InnerCircle(ho_RegionDilation, out hv_Row, out hv_Column, out hv_Radius);
                    ho_Circle.Dispose();
                    HOperatorSet.GenCircle(out ho_Circle, hv_Row, hv_Column, hv_Radius);
                    //
                    hv_BondRow = hv_Row.Clone();
                    hv_BondCol = hv_Column.Clone();
                }
                else
                {
                    ho_RegionErosion.Dispose();
                    HOperatorSet.ErosionCircle(ho__BondContour, out ho_RegionErosion, 1.5);
                    //
                    HOperatorSet.SmallestRectangle2(ho_RegionErosion, out hv_Row1, out hv_Column1,
                        out hv_Phi, out hv_Length1, out hv_Length2);
                    ho_Rectangle.Dispose();
                    HOperatorSet.GenRectangle2(out ho_Rectangle, hv_Row1, hv_Column1, hv_Phi,
                        hv_Length1, hv_Length2);
                    //
                    hv_BondRow = hv_Row1.Clone();
                    hv_BondCol = hv_Column1.Clone();
                }
                //
                if ((int)(new HTuple(hv__ThreErrCode.TupleGreater(0))) != 0)
                {
                    //焊点脱落
                    ho_o_BondContour.Dispose();
                    ho_o_BondContour = ho_EmptyRegion.CopyObj(1, -1);
                }
                else if ((int)(new HTuple(hv__ThreErrCode.TupleEqual(0))) != 0)
                {
                    //
                    hv_o_BondRow = hv_BondRow.Clone();
                    hv_o_BondCol = hv_BondCol.Clone();
                    //
                    ho_o_BondContour.Dispose();
                    ho_o_BondContour = ho__BondContour.CopyObj(1, -1);
                }
                //
                hv_o_ErrCode = 0;
                hv_o_ErrStr = "Bond Location is successful";
                ho_EmptyReg.Dispose();
                ho_i_Image.Dispose();
                ho__BondContour.Dispose();
                ho_EmptyRegion.Dispose();
                ho_RegionDilation.Dispose();
                ho_Circle.Dispose();
                ho_RegionErosion.Dispose();
                ho_Rectangle.Dispose();

                return;












                ho_EmptyReg.Dispose();
                ho_i_Image.Dispose();
                ho__BondContour.Dispose();
                ho_EmptyRegion.Dispose();
                ho_RegionDilation.Dispose();
                ho_Circle.Dispose();
                ho_RegionErosion.Dispose();
                ho_Rectangle.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_EmptyReg.Dispose();
                ho_i_Image.Dispose();
                ho__BondContour.Dispose();
                ho_EmptyRegion.Dispose();
                ho_RegionDilation.Dispose();
                ho_Circle.Dispose();
                ho_RegionErosion.Dispose();
                ho_Rectangle.Dispose();

                throw HDevExpDefaultException;
            }
        }
        public static void HTV_Gen_Bond_measure(HObject ho_i_Imgs, HObject ho_i_InspectReg, out HObject ho_o_BondContour,
            HTuple hv_i_HomMatMod2Img, HTuple hv_i_MeasureIndex, HTuple hv_i_ImgIdx, HTuple hv_i_MeasureType,
            HTuple hv_i_MetrologyHandle, HTuple hv_i_isPreJudge, HTuple hv_i_ThreshGray,
            HTuple hv_i_SegRegAreaFactor, out HTuple hv_o_BondRow, out HTuple hv_o_BondCol,
            out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {




            // Local iconic variables 

            HObject ho_EmptyFailReg, ho_i_Image, ho__BondContour;
            HObject ho_EmptyRegion, ho_RefBondCircle = null, ho__BondImage = null;
            HObject ho_SegReg = null, ho_SegReg0 = null, ho_RegDilation = null;
            HObject ho_RegDiff = null, ho_InspectRegUnion = null, ho_inspectImage = null;
            HObject ho_RefBondEllipse = null;

            // Local control variables 

            HTuple hv_HomMatSum = null, hv_Indices = null;
            HTuple hv__BondRegNum = null, hv__RefBondPara = null, hv__MeasureResult = null;
            HTuple hv__BondParas = null, hv__ErrMeasureCode = null;
            HTuple hv__ErrMeasureStr = null, hv_MetrologyType = null;
            HTuple hv__RefRow = new HTuple(), hv__RefCol = new HTuple();
            HTuple hv_RefRadius = new HTuple(), hv_RefBondRow = new HTuple();
            HTuple hv_RefBondCol = new HTuple(), hv_BondRow = new HTuple();
            HTuple hv_BondCol = new HTuple(), hv_BondRadius = new HTuple();
            HTuple hv_lowThresh = new HTuple(), hv_highThresh = new HTuple();
            HTuple hv_BondAreaAll = new HTuple(), hv_Row0 = new HTuple();
            HTuple hv_Col0 = new HTuple(), hv_BondAreaSeg = new HTuple();
            HTuple hv_Row1 = new HTuple(), hv_Col1 = new HTuple();
            HTuple hv_AreaFactor = new HTuple(), hv_BondAreaSeg0 = new HTuple();
            HTuple hv_DilateSize = new HTuple(), hv_RowIn = new HTuple();
            HTuple hv_ColIn = new HTuple(), hv_RadiusIn = new HTuple();
            HTuple hv_MetrologyHandle1 = new HTuple(), hv_RefLen1 = new HTuple();
            HTuple hv_RefLen2 = new HTuple(), hv_RefTransition = new HTuple();
            HTuple hv_RefThreshold = new HTuple(), hv__RefRadius = new HTuple();
            HTuple hv_MeasureSelect = new HTuple(), hv_DistanceThreshold = new HTuple();
            HTuple hv_AgainIndex = new HTuple(), hv_Parameter = new HTuple();
            HTuple hv_Exception = new HTuple(), hv_RefPhi = new HTuple();
            HTuple hv_RefRadius1 = new HTuple(), hv_RefRadius2 = new HTuple();
            HTuple hv_BondPhi = new HTuple(), hv_BondRadius1 = new HTuple();
            HTuple hv_BondRadius2 = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_BondContour);
            HOperatorSet.GenEmptyObj(out ho_EmptyFailReg);
            HOperatorSet.GenEmptyObj(out ho_i_Image);
            HOperatorSet.GenEmptyObj(out ho__BondContour);
            HOperatorSet.GenEmptyObj(out ho_EmptyRegion);
            HOperatorSet.GenEmptyObj(out ho_RefBondCircle);
            HOperatorSet.GenEmptyObj(out ho__BondImage);
            HOperatorSet.GenEmptyObj(out ho_SegReg);
            HOperatorSet.GenEmptyObj(out ho_SegReg0);
            HOperatorSet.GenEmptyObj(out ho_RegDilation);
            HOperatorSet.GenEmptyObj(out ho_RegDiff);
            HOperatorSet.GenEmptyObj(out ho_InspectRegUnion);
            HOperatorSet.GenEmptyObj(out ho_inspectImage);
            HOperatorSet.GenEmptyObj(out ho_RefBondEllipse);
            try
            {
                //****使用阈值分割的方法进行Bond1检测：1.先判断Bond1是否存在，2.再阈值分割判定Bond1的检测结果
                //----------图标参数
                //i_Image：输入图像
                //i_BondRegs：焊点检测区域（焊盘区域）
                //o_BondContours：检测到的Bond轮廓
                //o_FailRegs：未检测到Bond的缺陷区域
                //-----------控制参数
                //i_MetrologyHandle: 测量模板句柄
                //i_HomMatMod2Img: 测量区域的映射矩阵
                //i_MeasureType: 测量工具类型，允许对同一句柄添加多个测量工具，并分别指定类型，支持4类测量工具————1-直线工具，2-矩形工具，3-圆工具，4-椭圆工具
                //o_BondParas：检测到的Bond位置及半径信息
                //o_DefectValue：输出的实际检测得到的检测值
                //o_DefectType：输出的检测得到缺陷类型
                //o_ErrCode: 错误码，代表该算子执行过程中产生的错误，0-代表正常执行，正整数-代表错误类型(1-未检测到焊点，2-焊点太小，3-焊点太大，4-焊点偏出焊盘)，-1-代表异常，-2-代表未执行
                //o_ErrStr: 错误信息，对各种错误的具体描述
                //*****

                //初始化
                //
                ho_EmptyFailReg.Dispose();
                HOperatorSet.GenEmptyObj(out ho_EmptyFailReg);
                hv_o_BondRow = new HTuple();
                hv_o_BondCol = new HTuple();
                //
                ho_o_BondContour.Dispose();
                ho_o_BondContour = ho_EmptyFailReg.CopyObj(1, -1);
                hv_o_ErrCode = -2;
                hv_o_ErrStr = "Initializing";

                //传入映射矩阵有效性测试
                HOperatorSet.TupleSum(hv_i_HomMatMod2Img, out hv_HomMatSum);
                if ((int)(new HTuple(hv_HomMatSum.TupleEqual(-12))) != 0)
                {
                    hv_o_ErrCode = 1;
                    hv_o_ErrStr = "mapping matrix is invalid!";
                    ho_EmptyFailReg.Dispose();
                    ho_i_Image.Dispose();
                    ho__BondContour.Dispose();
                    ho_EmptyRegion.Dispose();
                    ho_RefBondCircle.Dispose();
                    ho__BondImage.Dispose();
                    ho_SegReg.Dispose();
                    ho_SegReg0.Dispose();
                    ho_RegDilation.Dispose();
                    ho_RegDiff.Dispose();
                    ho_InspectRegUnion.Dispose();
                    ho_inspectImage.Dispose();
                    ho_RefBondEllipse.Dispose();

                    return;
                }
                //输入有效性测试
                //传入映射矩阵有效性测试
                HOperatorSet.TupleSum(hv_i_HomMatMod2Img, out hv_HomMatSum);
                if ((int)(new HTuple(hv_HomMatSum.TupleEqual(-12))) != 0)
                {
                    hv_o_ErrCode = 1;
                    hv_o_ErrStr = "mapping matrix is invalid!";
                    ho_EmptyFailReg.Dispose();
                    ho_i_Image.Dispose();
                    ho__BondContour.Dispose();
                    ho_EmptyRegion.Dispose();
                    ho_RefBondCircle.Dispose();
                    ho__BondImage.Dispose();
                    ho_SegReg.Dispose();
                    ho_SegReg0.Dispose();
                    ho_RegDilation.Dispose();
                    ho_RegDiff.Dispose();
                    ho_InspectRegUnion.Dispose();
                    ho_inspectImage.Dispose();
                    ho_RefBondEllipse.Dispose();

                    return;
                }
                //
                //输入有效性测试
                HOperatorSet.GetMetrologyObjectIndices(hv_i_MetrologyHandle, out hv_Indices);
                hv__BondRegNum = new HTuple(hv_Indices.TupleLength());
                if ((int)(new HTuple(hv__BondRegNum.TupleEqual(0))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "bond region is empty";
                    ho_EmptyFailReg.Dispose();
                    ho_i_Image.Dispose();
                    ho__BondContour.Dispose();
                    ho_EmptyRegion.Dispose();
                    ho_RefBondCircle.Dispose();
                    ho__BondImage.Dispose();
                    ho_SegReg.Dispose();
                    ho_SegReg0.Dispose();
                    ho_RegDilation.Dispose();
                    ho_RegDiff.Dispose();
                    ho_InspectRegUnion.Dispose();
                    ho_inspectImage.Dispose();
                    ho_RefBondEllipse.Dispose();

                    return;
                }

                //
                //Bond参考信息获取
                HOperatorSet.GetMetrologyObjectParam(hv_i_MetrologyHandle, hv_i_MeasureIndex,
                    "object_params", out hv__RefBondPara);
                //
                //------应用测量工具方式进行Bond检测
                //测量图像选择
                ho_i_Image.Dispose();
                HOperatorSet.SelectObj(ho_i_Imgs, out ho_i_Image, hv_i_ImgIdx);
                ho__BondContour.Dispose();
                HTV_Apply_Measurement(ho_i_Image, ho_i_InspectReg, out ho__BondContour, hv_i_MetrologyHandle,
                    hv_i_HomMatMod2Img, hv_i_MeasureIndex, hv_i_MeasureType, out hv__MeasureResult,
                    out hv__BondParas, out hv__ErrMeasureCode, out hv__ErrMeasureStr);
                //函数异常
                if ((int)(new HTuple(hv__ErrMeasureCode.TupleLess(0))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = hv__ErrMeasureStr.Clone();
                    ho_EmptyFailReg.Dispose();
                    ho_i_Image.Dispose();
                    ho__BondContour.Dispose();
                    ho_EmptyRegion.Dispose();
                    ho_RefBondCircle.Dispose();
                    ho__BondImage.Dispose();
                    ho_SegReg.Dispose();
                    ho_SegReg0.Dispose();
                    ho_RegDilation.Dispose();
                    ho_RegDiff.Dispose();
                    ho_InspectRegUnion.Dispose();
                    ho_inspectImage.Dispose();
                    ho_RefBondEllipse.Dispose();

                    return;
                }
                //
                //获取真实焊点区域
                ho_EmptyRegion.Dispose();
                HOperatorSet.GenEmptyRegion(out ho_EmptyRegion);
                //确定测量类型
                hv_MetrologyType = hv_i_MeasureType.TupleSelect(hv_i_MeasureIndex);
                switch (hv_MetrologyType.I)
                {
                    case 1:
                        //直线参数对角端点  4个参数Row, Column, Row, Column
                        break;
                    case 2:
                        //带方向的矩形  5个参数 Row, Column, Phi, Length1, Length2
                        break;
                    case 3:
                        //圆 3个参数 Row1, Column1, Radius1
                        //
                        //Bond参考位置及半径
                        hv__RefRow = hv__RefBondPara[0];
                        hv__RefCol = hv__RefBondPara[1];
                        hv_RefRadius = hv__RefBondPara[2];
                        HOperatorSet.AffineTransPoint2d(hv_i_HomMatMod2Img, hv__RefRow, hv__RefCol,
                            out hv_RefBondRow, out hv_RefBondCol);
                        //
                        //Bond实际测量
                        hv_BondRow = hv__BondParas[0];
                        hv_BondCol = hv__BondParas[1];
                        hv_BondRadius = hv__BondParas[2];
                        //
                        //***************************************************************
                        //焊点内部阈值分割复判
                        if ((int)(hv_i_isPreJudge) != 0)
                        {
                            //为了避免检测的空心焊盘当做焊球
                            if ((int)(new HTuple(hv__MeasureResult.TupleEqual(0))) != 0)
                            {
                                hv_lowThresh = hv_i_ThreshGray[0];
                                hv_highThresh = hv_i_ThreshGray[1];
                                ho_RefBondCircle.Dispose();
                                HOperatorSet.GenCircle(out ho_RefBondCircle, hv_RefBondRow, hv_RefBondCol,
                                    hv_RefRadius);
                                ho__BondImage.Dispose();
                                HOperatorSet.ReduceDomain(ho_i_Imgs, ho_RefBondCircle, out ho__BondImage
                                    );
                                ho_SegReg.Dispose();
                                HOperatorSet.Threshold(ho__BondImage, out ho_SegReg, hv_lowThresh, hv_highThresh);
                                HOperatorSet.AreaCenter(ho_RefBondCircle, out hv_BondAreaAll, out hv_Row0,
                                    out hv_Col0);
                                HOperatorSet.AreaCenter(ho_SegReg, out hv_BondAreaSeg, out hv_Row1, out hv_Col1);
                                hv_AreaFactor = (hv_BondAreaSeg * 1.0) / hv_BondAreaAll;
                                //
                                if ((int)(new HTuple(hv_AreaFactor.TupleGreater(hv_i_SegRegAreaFactor))) != 0)
                                {
                                    //若分割区域面积过大，则判定焊点检测失败
                                    hv__MeasureResult = 1;
                                }
                                else if ((int)(new HTuple(hv_AreaFactor.TupleGreater(hv_i_SegRegAreaFactor / 2))) != 0)
                                {
                                    //若分割区域面积一般，则偏移模板中心重新测量
                                    ho__BondImage.Dispose();
                                    HOperatorSet.ReduceDomain(ho_i_Imgs, ho__BondContour, out ho__BondImage
                                        );
                                    ho_SegReg0.Dispose();
                                    HOperatorSet.Threshold(ho__BondImage, out ho_SegReg0, hv_lowThresh,
                                        hv_highThresh);
                                    HOperatorSet.AreaCenter(ho_SegReg0, out hv_BondAreaSeg0, out hv_Row1,
                                        out hv_Col1);

                                    if ((int)(new HTuple(hv_BondAreaSeg0.TupleGreater(hv_BondAreaSeg / 2))) != 0)
                                    {
                                        //测量中心为分割后剩余区域中心
                                        hv_DilateSize = hv_RefRadius / 2;
                                        ho_RegDilation.Dispose();
                                        HOperatorSet.DilationCircle(ho_SegReg, out ho_RegDilation, hv_DilateSize);
                                        ho_RegDiff.Dispose();
                                        HOperatorSet.Difference(ho_RefBondCircle, ho_RegDilation, out ho_RegDiff
                                            );
                                        if ((int)(new HTuple(ho_RegDiff.TestEqualObj(ho_EmptyRegion))) != 0)
                                        {
                                            ho_RegDiff.Dispose();
                                            HOperatorSet.Difference(ho_RefBondCircle, ho_SegReg, out ho_RegDiff
                                                );
                                            HOperatorSet.InnerCircle(ho_RegDiff, out hv_RowIn, out hv_ColIn,
                                                out hv_RadiusIn);
                                        }
                                        else
                                        {
                                            HOperatorSet.InnerCircle(ho_RegDiff, out hv_RowIn, out hv_ColIn,
                                                out hv_RadiusIn);
                                        }
                                        //gen_cross_contour_xld (cross, RowIn, ColIn, 4, 0)

                                        //偏移测量卡尺再次测量
                                        HOperatorSet.CreateMetrologyModel(out hv_MetrologyHandle1);
                                        //模板参数
                                        HOperatorSet.GetMetrologyObjectParam(hv_i_MetrologyHandle, hv_i_MeasureIndex,
                                            "measure_length1", out hv_RefLen1);
                                        HOperatorSet.GetMetrologyObjectParam(hv_i_MetrologyHandle, hv_i_MeasureIndex,
                                            "measure_length2", out hv_RefLen2);
                                        HOperatorSet.GetMetrologyObjectParam(hv_i_MetrologyHandle, hv_i_MeasureIndex,
                                            "measure_transition", out hv_RefTransition);
                                        HOperatorSet.GetMetrologyObjectParam(hv_i_MetrologyHandle, hv_i_MeasureIndex,
                                            "measure_threshold", out hv_RefThreshold);
                                        HOperatorSet.GetMetrologyObjectParam(hv_i_MetrologyHandle, hv_i_MeasureIndex,
                                            "radius", out hv__RefRadius);
                                        HOperatorSet.GetMetrologyObjectParam(hv_i_MetrologyHandle, hv_i_MeasureIndex,
                                            "measure_select", out hv_MeasureSelect);
                                        HOperatorSet.GetMetrologyObjectParam(hv_i_MetrologyHandle, hv_i_MeasureIndex,
                                            "distance_threshold", out hv_DistanceThreshold);
                                        //
                                        HOperatorSet.AddMetrologyObjectCircleMeasure(hv_MetrologyHandle1,
                                            hv_RowIn, hv_ColIn, hv__RefRadius, hv_RefLen1, hv_RefLen2, 1,
                                            hv_RefThreshold, ((new HTuple("measure_transition")).TupleConcat(
                                            "measure_distance")).TupleConcat("min_score"), ((hv_RefTransition.TupleConcat(
                                            1.5 * hv_RefLen2))).TupleConcat(0.5), out hv_AgainIndex);

                                        HOperatorSet.SetMetrologyObjectParam(hv_MetrologyHandle1, hv_AgainIndex,
                                            "measure_select", hv_MeasureSelect);
                                        HOperatorSet.SetMetrologyObjectParam(hv_MetrologyHandle1, hv_AgainIndex,
                                            "distance_threshold", hv_DistanceThreshold);

                                        ho_InspectRegUnion.Dispose();
                                        HOperatorSet.Union1(ho_i_InspectReg, out ho_InspectRegUnion);
                                        ho_inspectImage.Dispose();
                                        HOperatorSet.ReduceDomain(ho_i_Imgs, ho_InspectRegUnion, out ho_inspectImage
                                            );
                                        try
                                        {
                                            HOperatorSet.ApplyMetrologyModel(ho_inspectImage, hv_MetrologyHandle1);
                                            HOperatorSet.GetMetrologyObjectResult(hv_MetrologyHandle1, hv_AgainIndex,
                                                "all", "result_type", "all_param", out hv_Parameter);

                                            //get_metrology_object_measures (Contours1, MetrologyHandle1, 'all', 'all', Row1, Column1)
                                            //gen_cross_contour_xld (Cross, Row1, Column1, 3, 0.785398)
                                        }
                                        // catch (Exception) 
                                        catch (HalconException HDevExpDefaultException1)
                                        {
                                            HDevExpDefaultException1.ToHTuple(out hv_Exception);
                                            hv_Parameter = new HTuple();
                                        }
                                        HOperatorSet.ClearMetrologyModel(hv_MetrologyHandle1);

                                        if ((int)(new HTuple((new HTuple(hv_Parameter.TupleLength())).TupleLess(
                                            3))) != 0)
                                        {
                                            hv__MeasureResult = 1;
                                        }
                                        else
                                        {
                                            hv__MeasureResult = 0;
                                            ho__BondContour.Dispose();
                                            HOperatorSet.GenCircle(out ho__BondContour, hv_Parameter.TupleSelect(
                                                0), hv_Parameter.TupleSelect(1), hv_Parameter.TupleSelect(2));

                                            //更新Bond实际测量
                                            hv_BondRow = hv_Parameter[0];
                                            hv_BondCol = hv_Parameter[1];
                                            hv_BondRadius = hv_Parameter[2];
                                        }
                                    }
                                }
                            }
                        }
                        //***************************************************************
                        //
                        break;
                    case 4:
                        //椭圆 5个参数 Row, Column, Phi, Radius1, Radius2
                        hv__RefRow = hv__RefBondPara[0];
                        hv__RefCol = hv__RefBondPara[1];
                        hv_RefPhi = hv__RefBondPara[2];
                        hv_RefRadius1 = hv__RefBondPara[3];
                        hv_RefRadius2 = hv__RefBondPara[4];
                        hv_RefRadius = (hv_RefRadius1 + hv_RefRadius2) / 2;
                        HOperatorSet.AffineTransPoint2d(hv_i_HomMatMod2Img, hv__RefRow, hv__RefCol,
                            out hv_RefBondRow, out hv_RefBondCol);
                        //
                        //bond实际测量
                        hv_BondRow = hv__BondParas[0];
                        hv_BondCol = hv__BondParas[1];
                        hv_BondPhi = hv__BondParas[2];
                        hv_BondRadius1 = hv__BondParas[3];
                        hv_BondRadius2 = hv__BondParas[4];
                        //与阈值分割方法保持一致，使用椭圆的短半径作为过大过小判断标准
                        hv_BondRadius = hv_BondRadius2.Clone();
                        //
                        //***************************************************************
                        //焊点内部阈值分割复判
                        if ((int)(hv_i_isPreJudge) != 0)
                        {
                            //为了避免检测的空心焊盘当做焊球
                            if ((int)(new HTuple(hv__MeasureResult.TupleEqual(0))) != 0)
                            {
                                hv_lowThresh = hv_i_ThreshGray[0];
                                hv_highThresh = hv_i_ThreshGray[1];
                                ho_RefBondEllipse.Dispose();
                                HOperatorSet.GenEllipse(out ho_RefBondEllipse, hv_RefBondRow, hv_RefBondCol,
                                    hv_RefPhi, hv_RefRadius1, hv_RefRadius2);
                                ho__BondImage.Dispose();
                                HOperatorSet.ReduceDomain(ho_i_Imgs, ho_RefBondEllipse, out ho__BondImage
                                    );
                                ho_SegReg.Dispose();
                                HOperatorSet.Threshold(ho__BondImage, out ho_SegReg, hv_lowThresh, hv_highThresh);
                                HOperatorSet.AreaCenter(ho_RefBondEllipse, out hv_BondAreaAll, out hv_Row0,
                                    out hv_Col0);
                                HOperatorSet.AreaCenter(ho_SegReg, out hv_BondAreaSeg, out hv_Row1, out hv_Col1);
                                hv_AreaFactor = (hv_BondAreaSeg * 1.0) / hv_BondAreaAll;
                                //
                                if ((int)(new HTuple(hv_AreaFactor.TupleGreater(hv_i_SegRegAreaFactor))) != 0)
                                {
                                    hv__MeasureResult = 1;
                                }
                            }
                        }
                        //***************************************************************
                        //
                        break;
                }

                //分析焊点
                if ((int)(new HTuple(hv__MeasureResult.TupleGreater(0))) != 0)
                {
                    ho_o_BondContour.Dispose();
                    ho_o_BondContour = ho_EmptyRegion.CopyObj(1, -1);
                }
                else if ((int)(new HTuple(hv__MeasureResult.TupleEqual(0))) != 0)
                {
                    //
                    hv_o_BondRow = hv_BondRow.Clone();
                    hv_o_BondCol = hv_BondCol.Clone();
                    //
                    ho_o_BondContour.Dispose();
                    ho_o_BondContour = ho__BondContour.CopyObj(1, -1);
                }
                //输出执行结果
                hv_o_ErrCode = 0;
                hv_o_ErrStr = "Bond Location is successful";
                ho_EmptyFailReg.Dispose();
                ho_i_Image.Dispose();
                ho__BondContour.Dispose();
                ho_EmptyRegion.Dispose();
                ho_RefBondCircle.Dispose();
                ho__BondImage.Dispose();
                ho_SegReg.Dispose();
                ho_SegReg0.Dispose();
                ho_RegDilation.Dispose();
                ho_RegDiff.Dispose();
                ho_InspectRegUnion.Dispose();
                ho_inspectImage.Dispose();
                ho_RefBondEllipse.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_EmptyFailReg.Dispose();
                ho_i_Image.Dispose();
                ho__BondContour.Dispose();
                ho_EmptyRegion.Dispose();
                ho_RefBondCircle.Dispose();
                ho__BondImage.Dispose();
                ho_SegReg.Dispose();
                ho_SegReg0.Dispose();
                ho_RegDilation.Dispose();
                ho_RegDiff.Dispose();
                ho_InspectRegUnion.Dispose();
                ho_inspectImage.Dispose();
                ho_RefBondEllipse.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public static void HTV_Gen_Bond_model(HObject ho_i_Imgs, HObject ho_i_ModelImg, HObject ho_i_InspectReg,
            out HObject ho_o_BondContour, HTuple hv_i_ImgIdx, HTuple hv_i_BondNum, HTuple hv_i_ModelType,
            HTuple hv_i_ModelID, HTuple hv_i_Score, HTuple hv_i_AngleStart, HTuple hv_i_AngleExt,
            HTuple hv_i_BondSize, HTuple hv_i_IsBondRegRefine, HTuple hv_i_AddNum, HTuple hv_i_OverLap,
            HTuple hv_i_MinHistScore, out HTuple hv_o_BondRows, out HTuple hv_o_BondCols,
            out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {




            // Local iconic variables 

            HObject ho_EmptyObject, ho_i_Image, ho__BondContour = null;
            HObject ho_EmptyRegion;

            // Local control variables 

            HTuple hv__BondRegNum = null, hv_ImgNum = null;
            HTuple hv_ModelImgNum = null, hv__BondRows = new HTuple();
            HTuple hv__BondCols = new HTuple(), hv__ErrCode = new HTuple();
            HTuple hv__ErrStr = new HTuple(), hv__MatchScore = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_BondContour);
            HOperatorSet.GenEmptyObj(out ho_EmptyObject);
            HOperatorSet.GenEmptyObj(out ho_i_Image);
            HOperatorSet.GenEmptyObj(out ho__BondContour);
            HOperatorSet.GenEmptyObj(out ho_EmptyRegion);
            try
            {
                //**************************************************************************************************
                //---函数：HTV_Gen_Bond_Region
                //---作用：快速生成焊点区域
                //===图标参数
                //  i_Image：输入图像
                //  i_InspectRegs：Bond检测区域
                //  o_BondContours：检测到的Bond轮廓
                //  o_BondRegs：生成Bond的区域
                //  o_BondLines：Bond区域参考方向
                //===控制参数
                //  i_HomMatMod2Img: 检测区域的映射矩阵
                //  i_BondNum：定位区域内Bond的数量
                //  i_ModelType: 模板类型，一般使用ncc和shape定位模板，该参数为整型类型，0-ncc，1-shape
                //  i_ModelID: 模板ID号，创建匹配模板时返回值，通常由模板文件读入
                //  i_Score: 最小匹配分数
                //  i_AngleStart: 匹配定位起始角度
                //  i_AngleExt: 匹配定位角度范围
                //  i_BondSize：焊点半径大小
                //  o_BondParas：bond位置信息
                //  o_ErrCode: 错误码，代表该算子执行过程中产生的错误
                //  o_ErrStr: 错误信息，对各种错误的具体描述
                //**************************************************************************************************
                //初始化
                ho_EmptyObject.Dispose();
                HOperatorSet.GenEmptyObj(out ho_EmptyObject);
                //
                ho_o_BondContour.Dispose();
                ho_o_BondContour = ho_EmptyObject.CopyObj(1, -1);
                //
                hv_o_BondRows = new HTuple();
                hv_o_BondCols = new HTuple();
                //
                hv_o_ErrCode = -2;
                hv_o_ErrStr = "Initializing";

                //输入有效性测试
                HOperatorSet.CountObj(ho_i_InspectReg, out hv__BondRegNum);
                if ((int)(new HTuple(hv__BondRegNum.TupleEqual(0))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "bond region is empty";
                    ho_EmptyObject.Dispose();
                    ho_i_Image.Dispose();
                    ho__BondContour.Dispose();
                    ho_EmptyRegion.Dispose();

                    return;
                }
                HOperatorSet.CountObj(ho_i_Imgs, out hv_ImgNum);
                if ((int)(new HTuple(hv_ImgNum.TupleEqual(0))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "bond Image is empty";
                    ho_EmptyObject.Dispose();
                    ho_i_Image.Dispose();
                    ho__BondContour.Dispose();
                    ho_EmptyRegion.Dispose();

                    return;
                }
                HOperatorSet.CountObj(ho_i_ModelImg, out hv_ModelImgNum);
                if ((int)(new HTuple(hv_ModelImgNum.TupleEqual(0))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "bond ModelImgNum is empty";
                    ho_EmptyObject.Dispose();
                    ho_i_Image.Dispose();
                    ho__BondContour.Dispose();
                    ho_EmptyRegion.Dispose();

                    return;
                }
                //区域内检测图层获取
                ho_i_Image.Dispose();
                HOperatorSet.SelectObj(ho_i_Imgs, out ho_i_Image, hv_i_ImgIdx);

                if ((int)(hv_i_IsBondRegRefine) != 0)
                {
                    //通过直方图相似性择优选择检测结果
                    ho__BondContour.Dispose();
                    HTV_Bond_Location_Refine(ho_i_Image, ho_i_ModelImg, ho_i_InspectReg, out ho__BondContour,
                        hv_i_BondNum, hv_i_ModelType, hv_i_ModelID, hv_i_Score, hv_i_OverLap,
                        hv_i_AngleStart, hv_i_AngleExt, hv_i_BondSize, hv_i_AddNum, hv_i_MinHistScore,
                        out hv__BondRows, out hv__BondCols, out hv__ErrCode, out hv__ErrStr);
                }
                else
                {
                    //根据预设匹配数目检测
                    ho__BondContour.Dispose();
                    HTV_Bond_Location(ho_i_Image, ho_i_InspectReg, out ho__BondContour, hv_i_BondNum,
                        hv_i_ModelType, hv_i_ModelID, hv_i_Score, hv_i_AngleStart, hv_i_AngleExt,
                        hv_i_BondSize, out hv__MatchScore, out hv__BondRows, out hv__BondCols,
                        out hv__ErrCode, out hv__ErrStr);
                }
                //出现异常
                if ((int)(new HTuple(hv__ErrCode.TupleLess(0))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = hv__ErrStr.Clone();
                    ho_EmptyObject.Dispose();
                    ho_i_Image.Dispose();
                    ho__BondContour.Dispose();
                    ho_EmptyRegion.Dispose();

                    return;
                }
                ho_EmptyRegion.Dispose();
                HOperatorSet.GenEmptyRegion(out ho_EmptyRegion);
                //
                if ((int)(new HTuple(hv__ErrCode.TupleGreater(0))) != 0)
                {
                    ho_o_BondContour.Dispose();
                    ho_o_BondContour = ho__BondContour.CopyObj(1, -1);
                }
                else
                {
                    hv_o_BondRows = hv__BondRows.Clone();
                    hv_o_BondCols = hv__BondCols.Clone();
                    //
                    ho_o_BondContour.Dispose();
                    ho_o_BondContour = ho__BondContour.CopyObj(1, -1);
                }
                //
                hv_o_ErrCode = 0;
                hv_o_ErrStr = "Bond Regions gen success ";
                ho_EmptyObject.Dispose();
                ho_i_Image.Dispose();
                ho__BondContour.Dispose();
                ho_EmptyRegion.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_EmptyObject.Dispose();
                ho_i_Image.Dispose();
                ho__BondContour.Dispose();
                ho_EmptyRegion.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public static void HTV_Gen_Ball_UserRegion(HObject ho_i_Imgs, HObject ho_i_DieReg, out HObject ho_o_UserBallRegions,
            HTuple hv_i_UserBallBelongTo, HTuple hv_i_ModelPath, HTuple hv_i_RecipePath,
            HTuple hv_i_BallSize, out HTuple hv_o_BallRows, out HTuple hv_o_BallCols, out HTuple hv_o_ErrCode,
            out HTuple hv_o_ErrStr)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho__InspectReg = null, ho__ModelImg = null;
            HObject ho__BondInspectRegs = null, ho__BondInspectReg = null;
            HObject ho__BondContour = null, ho_Circle = null;

            HObjectVector hvec__BondObjs = new HObjectVector(2);
            HObjectVector hvec__InspectObj = new HObjectVector(1);

            // Local control variables 

            HTuple hv_balldModelItem = null, hv_userBallNum = null;
            HTuple hv_Files = null, hv_Matches = null, hv_ItemFiles = null;
            HTuple hv_idx = null, hv_userRegTo = new HTuple(), hv_BondItem = new HTuple();
            HTuple hv__BondModelPath = null, hv__BondErrCode = null;
            HTuple hv__BondErrStr = null, hv__BondRecipe = null, hv__recipeErrCode = null;
            HTuple hv__recipeErrStr = null, hv_ballIdx = null, hv_BondOnWhat = new HTuple();
            HTuple hv__HomMat2D = new HTuple(), hv__RefLocPara = new HTuple();
            HTuple hv__ErrCode = new HTuple(), hv__ErrStr = new HTuple();
            HTuple hv_BondInspectMethod = new HTuple(), hv__measureType = new HTuple();
            HTuple hv__metrologyHandle = new HTuple(), hv__modelType = new HTuple();
            HTuple hv__modelID = new HTuple(), hv_regNum = new HTuple();
            HTuple hv__BondRows = new HTuple(), hv__BondCols = new HTuple();
            HTuple hv_regidx = new HTuple(), hv__InspectMethod = new HTuple();
            HTuple hv__ImageIdx = new HTuple(), hv__BondSize = new HTuple();
            HTuple hv__ThreshGray = new HTuple(), hv__ClosingSize = new HTuple();
            HTuple hv__BondRow = new HTuple(), hv__BondCol = new HTuple();
            HTuple hv__thresholdErrCode = new HTuple(), hv__thresholdErrStr = new HTuple();
            HTuple hv__BondOverSizeFactor = new HTuple(), hv__BondUnderSizeFactor = new HTuple();
            HTuple hv__isPreJudge = new HTuple(), hv__SegRegAreaFactor = new HTuple();
            HTuple hv__mearsureErrCode = new HTuple(), hv__mearsureErrStr = new HTuple();
            HTuple hv__ballNum_onReg = new HTuple(), hv__matchMinScore = new HTuple();
            HTuple hv__matchAngleStart = new HTuple(), hv__matchAngleExt = new HTuple();
            HTuple hv__bondSize = new HTuple(), hv__IsBondRegRefine = new HTuple();
            HTuple hv__AddNum = new HTuple(), hv__OverLap = new HTuple();
            HTuple hv__MinHistScore = new HTuple(), hv__modelErrCode = new HTuple();
            HTuple hv__modelErrStr = new HTuple();

            HTupleVector hvec__BondModels = new HTupleVector(2);
            HTupleVector hvec__BondParameters = new HTupleVector(3), hvec__BondInspectParas = new HTupleVector(4);
            HTupleVector hvec__InspectModel = new HTupleVector(1), hvec__BondParas = new HTupleVector(2);
            HTupleVector hvec__RegInspectParas = new HTupleVector(1);
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_UserBallRegions);
            HOperatorSet.GenEmptyObj(out ho__InspectReg);
            HOperatorSet.GenEmptyObj(out ho__ModelImg);
            HOperatorSet.GenEmptyObj(out ho__BondInspectRegs);
            HOperatorSet.GenEmptyObj(out ho__BondInspectReg);
            HOperatorSet.GenEmptyObj(out ho__BondContour);
            HOperatorSet.GenEmptyObj(out ho_Circle);
            try
            {
                //***************************************
                //---函数：HTV_Gen_Bond_Region
                //---作用：快速生成焊点区域
                //===图标参数
                //  i_Imgs：输入图像的图像集
                //  o_UserBallRegions：生成Bond的区域
                //===控制参数
                //  i_UserBallBelongTo: Ball检测模板类别集合
                //  i_ModelPath：检测项目Models集合
                //  i_RecipePath：检测项目Recipe集合
                //  i_BallSize：生成Ball区域的半径大小
                //  o_BallRows：Ball的行坐标
                //  o_BallCols：Ball的列坐标
                //  o_ErrCode: 错误码，代表该算子执行过程中产生的错误
                //  o_ErrStr: 错误信息，对各种错误的具体描述
                //******************************************
                //
                //初始化
                ho_o_UserBallRegions.Dispose();
                HOperatorSet.GenEmptyObj(out ho_o_UserBallRegions);

                //
                hv_o_BallRows = new HTuple();
                hv_o_BallCols = new HTuple();
                //
                hv_o_ErrCode = -2;
                hv_o_ErrStr = "Initializing";

                //***************************************读取_BondModel下所有的模板文件
                //
                hv_balldModelItem = new HTuple();

                hv_userBallNum = new HTuple(hv_i_UserBallBelongTo.TupleLength());

                HOperatorSet.ListFiles(hv_i_ModelPath, "directories", out hv_Files);
                //获取Models下的模板项目数组
                HOperatorSet.TupleRegexpMatch(hv_Files, "Models.*", out hv_Matches);
                HOperatorSet.TupleRegexpReplace(hv_Matches, new HTuple("Models/") + "*", "",
                    out hv_ItemFiles);

                //提取与StartRegToWhat相同的balldModelPath
                HTuple end_val39 = hv_userBallNum - 1;
                HTuple step_val39 = 1;
                for (hv_idx = 0; hv_idx.Continue(end_val39, step_val39); hv_idx = hv_idx.TupleAdd(step_val39))
                {
                    hv_userRegTo = hv_i_UserBallBelongTo.TupleSelect(hv_idx);
                    HOperatorSet.TupleRegexpSelect(hv_ItemFiles, hv_userRegTo, out hv_BondItem);
                    hv_balldModelItem = hv_balldModelItem.TupleConcat(hv_BondItem);
                }
                //读取金线检测起始区域所在的所有BondModels
                hv__BondModelPath = hv_i_ModelPath + hv_balldModelItem;

                hvec__BondObjs.Dispose();
                HTV_read_bond_model(out hvec__BondObjs, hv__BondModelPath, out hvec__BondModels,
                    out hv__BondErrCode, out hv__BondErrStr);
                hv__BondRecipe = hv_i_RecipePath + hv_balldModelItem;
                HTV_read_bond_recipe(hv__BondRecipe, out hvec__BondParameters, out hv__recipeErrCode,
                    out hv__recipeErrStr);
                //
                //整合Models下bond的参数与xml中的检测参数
                hvec__BondInspectParas = ((new HTupleVector(4).Insert(0, (new HTupleVector(3).Insert(0, hvec__BondModels)))).Insert(
                    1, hvec__BondParameters));
                //
                //---------------------------------------gen_BallReg--------------------------
                //
                HTuple end_val56 = hv_userBallNum - 1;
                HTuple step_val56 = 1;
                for (hv_ballIdx = 0; hv_ballIdx.Continue(end_val56, step_val56); hv_ballIdx = hv_ballIdx.TupleAdd(step_val56))
                {
                    //
                    //--------获取bond检测对象参数
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        //hvec__InspectObj = dh.Take(hvec__BondObjs[hv_ballIdx]);
                        hvec__InspectObj = hvec__BondObjs.At(hv_ballIdx).Clone();
                    }
                    //检测区域
                    ho__InspectReg.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho__InspectReg = hvec__InspectObj[0].O.CopyObj(1, -1);
                    }

                    //-------获取bond检测model参数
                    hvec__InspectModel = hvec__BondInspectParas[0][0][hv_ballIdx];
                    //选择bond所属区域
                    hv_BondOnWhat = hvec__InspectModel[0].T.Clone();
                    //获取bond检测需要的映射矩阵
                    HTV_confirm_mapping_matrix(ho_i_Imgs, ho_i_DieReg, hv_i_ModelPath, hv_i_RecipePath,
                        hv_BondOnWhat, out hv__HomMat2D, out hv__RefLocPara, out hv__ErrCode,
                        out hv__ErrStr);
                    if ((int)(new HTuple(hv__ErrCode.TupleEqual(0))) != 0)
                    {
                        //
                        //获取bond模板类型：0-match;1-measure
                        hv_BondInspectMethod = hvec__InspectModel[1].T.Clone();
                        //输出类型带入Wire检测
                        if ((int)(new HTuple(hv_BondInspectMethod.TupleEqual(1))) != 0)
                        {
                            //
                            //获取检测测量模板参数
                            hv__measureType = hvec__InspectModel[2].T.Clone();
                            hv__metrologyHandle = hvec__InspectModel[3].T.Clone();
                        }
                        else
                        {
                            //获取检测匹配模板参数
                            //模板旋正图像
                            ho__ModelImg.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                ho__ModelImg = hvec__InspectObj[1].O.CopyObj(1, -1);
                            }
                            //
                            hv__modelType = hvec__InspectModel[2].T.Clone();
                            hv__modelID = hvec__InspectModel[3].T.Clone();

                        }
                        //-----获取Bond检测参数
                        hvec__BondParas = hvec__BondInspectParas[1][hv_ballIdx];
                        //
                        //*******************************************检测区域内选择合适方法进行检测*************************************
                        //获取焊点映射后的检测区域
                        ho__BondInspectRegs.Dispose();
                        HOperatorSet.AffineTransRegion(ho__InspectReg, out ho__BondInspectRegs,
                            hv__HomMat2D, "nearest_neighbor");
                        HOperatorSet.CountObj(ho__BondInspectRegs, out hv_regNum);
                        //初始化输出
                        hv__BondRows = new HTuple();
                        hv__BondCols = new HTuple();
                        //
                        HTuple end_val99 = hv_regNum - 1;
                        HTuple step_val99 = 1;
                        for (hv_regidx = 0; hv_regidx.Continue(end_val99, step_val99); hv_regidx = hv_regidx.TupleAdd(step_val99))
                        {
                            ho__BondInspectReg.Dispose();
                            HOperatorSet.SelectObj(ho__BondInspectRegs, out ho__BondInspectReg, hv_regidx + 1);
                            //获取区域内检测参数
                            hvec__RegInspectParas = hvec__BondParas[hv_regidx];
                            //获取bond检测区域内检测方法:0-threshold,1-measure,2-match
                            hv__InspectMethod = hvec__RegInspectParas[0].T.Clone();
                            //
                            switch (hv__InspectMethod.I)
                            {
                                case 0:
                                    //----阈值分割参数获取
                                    hv__ImageIdx = hvec__RegInspectParas[1].T.Clone();
                                    hv__BondSize = hvec__RegInspectParas[2].T.Clone();
                                    hv__ThreshGray = hvec__RegInspectParas[3].T.Clone();
                                    hv__ClosingSize = hvec__RegInspectParas[4].T.Clone();
                                    //
                                    ho__BondContour.Dispose();
                                    HTV_Gen_Bond_threshold(ho_i_Imgs, ho__BondInspectReg, out ho__BondContour,
                                        hv__ImageIdx, hv__BondSize, hv__ThreshGray, hv__ClosingSize, out hv__BondRow,
                                        out hv__BondCol, out hv__thresholdErrCode, out hv__thresholdErrStr);
                                    //
                                    break;
                                case 1:
                                    //---测量模板参数获取
                                    hv__ImageIdx = hvec__RegInspectParas[1].T.Clone();
                                    hv__BondOverSizeFactor = hvec__RegInspectParas[2].T.Clone();
                                    hv__BondUnderSizeFactor = hvec__RegInspectParas[3].T.Clone();
                                    hv__isPreJudge = hvec__RegInspectParas[4].T.Clone();
                                    hv__ThreshGray = hvec__RegInspectParas[5].T.Clone();
                                    hv__SegRegAreaFactor = hvec__RegInspectParas[6].T.Clone();
                                    //
                                    //开始检测
                                    ho__BondContour.Dispose();
                                    HTV_Gen_Bond_measure(ho_i_Imgs, ho__BondInspectReg, out ho__BondContour,
                                        hv__HomMat2D, hv_regidx, hv__ImageIdx, hv__measureType, hv__metrologyHandle,
                                        hv__isPreJudge, hv__ThreshGray, hv__SegRegAreaFactor, out hv__BondRow,
                                        out hv__BondCol, out hv__mearsureErrCode, out hv__mearsureErrStr);
                                    //

                                    break;
                                case 2:
                                    //---匹配模板参数获取
                                    hv__ImageIdx = hvec__RegInspectParas[1].T.Clone();
                                    hv__ballNum_onReg = hvec__RegInspectParas[2].T.Clone();
                                    hv__matchMinScore = hvec__RegInspectParas[3].T.Clone();
                                    hv__matchAngleStart = hvec__RegInspectParas[4].T.Clone();
                                    hv__matchAngleExt = hvec__RegInspectParas[5].T.Clone();
                                    hv__bondSize = hvec__RegInspectParas[6].T.Clone();
                                    hv__IsBondRegRefine = hvec__RegInspectParas[7].T.Clone();
                                    hv__AddNum = hvec__RegInspectParas[8].T.Clone();
                                    hv__OverLap = hvec__RegInspectParas[9].T.Clone();
                                    hv__MinHistScore = hvec__RegInspectParas[10].T.Clone();
                                    //
                                    //开始检测
                                    ho__BondContour.Dispose();
                                    HTV_Gen_Bond_model(ho_i_Imgs, ho__ModelImg, ho__BondInspectReg, out ho__BondContour,
                                        hv__ImageIdx, hv__ballNum_onReg, hv__modelType, hv__modelID, hv__matchMinScore,
                                        hv__matchAngleStart, hv__matchAngleExt, hv__bondSize, hv__IsBondRegRefine,
                                        hv__AddNum, hv__OverLap, hv__MinHistScore, out hv__BondRow, out hv__BondCol,
                                        out hv__modelErrCode, out hv__modelErrStr);
                                    break;
                            }
                            //整合区域位置
                            hv__BondRows = hv__BondRows.TupleConcat(hv__BondRow);
                            hv__BondCols = hv__BondCols.TupleConcat(hv__BondCol);
                        }
                        //整合所有焊点位置
                        hv_o_BallRows = hv_o_BallRows.TupleConcat(hv__BondRows);
                        hv_o_BallCols = hv_o_BallCols.TupleConcat(hv__BondCols);
                        //清除模板或测量模板
                        if ((int)(new HTuple(hv_BondInspectMethod.TupleEqual(1))) != 0)
                        {
                            //清除测量模板
                            HOperatorSet.ClearMetrologyModel(hv__metrologyHandle);
                        }
                        else
                        {
                            //清除ncc模板
                            HTV_clear_model(hv__modelID, hv__modelType);
                        }
                        //
                    }
                }

                //生成检测到的userBall区域
                for (hv_idx = 0; (int)hv_idx <= (int)((new HTuple(hv_o_BallRows.TupleLength())) - 1); hv_idx = (int)hv_idx + 1)
                {
                    //
                    ho_Circle.Dispose();
                    HOperatorSet.GenCircle(out ho_Circle, hv_o_BallRows.TupleSelect(hv_idx),
                        hv_o_BallCols.TupleSelect(hv_idx), hv_i_BallSize);
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_o_UserBallRegions, ho_Circle, out ExpTmpOutVar_0
                            );
                        ho_o_UserBallRegions.Dispose();
                        ho_o_UserBallRegions = ExpTmpOutVar_0;
                    }
                    //
                }
                //
                hv_o_ErrCode = 0;
                hv_o_ErrStr = "Success to gen use ball region!";
                ho__InspectReg.Dispose();
                ho__ModelImg.Dispose();
                ho__BondInspectRegs.Dispose();
                ho__BondInspectReg.Dispose();
                ho__BondContour.Dispose();
                ho_Circle.Dispose();
                hvec__BondObjs.Dispose();
                hvec__InspectObj.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho__InspectReg.Dispose();
                ho__ModelImg.Dispose();
                ho__BondInspectRegs.Dispose();
                ho__BondInspectReg.Dispose();
                ho__BondContour.Dispose();
                ho_Circle.Dispose();
                hvec__BondObjs.Dispose();
                hvec__InspectObj.Dispose();

                throw HDevExpDefaultException;
            }
        }
        #endregion

        public static void HTV_Gen_Epoxy_InspectReg(HObject ho_i_RefRegion, out HObject ho_o_EpoxyRegs,
            HTuple hv_i_EpoxyHigh, HTuple hv_i_EpoxyLenExpand, HTuple hv_i_EpoxyOffset,
            out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho__EpoxyRectReg1, ho__EpoxyRectReg2;
            HObject ho__EpoxyRectReg3, ho__EpoxyRectReg4;

            // Local control variables 

            HTuple hv_Row = null, hv_Col = null, hv_Phi = null;
            HTuple hv_Len1 = null, hv_Len2 = null, hv_Cos = null, hv_Sin = null;
            HTuple hv_a = null, hv_b = null, hv_Row1 = null, hv_Col1 = null;
            HTuple hv_c = null, hv_d = null, hv_Row2 = null, hv_Col2 = null;
            HTuple hv_e = null, hv_f = null, hv_Row3 = null, hv_Col3 = null;
            HTuple hv_g = null, hv_h = null, hv_Row4 = null, hv_Col4 = null;
            HTuple hv__EpoxyHalfHigh = null, hv__EpoxyOffset = null;
            HTuple hv_Row1Oft = null, hv_Col1Oft = null, hv_CenterRow1 = null;
            HTuple hv_CenterCol1 = null, hv_phi12 = null, hv_dist12 = null;
            HTuple hv_Reg1Len1 = null, hv_Reg1Len2 = null, hv_Row2Oft = null;
            HTuple hv_Col2Oft = null, hv_CenterRow2 = null, hv_CenterCol2 = null;
            HTuple hv_phi23 = null, hv_dist23 = null, hv_Reg2Len1 = null;
            HTuple hv_Reg2Len2 = null, hv_Row3Oft = null, hv_Col3Oft = null;
            HTuple hv_CenterRow3 = null, hv_CenterCol3 = null, hv_phi34 = null;
            HTuple hv_dist34 = null, hv_Reg3Len1 = null, hv_Reg3Len2 = null;
            HTuple hv_Row4Oft = null, hv_Col4Oft = null, hv_CenterRow4 = null;
            HTuple hv_CenterCol4 = null, hv_phi41 = null, hv_dist41 = null;
            HTuple hv_Reg4Len1 = null, hv_Reg4Len2 = null;
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_EpoxyRegs);
            HOperatorSet.GenEmptyObj(out ho__EpoxyRectReg1);
            HOperatorSet.GenEmptyObj(out ho__EpoxyRectReg2);
            HOperatorSet.GenEmptyObj(out ho__EpoxyRectReg3);
            HOperatorSet.GenEmptyObj(out ho__EpoxyRectReg4);
            //**************************************************************************************************
            //---函数：HTV_Gen_Epoxy_InspectReg
            //---作用：根据参考区自动生成银胶区
            //---参数：
            //===图标参数
            //  i_RefRegion：IC参考区
            //  o_EpoxyRegs：Epoxy检测所需要的对象集合：一维集合向量
            //===控制参数
            //  i_EpoxyHigh：银胶区高度
            //  i_EpoxyLenExpand：银胶区相对IC区扩展长度
            //  i_EpoxyOffset：银胶区偏离IC距离
            //  o_ErrCode：错误码
            //  o_ErrStr: 错误信息，对各种错误的具体描述
            //**************************************************************************************************

            hv_o_ErrCode = -2;
            hv_o_ErrStr = "initializing";
            ho_o_EpoxyRegs.Dispose();
            HOperatorSet.GenEmptyObj(out ho_o_EpoxyRegs);

            //输入合法性测试


            //IC参考区方向
            HOperatorSet.SmallestRectangle2(ho_i_RefRegion, out hv_Row, out hv_Col, out hv_Phi,
                out hv_Len1, out hv_Len2);
            HOperatorSet.TupleCos(hv_Phi, out hv_Cos);
            HOperatorSet.TupleSin(hv_Phi, out hv_Sin);

            //端点1
            hv_a = ((-hv_Len1) * hv_Cos) - (hv_Len2 * hv_Sin);
            hv_b = ((-hv_Len1) * hv_Sin) + (hv_Len2 * hv_Cos);
            hv_Row1 = hv_Row - hv_b;
            hv_Col1 = hv_Col + hv_a;
            //gen_cross_contour_xld (Cross, Row1, Col1, 16, rad(45))

            //
            //端点2
            hv_c = (hv_Len1 * hv_Cos) - (hv_Len2 * hv_Sin);
            hv_d = (hv_Len1 * hv_Sin) + (hv_Len2 * hv_Cos);
            hv_Row2 = hv_Row - hv_d;
            hv_Col2 = hv_Col + hv_c;
            //gen_cross_contour_xld (Cross, Row2, Col2, 16, rad(45))

            //
            //端点3
            hv_e = (hv_Len1 * hv_Cos) + (hv_Len2 * hv_Sin);
            hv_f = (hv_Len1 * hv_Sin) - (hv_Len2 * hv_Cos);
            hv_Row3 = hv_Row - hv_f;
            hv_Col3 = hv_Col + hv_e;
            //gen_cross_contour_xld (Cross, Row3, Col3, 16, rad(45))

            //
            //端点4
            hv_g = ((-hv_Len1) * hv_Cos) + (hv_Len2 * hv_Sin);
            hv_h = ((-hv_Len1) * hv_Sin) - (hv_Len2 * hv_Cos);
            hv_Row4 = hv_Row - hv_h;
            hv_Col4 = hv_Col + hv_g;
            //gen_cross_contour_xld (Cross, Row4, Col4, 16, rad(45))

            hv__EpoxyHalfHigh = hv_i_EpoxyHigh / 2;
            hv__EpoxyOffset = hv__EpoxyHalfHigh + hv_i_EpoxyOffset;

            //第一条边
            hv_Row1Oft = (-1 * hv__EpoxyOffset) * hv_Cos;
            hv_Col1Oft = (-1 * hv__EpoxyOffset) * hv_Sin;
            hv_CenterRow1 = ((hv_Row1 + hv_Row2) / 2) + hv_Row1Oft;
            hv_CenterCol1 = ((hv_Col1 + hv_Col2) / 2) + hv_Col1Oft;
            HOperatorSet.LineOrientation(hv_Row1, hv_Col1, hv_Row2, hv_Col2, out hv_phi12);
            HOperatorSet.DistancePp(hv_Row1, hv_Col1, hv_Row2, hv_Col2, out hv_dist12);
            hv_Reg1Len1 = (((hv_dist12 / 2) + hv_i_EpoxyLenExpand)).TupleMax2(hv__EpoxyHalfHigh);
            hv_Reg1Len2 = (((hv_dist12 / 2) + hv_i_EpoxyLenExpand)).TupleMin2(hv__EpoxyHalfHigh);
            ho__EpoxyRectReg1.Dispose();
            HOperatorSet.GenRectangle2(out ho__EpoxyRectReg1, hv_CenterRow1, hv_CenterCol1,
                hv_phi12, hv_Reg1Len1, hv_Reg1Len2);

            {
                HObject ExpTmpOutVar_0;
                HOperatorSet.ConcatObj(ho_o_EpoxyRegs, ho__EpoxyRectReg1, out ExpTmpOutVar_0);
                ho_o_EpoxyRegs.Dispose();
                ho_o_EpoxyRegs = ExpTmpOutVar_0;
            }

            //第二条边
            hv_Row2Oft = (-1 * hv__EpoxyOffset) * hv_Sin;
            hv_Col2Oft = hv__EpoxyOffset * hv_Cos;
            hv_CenterRow2 = ((hv_Row2 + hv_Row3) / 2) + hv_Row2Oft;
            hv_CenterCol2 = ((hv_Col2 + hv_Col3) / 2) + hv_Col2Oft;
            HOperatorSet.LineOrientation(hv_Row2, hv_Col2, hv_Row3, hv_Col3, out hv_phi23);
            HOperatorSet.DistancePp(hv_Row2, hv_Col2, hv_Row3, hv_Col3, out hv_dist23);
            hv_Reg2Len1 = (((hv_dist23 / 2) + hv_i_EpoxyLenExpand)).TupleMax2(hv__EpoxyHalfHigh);
            hv_Reg2Len2 = (((hv_dist23 / 2) + hv_i_EpoxyLenExpand)).TupleMin2(hv__EpoxyHalfHigh);
            ho__EpoxyRectReg2.Dispose();
            HOperatorSet.GenRectangle2(out ho__EpoxyRectReg2, hv_CenterRow2, hv_CenterCol2,
                hv_phi23, hv_Reg2Len1, hv_Reg2Len2);

            {
                HObject ExpTmpOutVar_0;
                HOperatorSet.ConcatObj(ho_o_EpoxyRegs, ho__EpoxyRectReg2, out ExpTmpOutVar_0);
                ho_o_EpoxyRegs.Dispose();
                ho_o_EpoxyRegs = ExpTmpOutVar_0;
            }

            //第三条边
            hv_Row3Oft = hv__EpoxyOffset * hv_Cos;
            hv_Col3Oft = hv__EpoxyOffset * hv_Sin;
            hv_CenterRow3 = ((hv_Row3 + hv_Row4) / 2) + hv_Row3Oft;
            hv_CenterCol3 = ((hv_Col3 + hv_Col4) / 2) + hv_Col3Oft;
            HOperatorSet.LineOrientation(hv_Row3, hv_Col3, hv_Row4, hv_Col4, out hv_phi34);
            HOperatorSet.DistancePp(hv_Row3, hv_Col3, hv_Row4, hv_Col4, out hv_dist34);
            hv_Reg3Len1 = (((hv_dist34 / 2) + hv_i_EpoxyLenExpand)).TupleMax2(hv__EpoxyHalfHigh);
            hv_Reg3Len2 = (((hv_dist34 / 2) + hv_i_EpoxyLenExpand)).TupleMin2(hv__EpoxyHalfHigh);
            ho__EpoxyRectReg3.Dispose();
            HOperatorSet.GenRectangle2(out ho__EpoxyRectReg3, hv_CenterRow3, hv_CenterCol3,
                hv_phi34, hv_Reg3Len1, hv_Reg3Len2);

            {
                HObject ExpTmpOutVar_0;
                HOperatorSet.ConcatObj(ho_o_EpoxyRegs, ho__EpoxyRectReg3, out ExpTmpOutVar_0);
                ho_o_EpoxyRegs.Dispose();
                ho_o_EpoxyRegs = ExpTmpOutVar_0;
            }

            //第四条边
            hv_Row4Oft = hv__EpoxyOffset * hv_Sin;
            hv_Col4Oft = (-1 * hv__EpoxyOffset) * hv_Cos;
            hv_CenterRow4 = ((hv_Row4 + hv_Row1) / 2) + hv_Row4Oft;
            hv_CenterCol4 = ((hv_Col4 + hv_Col1) / 2) + hv_Col4Oft;
            HOperatorSet.LineOrientation(hv_Row4, hv_Col4, hv_Row1, hv_Col1, out hv_phi41);
            HOperatorSet.DistancePp(hv_Row4, hv_Col4, hv_Row1, hv_Col1, out hv_dist41);
            hv_Reg4Len1 = (((hv_dist41 / 2) + hv_i_EpoxyLenExpand)).TupleMax2(hv__EpoxyHalfHigh);
            hv_Reg4Len2 = (((hv_dist41 / 2) + hv_i_EpoxyLenExpand)).TupleMin2(hv__EpoxyHalfHigh);
            ho__EpoxyRectReg4.Dispose();
            HOperatorSet.GenRectangle2(out ho__EpoxyRectReg4, hv_CenterRow4, hv_CenterCol4,
                hv_phi41, hv_Reg4Len1, hv_Reg4Len2);

            {
                HObject ExpTmpOutVar_0;
                HOperatorSet.ConcatObj(ho_o_EpoxyRegs, ho__EpoxyRectReg4, out ExpTmpOutVar_0);
                ho_o_EpoxyRegs.Dispose();
                ho_o_EpoxyRegs = ExpTmpOutVar_0;
            }


            hv_o_ErrCode = 0;
            hv_o_ErrStr = "gen epoxyregs success";
            ho__EpoxyRectReg1.Dispose();
            ho__EpoxyRectReg2.Dispose();
            ho__EpoxyRectReg3.Dispose();
            ho__EpoxyRectReg4.Dispose();

            return;
        }

        public static void list_image_files(HTuple hv_ImageDirectory, HTuple hv_Extensions, HTuple hv_Options,
            out HTuple hv_ImageFiles)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_HalconImages = null, hv_OS = null;
            HTuple hv_Directories = null, hv_Index = null, hv_Length = null;
            HTuple hv_network_drive = null, hv_Substring = new HTuple();
            HTuple hv_FileExists = new HTuple(), hv_AllFiles = new HTuple();
            HTuple hv_i = new HTuple(), hv_Selection = new HTuple();
            HTuple hv_Extensions_COPY_INP_TMP = hv_Extensions.Clone();
            HTuple hv_ImageDirectory_COPY_INP_TMP = hv_ImageDirectory.Clone();

            // Initialize local and output iconic variables 
            //This procedure returns all files in a given directory
            //with one of the suffixes specified in Extensions.
            //
            //input parameters:
            //ImageDirectory: as the name says
            //   If a tuple of directories is given, only the images in the first
            //   existing directory are returned.
            //   If a local directory is not found, the directory is searched
            //   under %HALCONIMAGES%/ImageDirectory. If %HALCONIMAGES% is not set,
            //   %HALCONROOT%/images is used instead.
            //Extensions: A string tuple containing the extensions to be found
            //   e.g. ['png','tif',jpg'] or others
            //If Extensions is set to 'default' or the empty string '',
            //   all image suffixes supported by HALCON are used.
            //Options: as in the operator list_files, except that the 'files'
            //   option is always used. Note that the 'directories' option
            //   has no effect but increases runtime, because only files are
            //   returned.
            //
            //output parameter:
            //ImageFiles: A tuple of all found image file names
            //
            if ((int)((new HTuple((new HTuple(hv_Extensions_COPY_INP_TMP.TupleEqual(new HTuple()))).TupleOr(
                new HTuple(hv_Extensions_COPY_INP_TMP.TupleEqual(""))))).TupleOr(new HTuple(hv_Extensions_COPY_INP_TMP.TupleEqual(
                "default")))) != 0)
            {
                hv_Extensions_COPY_INP_TMP = new HTuple();
                hv_Extensions_COPY_INP_TMP[0] = "ima";
                hv_Extensions_COPY_INP_TMP[1] = "tif";
                hv_Extensions_COPY_INP_TMP[2] = "tiff";
                hv_Extensions_COPY_INP_TMP[3] = "gif";
                hv_Extensions_COPY_INP_TMP[4] = "bmp";
                hv_Extensions_COPY_INP_TMP[5] = "jpg";
                hv_Extensions_COPY_INP_TMP[6] = "jpeg";
                hv_Extensions_COPY_INP_TMP[7] = "jp2";
                hv_Extensions_COPY_INP_TMP[8] = "jxr";
                hv_Extensions_COPY_INP_TMP[9] = "png";
                hv_Extensions_COPY_INP_TMP[10] = "pcx";
                hv_Extensions_COPY_INP_TMP[11] = "ras";
                hv_Extensions_COPY_INP_TMP[12] = "xwd";
                hv_Extensions_COPY_INP_TMP[13] = "pbm";
                hv_Extensions_COPY_INP_TMP[14] = "pnm";
                hv_Extensions_COPY_INP_TMP[15] = "pgm";
                hv_Extensions_COPY_INP_TMP[16] = "ppm";
                //
            }
            if ((int)(new HTuple(hv_ImageDirectory_COPY_INP_TMP.TupleEqual(""))) != 0)
            {
                hv_ImageDirectory_COPY_INP_TMP = ".";
            }
            HOperatorSet.GetSystem("image_dir", out hv_HalconImages);
            HOperatorSet.GetSystem("operating_system", out hv_OS);
            if ((int)(new HTuple(((hv_OS.TupleSubstr(0, 2))).TupleEqual("Win"))) != 0)
            {
                hv_HalconImages = hv_HalconImages.TupleSplit(";");
            }
            else
            {
                hv_HalconImages = hv_HalconImages.TupleSplit(":");
            }
            hv_Directories = hv_ImageDirectory_COPY_INP_TMP.Clone();
            for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_HalconImages.TupleLength()
                )) - 1); hv_Index = (int)hv_Index + 1)
            {
                hv_Directories = hv_Directories.TupleConcat(((hv_HalconImages.TupleSelect(hv_Index)) + "/") + hv_ImageDirectory_COPY_INP_TMP);
            }
            HOperatorSet.TupleStrlen(hv_Directories, out hv_Length);
            HOperatorSet.TupleGenConst(new HTuple(hv_Length.TupleLength()), 0, out hv_network_drive);
            if ((int)(new HTuple(((hv_OS.TupleSubstr(0, 2))).TupleEqual("Win"))) != 0)
            {
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_Length.TupleLength())) - 1); hv_Index = (int)hv_Index + 1)
                {
                    if ((int)(new HTuple(((((hv_Directories.TupleSelect(hv_Index))).TupleStrlen()
                        )).TupleGreater(1))) != 0)
                    {
                        HOperatorSet.TupleStrFirstN(hv_Directories.TupleSelect(hv_Index), 1, out hv_Substring);
                        if ((int)(new HTuple(hv_Substring.TupleEqual("//"))) != 0)
                        {
                            if (hv_network_drive == null)
                                hv_network_drive = new HTuple();
                            hv_network_drive[hv_Index] = 1;
                        }
                    }
                }
            }
            hv_ImageFiles = new HTuple();
            for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_Directories.TupleLength()
                )) - 1); hv_Index = (int)hv_Index + 1)
            {
                HOperatorSet.FileExists(hv_Directories.TupleSelect(hv_Index), out hv_FileExists);
                if ((int)(hv_FileExists) != 0)
                {
                    HOperatorSet.ListFiles(hv_Directories.TupleSelect(hv_Index), (new HTuple("files")).TupleConcat(
                        hv_Options), out hv_AllFiles);
                    hv_ImageFiles = new HTuple();
                    for (hv_i = 0; (int)hv_i <= (int)((new HTuple(hv_Extensions_COPY_INP_TMP.TupleLength()
                        )) - 1); hv_i = (int)hv_i + 1)
                    {
                        HOperatorSet.TupleRegexpSelect(hv_AllFiles, (((".*" + (hv_Extensions_COPY_INP_TMP.TupleSelect(
                            hv_i))) + "$")).TupleConcat("ignore_case"), out hv_Selection);
                        hv_ImageFiles = hv_ImageFiles.TupleConcat(hv_Selection);
                    }
                    HOperatorSet.TupleRegexpReplace(hv_ImageFiles, (new HTuple("\\\\")).TupleConcat(
                        "replace_all"), "/", out hv_ImageFiles);
                    if ((int)(hv_network_drive.TupleSelect(hv_Index)) != 0)
                    {
                        HOperatorSet.TupleRegexpReplace(hv_ImageFiles, (new HTuple("//")).TupleConcat(
                            "replace_all"), "/", out hv_ImageFiles);
                        hv_ImageFiles = "/" + hv_ImageFiles;
                    }
                    else
                    {
                        HOperatorSet.TupleRegexpReplace(hv_ImageFiles, (new HTuple("//")).TupleConcat(
                            "replace_all"), "/", out hv_ImageFiles);
                    }

                    return;
                }
            }

            return;
        }

        public static void HTV_Analysis_InspectResult(HObjectVector/*{eObjectVector,Dim=4}*/ hvec_i_ResultRegs,
            out HObject ho_o_FailRegs, out HObject ho_o_NormalRegs, HTupleVector/*{eTupleVector,Dim=4}*/ hvec_i_DefectTypes,
            out HTuple hv_o_ErrorTypes, out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho__ResultRegConcat, ho_FrameIdResultReg = null;
            HObject ho_IcIdFailReg = null, ho_EpoxyIdResultReg = null, ho_BondIdResultReg = null;
            HObject ho_WireIdResultReg = null;

            HObjectVector hvec_DieResultRegs = new HObjectVector(3);
            HObjectVector hvec_FramesResultRegs = new HObjectVector(2), hvec_IcsResultRegs = new HObjectVector(2);
            HObjectVector hvec_EpoxysResultRegs = new HObjectVector(2), hvec_BondsResultRegs = new HObjectVector(2);
            HObjectVector hvec_WiresResultRegs = new HObjectVector(2), hvec_frameResultRegs = new HObjectVector(1);
            HObjectVector hvec_icResultRegs = new HObjectVector(1), hvec_epoxyResultRegs = new HObjectVector(1);
            HObjectVector hvec_bondResultRegs = new HObjectVector(1), hvec_wireResultRegs = new HObjectVector(1);

            // Local control variables 

            HTuple hv__ErrVecCode = null, hv__ErrVecStr = null;
            HTuple hv__DefectTypeTup = null, hv_ResultNum = null, hv_defectLen = null;
            HTuple hv_idx = null, hv_i = new HTuple(), hv_j = new HTuple();
            HTuple hv_FrameIdType = new HTuple(), hv_IcIdType = new HTuple();
            HTuple hv_EpoxyIdType = new HTuple(), hv_BondIdType = new HTuple();
            HTuple hv_WireIdType = new HTuple();

            HTupleVector hvec_DieDefectType = new HTupleVector(3);
            HTupleVector hvec_FramesDefectType = new HTupleVector(2), hvec_IcsDefectType = new HTupleVector(2);
            HTupleVector hvec_EpoxysDefectType = new HTupleVector(2), hvec_BondsDefectType = new HTupleVector(2);
            HTupleVector hvec_WiresDefectType = new HTupleVector(2), hvec_frameDefectType = new HTupleVector(1);
            HTupleVector hvec_icDefectType = new HTupleVector(1), hvec_epoxyDefectType = new HTupleVector(1);
            HTupleVector hvec_bondDefectType = new HTupleVector(1), hvec_wireDefectType = new HTupleVector(1);
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_FailRegs);
            HOperatorSet.GenEmptyObj(out ho_o_NormalRegs);
            HOperatorSet.GenEmptyObj(out ho__ResultRegConcat);
            HOperatorSet.GenEmptyObj(out ho_FrameIdResultReg);
            HOperatorSet.GenEmptyObj(out ho_IcIdFailReg);
            HOperatorSet.GenEmptyObj(out ho_EpoxyIdResultReg);
            HOperatorSet.GenEmptyObj(out ho_BondIdResultReg);
            HOperatorSet.GenEmptyObj(out ho_WireIdResultReg);
            try
            {
                //**************************************************************************************************
                //---函数：HTV_Analysis_InspectResult
                //---作用：解析结果区域
                //===图标参数
                //  i_ResultRegs：结果区域
                //  o_FailRegs:缺陷区域
                //  o_NormalRegs：正常区域
                //===控制参数
                //  i_DefectTypes：输入缺陷错误码
                //  o_ErrorTypes：解析缺陷对应错误码
                //  o_ErrCode：错误码
                //  o_ErrStr：错误信息
                //**************************************************************************************************

                //初始化
                hv_o_ErrCode = -2;
                hv_o_ErrStr = "initializing";
                hv_o_ErrorTypes = new HTuple();
                ho_o_FailRegs.Dispose();
                HOperatorSet.GenEmptyObj(out ho_o_FailRegs);
                ho_o_NormalRegs.Dispose();
                HOperatorSet.GenEmptyObj(out ho_o_NormalRegs);

                //验证输入向量长度
                ho__ResultRegConcat.Dispose();
                HTV_Vector_to_ObjectConcat_4d(hvec_i_ResultRegs, out ho__ResultRegConcat, out hv__ErrVecCode,
                    out hv__ErrVecStr);
                HTV_Vector_to_Tuple_4d(hvec_i_DefectTypes, out hv__DefectTypeTup, out hv__ErrVecCode,
                    out hv__ErrVecStr);

                //判断defect与failreg数量是否一致
                HOperatorSet.CountObj(ho__ResultRegConcat, out hv_ResultNum);
                HOperatorSet.TupleLength(hv__DefectTypeTup, out hv_defectLen);
                if ((int)(new HTuple(hv_ResultNum.TupleNotEqual(hv_defectLen))) != 0)
                {
                    hv_o_ErrCode = -1;
                    hv_o_ErrStr = "The lengths of the input vectors are not equal!";
                }

                //结果解析
                //4维向量：1- die循环  2- 固定检测任务：Frame, Ic, Epoxy, Bond, Wire  3- 检测项组  4-检测项ID
                //> 0：错误项； =0：正常项; 为空：没有这个检测项
                //
                HTuple end_val37 = new HTuple(hvec_i_DefectTypes.Length) - 1;
                HTuple step_val37 = 1;
                for (hv_idx = 0; hv_idx.Continue(end_val37, step_val37); hv_idx = hv_idx.TupleAdd(step_val37))
                {
                    //1d
                    hvec_DieDefectType = hvec_i_DefectTypes[hv_idx];
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hvec_DieResultRegs = dh.Take(hvec_i_ResultRegs[hv_idx]);
                    }
                    //2d: 固定5个检测任务
                    hvec_FramesDefectType = hvec_DieDefectType[0];
                    hvec_IcsDefectType = hvec_DieDefectType[1];
                    hvec_EpoxysDefectType = hvec_DieDefectType[2];
                    hvec_BondsDefectType = hvec_DieDefectType[3];
                    hvec_WiresDefectType = hvec_DieDefectType[4];
                    //
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hvec_FramesResultRegs = dh.Take(hvec_DieResultRegs[0]);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hvec_IcsResultRegs = dh.Take(hvec_DieResultRegs[1]);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hvec_EpoxysResultRegs = dh.Take(hvec_DieResultRegs[2]);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hvec_BondsResultRegs = dh.Take(hvec_DieResultRegs[3]);
                    }
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        hvec_WiresResultRegs = dh.Take(hvec_DieResultRegs[4]);
                    }

                    //Frame
                    HTuple end_val55 = new HTuple(hvec_FramesDefectType.Length) - 1;
                    HTuple step_val55 = 1;
                    for (hv_i = 0; hv_i.Continue(end_val55, step_val55); hv_i = hv_i.TupleAdd(step_val55))
                    {
                        //3d
                        hvec_frameDefectType = hvec_FramesDefectType[hv_i];
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hvec_frameResultRegs = dh.Take(hvec_FramesResultRegs[hv_i]);
                        }
                        HTuple end_val59 = new HTuple(hvec_frameDefectType.Length) - 1;
                        HTuple step_val59 = 1;
                        for (hv_j = 0; hv_j.Continue(end_val59, step_val59); hv_j = hv_j.TupleAdd(step_val59))
                        {
                            //4d : Frame 一组只有一个ID
                            hv_FrameIdType = hvec_frameDefectType[hv_j].T.Clone();
                            ho_FrameIdResultReg.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                ho_FrameIdResultReg = hvec_frameResultRegs[hv_j].O.CopyObj(1, -1);
                            }
                            //分为正常区域和缺陷区区域
                            if ((int)(new HTuple((new HTuple(hv_FrameIdType.TupleLength())).TupleGreater(
                                0))) != 0)
                            {
                                if ((int)(new HTuple(hv_FrameIdType.TupleEqual(0))) != 0)
                                {
                                    {
                                        HObject ExpTmpOutVar_0;
                                        HOperatorSet.ConcatObj(ho_o_NormalRegs, ho_FrameIdResultReg, out ExpTmpOutVar_0
                                            );
                                        ho_o_NormalRegs.Dispose();
                                        ho_o_NormalRegs = ExpTmpOutVar_0;
                                    }
                                }
                                else
                                {
                                    hv_o_ErrorTypes = hv_o_ErrorTypes.TupleConcat(hv_FrameIdType);
                                    {
                                        HObject ExpTmpOutVar_0;
                                        HOperatorSet.ConcatObj(ho_o_FailRegs, ho_FrameIdResultReg, out ExpTmpOutVar_0
                                            );
                                        ho_o_FailRegs.Dispose();
                                        ho_o_FailRegs = ExpTmpOutVar_0;
                                    }
                                }
                            }
                        }
                    }
                    //IC
                    HTuple end_val75 = new HTuple(hvec_IcsDefectType.Length) - 1;
                    HTuple step_val75 = 1;
                    for (hv_i = 0; hv_i.Continue(end_val75, step_val75); hv_i = hv_i.TupleAdd(step_val75))
                    {
                        //3d
                        hvec_icDefectType = hvec_IcsDefectType[hv_i];
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hvec_icResultRegs = dh.Take(hvec_IcsResultRegs[hv_i]);
                        }
                        HTuple end_val79 = new HTuple(hvec_icDefectType.Length) - 1;
                        HTuple step_val79 = 1;
                        for (hv_j = 0; hv_j.Continue(end_val79, step_val79); hv_j = hv_j.TupleAdd(step_val79))
                        {
                            //4d : IC 一组只有一个ID
                            hv_IcIdType = hvec_icDefectType[hv_j].T.Clone();
                            ho_IcIdFailReg.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                ho_IcIdFailReg = hvec_icResultRegs[hv_j].O.CopyObj(1, -1);
                            }
                            //分为正常区域和缺陷区区域
                            if ((int)(new HTuple((new HTuple(hv_IcIdType.TupleLength())).TupleGreater(
                                0))) != 0)
                            {
                                if ((int)(new HTuple(hv_IcIdType.TupleEqual(0))) != 0)
                                {
                                    {
                                        HObject ExpTmpOutVar_0;
                                        HOperatorSet.ConcatObj(ho_o_NormalRegs, ho_IcIdFailReg, out ExpTmpOutVar_0
                                            );
                                        ho_o_NormalRegs.Dispose();
                                        ho_o_NormalRegs = ExpTmpOutVar_0;
                                    }
                                }
                                else
                                {
                                    hv_o_ErrorTypes = hv_o_ErrorTypes.TupleConcat(hv_IcIdType);
                                    {
                                        HObject ExpTmpOutVar_0;
                                        HOperatorSet.ConcatObj(ho_o_FailRegs, ho_IcIdFailReg, out ExpTmpOutVar_0
                                            );
                                        ho_o_FailRegs.Dispose();
                                        ho_o_FailRegs = ExpTmpOutVar_0;
                                    }
                                }
                            }
                        }
                    }
                    //Epoxy
                    HTuple end_val95 = new HTuple(hvec_EpoxysDefectType.Length) - 1;
                    HTuple step_val95 = 1;
                    for (hv_i = 0; hv_i.Continue(end_val95, step_val95); hv_i = hv_i.TupleAdd(step_val95))
                    {
                        //3d
                        hvec_epoxyDefectType = hvec_EpoxysDefectType[hv_i];
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hvec_epoxyResultRegs = dh.Take(hvec_EpoxysResultRegs[hv_i]);
                        }
                        HTuple end_val99 = new HTuple(hvec_epoxyDefectType.Length) - 1;
                        HTuple step_val99 = 1;
                        for (hv_j = 0; hv_j.Continue(end_val99, step_val99); hv_j = hv_j.TupleAdd(step_val99))
                        {
                            //4d : Epoxy 一个区域对应一个ID
                            hv_EpoxyIdType = hvec_epoxyDefectType[hv_j].T.Clone();
                            ho_EpoxyIdResultReg.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                ho_EpoxyIdResultReg = hvec_epoxyResultRegs[hv_j].O.CopyObj(1, -1);
                            }
                            //分为正常区域和缺陷区区域
                            if ((int)(new HTuple((new HTuple(hv_EpoxyIdType.TupleLength())).TupleGreater(
                                0))) != 0)
                            {
                                if ((int)(new HTuple(hv_EpoxyIdType.TupleEqual(0))) != 0)
                                {
                                    {
                                        HObject ExpTmpOutVar_0;
                                        HOperatorSet.ConcatObj(ho_o_NormalRegs, ho_EpoxyIdResultReg, out ExpTmpOutVar_0
                                            );
                                        ho_o_NormalRegs.Dispose();
                                        ho_o_NormalRegs = ExpTmpOutVar_0;
                                    }
                                }
                                else
                                {
                                    hv_o_ErrorTypes = hv_o_ErrorTypes.TupleConcat(hv_EpoxyIdType);
                                    {
                                        HObject ExpTmpOutVar_0;
                                        HOperatorSet.ConcatObj(ho_o_FailRegs, ho_EpoxyIdResultReg, out ExpTmpOutVar_0
                                            );
                                        ho_o_FailRegs.Dispose();
                                        ho_o_FailRegs = ExpTmpOutVar_0;
                                    }
                                }
                            }
                        }
                    }
                    //Bond
                    HTuple end_val115 = new HTuple(hvec_BondsDefectType.Length) - 1;
                    HTuple step_val115 = 1;
                    for (hv_i = 0; hv_i.Continue(end_val115, step_val115); hv_i = hv_i.TupleAdd(step_val115))
                    {
                        //3d
                        hvec_bondDefectType = hvec_BondsDefectType[hv_i];
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hvec_bondResultRegs = dh.Take(hvec_BondsResultRegs[hv_i]);
                        }
                        HTuple end_val119 = new HTuple(hvec_bondDefectType.Length) - 1;
                        HTuple step_val119 = 1;
                        for (hv_j = 0; hv_j.Continue(end_val119, step_val119); hv_j = hv_j.TupleAdd(step_val119))
                        {
                            //4d : Bond 一个焊点对应一个ID
                            hv_BondIdType = hvec_bondDefectType[hv_j].T.Clone();
                            ho_BondIdResultReg.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                ho_BondIdResultReg = hvec_bondResultRegs[hv_j].O.CopyObj(1, -1);
                            }
                            //分为正常区域和缺陷区区域
                            if ((int)(new HTuple((new HTuple(hv_BondIdType.TupleLength())).TupleGreater(
                                0))) != 0)
                            {
                                if ((int)(new HTuple(hv_BondIdType.TupleEqual(0))) != 0)
                                {
                                    {
                                        HObject ExpTmpOutVar_0;
                                        HOperatorSet.ConcatObj(ho_o_NormalRegs, ho_BondIdResultReg, out ExpTmpOutVar_0
                                            );
                                        ho_o_NormalRegs.Dispose();
                                        ho_o_NormalRegs = ExpTmpOutVar_0;
                                    }
                                }
                                else
                                {
                                    hv_o_ErrorTypes = hv_o_ErrorTypes.TupleConcat(hv_BondIdType);
                                    {
                                        HObject ExpTmpOutVar_0;
                                        HOperatorSet.ConcatObj(ho_o_FailRegs, ho_BondIdResultReg, out ExpTmpOutVar_0
                                            );
                                        ho_o_FailRegs.Dispose();
                                        ho_o_FailRegs = ExpTmpOutVar_0;
                                    }
                                }
                            }
                        }
                    }
                    //wire
                    HTuple end_val135 = new HTuple(hvec_WiresDefectType.Length) - 1;
                    HTuple step_val135 = 1;
                    for (hv_i = 0; hv_i.Continue(end_val135, step_val135); hv_i = hv_i.TupleAdd(step_val135))
                    {
                        //3d
                        hvec_wireDefectType = hvec_WiresDefectType[hv_i];
                        using (HDevDisposeHelper dh = new HDevDisposeHelper())
                        {
                            hvec_wireResultRegs = dh.Take(hvec_WiresResultRegs[hv_i]);
                        }
                        HTuple end_val139 = new HTuple(hvec_wireDefectType.Length) - 1;
                        HTuple step_val139 = 1;
                        for (hv_j = 0; hv_j.Continue(end_val139, step_val139); hv_j = hv_j.TupleAdd(step_val139))
                        {
                            //4d : Wire 一根金线对应一个ID
                            hv_WireIdType = hvec_wireDefectType[hv_j].T.Clone();
                            ho_WireIdResultReg.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                ho_WireIdResultReg = hvec_wireResultRegs[hv_j].O.CopyObj(1, -1);
                            }
                            //分为正常区域和缺陷区区域
                            if ((int)(new HTuple((new HTuple(hv_WireIdType.TupleLength())).TupleGreater(
                                0))) != 0)
                            {
                                if ((int)(new HTuple(hv_WireIdType.TupleEqual(0))) != 0)
                                {
                                    {
                                        HObject ExpTmpOutVar_0;
                                        HOperatorSet.ConcatObj(ho_o_NormalRegs, ho_WireIdResultReg, out ExpTmpOutVar_0
                                            );
                                        ho_o_NormalRegs.Dispose();
                                        ho_o_NormalRegs = ExpTmpOutVar_0;
                                    }
                                }
                                else
                                {
                                    hv_o_ErrorTypes = hv_o_ErrorTypes.TupleConcat(hv_WireIdType);
                                    {
                                        HObject ExpTmpOutVar_0;
                                        HOperatorSet.ConcatObj(ho_o_FailRegs, ho_WireIdResultReg, out ExpTmpOutVar_0
                                            );
                                        ho_o_FailRegs.Dispose();
                                        ho_o_FailRegs = ExpTmpOutVar_0;
                                    }
                                }
                            }
                        }
                    }
                }

                hv_o_ErrCode = 0;
                hv_o_ErrStr = "analysis result suceess";
                ho__ResultRegConcat.Dispose();
                ho_FrameIdResultReg.Dispose();
                ho_IcIdFailReg.Dispose();
                ho_EpoxyIdResultReg.Dispose();
                ho_BondIdResultReg.Dispose();
                ho_WireIdResultReg.Dispose();
                hvec_DieResultRegs.Dispose();
                hvec_FramesResultRegs.Dispose();
                hvec_IcsResultRegs.Dispose();
                hvec_EpoxysResultRegs.Dispose();
                hvec_BondsResultRegs.Dispose();
                hvec_WiresResultRegs.Dispose();
                hvec_frameResultRegs.Dispose();
                hvec_icResultRegs.Dispose();
                hvec_epoxyResultRegs.Dispose();
                hvec_bondResultRegs.Dispose();
                hvec_wireResultRegs.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho__ResultRegConcat.Dispose();
                ho_FrameIdResultReg.Dispose();
                ho_IcIdFailReg.Dispose();
                ho_EpoxyIdResultReg.Dispose();
                ho_BondIdResultReg.Dispose();
                ho_WireIdResultReg.Dispose();
                hvec_DieResultRegs.Dispose();
                hvec_FramesResultRegs.Dispose();
                hvec_IcsResultRegs.Dispose();
                hvec_EpoxysResultRegs.Dispose();
                hvec_BondsResultRegs.Dispose();
                hvec_WiresResultRegs.Dispose();
                hvec_frameResultRegs.Dispose();
                hvec_icResultRegs.Dispose();
                hvec_epoxyResultRegs.Dispose();
                hvec_bondResultRegs.Dispose();
                hvec_wireResultRegs.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public static void HTV_Vector_to_ObjectConcat_1d(HObjectVector/*{eObjectVector,Dim=1}*/ hvec_i_Vector,
            out HObject ho_o_ObjConcat, out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_ObjTmp = null;

            // Local control variables 

            HTuple hv_idx = null;
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_ObjConcat);
            HOperatorSet.GenEmptyObj(out ho_ObjTmp);
            //**************************************************************************************************
            //---函数：HTV_Vector_to_ObjectConcat_1d
            //---作用：1维向量转ObjConcat
            //===图标参数
            //===控制参数
            //  i_Vector：1维向量
            //  o_ObjConcat：1维obj
            //  o_ErrCode：错误码
            //  o_ErrStr：错误信息
            //**************************************************************************************************

            hv_o_ErrCode = -2;
            hv_o_ErrStr = "initializing";
            ho_o_ObjConcat.Dispose();
            HOperatorSet.GenEmptyObj(out ho_o_ObjConcat);

            //1维向量1层循环
            HTuple end_val16 = new HTuple(hvec_i_Vector.Length) - 1;
            HTuple step_val16 = 1;
            for (hv_idx = 0; hv_idx.Continue(end_val16, step_val16); hv_idx = hv_idx.TupleAdd(step_val16))
            {
                ho_ObjTmp.Dispose();
                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                {
                    ho_ObjTmp = hvec_i_Vector[hv_idx].O.CopyObj(1, -1);
                }
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.ConcatObj(ho_o_ObjConcat, ho_ObjTmp, out ExpTmpOutVar_0);
                    ho_o_ObjConcat.Dispose();
                    ho_o_ObjConcat = ExpTmpOutVar_0;
                }
            }

            hv_o_ErrCode = 0;
            hv_o_ErrStr = "Vertor translate success ";

            ho_ObjTmp.Dispose();

            return;
        }

        public static void HTV_Vector_to_ObjectConcat_2d(HObjectVector/*{eObjectVector,Dim=2}*/ hvec_i_Vector,
            out HObject ho_o_ObjConcat, out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_ObjTmp = null;

            // Local control variables 

            HTuple hv_idx = null, hv_i = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_ObjConcat);
            HOperatorSet.GenEmptyObj(out ho_ObjTmp);
            //**************************************************************************************************
            //---函数：HTV_Vector_to_ObjectConcat_2d
            //---作用：2维向量转ObjConcat
            //===图标参数
            //===控制参数
            //  i_Vector：2维向量
            //  o_ObjConcat：一维obj
            //  o_ErrCode：错误码
            //  o_ErrStr：错误信息
            //**************************************************************************************************

            hv_o_ErrCode = -2;
            hv_o_ErrStr = "initializing";
            ho_o_ObjConcat.Dispose();
            HOperatorSet.GenEmptyObj(out ho_o_ObjConcat);

            //2维向量2层循环
            HTuple end_val16 = new HTuple(hvec_i_Vector.Length) - 1;
            HTuple step_val16 = 1;
            for (hv_idx = 0; hv_idx.Continue(end_val16, step_val16); hv_idx = hv_idx.TupleAdd(step_val16))
            {
                HTuple end_val17 = new HTuple(hvec_i_Vector[hv_idx].Length) - 1;
                HTuple step_val17 = 1;
                for (hv_i = 0; hv_i.Continue(end_val17, step_val17); hv_i = hv_i.TupleAdd(step_val17))
                {
                    ho_ObjTmp.Dispose();
                    using (HDevDisposeHelper dh = new HDevDisposeHelper())
                    {
                        ho_ObjTmp = hvec_i_Vector[hv_idx][hv_i].O.CopyObj(1, -1);
                    }
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.ConcatObj(ho_o_ObjConcat, ho_ObjTmp, out ExpTmpOutVar_0);
                        ho_o_ObjConcat.Dispose();
                        ho_o_ObjConcat = ExpTmpOutVar_0;
                    }
                }
            }

            hv_o_ErrCode = 0;
            hv_o_ErrStr = "Vertor translate success ";

            ho_ObjTmp.Dispose();

            return;
        }

        public static void HTV_Vector_to_ObjectConcat_3d(HObjectVector/*{eObjectVector,Dim=3}*/ hvec_i_Vector,
            out HObject ho_o_ObjConcat, out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_ObjTmp = null;

            // Local control variables 

            HTuple hv_idx = null, hv_i = new HTuple();
            HTuple hv_j = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_ObjConcat);
            HOperatorSet.GenEmptyObj(out ho_ObjTmp);
            try
            {
                //**************************************************************************************************
                //---函数：HTV_Vector_to_ObjectConcat_3d
                //---作用：3维向量转ObjConcat
                //===图标参数
                //===控制参数
                //  i_Vector：3维向量
                //  o_ObjConcat：一维Obj
                //  o_ErrCode：错误码
                //  o_ErrStr：错误信息
                //**************************************************************************************************

                hv_o_ErrCode = -2;
                hv_o_ErrStr = "initializing";
                ho_o_ObjConcat.Dispose();
                HOperatorSet.GenEmptyObj(out ho_o_ObjConcat);

                //3维向量3层循环
                HTuple end_val16 = new HTuple(hvec_i_Vector.Length) - 1;
                HTuple step_val16 = 1;
                for (hv_idx = 0; hv_idx.Continue(end_val16, step_val16); hv_idx = hv_idx.TupleAdd(step_val16))
                {
                    HTuple end_val17 = new HTuple(hvec_i_Vector[hv_idx].Length) - 1;
                    HTuple step_val17 = 1;
                    for (hv_i = 0; hv_i.Continue(end_val17, step_val17); hv_i = hv_i.TupleAdd(step_val17))
                    {
                        HTuple end_val18 = new HTuple(hvec_i_Vector[hv_idx][hv_i].Length) - 1;
                        HTuple step_val18 = 1;
                        for (hv_j = 0; hv_j.Continue(end_val18, step_val18); hv_j = hv_j.TupleAdd(step_val18))
                        {
                            ho_ObjTmp.Dispose();
                            using (HDevDisposeHelper dh = new HDevDisposeHelper())
                            {
                                ho_ObjTmp = hvec_i_Vector[hv_idx][hv_i][hv_j].O.CopyObj(1, -1);
                            }
                            {
                                HObject ExpTmpOutVar_0;
                                HOperatorSet.ConcatObj(ho_o_ObjConcat, ho_ObjTmp, out ExpTmpOutVar_0);
                                ho_o_ObjConcat.Dispose();
                                ho_o_ObjConcat = ExpTmpOutVar_0;
                            }
                        }
                    }
                }

                hv_o_ErrCode = 0;
                hv_o_ErrStr = "Vertor translate success ";

                ho_ObjTmp.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_ObjTmp.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public static void HTV_Vector_to_ObjectConcat_4d(HObjectVector/*{eObjectVector,Dim=4}*/ hvec_i_Vector,
            out HObject ho_o_ObjConcat, out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_ObjTmp = null;

            // Local control variables 

            HTuple hv_idx = null, hv_i = new HTuple();
            HTuple hv_j = new HTuple(), hv_n = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_ObjConcat);
            HOperatorSet.GenEmptyObj(out ho_ObjTmp);
            try
            {
                //**************************************************************************************************
                //---函数：HTV_Vector_to_ObjectConcat_4d
                //---作用：4维向量转ObjConcat
                //===图标参数
                //===控制参数
                //  i_Vector：4维向量
                //  o_ObjConcat：一维obj
                //  o_ErrCode：错误码
                //  o_ErrStr：错误信息
                //**************************************************************************************************

                hv_o_ErrCode = -2;
                hv_o_ErrStr = "initializing";
                ho_o_ObjConcat.Dispose();
                HOperatorSet.GenEmptyObj(out ho_o_ObjConcat);

                //4维向量4层循环
                HTuple end_val16 = new HTuple(hvec_i_Vector.Length) - 1;
                HTuple step_val16 = 1;
                for (hv_idx = 0; hv_idx.Continue(end_val16, step_val16); hv_idx = hv_idx.TupleAdd(step_val16))
                {
                    HTuple end_val17 = new HTuple(hvec_i_Vector[hv_idx].Length) - 1;
                    HTuple step_val17 = 1;
                    for (hv_i = 0; hv_i.Continue(end_val17, step_val17); hv_i = hv_i.TupleAdd(step_val17))
                    {
                        HTuple end_val18 = new HTuple(hvec_i_Vector[hv_idx][hv_i].Length) - 1;
                        HTuple step_val18 = 1;
                        for (hv_j = 0; hv_j.Continue(end_val18, step_val18); hv_j = hv_j.TupleAdd(step_val18))
                        {
                            HTuple end_val19 = new HTuple(hvec_i_Vector[hv_idx][hv_i][hv_j].Length) - 1;
                            HTuple step_val19 = 1;
                            for (hv_n = 0; hv_n.Continue(end_val19, step_val19); hv_n = hv_n.TupleAdd(step_val19))
                            {
                                ho_ObjTmp.Dispose();
                                using (HDevDisposeHelper dh = new HDevDisposeHelper())
                                {
                                    ho_ObjTmp = hvec_i_Vector[hv_idx][hv_i][hv_j][hv_n].O.CopyObj(1, -1);
                                }
                                {
                                    HObject ExpTmpOutVar_0;
                                    HOperatorSet.ConcatObj(ho_o_ObjConcat, ho_ObjTmp, out ExpTmpOutVar_0
                                        );
                                    ho_o_ObjConcat.Dispose();
                                    ho_o_ObjConcat = ExpTmpOutVar_0;
                                }
                            }
                        }
                    }
                }

                hv_o_ErrCode = 0;
                hv_o_ErrStr = "Vertor translate success ";

                ho_ObjTmp.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_ObjTmp.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public static void HTV_Vector_to_Tuple_1d(HTupleVector/*{eTupleVector,Dim=1}*/ hvec_i_Vector,
            out HTuple hv_o_Tuple, out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_idx = null, hv_TupleTmp = new HTuple();
            // Initialize local and output iconic variables 
            //**************************************************************************************************
            //---函数：HTV_Vector_to_Tuple_1d
            //---作用：1维向量转Tuple
            //===图标参数
            //===控制参数
            //  i_Vector：1维向量
            //  o_Tuple：一维tuple
            //  o_ErrCode：错误码
            //  o_ErrStr：错误信息
            //**************************************************************************************************

            hv_o_ErrCode = -2;
            hv_o_ErrStr = "initializing";
            hv_o_Tuple = new HTuple();

            //2维向量2层循环
            HTuple end_val16 = new HTuple(hvec_i_Vector.Length) - 1;
            HTuple step_val16 = 1;
            for (hv_idx = 0; hv_idx.Continue(end_val16, step_val16); hv_idx = hv_idx.TupleAdd(step_val16))
            {
                hv_TupleTmp = hvec_i_Vector[hv_idx].T.Clone();
                hv_o_Tuple = hv_o_Tuple.TupleConcat(hv_TupleTmp);
            }

            hv_o_ErrCode = 0;
            hv_o_ErrStr = "Vertor translate success ";


            return;
        }

        public static void HTV_Vector_to_Tuple_2d(HTupleVector/*{eTupleVector,Dim=2}*/ hvec_i_Vector,
            out HTuple hv_o_Tuple, out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_idx = null, hv_i = new HTuple();
            HTuple hv_TupleTmp = new HTuple();
            // Initialize local and output iconic variables 
            //**************************************************************************************************
            //---函数：HTV_Vector_to_Tuple_2d
            //---作用：2维向量转Tuple
            //===图标参数
            //===控制参数
            //  i_Vector：2维向量
            //  o_Tuple：一维tuple
            //  o_ErrCode：错误码
            //  o_ErrStr：错误信息
            //**************************************************************************************************

            hv_o_ErrCode = -2;
            hv_o_ErrStr = "initializing";
            hv_o_Tuple = new HTuple();

            //2维向量2层循环
            HTuple end_val16 = new HTuple(hvec_i_Vector.Length) - 1;
            HTuple step_val16 = 1;
            for (hv_idx = 0; hv_idx.Continue(end_val16, step_val16); hv_idx = hv_idx.TupleAdd(step_val16))
            {
                HTuple end_val17 = new HTuple(hvec_i_Vector[hv_idx].Length) - 1;
                HTuple step_val17 = 1;
                for (hv_i = 0; hv_i.Continue(end_val17, step_val17); hv_i = hv_i.TupleAdd(step_val17))
                {
                    hv_TupleTmp = hvec_i_Vector[hv_idx][hv_i].T.Clone();
                    hv_o_Tuple = hv_o_Tuple.TupleConcat(hv_TupleTmp);
                }
            }

            hv_o_ErrCode = 0;
            hv_o_ErrStr = "Vertor translate success ";


            return;
        }

        public static void HTV_Vector_to_Tuple_3d(HTupleVector/*{eTupleVector,Dim=3}*/ hvec_i_Vector,
            out HTuple hv_o_Tuple, out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_idx = null, hv_i = new HTuple();
            HTuple hv_j = new HTuple(), hv_TupleTmp = new HTuple();
            // Initialize local and output iconic variables 
            //**************************************************************************************************
            //---函数：HTV_Vector_to_Tuple_3d
            //---作用：3维向量转Tuple
            //===图标参数
            //===控制参数
            //  i_Vector：3维向量
            //  o_Tuple：一维tuple
            //  o_ErrCode：错误码
            //  o_ErrStr：错误信息
            //**************************************************************************************************

            hv_o_ErrCode = -2;
            hv_o_ErrStr = "initializing";
            hv_o_Tuple = new HTuple();

            //3维向量3层循环
            HTuple end_val16 = new HTuple(hvec_i_Vector.Length) - 1;
            HTuple step_val16 = 1;
            for (hv_idx = 0; hv_idx.Continue(end_val16, step_val16); hv_idx = hv_idx.TupleAdd(step_val16))
            {
                HTuple end_val17 = new HTuple(hvec_i_Vector[hv_idx].Length) - 1;
                HTuple step_val17 = 1;
                for (hv_i = 0; hv_i.Continue(end_val17, step_val17); hv_i = hv_i.TupleAdd(step_val17))
                {
                    HTuple end_val18 = new HTuple(hvec_i_Vector[hv_idx][hv_i].Length) - 1;
                    HTuple step_val18 = 1;
                    for (hv_j = 0; hv_j.Continue(end_val18, step_val18); hv_j = hv_j.TupleAdd(step_val18))
                    {

                        hv_TupleTmp = hvec_i_Vector[hv_idx][hv_i][hv_j].T.Clone();
                        hv_o_Tuple = hv_o_Tuple.TupleConcat(hv_TupleTmp);
                    }
                }
            }

            hv_o_ErrCode = 0;
            hv_o_ErrStr = "Vertor translate success ";


            return;
        }

        public static void HTV_Vector_to_Tuple_4d(HTupleVector/*{eTupleVector,Dim=4}*/ hvec_i_Vector,
            out HTuple hv_o_Tuple, out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_idx = null, hv_i = new HTuple();
            HTuple hv_j = new HTuple(), hv_n = new HTuple(), hv_TupleTmp = new HTuple();
            // Initialize local and output iconic variables 
            //**************************************************************************************************
            //---函数：HTV_Vector_to_Tuple_4d
            //---作用：4维向量转Tuple
            //===图标参数
            //===控制参数
            //  i_Vector：4维向量
            //  o_Tuple：一维tuple
            //  o_ErrCode：错误码
            //  o_ErrStr：错误信息
            //**************************************************************************************************

            hv_o_ErrCode = -2;
            hv_o_ErrStr = "initializing";
            hv_o_Tuple = new HTuple();

            //4维向量4层循环
            HTuple end_val16 = new HTuple(hvec_i_Vector.Length) - 1;
            HTuple step_val16 = 1;
            for (hv_idx = 0; hv_idx.Continue(end_val16, step_val16); hv_idx = hv_idx.TupleAdd(step_val16))
            {
                HTuple end_val17 = new HTuple(hvec_i_Vector[hv_idx].Length) - 1;
                HTuple step_val17 = 1;
                for (hv_i = 0; hv_i.Continue(end_val17, step_val17); hv_i = hv_i.TupleAdd(step_val17))
                {
                    HTuple end_val18 = new HTuple(hvec_i_Vector[hv_idx][hv_i].Length) - 1;
                    HTuple step_val18 = 1;
                    for (hv_j = 0; hv_j.Continue(end_val18, step_val18); hv_j = hv_j.TupleAdd(step_val18))
                    {
                        HTuple end_val19 = new HTuple(hvec_i_Vector[hv_idx][hv_i][hv_j].Length) - 1;
                        HTuple step_val19 = 1;
                        for (hv_n = 0; hv_n.Continue(end_val19, step_val19); hv_n = hv_n.TupleAdd(step_val19))
                        {
                            hv_TupleTmp = hvec_i_Vector[hv_idx][hv_i][hv_j][hv_n].T.Clone();
                            hv_o_Tuple = hv_o_Tuple.TupleConcat(hv_TupleTmp);
                        }
                    }
                }
            }

            hv_o_ErrCode = 0;
            hv_o_ErrStr = "Vertor translate success ";


            return;
        }

        // 合成多通道图
        public static void HTV_Create_Multichannel_Image(out HObject ho_o_MultiImage, HTuple hv_i_ImageFilesPath,
            HTuple hv_i_FovName, HTuple hv_i_ImageIdx, out HTuple hv_o_ImageVerifyNum, out HTuple hv_o_ImageFiles, 
            out HTuple hv_o_ErrCode, out HTuple hv_o_ErrStr)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_MutiImage, ho_taskImg = null;

            // Local control variables 

            HTuple hv_Files = null, hv_MatcheFiles = null, hv_FovNameList = null;
            HTuple hv_SelectFiles = null, hv_Idx = null, hv_FovName = new HTuple();
            HTuple hv_FovIndex = null, hv_FovFiles = null, hv_ImageFilesPath = null;
            HTuple hv_ImageFiles = null, hv_ImgIdx = null, hv_ObjNum = null;
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_o_MultiImage);
            HOperatorSet.GenEmptyObj(out ho_MutiImage);
            HOperatorSet.GenEmptyObj(out ho_taskImg);
            //**************************************************************************************************
            //---函数：HTV_Create_Multichannel_Image
            //---作用：根据文件路径按Fov分类并合成多通道图
            //---参数：
            //===图标参数
            //  o_MultiImage：输出多通道图
            //===控制参数
            //  i_ImageFilesPath：多Fov多Task图集路径
            //  i_FovName：当前Fov路径
            //  i_ImageIdx：图集中图像索引
            //  o_ErrCode：错误码
            //  o_ErrStr：错误信息
            //**************************************************************************************************

            //初始化
            hv_o_ErrCode = -2;
            hv_o_ErrStr = "initializing";
            hv_o_ImageFiles = new HTuple();
            hv_o_ImageVerifyNum = 0;
            ho_o_MultiImage.Dispose();
            HOperatorSet.GenEmptyObj(out ho_o_MultiImage);

            //输入参数有效性检查
            if ((int)(new HTuple(hv_i_ImageIdx.TupleLess(0))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "para i_ImageIdx is illegal";
                ho_MutiImage.Dispose();
                ho_taskImg.Dispose();

                return;
            }

            //遍历文件夹
            HOperatorSet.ListFiles(hv_i_ImageFilesPath, "directories", out hv_Files);
            HOperatorSet.TupleRegexpSelect(hv_Files, "-Fov_*", out hv_Files);
            HOperatorSet.TupleRegexpMatch(hv_Files, "Fov_(.*)\\\\", out hv_MatcheFiles);

            if ((int)(new HTuple((new HTuple(hv_MatcheFiles.TupleLength())).TupleEqual(0))) != 0)
            {
                //图像存储规则不正确
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "imageFile format is error";
                ho_MutiImage.Dispose();
                ho_taskImg.Dispose();

                return;
            }

            //Fov数目
            hv_FovNameList = new HTuple();
            hv_SelectFiles = hv_MatcheFiles.Clone();
            for (hv_Idx = 0; (int)hv_Idx <= (int)((new HTuple(hv_MatcheFiles.TupleLength())) - 1); hv_Idx = (int)hv_Idx + 1)
            {

                hv_FovName = hv_SelectFiles[0];
                hv_FovNameList = hv_FovNameList.TupleConcat(hv_FovName);
                HOperatorSet.TupleDifference(hv_SelectFiles, hv_FovName, out hv_SelectFiles);
                if ((int)(new HTuple(hv_SelectFiles.TupleEqual(new HTuple()))) != 0)
                {
                    break;
                }
            }

            //选择当前Fov图像
            HOperatorSet.TupleFind(hv_FovNameList, hv_i_FovName, out hv_FovIndex);
            if ((int)(new HTuple(hv_FovIndex.TupleLess(0))) != 0)
            {
                //Fov名称不匹配
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "fovName is illegal";
                ho_MutiImage.Dispose();
                ho_taskImg.Dispose();

                return;
            }

            hv_FovName = hv_FovNameList.TupleSelect(hv_FovIndex);
            HOperatorSet.TupleFind(hv_MatcheFiles, hv_FovName, out hv_FovIndex);
            HOperatorSet.TupleSelect(hv_Files, hv_FovIndex, out hv_FovFiles);

            //选择当前索引图像
            hv_ImageFilesPath = hv_FovFiles.Clone();
            if ((int)(new HTuple(hv_i_ImageIdx.TupleGreaterEqual(new HTuple(hv_ImageFilesPath.TupleLength())))) != 0)
            {
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "para i_ImageIdx is illegal";
                ho_MutiImage.Dispose();
                ho_taskImg.Dispose();

                return;
            }

            //输出图集数目
            hv_o_ImageVerifyNum = new HTuple(hv_ImageFilesPath.TupleLength());

            list_image_files(hv_ImageFilesPath.TupleSelect(hv_i_ImageIdx), (((((new HTuple(".bmp")).TupleConcat(
                ".tiff")).TupleConcat(".tif")).TupleConcat(".jpg")).TupleConcat(".jpeg")).TupleConcat(".png"),
                "recursive", out hv_ImageFiles);

            //合成多通道图
            ho_MutiImage.Dispose();
            HOperatorSet.GenEmptyObj(out ho_MutiImage);
            for (hv_ImgIdx = 0; (int)hv_ImgIdx <= (int)((new HTuple(hv_ImageFiles.TupleLength()
                )) - 1); hv_ImgIdx = (int)hv_ImgIdx + 1)
            {
                ho_taskImg.Dispose();
                HOperatorSet.ReadImage(out ho_taskImg, hv_ImageFiles.TupleSelect(hv_ImgIdx));
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.AppendChannel(ho_MutiImage, ho_taskImg, out ExpTmpOutVar_0);
                    ho_MutiImage.Dispose();
                    ho_MutiImage = ExpTmpOutVar_0;
                }
            }

            HOperatorSet.CountObj(ho_MutiImage, out hv_ObjNum);
            if ((int)(new HTuple(hv_ObjNum.TupleGreater(0))) != 0)
            {
                hv_o_ImageFiles = hv_ImageFiles.Clone();
                ho_o_MultiImage.Dispose();
                ho_o_MultiImage = ho_MutiImage.CopyObj(1, -1);
                hv_o_ErrCode = 0;
                hv_o_ErrStr = "create image Success";
            }
            else
            {
                //空文件夹
                hv_o_ErrCode = -1;
                hv_o_ErrStr = "image file is empty";
            }

            ho_MutiImage.Dispose();
            ho_taskImg.Dispose();

            return;
        }

#if !NO_EXPORT_MAIN
        // Main procedure 


#endif


    }
}


