//
//  File generated by HDevelop for HALCON/DOTNET (C#) Version 12.0
//
//  This file is intended to be used with the HDevelopTemplate or
//  HDevelopTemplateWPF projects located under %HALCONEXAMPLES%\c#

using HalconDotNet;
using ToolKits.FunctionModule;

namespace VisionMethonDll
{
    public class VisionMethon
    {
        #region 料片图谱
        /// <summary>
        /// 生成图谱
        /// </summary>
        /// <param name="ho_mapImage">生成的大图</param>
        /// <param name="hv_imageFolderPath">采样图的路径</param>
        /// <param name="hv_uvHxy">变换矩阵</param>
        /// <param name="hv_zoomFactor">缩放系数</param>
        /// <param name="hv_xSnapPosLT">大图0点为中心时轴坐标x</param>
        /// <param name="hv_ySnapPosLT">大图0点为中心时轴坐标y</param>
        /// <param name="hv_iFlag">字符串，为""无错</param>
        public static void gen_map_images(out HObject ho_mapImage, HTuple hv_imageFolderPath,
          HTuple hv_uvHxy, HTuple hv_zoomFactor, out HTuple hv_xSnapPosLT, out HTuple hv_ySnapPosLT,
          out HTuple hv_iFlag)
        {



            // Local iconic variables 

            HObject ho_Image, ho_firstImg;

            // Local control variables 

            HTuple hv_imagePaths = null, hv_rowCnt = null;
            HTuple hv_colCnt = null, hv_xSnapPos = null, hv_ySnapPos = null;
            HTuple hv_path = null, hv_xPosExist = null, hv_i = null;
            HTuple hv_j = new HTuple(), hv_imgPath = new HTuple();
            HTuple hv_imgExist = new HTuple(), hv_factor = null, hv_uvHxyScaled = null;
            HTuple hv_Width = null, hv_Height = null;
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_mapImage);
            HOperatorSet.GenEmptyObj(out ho_Image);
            HOperatorSet.GenEmptyObj(out ho_firstImg);
            try
            {
                hv_iFlag = "";
                hv_xSnapPosLT = new HTuple();
                hv_ySnapPosLT = new HTuple();
                ho_mapImage.Dispose();
                HOperatorSet.GenEmptyObj(out ho_mapImage);

                hv_imagePaths = new HTuple();
                hv_rowCnt = 0;
                hv_colCnt = 0;
                hv_xSnapPos = new HTuple();
                hv_ySnapPos = new HTuple();

                hv_path = hv_imageFolderPath + "/Xpoint.dat";
                HOperatorSet.FileExists(hv_path, out hv_xPosExist);
                if ((int)(new HTuple(hv_xPosExist.TupleEqual(0))) != 0)
                {
                    hv_iFlag = "no x pose file exist!";
                    ho_Image.Dispose();
                    ho_firstImg.Dispose();

                    return;
                }
                HOperatorSet.ReadTuple(hv_path, out hv_xSnapPos);

                hv_path = hv_imageFolderPath + "/Ypoint.dat";
                HOperatorSet.FileExists(hv_path, out hv_xPosExist);
                if ((int)(new HTuple(hv_xPosExist.TupleEqual(0))) != 0)
                {
                    hv_iFlag = "no y pose file exist!";
                    ho_Image.Dispose();
                    ho_firstImg.Dispose();

                    return;
                }
                HOperatorSet.ReadTuple(hv_path, out hv_ySnapPos);

                hv_i = 0;
                while ((int)(1) != 0)
                {
                    hv_j = 0;
                    while ((int)(1) != 0)
                    {
                        hv_imgPath = ((((hv_imageFolderPath + "/") + hv_i) + "-") + hv_j) + ".tiff";
                        HOperatorSet.FileExists(hv_imgPath, out hv_imgExist);
                        if ((int)(new HTuple(hv_imgExist.TupleEqual(0))) != 0)
                        {
                            break;
                        }
                        hv_imagePaths = hv_imagePaths.TupleConcat(hv_imgPath);
                        hv_j = hv_j + 1;
                    }
                    if ((int)(new HTuple(hv_j.TupleEqual(0))) != 0)
                    {
                        break;
                    }
                    hv_colCnt = hv_j.Clone();
                    hv_i = hv_i + 1;
                }
                hv_rowCnt = hv_i.Clone();
                if ((int)((new HTuple(hv_i.TupleEqual(0))).TupleAnd(new HTuple(hv_j.TupleEqual(
                    0)))) != 0)
                {
                    hv_iFlag = "no images exist!";
                    ho_Image.Dispose();
                    ho_firstImg.Dispose();

                    return;
                }

                ho_Image.Dispose();
                HOperatorSet.ReadImage(out ho_Image, hv_imagePaths);

                //ind := 1
                //for p := 0 to rowCnt-1 by 1
                //for q := 0 to colCnt-1 by 1
                //select_obj (Image, selectImg, ind)
                //*         zoom_image_factor (selectImg, ImageZoomed, zoomFactor, zoomFactor, 'constant')
                //*         write_image (ImageZoomed, 'tiff', 0, 'ZoomImageDir/'+p+'-'+q+'.tiff')
                //ind := ind+1
                //endfor
                //endfor
                //write_tuple (xSnapPos, 'ZoomImageDir/Xpoint.dat')
                //write_tuple (ySnapPos, 'ZoomImageDir/Ypoint.dat')

                hv_factor = 1.0;
                HOperatorSet.HomMat2dScale(hv_uvHxy, 1 / hv_zoomFactor, 1 / hv_zoomFactor, 0, 0,
                    out hv_uvHxyScaled);
                ho_mapImage.Dispose();
                tile_map_images(ho_Image, out ho_mapImage, hv_xSnapPos, hv_ySnapPos, hv_uvHxyScaled,
                    hv_rowCnt, hv_colCnt, hv_factor, out hv_iFlag);


                //*******计算die实际xy点位
                ho_firstImg.Dispose();
                HOperatorSet.SelectObj(ho_Image, out ho_firstImg, 1);
                HOperatorSet.GetImageSize(ho_firstImg, out hv_Width, out hv_Height);
                hv_xSnapPosLT = ((hv_xSnapPos.TupleSelect(0)) + (((hv_uvHxyScaled.TupleSelect(
                    0)) * (hv_Height - 1)) / 2.0)) + (((hv_uvHxyScaled.TupleSelect(1)) * (hv_Width - 1)) / 2.0);
                hv_ySnapPosLT = ((hv_ySnapPos.TupleSelect(0)) + (((hv_uvHxyScaled.TupleSelect(
                    3)) * (hv_Height - 1)) / 2.0)) + (((hv_uvHxyScaled.TupleSelect(4)) * (hv_Width - 1)) / 2.0);

                ho_Image.Dispose();
                ho_firstImg.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_Image.Dispose();
                ho_firstImg.Dispose();

                throw HDevExpDefaultException;
            }
        }

        /// <summary>
        /// 生成图谱点位
        /// </summary>
        /// <param name="ho_image">大图</param>
        /// <param name="ho_showContour">显示区</param>
        /// <param name="hv_modelType">模板类型</param>
        /// <param name="hv_modelID">模板id</param>
        /// <param name="hv_defRow">参考点横坐标</param>
        /// <param name="hv_defCol">参考点纵坐标</param>
        /// <param name="hv_scoreThresh">匹配分数</param>
        /// <param name="hv_xSnapPosLT">大图0点为中心时轴坐标x</param>
        /// <param name="hv_ySnapPosLT">大图0点为中心时轴坐标y</param>
        /// <param name="hv_uvHxy">Uv2Xy矩阵</param>
        /// <param name="hv_zoomFactor">降采样比例</param>
        /// <param name="hv_mapRowCnt">图谱行数</param>
        /// <param name="hv_mapColCnt">图谱列数</param>
        /// <param name="hv_mapX">图谱点位，三字扫描序，X</param>
        /// <param name="hv_mapY">图谱点位，三字扫描序，Y</param>
        /// <param name="hv_mapRow">图谱点位，三字扫描序，芯片在整个料片横坐标，0始</param>
        /// <param name="hv_mapCol">图谱点位，三字扫描序，芯片在整个料片纵坐标，0始</param>
        /// <param name="hv_mapU"></param>
        /// <param name="hv_mapV"></param>
        /// <param name="hv_dieWidth">缩放后芯片最小包围矩像素宽度</param>
        /// <param name="hv_dieHeight">缩放后芯片最小包围矩像素高度</param>
        /// <param name="hv_iFlag">操作成功标记，字符串，""成功</param>
        public static void get_mapping_coords(HObject ho_image, HObject ho_showContour, HTuple hv_modelType,
          HTuple hv_modelID, HTuple hv_defRow, HTuple hv_defCol, HTuple hv_scoreThresh,
          HTuple hv_xSnapPosLT, HTuple hv_ySnapPosLT, HTuple hv_uvHxy, HTuple hv_zoomFactor,
          HTuple hv_mapRowCnt, HTuple hv_mapColCnt, out HTuple hv_mapX, out HTuple hv_mapY,
          out HTuple hv_mapRow, out HTuple hv_mapCol, out HTuple hv_mapU, out HTuple hv_mapV,
          out HTuple hv_dieWidth, out HTuple hv_dieHeight, out HTuple hv_iFlag)
        {




            // Local iconic variables 

            HObject ho_updateShowContour = null, ho_selectShowCont = null;
            HObject ho_selectRegion = null, ho_unionRegion = null, ho_sortedContours = null;
            HObject ho_affineShowCont = null, ho_affineSortedCont = null;
            HObject ho_firstCont = null;

            // Local control variables 

            HTuple hv_found_row = new HTuple(), hv_found_col = new HTuple();
            HTuple hv_found_angle = new HTuple(), hv_found_score = new HTuple();
            HTuple hv_update_def_row = new HTuple(), hv_update_def_col = new HTuple();
            HTuple hv_model_H_new = new HTuple(), hv_iFlag1 = new HTuple();
            HTuple hv_ind = new HTuple(), hv_unionRow = new HTuple();
            HTuple hv_unionCol = new HTuple(), hv_unionPhi = new HTuple();
            HTuple hv_unionLen1 = new HTuple(), hv_unionLen2 = new HTuple();
            HTuple hv_Row = new HTuple(), hv_Column = new HTuple();
            HTuple hv_Phi = new HTuple(), hv_Length1 = new HTuple();
            HTuple hv_Length2 = new HTuple(), hv_hom2d = new HTuple();
            HTuple hv_HomMat2DInvert = new HTuple(), hv_uvHxyScaled = new HTuple();
            HTuple hv_Row1 = new HTuple(), hv_Column1 = new HTuple();
            HTuple hv_Row2 = new HTuple(), hv_Column2 = new HTuple();
            HTuple hv__dieWidth = new HTuple(), hv__dieHeight = new HTuple();
            HTuple hv_colIndSeq = new HTuple(), hv_i = new HTuple();
            HTuple hv_rowIndSeq = new HTuple(), hv_xyHuv = new HTuple();
            HTuple hv_Exception = null;
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_updateShowContour);
            HOperatorSet.GenEmptyObj(out ho_selectShowCont);
            HOperatorSet.GenEmptyObj(out ho_selectRegion);
            HOperatorSet.GenEmptyObj(out ho_unionRegion);
            HOperatorSet.GenEmptyObj(out ho_sortedContours);
            HOperatorSet.GenEmptyObj(out ho_affineShowCont);
            HOperatorSet.GenEmptyObj(out ho_affineSortedCont);
            HOperatorSet.GenEmptyObj(out ho_firstCont);
            hv_mapU = new HTuple();
            hv_mapV = new HTuple();
            try
            {
                hv_iFlag = "";
                hv_mapX = new HTuple();
                hv_mapY = new HTuple();
                hv_mapRow = new HTuple();
                hv_mapCol = new HTuple();
                hv_dieWidth = 0;
                hv_dieHeight = 0;

                try
                {

                    ho_updateShowContour.Dispose();
                    Vision.find_model(ho_image, ho_image, ho_showContour, out ho_updateShowContour,
                        hv_modelType, hv_modelID, -1, -1, hv_scoreThresh, 0, hv_defRow, hv_defCol,
                        out hv_found_row, out hv_found_col, out hv_found_angle, out hv_found_score,
                        out hv_update_def_row, out hv_update_def_col, out hv_model_H_new, out hv_iFlag1);
                    if ((int)(new HTuple(hv_iFlag1.TupleNotEqual(0))) != 0)
                    {
                        hv_iFlag = "match failed!";
                        ho_updateShowContour.Dispose();
                        ho_selectShowCont.Dispose();
                        ho_selectRegion.Dispose();
                        ho_unionRegion.Dispose();
                        ho_sortedContours.Dispose();
                        ho_affineShowCont.Dispose();
                        ho_affineSortedCont.Dispose();
                        ho_firstCont.Dispose();

                        return;
                    }
                    if ((int)(new HTuple((new HTuple(hv_found_score.TupleLength())).TupleLess(
                        hv_mapRowCnt * hv_mapColCnt))) != 0)
                    {
                        hv_iFlag = (new HTuple(new HTuple("match count ") + (new HTuple(hv_found_score.TupleLength()
                            ))) + " is not equal real die count ") + (hv_mapRowCnt * hv_mapColCnt);
                        ho_updateShowContour.Dispose();
                        ho_selectShowCont.Dispose();
                        ho_selectRegion.Dispose();
                        ho_unionRegion.Dispose();
                        ho_sortedContours.Dispose();
                        ho_affineShowCont.Dispose();
                        ho_affineSortedCont.Dispose();
                        ho_firstCont.Dispose();

                        return;
                    }
                    //******rotate
                    HOperatorSet.TupleGenSequence(1, hv_mapRowCnt * hv_mapColCnt, 1, out hv_ind);
                    ho_selectShowCont.Dispose();
                    HOperatorSet.SelectObj(ho_updateShowContour, out ho_selectShowCont, hv_ind);
                    ho_selectRegion.Dispose();
                    HOperatorSet.GenRegionContourXld(ho_selectShowCont, out ho_selectRegion,
                        "filled");
                    ho_unionRegion.Dispose();
                    HOperatorSet.Union1(ho_selectRegion, out ho_unionRegion);
                    HOperatorSet.SmallestRectangle2(ho_unionRegion, out hv_unionRow, out hv_unionCol,
                        out hv_unionPhi, out hv_unionLen1, out hv_unionLen2);
                    if ((int)(new HTuple(hv_unionPhi.TupleLess((new HTuple(-45)).TupleRad()))) != 0)
                    {
                        hv_unionPhi = hv_unionPhi + ((new HTuple(90)).TupleRad());
                    }
                    else if ((int)(new HTuple(hv_unionPhi.TupleGreater((new HTuple(45)).TupleRad()
                        ))) != 0)
                    {
                        hv_unionPhi = ((new HTuple(90)).TupleRad()) - hv_unionPhi;
                    }

                    //sort_contours_xld (selectShowCont, sortedContours, 'character', 'true', 'row')
                    //smallest_rectangle2_xld (sortedContours, Row, Column, Phi, Length1, Length2)
                    //tuple_sort_index (Column[0:mapColCnt-1], Indices)
                    //line_orientation (Row[Indices[0]], Column[Indices[0]], Row[Indices[|Indices|-1]], Column[Indices[|Indices|-1]], phi)
                    HOperatorSet.HomMat2dIdentity(out hv_hom2d);
                    HOperatorSet.HomMat2dRotate(hv_hom2d, -hv_unionPhi, 0, 0, out hv_hom2d);
                    ho_affineShowCont.Dispose();
                    HOperatorSet.AffineTransContourXld(ho_selectShowCont, out ho_affineShowCont,
                        hv_hom2d);
                    ho_sortedContours.Dispose();

                    //HTuple hv_Row_2 = new HTuple();
                    //HTuple hv_Column_2 = new HTuple();
                    //HTuple hv_Phi_2 = new HTuple();
                    //HTuple hv_Length1_2 = new HTuple();
                    //HTuple hv_Length2_2 = new HTuple();

                    //HOperatorSet.SmallestRectangle2Xld(ho_affineShowCont, out hv_Row_2, out hv_Column_2,
                    //    out hv_Phi_2, out hv_Length1_2, out hv_Length2_2);

                    HOperatorSet.SortContoursXld(ho_affineShowCont, out ho_sortedContours, "character",
                        "true", "row");
                    HOperatorSet.HomMat2dInvert(hv_hom2d, out hv_HomMat2DInvert);
                    ho_affineSortedCont.Dispose();
                    HOperatorSet.AffineTransContourXld(ho_sortedContours, out ho_affineSortedCont,
                        hv_HomMat2DInvert);
                    HOperatorSet.SmallestRectangle2Xld(ho_affineSortedCont, out hv_Row, out hv_Column,
                        out hv_Phi, out hv_Length1, out hv_Length2);
                    HOperatorSet.HomMat2dScale(hv_uvHxy, 1 / hv_zoomFactor, 1 / hv_zoomFactor, 0,
                        0, out hv_uvHxyScaled);
                    hv_mapX = (hv_xSnapPosLT + ((hv_uvHxyScaled.TupleSelect(0)) * (-hv_Row))) + ((hv_uvHxyScaled.TupleSelect(
                        1)) * (-hv_Column));
                    hv_mapY = (hv_ySnapPosLT + ((hv_uvHxyScaled.TupleSelect(3)) * (-hv_Row))) + ((hv_uvHxyScaled.TupleSelect(
                        4)) * (-hv_Column));

                    ho_firstCont.Dispose();
                    HOperatorSet.SelectObj(ho_showContour, out ho_firstCont, 1);
                    HOperatorSet.SmallestRectangle1Xld(ho_firstCont, out hv_Row1, out hv_Column1,
                        out hv_Row2, out hv_Column2);
                    hv__dieWidth = hv_Column2 - hv_Column1;
                    hv__dieHeight = hv_Row2 - hv_Row1;
                    hv_dieWidth = ((((hv_uvHxyScaled.TupleSelect(0)) * hv__dieHeight) + ((hv_uvHxyScaled.TupleSelect(
                        1)) * hv__dieWidth))).TupleAbs();
                    hv_dieHeight = ((((hv_uvHxyScaled.TupleSelect(3)) * hv__dieHeight) + ((hv_uvHxyScaled.TupleSelect(
                        4)) * hv__dieWidth))).TupleAbs();


                    HOperatorSet.TupleGenSequence(0, hv_mapColCnt - 1, 1, out hv_colIndSeq);
                    HTuple end_val55 = hv_mapRowCnt - 1;
                    HTuple step_val55 = 1;
                    for (hv_i = 0; hv_i.Continue(end_val55, step_val55); hv_i = hv_i.TupleAdd(step_val55))
                    {
                        HOperatorSet.TupleGenConst(hv_mapColCnt, hv_i, out hv_rowIndSeq);
                        hv_mapRow = hv_mapRow.TupleConcat(hv_rowIndSeq);
                        hv_mapCol = hv_mapCol.TupleConcat(hv_colIndSeq);
                    }

                    HOperatorSet.HomMat2dInvert(hv_uvHxyScaled, out hv_xyHuv);

                    hv_mapU = ((hv_xyHuv.TupleSelect(0)) * (hv_xSnapPosLT - hv_mapX)) + ((hv_xyHuv.TupleSelect(
                        1)) * (hv_ySnapPosLT - hv_mapY));
                    hv_mapV = ((hv_xyHuv.TupleSelect(3)) * (hv_xSnapPosLT - hv_mapX)) + ((hv_xyHuv.TupleSelect(
                        4)) * (hv_ySnapPosLT - hv_mapY));
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    GetErrInfo(hv_Exception, out hv_iFlag);
                }

                ho_updateShowContour.Dispose();
                ho_selectShowCont.Dispose();
                ho_selectRegion.Dispose();
                ho_unionRegion.Dispose();
                ho_sortedContours.Dispose();
                ho_affineShowCont.Dispose();
                ho_affineSortedCont.Dispose();
                ho_firstCont.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_updateShowContour.Dispose();
                ho_selectShowCont.Dispose();
                ho_selectRegion.Dispose();
                ho_unionRegion.Dispose();
                ho_sortedContours.Dispose();
                ho_affineShowCont.Dispose();
                ho_affineSortedCont.Dispose();
                ho_firstCont.Dispose();

                throw HDevExpDefaultException;
            }
        }
        /// <summary>
        /// 将区域转化为坐标
        /// </summary>
        /// <param name="ho_updateShowContour">芯片XLD</param>
        /// <param name="hv_xSnapPosLT">大图0点为中心时轴坐标x</param>
        /// <param name="hv_ySnapPosLT">大图0点为中心时轴坐标y</param>
        /// <param name="hv_uvHxy">Uv2Xy矩阵</param>
        /// <param name="hv_zoomFactor">降采样比例</param>
        /// <param name="hv_mapRowCnt">图谱行数</param>
        /// <param name="hv_mapColCnt">图谱列数</param>
        /// <param name="hv_mapX">图谱点位，三字扫描序，X</param>
        /// <param name="hv_mapY">图谱点位，三字扫描序，Y</param>
        /// <param name="hv_mapRow">图谱点位，三字扫描序，芯片在整个料片横坐标，0始</param>
        /// <param name="hv_mapCol">图谱点位，三字扫描序，芯片在整个料片纵坐标，0始</param>
        /// <param name="hv_mapU"></param>
        /// <param name="hv_mapV"></param>
        /// <param name="hv_dieWidth">缩放后芯片最小包围矩像素宽度</param>
        /// <param name="hv_dieHeight">缩放后芯片最小包围矩像素高度</param>
        /// <param name="hv_iFlag">操作成功标记，字符串，""成功</param>
        public static void get_mapping_coords_ext(HObject ho_updateShowContour, HTuple hv_xSnapPosLT,
      HTuple hv_ySnapPosLT, HTuple hv_uvHxy, HTuple hv_zoomFactor, HTuple hv_mapRowCnt,
      HTuple hv_mapColCnt, out HTuple hv_mapX, out HTuple hv_mapY, out HTuple hv_mapRow,
      out HTuple hv_mapCol, out HTuple hv_mapU, out HTuple hv_mapV, out HTuple hv_dieWidth,
      out HTuple hv_dieHeight, out HTuple hv_iFlag)
        {




            // Local iconic variables 

            HObject ho_selectShowCont = null, ho_selectRegion = null;
            HObject ho_unionRegion = null, ho_affineShowCont = null, ho_sortedContours = null;
            HObject ho_affineSortedCont = null, ho_firstCont = null;

            // Local control variables 

            HTuple hv_ind = new HTuple(), hv_unionRow = new HTuple();
            HTuple hv_unionCol = new HTuple(), hv_unionPhi = new HTuple();
            HTuple hv_unionLen1 = new HTuple(), hv_unionLen2 = new HTuple();
            HTuple hv_hom2d = new HTuple(), hv_Row3 = new HTuple();
            HTuple hv_Column3 = new HTuple(), hv_Phi1 = new HTuple();
            HTuple hv_Length11 = new HTuple(), hv_Length21 = new HTuple();
            HTuple hv_Indices = new HTuple(), hv_sortedIndices = new HTuple();
            HTuple hv_i = new HTuple(), hv_indices = new HTuple();
            HTuple hv_cols = new HTuple(), hv_Indices1 = new HTuple();
            HTuple hv_HomMat2DInvert = new HTuple(), hv_Row = new HTuple();
            HTuple hv_Column = new HTuple(), hv_Phi = new HTuple();
            HTuple hv_Length1 = new HTuple(), hv_Length2 = new HTuple();
            HTuple hv_uvHxyScaled = new HTuple(), hv_Row1 = new HTuple();
            HTuple hv_Column1 = new HTuple(), hv_Row2 = new HTuple();
            HTuple hv_Column2 = new HTuple(), hv__dieWidth = new HTuple();
            HTuple hv__dieHeight = new HTuple(), hv_colIndSeq = new HTuple();
            HTuple hv_rowIndSeq = new HTuple(), hv_xyHuv = new HTuple();
            HTuple hv_Exception = null;
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_selectShowCont);
            HOperatorSet.GenEmptyObj(out ho_selectRegion);
            HOperatorSet.GenEmptyObj(out ho_unionRegion);
            HOperatorSet.GenEmptyObj(out ho_affineShowCont);
            HOperatorSet.GenEmptyObj(out ho_sortedContours);
            HOperatorSet.GenEmptyObj(out ho_affineSortedCont);
            HOperatorSet.GenEmptyObj(out ho_firstCont);
            hv_mapU = new HTuple();
            hv_mapV = new HTuple();
            try
            {
                hv_iFlag = "";
                hv_mapX = new HTuple();
                hv_mapY = new HTuple();
                hv_mapRow = new HTuple();
                hv_mapCol = new HTuple();
                hv_dieWidth = 0;
                hv_dieHeight = 0;

                try
                {
                    //******rotate
                    HOperatorSet.TupleGenSequence(1, hv_mapRowCnt * hv_mapColCnt, 1, out hv_ind);
                    ho_selectShowCont.Dispose();
                    HOperatorSet.SelectObj(ho_updateShowContour, out ho_selectShowCont, hv_ind);
                    ho_selectRegion.Dispose();
                    HOperatorSet.GenRegionContourXld(ho_selectShowCont, out ho_selectRegion,
                        "filled");
                    ho_unionRegion.Dispose();
                    HOperatorSet.Union1(ho_selectRegion, out ho_unionRegion);
                    HOperatorSet.SmallestRectangle2(ho_unionRegion, out hv_unionRow, out hv_unionCol,
                        out hv_unionPhi, out hv_unionLen1, out hv_unionLen2);
                    if ((int)(new HTuple(hv_unionPhi.TupleLess((new HTuple(-45)).TupleRad()))) != 0)
                    {
                        hv_unionPhi = hv_unionPhi + ((new HTuple(90)).TupleRad());
                    }
                    else if ((int)(new HTuple(hv_unionPhi.TupleGreater((new HTuple(45)).TupleRad()
                        ))) != 0)
                    {
                        hv_unionPhi = ((new HTuple(90)).TupleRad()) - hv_unionPhi;
                    }

                    HOperatorSet.HomMat2dIdentity(out hv_hom2d);
                    HOperatorSet.HomMat2dRotate(hv_hom2d, -hv_unionPhi, 0, 0, out hv_hom2d);
                    ho_affineShowCont.Dispose();
                    HOperatorSet.AffineTransContourXld(ho_selectShowCont, out ho_affineShowCont,
                        hv_hom2d);
                    HOperatorSet.SmallestRectangle2Xld(ho_affineShowCont, out hv_Row3, out hv_Column3,
                        out hv_Phi1, out hv_Length11, out hv_Length21);
                    HOperatorSet.TupleSortIndex(hv_Row3, out hv_Indices);
                    hv_sortedIndices = new HTuple();
                    HTuple end_val27 = hv_mapRowCnt - 1;
                    HTuple step_val27 = 1;
                    for (hv_i = 0; hv_i.Continue(end_val27, step_val27); hv_i = hv_i.TupleAdd(step_val27))
                    {
                        hv_indices = hv_Indices.TupleSelectRange(hv_i * hv_mapColCnt, ((hv_i + 1) * hv_mapColCnt) - 1);
                        hv_cols = hv_Column3.TupleSelect(hv_indices);
                        HOperatorSet.TupleSortIndex(hv_cols, out hv_Indices1);
                        hv_sortedIndices = hv_sortedIndices.TupleConcat(hv_indices.TupleSelect(
                            hv_Indices1));
                    }
                    ho_sortedContours.Dispose();
                    //2019.4.8 修改 将ho_selectShowCont 改成 ho_affineShowCont
                    HOperatorSet.SelectObj(ho_affineShowCont, out ho_sortedContours, hv_sortedIndices + 1);
                    HOperatorSet.HomMat2dInvert(hv_hom2d, out hv_HomMat2DInvert);
                    ho_affineSortedCont.Dispose();
                    HOperatorSet.AffineTransContourXld(ho_sortedContours, out ho_affineSortedCont,
                        hv_HomMat2DInvert);
                    HOperatorSet.SmallestRectangle2Xld(ho_affineSortedCont, out hv_Row, out hv_Column,
                        out hv_Phi, out hv_Length1, out hv_Length2);
                    HOperatorSet.HomMat2dScale(hv_uvHxy, 1 / hv_zoomFactor, 1 / hv_zoomFactor, 0,
                        0, out hv_uvHxyScaled);
                    hv_mapX = (hv_xSnapPosLT + ((hv_uvHxyScaled.TupleSelect(0)) * (-hv_Row))) + ((hv_uvHxyScaled.TupleSelect(
                        1)) * (-hv_Column));
                    hv_mapY = (hv_ySnapPosLT + ((hv_uvHxyScaled.TupleSelect(3)) * (-hv_Row))) + ((hv_uvHxyScaled.TupleSelect(
                        4)) * (-hv_Column));

                    ho_firstCont.Dispose();
                    HOperatorSet.SelectObj(ho_affineShowCont, out ho_firstCont, 1);
                    HOperatorSet.SmallestRectangle1Xld(ho_firstCont, out hv_Row1, out hv_Column1,
                        out hv_Row2, out hv_Column2);
                    hv__dieWidth = hv_Column2 - hv_Column1;
                    hv__dieHeight = hv_Row2 - hv_Row1;
                    hv_dieWidth = ((((hv_uvHxyScaled.TupleSelect(0)) * hv__dieHeight) + ((hv_uvHxyScaled.TupleSelect(
                        1)) * hv__dieWidth))).TupleAbs();
                    hv_dieHeight = ((((hv_uvHxyScaled.TupleSelect(3)) * hv__dieHeight) + ((hv_uvHxyScaled.TupleSelect(
                        4)) * hv__dieWidth))).TupleAbs();

                    HOperatorSet.TupleGenSequence(0, hv_mapColCnt - 1, 1, out hv_colIndSeq);
                    HTuple end_val49 = hv_mapRowCnt - 1;
                    HTuple step_val49 = 1;
                    for (hv_i = 0; hv_i.Continue(end_val49, step_val49); hv_i = hv_i.TupleAdd(step_val49))
                    {
                        HOperatorSet.TupleGenConst(hv_mapColCnt, hv_i, out hv_rowIndSeq);
                        hv_mapRow = hv_mapRow.TupleConcat(hv_rowIndSeq);
                        hv_mapCol = hv_mapCol.TupleConcat(hv_colIndSeq);
                    }

                    HOperatorSet.HomMat2dInvert(hv_uvHxyScaled, out hv_xyHuv);

                    hv_mapU = ((hv_xyHuv.TupleSelect(0)) * (hv_xSnapPosLT - hv_mapX)) + ((hv_xyHuv.TupleSelect(
                        1)) * (hv_ySnapPosLT - hv_mapY));
                    hv_mapV = ((hv_xyHuv.TupleSelect(3)) * (hv_xSnapPosLT - hv_mapX)) + ((hv_xyHuv.TupleSelect(
                        4)) * (hv_ySnapPosLT - hv_mapY));
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    GetErrInfo(hv_Exception, out hv_iFlag);
                }

                ho_selectShowCont.Dispose();
                ho_selectRegion.Dispose();
                ho_unionRegion.Dispose();
                ho_affineShowCont.Dispose();
                ho_sortedContours.Dispose();
                ho_affineSortedCont.Dispose();
                ho_firstCont.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_selectShowCont.Dispose();
                ho_selectRegion.Dispose();
                ho_unionRegion.Dispose();
                ho_affineShowCont.Dispose();
                ho_sortedContours.Dispose();
                ho_affineSortedCont.Dispose();
                ho_firstCont.Dispose();

                throw HDevExpDefaultException;
            }
        }
        public static void tile_map_images(HObject ho_Images, out HObject ho_TiledImage, HTuple hv_xSnapPos,
          HTuple hv_ySnapPos, HTuple hv_uvHxy, HTuple hv_rowCnt, HTuple hv_colCnt, HTuple hv_zoomFactor,
          out HTuple hv_iFlag)
        {




            // Local iconic variables 

            HObject ho_firstImage = null, ho_ImageZoomed = null;

            // Local control variables 

            HTuple hv_width = null, hv_height = null, hv_Width = new HTuple();
            HTuple hv_Height = new HTuple(), hv__xSnapPos = new HTuple();
            HTuple hv__ySnapPos = new HTuple(), hv_uvHxyScaled = new HTuple();
            HTuple hv_xyHuv = new HTuple(), hv_offsetRows = new HTuple();
            HTuple hv_offsetCols = new HTuple(), hv_row1 = new HTuple();
            HTuple hv_col1 = new HTuple(), hv_row2 = new HTuple();
            HTuple hv_col2 = new HTuple(), hv_Exception = null;
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_TiledImage);
            HOperatorSet.GenEmptyObj(out ho_firstImage);
            HOperatorSet.GenEmptyObj(out ho_ImageZoomed);
            try
            {
                hv_iFlag = "";
                hv_width = 0;
                hv_height = 0;
                ho_TiledImage.Dispose();
                HOperatorSet.GenEmptyObj(out ho_TiledImage);

                //factor := 1/2.0
                try
                {
                    ho_firstImage.Dispose();
                    HOperatorSet.SelectObj(ho_Images, out ho_firstImage, 1);
                    HOperatorSet.GetImageSize(ho_firstImage, out hv_Width, out hv_Height);
                    //_xSnapPos := xSnapPos + uvHxy[0]*(-(Height-1)/2.0)+uvHxy[1]*(-(Width-1)/2.0)
                    //_ySnapPos := ySnapPos + uvHxy[3]*(-(Height-1)/2.0)+uvHxy[4]*(-(Width-1)/2.0)
                    hv__xSnapPos = (hv_xSnapPos + (((hv_uvHxy.TupleSelect(0)) * (hv_Height - 1)) / 2.0)) + (((hv_uvHxy.TupleSelect(
                        1)) * (hv_Width - 1)) / 2.0);
                    hv__ySnapPos = (hv_ySnapPos + (((hv_uvHxy.TupleSelect(3)) * (hv_Height - 1)) / 2.0)) + (((hv_uvHxy.TupleSelect(
                        4)) * (hv_Width - 1)) / 2.0);
                    HOperatorSet.HomMat2dScale(hv_uvHxy, 1 / hv_zoomFactor, 1 / hv_zoomFactor, 0,
                        0, out hv_uvHxyScaled);
                    HOperatorSet.HomMat2dInvert(hv_uvHxyScaled, out hv_xyHuv);
                    //affine_trans_point_2d (xyHuv, _xSnapPos, _ySnapPos, affineRows, affineCols)
                    //*     offsetRows1 := affineRows[0]-affineRows
                    //*     offsetCols1 := affineCols[0]-affineCols

                    //HTuple affineRows, affineCols;
                    //HOperatorSet.AffineTransPoint2d(hv_xyHuv, hv__xSnapPos, hv__ySnapPos, out affineRows, out affineCols);
                    //hv_offsetRows = affineRows[0] - affineRows;
                    //hv_offsetCols = affineCols[0] - affineCols;
                    //double d = 1.0 / (hv_uvHxyScaled[0] * hv_uvHxyScaled[4] - hv_uvHxyScaled[1] * hv_uvHxyScaled[3]);
                    //double a0 = hv_uvHxyScaled[4] * d;
                    //double a1 = -1*hv_uvHxyScaled[1] * d;
                    hv_offsetRows = ((hv_xyHuv.TupleSelect(0)) * ((hv__xSnapPos.TupleSelect(0)) - hv__xSnapPos)) + ((hv_xyHuv.TupleSelect(
                        1)) * ((hv__ySnapPos.TupleSelect(0)) - hv__ySnapPos));
                    hv_offsetCols = ((hv_xyHuv.TupleSelect(3)) * ((hv__xSnapPos.TupleSelect(0)) - hv__xSnapPos)) + ((hv_xyHuv.TupleSelect(
                        4)) * ((hv__ySnapPos.TupleSelect(0)) - hv__ySnapPos));


                    hv_width = ((((hv_offsetCols.TupleMax()) - (hv_offsetCols.TupleMin()))).TupleInt()
                        ) + hv_Width;
                    hv_height = ((((hv_offsetRows.TupleMax()) - (hv_offsetRows.TupleMin()))).TupleInt()
                        ) + hv_Height;
                    HOperatorSet.TupleGenConst(new HTuple(hv_offsetRows.TupleLength()), -1, out hv_row1);
                    HOperatorSet.TupleGenConst(new HTuple(hv_offsetRows.TupleLength()), -1, out hv_col1);
                    HOperatorSet.TupleGenConst(new HTuple(hv_offsetRows.TupleLength()), -1, out hv_row2);
                    HOperatorSet.TupleGenConst(new HTuple(hv_offsetRows.TupleLength()), -1, out hv_col2);
                    ho_ImageZoomed.Dispose();
                    HOperatorSet.ZoomImageFactor(ho_Images, out ho_ImageZoomed, hv_zoomFactor,
                        hv_zoomFactor, "constant");
                    ho_TiledImage.Dispose();
                    HOperatorSet.TileImagesOffset(ho_ImageZoomed, out ho_TiledImage, hv_offsetRows,
                        hv_offsetCols, hv_row1, hv_col1, hv_row2, hv_col2, hv_width, hv_height);
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    GetErrInfo(hv_Exception, out hv_iFlag);
                }

                ho_firstImage.Dispose();
                ho_ImageZoomed.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_firstImage.Dispose();
                ho_ImageZoomed.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public static void GetErrInfo(HTuple hv_Exception, out HTuple hv_ErrMessage)
        {



            // Local iconic variables 
            // Initialize local and output iconic variables 
            hv_ErrMessage = (((("method [" + (hv_Exception.TupleSelect(7))) + "] use [") + (hv_Exception.TupleSelect(
                5))) + "] err! ") + (hv_Exception.TupleSelect(2));

            return;
        }

        /// <summary>
        /// 获取扫描点位
        /// </summary>
        /// <param name="hv_imageWidth">原始图宽</param>
        /// <param name="hv_imageHeight">原始图高</param>
        /// <param name="hv_widthFactor">原始图宽使用比例</param>
        /// <param name="hv_heightFactor">原始图高使用比例</param>
        /// <param name="hv_zoomFactor">缩放比例，跟前用保持一致</param>
        /// <param name="hv_dieWidth">缩放后芯片最小包围矩像素宽度</param>
        /// <param name="hv_dieHeight">缩放后芯片最小包围矩像素高度</param>
        /// <param name="hv_mapX">图谱点位，三字扫描序，X</param>
        /// <param name="hv_mapY">图谱点位，三字扫描序，Y</param>
        /// <param name="hv_uvHxy">映射矩阵</param>
        /// <param name="hv_xSnapPosLT">大图0点为中心时轴坐标X</param>
        /// <param name="hv_ySnapPosLT">大图0点为中心时轴坐标Y</param>
        /// <param name="hv_mapRowCnt">图谱行数</param>
        /// <param name="hv_mapColCnt">图谱列数</param>
        /// <param name="hv_M">视野内芯片行数</param>
        /// <param name="hv_N">视野内芯片列数</param>
        /// <param name="hv_snapMapX">拍照点位X</param>
        /// <param name="hv_snapMapY">拍照点Y</param>
        /// <param name="hv_iFlag">错误，""无错</param>
        public static void get_scan_points(out HObject ho_scanRects, HTuple hv_imageWidth, HTuple hv_imageHeight,
      HTuple hv_widthFactor, HTuple hv_heightFactor, HTuple hv_zoomFactor, HTuple hv_dieWidth,
      HTuple hv_dieHeight, HTuple hv_mapX, HTuple hv_mapY, HTuple hv_uvHxy, HTuple hv_xSnapPosLT,
      HTuple hv_ySnapPosLT, HTuple hv_mapRowCnt, HTuple hv_mapColCnt, out HTuple hv_M,
      out HTuple hv_N, out HTuple hv_snapMapX, out HTuple hv_snapMapY, out HTuple hv_snapMapRow,
      out HTuple hv_snapMapCol, out HTuple hv_iFlag)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_viewWidth = new HTuple(), hv_viewHeight = new HTuple();
            HTuple hv_uvHxyScaled = new HTuple(), hv_xyHuv = new HTuple();
            HTuple hv__dieHeight = new HTuple(), hv__dieWidth = new HTuple();
            HTuple hv_mapU = new HTuple(), hv_mapV = new HTuple();
            HTuple hv_minH = new HTuple(), hv_minV = new HTuple();
            HTuple hv_i = new HTuple(), hv_j = new HTuple(), hv_rowConst0 = new HTuple();
            HTuple hv_colConst0 = new HTuple(), hv_distH = new HTuple();
            HTuple hv_rowConst1 = new HTuple(), hv_colConst1 = new HTuple();
            HTuple hv_rowSeq = new HTuple(), hv_distV = new HTuple();
            HTuple hv_sortDistH = new HTuple(), hv_sortDistV = new HTuple();
            HTuple hv__minH = new HTuple(), hv__minV = new HTuple();
            HTuple hv_deltaRow = new HTuple(), hv_deltaCol = new HTuple();
            HTuple hv_scanRows = new HTuple(), hv_scanCols = new HTuple();
            HTuple hv_scanRowCnt = new HTuple(), hv_scanColCnt = new HTuple();
            HTuple hv_I = new HTuple(), hv_J = new HTuple(), hv_initScanRow = new HTuple();
            HTuple hv_initScanCol = new HTuple(), hv_p = new HTuple();
            HTuple hv__snapMapX = new HTuple(), hv__snapMapY = new HTuple();
            HTuple hv_seqInd = new HTuple(), hv_rowIndConst = new HTuple();
            HTuple hv_colIndSeq = new HTuple(), hv__x = new HTuple();
            HTuple hv__y = new HTuple(), hv_Exception = null;
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_scanRects);
            hv_iFlag = "";
            hv_M = 0;
            hv_N = 0;
            hv_snapMapX = new HTuple();
            hv_snapMapY = new HTuple();
            hv_snapMapRow = new HTuple();
            hv_snapMapCol = new HTuple();
            ho_scanRects.Dispose();
            HOperatorSet.GenEmptyObj(out ho_scanRects);

            try
            {
                hv_viewWidth = (hv_imageWidth * hv_widthFactor) * hv_zoomFactor;
                hv_viewHeight = (hv_imageHeight * hv_heightFactor) * hv_zoomFactor;
                //*****计算点扫拍照点位
                HOperatorSet.HomMat2dScale(hv_uvHxy, 1 / hv_zoomFactor, 1 / hv_zoomFactor, 0, 0,
                    out hv_uvHxyScaled);
                HOperatorSet.HomMat2dInvert(hv_uvHxyScaled, out hv_xyHuv);
                hv__dieHeight = ((((hv_xyHuv.TupleSelect(0)) * hv_dieWidth) + ((hv_xyHuv.TupleSelect(
                    1)) * (-hv_dieHeight)))).TupleAbs();
                hv__dieWidth = ((((hv_xyHuv.TupleSelect(3)) * hv_dieWidth) + ((hv_xyHuv.TupleSelect(
                    4)) * (-hv_dieHeight)))).TupleAbs();
                hv_mapU = ((hv_xyHuv.TupleSelect(0)) * (hv_xSnapPosLT - hv_mapX)) + ((hv_xyHuv.TupleSelect(
                    1)) * (hv_ySnapPosLT - hv_mapY));
                hv_mapV = ((hv_xyHuv.TupleSelect(3)) * (hv_xSnapPosLT - hv_mapX)) + ((hv_xyHuv.TupleSelect(
                    4)) * (hv_ySnapPosLT - hv_mapY));
                //gen_cross_contour_xld (Cross, mapUOut, mapVOut, 10, 0)
                //gen_rectangle1_contour_xld (rectangle, mapU-dieHeight/2.0, mapV-dieWidth/2.0, mapU+dieHeight/2.0, mapV+dieWidth/2.0)
                //***计算MN
                hv_M = 1;
                hv_N = 1;
                //***计算die之间最小间距minH,minV
                hv_minH = 99999;
                hv_minV = 99999;
                HTuple end_val27 = hv_mapRowCnt - 1;
                HTuple step_val27 = 1;
                for (hv_i = 0; hv_i.Continue(end_val27, step_val27); hv_i = hv_i.TupleAdd(step_val27))
                {
                    HTuple end_val28 = hv_mapColCnt - 1;
                    HTuple step_val28 = 1;
                    for (hv_j = 0; hv_j.Continue(end_val28, step_val28); hv_j = hv_j.TupleAdd(step_val28))
                    {
                        HOperatorSet.TupleGenConst(hv_mapColCnt, hv_mapU.TupleSelect((hv_i * hv_mapColCnt) + hv_j),
                            out hv_rowConst0);
                        HOperatorSet.TupleGenConst(hv_mapColCnt, hv_mapV.TupleSelect((hv_i * hv_mapColCnt) + hv_j),
                            out hv_colConst0);
                        HOperatorSet.DistancePp(hv_rowConst0, hv_colConst0, hv_mapU.TupleSelectRange(
                            hv_i * hv_mapColCnt, ((hv_i + 1) * hv_mapColCnt) - 1), hv_mapV.TupleSelectRange(
                            hv_i * hv_mapColCnt, ((hv_i + 1) * hv_mapColCnt) - 1), out hv_distH);

                        HOperatorSet.TupleGenConst(hv_mapRowCnt, hv_mapU.TupleSelect((hv_i * hv_mapColCnt) + hv_j),
                            out hv_rowConst1);
                        HOperatorSet.TupleGenConst(hv_mapRowCnt, hv_mapV.TupleSelect((hv_i * hv_mapColCnt) + hv_j),
                            out hv_colConst1);
                        HOperatorSet.TupleGenSequence(hv_j, ((hv_mapRowCnt * hv_mapColCnt) - 1) + hv_j,
                            hv_mapColCnt, out hv_rowSeq);
                        HOperatorSet.DistancePp(hv_rowConst1, hv_colConst1, hv_mapU.TupleSelect(
                            hv_rowSeq), hv_mapV.TupleSelect(hv_rowSeq), out hv_distV);

                        //if (hv_distV[hv_i].D==0)
                        //{
                        //    hv__minH = 0.01;
                        //    hv_minV = 0.01;
                        //}
                        //else
                        //{
                            HOperatorSet.TupleSort(hv_distH, out hv_sortDistH);
                            HOperatorSet.TupleSort(hv_distV, out hv_sortDistV);
                            hv__minH = hv_sortDistH[1];
                            hv__minV = hv_sortDistV[1];
                            if ((int)(new HTuple(hv__minH.TupleLess(hv_minH))) != 0)
                            {
                                hv_minH = hv__minH.Clone();
                            }
                            if ((int)(new HTuple(hv__minV.TupleLess(hv_minV))) != 0)
                            {
                                hv_minV = hv__minV.Clone();
                            }
                        //}
                    }
                }

                //****计算M
                while ((int)(1) != 0)
                {
                    if ((int)(new HTuple((((hv_viewHeight * hv_M) / (hv_M + 1))).TupleGreaterEqual(
                        hv__dieHeight + (hv_minV * (hv_M - 1))))) != 0)
                    {
                        hv_M = hv_M + 1;
                        continue;
                    }
                    else
                    {
                        break;
                    }
                }
                //*****计算N
                while ((int)(1) != 0)
                {
                    if ((int)(new HTuple((((hv_viewWidth * hv_N) / (hv_N + 1))).TupleGreaterEqual(hv__dieWidth + (hv_minH * (hv_N - 1))))) != 0)
                    {
                        hv_N = hv_N + 1;
                        continue;
                    }
                    else
                    {
                        break;
                    }
                }
                //stop ()
                //*******生成扫描点阵,先假设视野内左上角芯片距离视野中心关系为minH,minV;实际是需要根据uvHxy,Δu,Δv,计算图像中心所在的xy坐标

                hv_deltaRow = ((hv_M - 1) / 2.0) * hv_minV;
                hv_deltaCol = ((hv_N - 1) / 2.0) * hv_minH;
                hv_scanRows = new HTuple();
                hv_scanCols = new HTuple();
                hv_scanRowCnt = 0;
                hv_scanColCnt = 0;
                hv_i = 0;
                while ((int)(new HTuple(hv_i.TupleLess(hv_mapRowCnt))) != 0)
                {
                    hv_I = 1;
                    hv_j = 0;

                    while ((int)(new HTuple(hv_j.TupleLess(hv_mapColCnt))) != 0)
                    {
                        hv_J = 1;
                        hv_initScanRow = (hv_mapU.TupleSelect((hv_i * hv_mapColCnt) + hv_j)) + hv_deltaRow;
                        hv_initScanCol = (hv_mapV.TupleSelect((hv_i * hv_mapColCnt) + hv_j)) + hv_deltaCol;
                        //gen_cross_contour_xld (Cross2, initScanRow, initScanCol, 16, 0)
                        if ((int)(new HTuple(((hv_initScanCol + (hv_viewWidth / 2.0))).TupleGreaterEqual(
                            (hv_mapV.TupleSelect(((hv_i + 1) * hv_mapColCnt) - 1)) + (hv__dieWidth / 2.0)))) != 0)
                        {
                            //gen_cross_contour_xld (Cross2, initScanRow, initScanCol, 16, 0.25)
                            hv_scanRows = hv_scanRows.TupleConcat(hv_initScanRow);
                            hv_scanCols = hv_scanCols.TupleConcat(hv_initScanCol);
                            hv_scanColCnt = hv_scanColCnt + 1;
                            break;
                        }
                        else
                        {
                            HTuple end_val95 = hv_mapColCnt - 1;
                            HTuple step_val95 = 1;
                            for (hv_p = hv_j + 1; hv_p.Continue(end_val95, step_val95); hv_p = hv_p.TupleAdd(step_val95))
                            {
                                if ((int)(new HTuple(((hv_initScanCol + (hv_viewWidth / 2.0))).TupleGreaterEqual(
                                    (hv_mapV.TupleSelect((hv_i * hv_mapColCnt) + hv_p)) + (hv__dieWidth / 2.0)))) != 0)
                                {
                                    hv_J = hv_J + 1;
                                }
                                else
                                {
                                    //gen_cross_contour_xld (Cross2, initScanRow, initScanCol, 16, 0.25)
                                    hv_scanRows = hv_scanRows.TupleConcat(hv_initScanRow);
                                    hv_scanCols = hv_scanCols.TupleConcat(hv_initScanCol);
                                    hv_scanColCnt = hv_scanColCnt + 1;
                                    break;
                                }
                            }
                        }
                        hv_j = hv_j + hv_J;
                    }

                    if ((int)(new HTuple(((hv_initScanRow + (hv_viewHeight / 2.0))).TupleGreaterEqual(
                        (hv_mapU.TupleSelect((hv_mapRowCnt * hv_mapColCnt) - 1)) + (hv__dieHeight / 2.0)))) != 0)
                    {
                        hv_scanRowCnt = hv_scanRowCnt + 1;
                        break;
                    }
                    else
                    {
                        HTuple end_val114 = hv_mapRowCnt - 1;
                        HTuple step_val114 = 1;
                        for (hv_p = hv_i + 1; hv_p.Continue(end_val114, step_val114); hv_p = hv_p.TupleAdd(step_val114))
                        {
                            if ((int)(new HTuple(((hv_initScanRow + (hv_viewHeight / 2.0))).TupleGreaterEqual(
                                (hv_mapU.TupleSelect(((hv_p + 1) * hv_mapColCnt) - 1)) + (hv__dieHeight / 2.0)))) != 0)
                            {
                                hv_I = hv_I + 1;
                            }
                            else
                            {
                                hv_scanRowCnt = hv_scanRowCnt + 1;
                                break;
                            }
                        }
                    }
                    hv_i = hv_i + hv_I;
                }
                hv_scanColCnt = hv_scanColCnt / hv_scanRowCnt;

                ho_scanRects.Dispose();
                gen_rectangle1_contour_xld(out ho_scanRects, hv_scanRows - (hv_viewHeight / 2.0),
                    hv_scanCols - (hv_viewWidth / 2.0), hv_scanRows + (hv_viewHeight / 2.0), hv_scanCols + (hv_viewWidth / 2.0));
                //gen_cross_contour_xld (Cross3, scanRows, scanCols, 36, 0.5)

                hv__snapMapX = (hv_xSnapPosLT + ((hv_uvHxyScaled.TupleSelect(0)) * (-hv_scanRows))) + ((hv_uvHxyScaled.TupleSelect(
                    1)) * (-hv_scanCols));
                hv__snapMapY = (hv_ySnapPosLT + ((hv_uvHxyScaled.TupleSelect(3)) * (-hv_scanRows))) + ((hv_uvHxyScaled.TupleSelect(
                    4)) * (-hv_scanCols));
                //*****将扫描点位按弓字形排序
                HTuple end_val133 = hv_scanRowCnt - 1;
                HTuple step_val133 = 1;
                for (hv_i = 0; hv_i.Continue(end_val133, step_val133); hv_i = hv_i.TupleAdd(step_val133))
                {
                    HOperatorSet.TupleGenSequence(hv_i * hv_scanColCnt, ((hv_i + 1) * hv_scanColCnt) - 1,
                        1, out hv_seqInd);
                    HOperatorSet.TupleGenConst(hv_scanColCnt, hv_i, out hv_rowIndConst);
                    HOperatorSet.TupleGenSequence(0, hv_scanColCnt - 1, 1, out hv_colIndSeq);
                    if ((int)(new HTuple(((hv_i % 2)).TupleEqual(0))) != 0)
                    {
                        hv__x = hv__snapMapX.TupleSelect(hv_seqInd);
                        hv__y = hv__snapMapY.TupleSelect(hv_seqInd);
                    }
                    else
                    {
                        hv__x = ((hv__snapMapX.TupleSelect(hv_seqInd))).TupleInverse();
                        hv__y = ((hv__snapMapY.TupleSelect(hv_seqInd))).TupleInverse();
                        hv_colIndSeq = hv_colIndSeq.TupleInverse();
                    }
                    hv_snapMapX = hv_snapMapX.TupleConcat(hv__x);
                    hv_snapMapY = hv_snapMapY.TupleConcat(hv__y);
                    hv_snapMapRow = hv_snapMapRow.TupleConcat(hv_rowIndConst);
                    hv_snapMapCol = hv_snapMapCol.TupleConcat(hv_colIndSeq);
                }


            }
            // catch (Exception) 
            catch (HalconException HDevExpDefaultException1)
            {
                HDevExpDefaultException1.ToHTuple(out hv_Exception);
                GetErrInfo(hv_Exception, out hv_iFlag);
            }

            return;
        }


        /// <summary>
        /// 根据矫正点位更新芯片点位扫描点位
        /// </summary>
        /// <param name="ho_image">矫正点图片</param>
        /// <param name="ho_matchRegion">模板匹配区</param>
        /// <param name="hv_modelType">模板类型</param>
        /// <param name="hv_modelID">模板ID</param>
        /// <param name="hv_scoreThresh">匹配分数</param>
        /// <param name="hv_mapX">芯片X</param>
        /// <param name="hv_mapY">芯片Y</param>
        /// <param name="hv_snapMapX">扫描点X</param>
        /// <param name="hv_snapMapY">扫描点Y</param>
        /// <param name="hv_uvHxy">变换矩阵</param>
        /// <param name="hv_updateMapX">更新后芯片点X</param>
        /// <param name="hv_updateMapY">更新后芯片点Y</param>
        /// <param name="hv_updateSnapMapX">更新后扫描点X</param>
        /// <param name="hv_updateSnapMapY">更新后扫描点Y</param>
        /// <param name="hv_iFlag">标志</param>
        public static void update_map_points(HObject ho_image, HObject ho_matchRegion, HTuple hv_modelType,
          HTuple hv_modelID, HTuple hv_scoreThresh, HTuple hv_mapX, HTuple hv_mapY, HTuple hv_snapMapX,
          HTuple hv_snapMapY, HTuple hv_uvHxy, out HTuple hv_updateMapX, out HTuple hv_updateMapY,
          out HTuple hv_updateSnapMapX, out HTuple hv_updateSnapMapY, out HTuple hv_found_row, out HTuple hv_found_col, out HTuple hv_iFlag)
        {




            // Local iconic variables 

            HObject ho_showCount = null, ho_update_show_contour = null;

            // Local control variables 

            HTuple hv_found_angle = new HTuple(), hv_found_score = new HTuple();
            HTuple hv_update_def_row = new HTuple(), hv_update_def_col = new HTuple();
            HTuple hv_model_H_new = new HTuple(), hv_iFlag1 = new HTuple();
            HTuple hv_modelHimg = new HTuple(), hv_deltaX = new HTuple();
            HTuple hv_deltaY = new HTuple(), hv_modelHmap = new HTuple();
            HTuple hv_Exception = null;
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_showCount);
            HOperatorSet.GenEmptyObj(out ho_update_show_contour);
            try
            {
                hv_iFlag = "";
                hv_updateMapX = new HTuple();
                hv_updateMapY = new HTuple();
                hv_updateSnapMapX = new HTuple();
                hv_updateSnapMapY = new HTuple();
                hv_found_row = new HTuple();
                hv_found_col = new HTuple();

                try
                {
                    ho_showCount.Dispose();
                    HOperatorSet.GenEmptyObj(out ho_showCount);
                    ho_update_show_contour.Dispose();
                    ToolKits.FunctionModule.Vision.find_model(ho_image, ho_matchRegion, ho_showCount, out ho_update_show_contour,
                        hv_modelType, hv_modelID, -1, -1, hv_scoreThresh, 1, -1, -1, out hv_found_row,
                        out hv_found_col, out hv_found_angle, out hv_found_score, out hv_update_def_row,
                        out hv_update_def_col, out hv_modelHimg, out hv_iFlag1);
                    if ((int)(new HTuple(hv_iFlag1.TupleNotEqual(0))) != 0)
                    {
                        hv_iFlag = "match failed!";
                        ho_showCount.Dispose();
                        ho_update_show_contour.Dispose();

                        return;
                    }
                    hv_deltaX = ((hv_uvHxy.TupleSelect(0)) * (-(hv_modelHimg.TupleSelect(2)))) + ((hv_uvHxy.TupleSelect(
                        1)) * (-(hv_modelHimg.TupleSelect(5))));
                    hv_deltaY = ((hv_uvHxy.TupleSelect(3)) * (-(hv_modelHimg.TupleSelect(2)))) + ((hv_uvHxy.TupleSelect(
                        4)) * (-(hv_modelHimg.TupleSelect(5))));
                    hv_modelHmap = hv_modelHimg.Clone();
                    if (hv_modelHmap == null)
                        hv_modelHmap = new HTuple();
                    hv_modelHmap[2] = hv_deltaX;
                    if (hv_modelHmap == null)
                        hv_modelHmap = new HTuple();
                    hv_modelHmap[5] = hv_deltaY;
                    HOperatorSet.AffineTransPoint2d(hv_modelHmap, hv_mapX, hv_mapY, out hv_updateMapX,
                        out hv_updateMapY);
                    HOperatorSet.AffineTransPoint2d(hv_modelHmap, hv_snapMapX, hv_snapMapY, out hv_updateSnapMapX,
                        out hv_updateSnapMapY);

                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    GetErrInfo(hv_Exception, out hv_iFlag);
                }

                ho_showCount.Dispose();
                ho_update_show_contour.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_showCount.Dispose();
                ho_update_show_contour.Dispose();

                throw HDevExpDefaultException;
            }
        }



        #region 矫正点新算法 2019.5.21  update_map_points_Test


        public static void update_map_points_Test(HObject ho_image, HObject ho_matchRegion, HTuple hv_modelType,
      HTuple hv_modelID, HTuple hv_defRow, HTuple hv_defCol, HTuple hv_i_hLineRows,
      HTuple hv_i_hLineCols, HTuple hv_i_vLineRows, HTuple hv_i_vLineCols, HTuple hv_i_RefPointsRow,
      HTuple hv_i_RefPointsCol, HTuple hv_mapX, HTuple hv_mapY, HTuple hv_snapMapX,
      HTuple hv_snapMapY, HTuple hv_uvHxy, out HTuple hv_updateMapX, out HTuple hv_updateMapY,
      out HTuple hv_updateSnapMapX, out HTuple hv_updateSnapMapY, out HTuple hv_updateDefRow,
      out HTuple hv_updateDefCol, out HTuple hv_iFlag)
        {




            // Local iconic variables 

            HObject ho_showCount = null, ho_update_show_contour = null;

            // Local control variables 

            HTuple hv_modelHimg = new HTuple(), hv_update_def_row = new HTuple();
            HTuple hv_update_def_col = new HTuple(), hv_iFlag1 = new HTuple();
            HTuple hv_deltaX = new HTuple(), hv_deltaY = new HTuple();
            HTuple hv_modelHmap = new HTuple(), hv_Exception = null;
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_showCount);
            HOperatorSet.GenEmptyObj(out ho_update_show_contour);
            try
            {
                hv_iFlag = "";
                hv_updateMapX = new HTuple();
                hv_updateMapY = new HTuple();
                hv_updateSnapMapX = new HTuple();
                hv_updateSnapMapY = new HTuple();
                hv_updateDefRow = new HTuple();
                hv_updateDefCol = new HTuple();

                try
                {
                    ho_showCount.Dispose();
                    HOperatorSet.GenEmptyObj(out ho_showCount);
                    ho_update_show_contour.Dispose();
                    find_affine_trans_info(ho_image, ho_matchRegion, ho_showCount, out ho_update_show_contour,
                        hv_modelType, hv_modelID, hv_i_hLineRows, hv_i_hLineCols, hv_i_vLineRows,
                        hv_i_vLineCols, hv_i_RefPointsRow, hv_i_RefPointsCol, hv_defRow, hv_defCol,
                        out hv_modelHimg, out hv_update_def_row, out hv_update_def_col, out hv_iFlag1);
                    //*     find_model_ext (image, matchRegion, showCount, update_show_contour, modelType, modelID, -1, -1, scoreThresh, 1, defRow, defCol, found_row, found_col, found_angle, found_score, update_def_row, update_def_col, modelHimg, iFlag1)
                    if ((int)(new HTuple(hv_iFlag1.TupleNotEqual(0))) != 0)
                    {
                        hv_iFlag = "match failed!";
                        ho_showCount.Dispose();
                        ho_update_show_contour.Dispose();

                        return;
                    }
                    //uv坐标系中的平移量变换到xy坐标系
                    hv_deltaX = ((hv_uvHxy.TupleSelect(0)) * (-(hv_modelHimg.TupleSelect(2)))) + ((hv_uvHxy.TupleSelect(
                        1)) * (-(hv_modelHimg.TupleSelect(5))));
                    hv_deltaY = ((hv_uvHxy.TupleSelect(3)) * (-(hv_modelHimg.TupleSelect(2)))) + ((hv_uvHxy.TupleSelect(
                        4)) * (-(hv_modelHimg.TupleSelect(5))));
                    //uv坐标系中的旋转量与xy坐标系中的旋转量一致
                    //uv坐标系中的匹配映射关系修正平移量后直接作为xy坐标系中的匹配映射关系
                    hv_modelHmap = hv_modelHimg.Clone();
                    if (hv_modelHmap == null)
                        hv_modelHmap = new HTuple();
                    hv_modelHmap[2] = hv_deltaX;
                    if (hv_modelHmap == null)
                        hv_modelHmap = new HTuple();
                    hv_modelHmap[5] = hv_deltaY;
                    //对图谱点位和采图点位进行更新
                    HOperatorSet.AffineTransPoint2d(hv_modelHmap, hv_mapX, hv_mapY, out hv_updateMapX,
                        out hv_updateMapY);
                    HOperatorSet.AffineTransPoint2d(hv_modelHmap, hv_snapMapX, hv_snapMapY, out hv_updateSnapMapX,
                        out hv_updateSnapMapY);
                    hv_updateDefRow = hv_update_def_row.Clone();
                    hv_updateDefCol = hv_update_def_col.Clone();
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    GetErrInfo(hv_Exception, out hv_iFlag);
                }

                ho_showCount.Dispose();
                ho_update_show_contour.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_showCount.Dispose();
                ho_update_show_contour.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public static void find_affine_trans_info(HObject ho_i_Image, HObject ho_i_InspectReg,
      HObject ho_show_contour, out HObject ho_update_show_contour, HTuple hv_i_ModelType,
      HTuple hv_i_ModelID, HTuple hv_i_hLineRows, HTuple hv_i_hLineCols, HTuple hv_i_vLineRows,
      HTuple hv_i_vLineCols, HTuple hv_i_RefPointsRow, HTuple hv_i_RefPointsCol, HTuple hv_def_row,
      HTuple hv_def_col, out HTuple hv_o_ModelHNew, out HTuple hv_update_def_row,
      out HTuple hv_update_def_col, out HTuple hv_o_Flag)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_complement_region, ho_image = null;
            HObject ho_paint_image, ho_affine_show_contour;

            // Local control variables 

            HTuple hv_Channels = null, hv_cornorRowsCur = null;
            HTuple hv_cornorColsCur = null, hv_Phi1 = null, hv_Tx = null;
            HTuple hv_Ty = null, hv__Flag = null, hv_model_H_any = null;
            HTuple hv_def_row_ind = null, hv_def_col_ind = null, hv__update_def_row = new HTuple();
            HTuple hv__update_def_col = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_update_show_contour);
            HOperatorSet.GenEmptyObj(out ho_complement_region);
            HOperatorSet.GenEmptyObj(out ho_image);
            HOperatorSet.GenEmptyObj(out ho_paint_image);
            HOperatorSet.GenEmptyObj(out ho_affine_show_contour);
            hv_o_Flag = new HTuple();
            try
            {
                hv_update_def_row = new HTuple();
                hv_update_def_col = new HTuple();
                hv_o_ModelHNew = new HTuple();

                ho_update_show_contour.Dispose();
                HOperatorSet.GenEmptyObj(out ho_update_show_contour);
                ho_complement_region.Dispose();
                HOperatorSet.Complement(ho_i_InspectReg, out ho_complement_region);
                HOperatorSet.CountChannels(ho_i_Image, out hv_Channels);
                if ((int)(new HTuple(hv_Channels.TupleNotEqual(1))) != 0)
                {
                    ho_image.Dispose();
                    HOperatorSet.Rgb1ToGray(ho_i_Image, out ho_image);
                }
                ho_paint_image.Dispose();
                HOperatorSet.PaintRegion(ho_complement_region, ho_image, out ho_paint_image,
                    255, "fill");
                //函数调用 输出角度偏移值：Phi1,位置偏移值：Tx, Ty
                Points_Coordinate_Test(ho_image, ho_i_InspectReg, hv_i_ModelType, hv_i_ModelID,
                    hv_i_hLineRows, hv_i_hLineCols, hv_i_vLineRows, hv_i_vLineCols, hv_i_RefPointsRow,
                    hv_i_RefPointsCol, hv_def_row, hv_def_col, out hv_cornorRowsCur, out hv_cornorColsCur,
                    out hv_Phi1, out hv_Tx, out hv_Ty, out hv__Flag);
                if ((int)(new HTuple(hv__Flag.TupleNotEqual(0))) != 0)
                {
                    hv_o_Flag = -1;
                    ho_complement_region.Dispose();
                    ho_image.Dispose();
                    ho_paint_image.Dispose();
                    ho_affine_show_contour.Dispose();

                    return;
                }
                //创建仿射变换
                HOperatorSet.VectorAngleToRigid(0, 0, 0, hv_Ty, hv_Tx, hv_Phi1, out hv_model_H_any);
                //对轮廓进行应用仿射变换
                ho_affine_show_contour.Dispose();
                HOperatorSet.AffineTransContourXld(ho_show_contour, out ho_affine_show_contour,
                    hv_model_H_any);
                HOperatorSet.TupleFind(hv_def_row, -1, out hv_def_row_ind);
                HOperatorSet.TupleFind(hv_def_col, -1, out hv_def_col_ind);

                if ((int)((new HTuple(hv_def_row_ind.TupleEqual(-1))).TupleAnd(new HTuple(hv_def_col_ind.TupleEqual(
                    -1)))) != 0)
                {
                    HOperatorSet.AffineTransPoint2d(hv_model_H_any, hv_def_row, hv_def_col, out hv__update_def_row,
                        out hv__update_def_col);
                }
                else
                {
                    hv__update_def_row = new HTuple();
                    hv__update_def_col = new HTuple();
                }
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.ConcatObj(ho_update_show_contour, ho_affine_show_contour, out ExpTmpOutVar_0
                        );
                    ho_update_show_contour.Dispose();
                    ho_update_show_contour = ExpTmpOutVar_0;
                }
                //*****更新实际的模板坐标
                hv_update_def_row = hv_update_def_row.TupleConcat(hv__update_def_row);
                hv_update_def_col = hv_update_def_col.TupleConcat(hv__update_def_col);
                hv_o_ModelHNew = hv_o_ModelHNew.TupleConcat(hv_model_H_any);

                hv_o_Flag = 0;
                ho_complement_region.Dispose();
                ho_image.Dispose();
                ho_paint_image.Dispose();
                ho_affine_show_contour.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_complement_region.Dispose();
                ho_image.Dispose();
                ho_paint_image.Dispose();
                ho_affine_show_contour.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public static void Points_Coordinate_Test(HObject ho_ImageR, HObject ho_inspectReg, HTuple hv_ModelType,
     HTuple hv_ModelID, HTuple hv_hRows, HTuple hv_hCols, HTuple hv_vRows, HTuple hv_vCols,
     HTuple hv_i_cornorRows, HTuple hv_i_cornorCols, HTuple hv_def_row, HTuple hv_def_col,
     out HTuple hv_cornorRowsCur, out HTuple hv_cornorColsCur, out HTuple hv_Phi1,
     out HTuple hv_Tx, out HTuple hv_Ty, out HTuple hv_o_Flag)
        {




            // Local iconic variables 

            HObject ho_ImageReduced1;

            // Local control variables 

            HTuple hv_linePairNum = null, hv_Row = new HTuple();
            HTuple hv_Column = new HTuple(), hv_Angle = new HTuple();
            HTuple hv_Score = new HTuple(), hv_Row1 = new HTuple();
            HTuple hv_Column1 = new HTuple(), hv_HomMat2D = new HTuple();
            HTuple hv_hRowsAffined = new HTuple(), hv_hColsAffined = new HTuple();
            HTuple hv_vRowsAffined = new HTuple(), hv_vColsAffined = new HTuple();
            HTuple hv_Ind = new HTuple(), hv_cornorCols = new HTuple();
            HTuple hv_cornorRows = new HTuple(), hv_HomMat2D1 = new HTuple();
            HTuple hv_HomMat2DInvert = new HTuple(), hv_Sx = new HTuple();
            HTuple hv_Sy = new HTuple(), hv_Theta = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_ImageReduced1);
            hv_Phi1 = new HTuple();
            hv_Tx = new HTuple();
            hv_Ty = new HTuple();
            hv_o_Flag = new HTuple();
            hv_cornorRowsCur = new HTuple();
            hv_cornorColsCur = new HTuple();
            //水平和垂直的线对数 linePairNum=12
            hv_linePairNum = (new HTuple(hv_hRows.TupleLength())) / 2;
            //在ROI区域中寻找模板
            ho_ImageReduced1.Dispose();
            HOperatorSet.ReduceDomain(ho_ImageR, ho_inspectReg, out ho_ImageReduced1);
            if ((int)(new HTuple(hv_ModelType.TupleEqual(0))) != 0)
            {
                //基于NCC匹配
                HOperatorSet.FindNccModel(ho_ImageReduced1, hv_ModelID, -0.39, 0.78, 0.5, 1,
                    0.5, "true", 0, out hv_Row, out hv_Column, out hv_Angle, out hv_Score);
                HOperatorSet.GetNccModelOrigin(hv_ModelID, out hv_Row1, out hv_Column1);
            }
            else
            {
                //基于形状的模板粗匹配
                HOperatorSet.FindShapeModel(ho_ImageReduced1, hv_ModelID, -0.39, 0.78, 0.5,
                    1, 0.5, "least_squares", 0, 0.9, out hv_Row, out hv_Column, out hv_Angle,
                    out hv_Score);
                HOperatorSet.GetShapeModelOrigin(hv_ModelID, out hv_Row1, out hv_Column1);
            }
            if ((int)((new HTuple((new HTuple(hv_Score.TupleLength())).TupleGreater(0))).TupleAnd(
                new HTuple(hv_Score.TupleGreater(0.6)))) != 0)
            {
                if ((int)((new HTuple(hv_Row1.TupleEqual(0))).TupleAnd(new HTuple(hv_Column1.TupleEqual(
                    0)))) != 0)
                {
                    HOperatorSet.VectorAngleToRigid(hv_def_row, hv_def_col, 0, hv_Row, hv_Column,
                        hv_Angle, out hv_HomMat2D);
                }
                else
                {
                    HOperatorSet.VectorAngleToRigid(0, 0, 0, hv_Row, hv_Column, hv_Angle, out hv_HomMat2D);
                }
                //找到测试图像上 12条水平线的端点即24个点
                HOperatorSet.AffineTransPoint2d(hv_HomMat2D, hv_hRows, hv_hCols, out hv_hRowsAffined,
                    out hv_hColsAffined);
                //找到测试图像上 12条垂直线的端点即24个点
                HOperatorSet.AffineTransPoint2d(hv_HomMat2D, hv_vRows, hv_vCols, out hv_vRowsAffined,
                    out hv_vColsAffined);
                //显示模板匹配后的24个交点
                //disp_cross (3600, hRowsAffined, hColsAffined, 60, Angle)

                //获得测试图像的交点
                Points_Coordinate(ho_ImageR, ho_inspectReg, hv_hRowsAffined, hv_hColsAffined,
                    hv_vRowsAffined, hv_vColsAffined, out hv_cornorRowsCur, out hv_cornorColsCur,
                    out hv_Ind);

                if ((int)((new HTuple((new HTuple(hv_cornorRowsCur.TupleLength())).TupleGreater(
                    0))).TupleAnd(new HTuple((new HTuple(hv_cornorColsCur.TupleLength())).TupleGreater(
                    0)))) != 0)
                {
                    //求变换矩阵
                    //由匹配点到模板
                    hv_cornorCols = hv_i_cornorCols.TupleSelect(hv_Ind);
                    hv_cornorRows = hv_i_cornorRows.TupleSelect(hv_Ind);
                    HOperatorSet.VectorToHomMat2d(hv_cornorColsCur, hv_cornorRowsCur, hv_cornorCols,
                        hv_cornorRows, out hv_HomMat2D1);
                    //对矩阵求逆
                    HOperatorSet.HomMat2dInvert(hv_HomMat2D1, out hv_HomMat2DInvert);
                    //从矩阵来计算仿射变换参数
                    HOperatorSet.HomMat2dToAffinePar(hv_HomMat2DInvert, out hv_Sx, out hv_Sy,
                        out hv_Phi1, out hv_Theta, out hv_Tx, out hv_Ty);
                    //hv_Ty = 0;//try
                    //stop ()
                }
                else
                {
                    hv_o_Flag = -1;
                    ho_ImageReduced1.Dispose();

                    return;
                }
            }
            else
            {
                hv_o_Flag = -1;
                ho_ImageReduced1.Dispose();

                return;
            }
            hv_o_Flag = 0;
            ho_ImageReduced1.Dispose();

            return;
        }

        public static void Points_Coordinate(HObject ho_ImageR, HObject ho_inspectReg, HTuple hv_hRows,
      HTuple hv_hCols, HTuple hv_vRows, HTuple hv_vCols, out HTuple hv_cornorRows,
      out HTuple hv_cornorCols, out HTuple hv_Ind)
        {




            // Local iconic variables 

            HObject ho_lineReg;

            // Local control variables 

            HTuple hv_Parameter1 = null, hv_Parameter2 = null;
            HTuple hv_herrIdx = null, hv_verrIdx = null, hv_Width = null;
            HTuple hv_Height = null, hv_linePairNum = null, hv_MetrologyHandle = null;
            HTuple hv_hIndex = null, hv_hIdx = null, hv_Index = new HTuple();
            HTuple hv_vIndex = null, hv_vIdx = null, hv_Index2 = new HTuple();
            HTuple hv__Parameter1 = new HTuple(), hv__Parameter2 = new HTuple();
            HTuple hv_Abs = null, hv_RowCornorCur = null, hv_ColumnCornorCur = null;
            HTuple hv_Idx = new HTuple(), hv_isP1Flag = new HTuple();
            HTuple hv_isP2Flag = new HTuple(), hv__RowCornorCur = new HTuple();
            HTuple hv__ColumnCornorCur = new HTuple(), hv__Abs = new HTuple();
            HTuple hv_IsOverlapping = new HTuple(), hv__Angle = new HTuple();
            HTuple hv_Indices2 = null, hv_Reduced = null, hv_n = new HTuple();
            HTuple hv_Greatereq = new HTuple(), hv_Greatereq1 = new HTuple();
            HTuple hv_GreaterIdx = new HTuple(), hv_Indices = new HTuple();
            HTuple hv_Deviation = new HTuple(), hv_Index1 = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_lineReg);

            hv_cornorRows = new HTuple();
            hv_cornorCols = new HTuple();
            hv_Ind = new HTuple();

            hv_Parameter1 = new HTuple();
            hv_Parameter2 = new HTuple();

            //水平线结果获取为空是 错误索引
            hv_herrIdx = new HTuple();
            //垂直线结果获取为空是 错误索引
            hv_verrIdx = new HTuple();

            HOperatorSet.GetImageSize(ho_ImageR, out hv_Width, out hv_Height);
            //水平和垂直线对：linePairNum=12
            hv_linePairNum = (new HTuple(hv_hRows.TupleLength())) / 2;

            //计算参考交点坐标  模板的12个线对分别添加进去（水平，垂直） 添加到metrologyhandle
            HOperatorSet.CreateMetrologyModel(out hv_MetrologyHandle);
            hv_hIndex = new HTuple();
            HTuple end_val20 = hv_linePairNum - 1;
            HTuple step_val20 = 1;
            for (hv_hIdx = 0; hv_hIdx.Continue(end_val20, step_val20); hv_hIdx = hv_hIdx.TupleAdd(step_val20))
            {
                //添加水平线到测量模板
                HOperatorSet.AddMetrologyObjectLineMeasure(hv_MetrologyHandle, hv_hRows.TupleSelect(
                    2 * hv_hIdx), hv_hCols.TupleSelect(2 * hv_hIdx), hv_hRows.TupleSelect((2 * hv_hIdx) + 1),
                    hv_hCols.TupleSelect((2 * hv_hIdx) + 1), 20, 5, 1, 30, new HTuple(), new HTuple(),
                    out hv_Index);
                hv_hIndex = hv_hIndex.TupleConcat(hv_Index);
            }
            hv_vIndex = new HTuple();
            HTuple end_val26 = hv_linePairNum - 1;
            HTuple step_val26 = 1;
            for (hv_vIdx = 0; hv_vIdx.Continue(end_val26, step_val26); hv_vIdx = hv_vIdx.TupleAdd(step_val26))
            {
                //添加垂直线到测量模板
                HOperatorSet.AddMetrologyObjectLineMeasure(hv_MetrologyHandle, hv_vRows.TupleSelect(
                    2 * hv_vIdx), hv_vCols.TupleSelect(2 * hv_vIdx), hv_vRows.TupleSelect((2 * hv_vIdx) + 1),
                    hv_vCols.TupleSelect((2 * hv_vIdx) + 1), 20, 5, 1, 30, new HTuple(), new HTuple(),
                    out hv_Index);
                hv_vIndex = hv_vIndex.TupleConcat(hv_Index);
            }

            //******************************通过metrology变换，得到Parameter1，Parameter2*****************************
            HOperatorSet.SetMetrologyModelImageSize(hv_MetrologyHandle, hv_Width, hv_Height);
            HOperatorSet.ApplyMetrologyModel(ho_ImageR, hv_MetrologyHandle);
            //get_metrology_object_result (MetrologyHandle, 0, 'all', 'result_type', 'all_param', Parameter1)
            //Parameter1 水平线的起始点x,y；12条线*2个端点*（x,y两个坐标）=48
            HOperatorSet.GetMetrologyObjectResult(hv_MetrologyHandle, hv_hIndex, "all", "result_type",
                "all_param", out hv_Parameter1);


            //添加判断 循环费时8.4ms  而直接输出结果1.25ms
            //所以增加判断 只有在不相等的情况下才进行循环
            if ((int)(new HTuple((new HTuple((new HTuple(hv_hIndex.TupleLength())) * 4)).TupleEqual(
                new HTuple(hv_Parameter1.TupleLength())))) != 0)
            {

            }
            else
            {
                hv_Parameter1 = new HTuple();
                for (hv_Index2 = 0; (int)hv_Index2 <= (int)((new HTuple(hv_hIndex.TupleLength()
                    )) - 1); hv_Index2 = (int)hv_Index2 + 1)
                {
                    HOperatorSet.GetMetrologyObjectResult(hv_MetrologyHandle, hv_hIndex.TupleSelect(
                        hv_Index2), "all", "result_type", "all_param", out hv__Parameter1);
                    if ((int)(new HTuple((new HTuple(hv__Parameter1.TupleLength())).TupleEqual(
                        0))) != 0)
                    {
                        hv_herrIdx = hv_herrIdx.TupleConcat(hv_Index2);
                        hv__Parameter1 = new HTuple();
                        hv__Parameter1[0] = -1;
                        hv__Parameter1[1] = -1;
                        hv__Parameter1[2] = -1;
                        hv__Parameter1[3] = -1;
                    }
                    hv_Parameter1 = hv_Parameter1.TupleConcat(hv__Parameter1);
                }
            }

            //Parameter2 垂直线的起始点x,y；12条线*2个端点*（x,y两个坐标）=48
            HOperatorSet.GetMetrologyObjectResult(hv_MetrologyHandle, hv_vIndex, "all", "result_type",
                "all_param", out hv_Parameter2);

            if ((int)(new HTuple((new HTuple((new HTuple(hv_vIndex.TupleLength())) * 4)).TupleEqual(
                new HTuple(hv_Parameter2.TupleLength())))) != 0)
            {

            }
            else
            {
                hv_Parameter2 = new HTuple();
                for (hv_Index2 = 0; (int)hv_Index2 <= (int)((new HTuple(hv_hIndex.TupleLength()
                    )) - 1); hv_Index2 = (int)hv_Index2 + 1)
                {
                    HOperatorSet.GetMetrologyObjectResult(hv_MetrologyHandle, hv_vIndex.TupleSelect(
                        hv_Index2), "all", "result_type", "all_param", out hv__Parameter2);
                    if ((int)(new HTuple((new HTuple(hv__Parameter2.TupleLength())).TupleEqual(
                        0))) != 0)
                    {
                        hv_verrIdx = hv_verrIdx.TupleConcat(hv_Index2);
                        hv__Parameter2 = new HTuple();
                        hv__Parameter2[0] = -1;
                        hv__Parameter2[1] = -1;
                        hv__Parameter2[2] = -1;
                        hv__Parameter2[3] = -1;
                    }
                    hv_Parameter2 = hv_Parameter2.TupleConcat(hv__Parameter2);
                }
            }
            HOperatorSet.ClearMetrologyModel(hv_MetrologyHandle);

            //如果存在有错误的情况
            //if (|herrIdx|#0 or |verrIdx|#0)
            //RemoveIdx := []
            //tuple_intersection (herrIdx, verrIdx, Intersection)
            //if (|Intersection|#0)
            //tuple_find (herrIdx, Intersection, Indices1)
            //tuple_remove (herrIdx, Indices1, herrIdx)
            //endif
            //errIdx := [herrIdx,verrIdx]

            //for Index3 := 0 to |errIdx|-1 by 1
            //_RemoveIdx := [errIdx[Index3]*4,errIdx[Index3]*4+1,errIdx[Index3]*4+2,errIdx[Index3]*4+3]
            //RemoveIdx := [RemoveIdx,_RemoveIdx]
            //endfor
            //tuple_remove (Parameter1, RemoveIdx, Parameter1)
            //tuple_remove (Parameter2, RemoveIdx, Parameter2)
            //linePairNum := |Parameter1|/4
            //endif

            //求交点  根据 Parameter1，Parameter2 画线求交点
            ho_lineReg.Dispose();
            HOperatorSet.GenEmptyObj(out ho_lineReg);
            hv_Abs = new HTuple();
            hv_RowCornorCur = new HTuple();
            hv_ColumnCornorCur = new HTuple();
            if ((int)((new HTuple((new HTuple((new HTuple(hv_Parameter1.TupleLength())).TupleGreater(
                0))).TupleAnd(new HTuple((new HTuple(hv_Parameter2.TupleLength())).TupleGreater(
                0))))).TupleAnd(new HTuple((new HTuple(hv_Parameter1.TupleLength())).TupleEqual(
                new HTuple(hv_Parameter2.TupleLength()))))) != 0)
            {
                HTuple end_val99 = hv_linePairNum - 1;
                HTuple step_val99 = 1;
                for (hv_Idx = 0; hv_Idx.Continue(end_val99, step_val99); hv_Idx = hv_Idx.TupleAdd(step_val99))
                {
                    //for test
                    hv_isP1Flag = (new HTuple((new HTuple((new HTuple(((hv_Parameter1.TupleSelect(
                        hv_Idx * 4))).TupleEqual(-1))).TupleAnd(new HTuple(((hv_Parameter1.TupleSelect(
                        (hv_Idx * 4) + 1))).TupleEqual(-1))))).TupleAnd(new HTuple(((hv_Parameter1.TupleSelect(
                        (hv_Idx * 4) + 2))).TupleEqual(-1))))).TupleAnd(new HTuple(((hv_Parameter1.TupleSelect(
                        (hv_Idx * 4) + 3))).TupleEqual(-1)));
                    hv_isP2Flag = (new HTuple((new HTuple((new HTuple(((hv_Parameter2.TupleSelect(
                        hv_Idx * 4))).TupleEqual(-1))).TupleAnd(new HTuple(((hv_Parameter2.TupleSelect(
                        (hv_Idx * 4) + 1))).TupleEqual(-1))))).TupleAnd(new HTuple(((hv_Parameter2.TupleSelect(
                        (hv_Idx * 4) + 2))).TupleEqual(-1))))).TupleAnd(new HTuple(((hv_Parameter2.TupleSelect(
                        (hv_Idx * 4) + 3))).TupleEqual(-1)));

                    //gen_region_line (RegionLines1, Parameter1[Idx*4], Parameter1[Idx*4+1], Parameter1[Idx*4+2], Parameter1[Idx*4+3])
                    //concat_obj (lineReg, RegionLines1, lineReg)
                    //gen_region_line (RegionLines2, Parameter2[Idx*4], Parameter2[Idx*4+1], Parameter2[Idx*4+2], Parameter2[Idx*4+3])
                    //concat_obj (lineReg, RegionLines2, lineReg)
                    //判断是否为没有计算出结果的情况 只要有一个没有得到结果就 认为是-1
                    if ((int)(hv_isP1Flag.TupleOr(hv_isP2Flag)) != 0)
                    {
                        hv__RowCornorCur = -1;
                        hv__ColumnCornorCur = -1;
                        hv__Abs = 360;
                    }
                    else
                    {
                        HOperatorSet.IntersectionLines(hv_Parameter1.TupleSelect(hv_Idx * 4), hv_Parameter1.TupleSelect(
                            (hv_Idx * 4) + 1), hv_Parameter1.TupleSelect((hv_Idx * 4) + 2), hv_Parameter1.TupleSelect(
                            (hv_Idx * 4) + 3), hv_Parameter2.TupleSelect(hv_Idx * 4), hv_Parameter2.TupleSelect(
                            (hv_Idx * 4) + 1), hv_Parameter2.TupleSelect((hv_Idx * 4) + 2), hv_Parameter2.TupleSelect(
                            (hv_Idx * 4) + 3), out hv__RowCornorCur, out hv__ColumnCornorCur, out hv_IsOverlapping);
                        HOperatorSet.AngleLl(hv_Parameter1.TupleSelect(hv_Idx * 4), hv_Parameter1.TupleSelect(
                            (hv_Idx * 4) + 1), hv_Parameter1.TupleSelect((hv_Idx * 4) + 2), hv_Parameter1.TupleSelect(
                            (hv_Idx * 4) + 3), hv_Parameter2.TupleSelect(hv_Idx * 4), hv_Parameter2.TupleSelect(
                            (hv_Idx * 4) + 1), hv_Parameter2.TupleSelect((hv_Idx * 4) + 2), hv_Parameter2.TupleSelect(
                            (hv_Idx * 4) + 3), out hv__Angle);
                        HOperatorSet.TupleAbs(hv__Angle.TupleDeg(), out hv__Abs);
                    }
                    hv_RowCornorCur = hv_RowCornorCur.TupleConcat(hv__RowCornorCur);
                    hv_ColumnCornorCur = hv_ColumnCornorCur.TupleConcat(hv__ColumnCornorCur);
                    //计算两条直线的角度

                    hv_Abs = hv_Abs.TupleConcat(hv__Abs);

                }
            }
            //挑选 设定角度范围 土0.5度 之间 如果数量不到3个放宽角度
            //对点在一条线上进行判断，如果近似一条线的话就会有较大偏差
            HOperatorSet.TupleFind(hv_Abs, 360, out hv_Indices2);
            HOperatorSet.TupleRemove(hv_Abs, hv_Indices2, out hv_Reduced);
            if ((int)(new HTuple((new HTuple(hv_Reduced.TupleLength())).TupleGreater(3))) != 0)
            {
                hv_n = 1;
                while ((int)(1) != 0)
                {
                    HOperatorSet.TupleGreaterEqualElem(hv_Abs, 90 - (hv_n * 0.5), out hv_Greatereq);
                    HOperatorSet.TupleGreaterEqualElem(90 + (hv_n * 0.5), hv_Abs, out hv_Greatereq1);
                    hv_GreaterIdx = hv_Greatereq * hv_Greatereq1;
                    HOperatorSet.TupleFind(hv_GreaterIdx, 1, out hv_Indices);
                    if ((int)(new HTuple((new HTuple(hv_Indices.TupleLength())).TupleGreaterEqual(
                        3))) != 0)
                    {
                        hv_cornorRows = hv_RowCornorCur.TupleSelect(hv_Indices);
                        hv_cornorCols = hv_ColumnCornorCur.TupleSelect(hv_Indices);
                        hv_Ind = hv_Indices.Clone();
                        HOperatorSet.TupleDeviation(hv_cornorRows, out hv_Deviation);
                        if ((int)(new HTuple(hv_Deviation.TupleGreater(10))) != 0)
                        {
                            break;
                        }
                        else
                        {
                            hv_n = hv_n + 1;
                        }
                    }
                    else
                    {
                        hv_n = hv_n + 1;
                    }
                }
            }
            else
            {
                hv_cornorRows = hv_RowCornorCur.Clone();
                hv_cornorCols = hv_ColumnCornorCur.Clone();
                for (hv_Index1 = 0; (int)hv_Index1 <= (int)((new HTuple(hv_cornorRows.TupleLength()
                    )) - 1); hv_Index1 = (int)hv_Index1 + 1)
                {
                    hv_Ind = hv_Ind.TupleConcat(hv_Index1);
                }

            }
            ho_lineReg.Dispose();

            return;
        }

        #endregion


        #region 矫正点匹配，适用于两个矫正点匹配，2019.7.24 Map_Points_Match
        /// <summary>
        /// 矫正点匹配
        /// </summary>
        /// <param name="ho_image">图像</param>
        /// <param name="ho_matchRegion">匹配区域</param>
        /// <param name="hv_modelType">模板类型</param>
        /// <param name="hv_modelID">模板id</param>
        /// <param name="hv_scoreThresh">p匹配分数</param>
        /// <param name="hv_defRow">模板中心row</param>
        /// <param name="hv_defCol">模板中心col</param>
        /// <param name="hv_coorX">采图坐标x</param>
        /// <param name="hv_coorY">采图坐标y</param>
        /// <param name="hv_uvHxy">标定矩阵</param>
        /// <param name="hv_modelHmap">输出：模板映射矩阵</param>
        /// <param name="hv_updateCoorX">输出：实际定位结果坐标x</param>
        /// <param name="hv_updateCoorY">输出：实际定位结果坐标y</param>
        /// <param name="hv_updateDefRow">输出：图像定位结果row</param>
        /// <param name="hv_updateDefCol">输出：图像定位结果col</param>
        /// <param name="hv_iFlag">输出：为空则成功，不为空失败</param>
        public static void Map_Points_Match(HObject ho_image, HObject ho_matchRegion, HTuple hv_modelType,
             HTuple hv_modelID, HTuple hv_scoreThresh, HTuple hv_defRow, HTuple hv_defCol,
             HTuple hv_coorX, HTuple hv_coorY, HTuple hv_uvHxy, out HTuple hv_modelHmap,
             out HTuple hv_updateCoorX, out HTuple hv_updateCoorY, out HTuple hv_updateDefRow,
             out HTuple hv_updateDefCol, out HTuple hv_iFlag)
        {




            // Local iconic variables 

            HObject ho_showCount = null, ho_update_show_contour = null;

            // Local control variables 

            HTuple hv_iFlag1 = new HTuple(), hv_deltaX = new HTuple();
            HTuple hv_modelHimg = new HTuple(), hv_deltaY = new HTuple();
            HTuple hv_update_def_row = new HTuple(), hv_update_def_col = new HTuple();
            HTuple hv_Exception = null, hv_found_row = new HTuple();
            HTuple hv_found_col = new HTuple(), hv_found_angle = new HTuple();
            HTuple hv_found_score = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_showCount);
            HOperatorSet.GenEmptyObj(out ho_update_show_contour);
            hv_modelHmap = new HTuple();
            hv_updateCoorX = new HTuple();
            hv_updateCoorY = new HTuple();
            hv_updateDefRow = new HTuple();
            hv_updateDefCol = new HTuple();
            try
            {
                hv_iFlag = "";

                try
                {
                    ho_showCount.Dispose();
                    HOperatorSet.GenEmptyObj(out ho_showCount);
                    ho_update_show_contour.Dispose();
                    find_model_ext(ho_image, ho_matchRegion, ho_showCount, out ho_update_show_contour,
                        hv_modelType, hv_modelID, -1, -1, hv_scoreThresh, 1, hv_defRow, hv_defCol,
                        out hv_found_row, out hv_found_col, out hv_found_angle, out hv_found_score,
                        out hv_update_def_row, out hv_update_def_col, out hv_modelHimg, out hv_iFlag1);


                    if ((int)(new HTuple(hv_iFlag1.TupleNotEqual(0))) != 0)
                    {
                        hv_iFlag = "match failed!";
                        ho_showCount.Dispose();
                        ho_update_show_contour.Dispose();

                        return;
                    }

                    hv_deltaX = ((hv_uvHxy.TupleSelect(0)) * (-(hv_modelHimg.TupleSelect(2)))) + ((hv_uvHxy.TupleSelect(
                        1)) * (-(hv_modelHimg.TupleSelect(5))));
                    hv_deltaY = ((hv_uvHxy.TupleSelect(3)) * (-(hv_modelHimg.TupleSelect(2)))) + ((hv_uvHxy.TupleSelect(
                        4)) * (-(hv_modelHimg.TupleSelect(5))));

                    hv_updateCoorX = hv_coorX + hv_deltaX;
                    hv_updateCoorY = hv_coorY + hv_deltaY;

                    hv_modelHmap = hv_modelHimg.Clone();
                    if (hv_modelHmap == null)
                        hv_modelHmap = new HTuple();
                    hv_modelHmap[2] = hv_deltaX;
                    if (hv_modelHmap == null)
                        hv_modelHmap = new HTuple();
                    hv_modelHmap[5] = hv_deltaY;

                    hv_updateDefRow = hv_update_def_row.Clone();
                    hv_updateDefCol = hv_update_def_col.Clone();
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    GetErrInfo(hv_Exception, out hv_iFlag);
                }
                ho_showCount.Dispose();
                ho_update_show_contour.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_showCount.Dispose();
                ho_update_show_contour.Dispose();

                throw HDevExpDefaultException;
            }
        }

        #endregion

        #region 两个矫正点匹配后，映射点位 update_map_correction v1
        /// <summary>
        /// 两个矫正点匹配后，映射扫描和芯片点位
        /// </summary>
        /// <param name="hv_mapX">芯片点位X</param>
        /// <param name="hv_mapY">芯片点位Y</param>
        /// <param name="hv_snapMapX">扫描点位X</param>
        /// <param name="hv_snapMapY">扫描点位Y</param>
        /// <param name="hv_baseCoorX">左矫正点中心的实际点位X</param>
        /// <param name="hv_baseCoorY">左娇正点中心的实际点位Y</param>
        /// <param name="hv_baseMatrix">左娇正点映射矩阵</param>
        /// <param name="hv_otherCoorX">右矫正点模板中心物理坐标X</param>
        /// <param name="hv_otherCoorY">右矫正点模板中心物理坐标Y</param>
        /// <param name="hv_updateCoorX">右矫正点中心的实际点位X</param>
        /// <param name="hv_updateCoorY">右矫正点中心的实际点位X</param>
        /// <param name="hv_updateMapX">输出：更新后芯片图谱X</param>
        /// <param name="hv_updateMapY">输出：更新后芯片图谱Y</param>
        /// <param name="hv_updateSnapMapX">输出：更新后扫描点位图谱X</param>
        /// <param name="hv_updateSnapMapY">输出：更新后扫描点位图谱Y</param>
        /// <param name="hv_iFlag">输出：为空则成功，不为空失败</param>
        public static void update_map_correction(HTuple hv_mapX, HTuple hv_mapY, HTuple hv_snapMapX,
            HTuple hv_snapMapY, HTuple hv_baseCoorX, HTuple hv_baseCoorY, HTuple hv_baseMatrix,
            HTuple hv_otherCoorX, HTuple hv_otherCoorY, HTuple hv_updateCoorX, HTuple hv_updateCoorY,
            out HTuple hv_updateMapX, out HTuple hv_updateMapY, out HTuple hv_updateSnapMapX,
            out HTuple hv_updateSnapMapY, out HTuple hv_iFlag)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_Qx = new HTuple(), hv_Qy = new HTuple();
            HTuple hv_Phi1 = new HTuple(), hv_Phi2 = new HTuple();
            HTuple hv_deltaPhi = new HTuple(), hv_HomMat2DRotate = new HTuple();
            HTuple hv_Exception = null;
            // Initialize local and output iconic variables 
            hv_updateMapX = new HTuple();
            hv_updateMapY = new HTuple();
            hv_updateSnapMapX = new HTuple();
            hv_updateSnapMapY = new HTuple();
            hv_iFlag = "";

            try
            {
                HOperatorSet.AffineTransPoint2d(hv_baseMatrix, hv_otherCoorX, hv_otherCoorY,
                    out hv_Qx, out hv_Qy);

                HOperatorSet.LineOrientation(hv_baseCoorY, hv_baseCoorX, hv_Qy, hv_Qx, out hv_Phi1);

                HOperatorSet.LineOrientation(hv_baseCoorY, hv_baseCoorX, hv_updateCoorY, hv_updateCoorX,
                    out hv_Phi2);

                hv_deltaPhi = hv_Phi1 - hv_Phi2;

                HOperatorSet.HomMat2dRotate(hv_baseMatrix, hv_deltaPhi, 0, 0, out hv_HomMat2DRotate);

                HOperatorSet.AffineTransPoint2d(hv_HomMat2DRotate, hv_mapX, hv_mapY, out hv_updateMapX,
                    out hv_updateMapY);
                HOperatorSet.AffineTransPoint2d(hv_HomMat2DRotate, hv_snapMapX, hv_snapMapY,
                    out hv_updateSnapMapX, out hv_updateSnapMapY);
            }
            // catch (Exception) 
            catch (HalconException HDevExpDefaultException1)
            {
                HDevExpDefaultException1.ToHTuple(out hv_Exception);
                GetErrInfo(hv_Exception, out hv_iFlag);
            }



            return;
        }
        /// <summary>
        /// 两个矫正点匹配后，映射扫描和芯片点位,增加输入像素偏差 update_map_correction
        /// </summary>
        /// <param name="hv_mapX"></param>
        /// <param name="hv_mapY"></param>
        /// <param name="hv_snapMapX"></param>
        /// <param name="hv_snapMapY"></param>
        /// <param name="hv_baseCoorX"></param>
        /// <param name="hv_baseCoorY"></param>
        /// <param name="hv_baseMatrix"></param>
        /// <param name="hv_otherCoorX"></param>
        /// <param name="hv_otherCoorY"></param>
        /// <param name="hv_updateCoorX"></param>
        /// <param name="hv_updateCoorY"></param>
        /// <param name="hv_uvHxy">标定矩阵</param>
        /// <param name="hv_updateMapX"></param>
        /// <param name="hv_updateMapY"></param>
        /// <param name="hv_updateSnapMapX"></param>
        /// <param name="hv_updateSnapMapY"></param>
        /// <param name="hv_iFlag"></param>
        /// <param name="hv_du">x方向像素偏差</param>
        /// <param name="hv_dv">y方向像素偏差</param>
        public static void update_map_correction(HTuple hv_mapX, HTuple hv_mapY, HTuple hv_snapMapX,
            HTuple hv_snapMapY, HTuple hv_baseCoorX, HTuple hv_baseCoorY, HTuple hv_baseMatrix,
            HTuple hv_otherCoorX, HTuple hv_otherCoorY, HTuple hv_updateCoorX, HTuple hv_updateCoorY,
            HTuple hv_uvHxy, out HTuple hv_updateMapX, out HTuple hv_updateMapY, out HTuple hv_updateSnapMapX,
            out HTuple hv_updateSnapMapY, out HTuple hv_iFlag, out HTuple hv_du, out HTuple hv_dv)
            {



                // Local iconic variables 

                // Local control variables 

                HTuple hv_dx = null, hv_dy = null, hv_Qx = new HTuple();
                HTuple hv_Qy = new HTuple(), hv_xyHuv = new HTuple(), hv_Phi1 = new HTuple();
                HTuple hv_Phi2 = new HTuple(), hv_deltaPhi = new HTuple();
                HTuple hv_HomMat2DRotate = new HTuple(), hv_Qx1 = new HTuple();
                HTuple hv_Qy1 = new HTuple(), hv_Exception = null;
                // Initialize local and output iconic variables 
                hv_updateMapX = new HTuple();
                hv_updateMapY = new HTuple();
                hv_updateSnapMapX = new HTuple();
                hv_updateSnapMapY = new HTuple();
                hv_iFlag = "";

                hv_dx = new HTuple();
                hv_dy = new HTuple();
                hv_du = new HTuple();
                hv_dv = new HTuple();
                try
                {
                    HOperatorSet.AffineTransPoint2d(hv_baseMatrix, hv_otherCoorX, hv_otherCoorY,
                        out hv_Qx, out hv_Qy);

                    if (hv_dx == null)
                        hv_dx = new HTuple();
                    hv_dx[0] = hv_Qx - hv_updateCoorX;
                    if (hv_dy == null)
                        hv_dy = new HTuple();
                    hv_dy[0] = hv_Qy - hv_updateCoorY;

                    HOperatorSet.HomMat2dInvert(hv_uvHxy, out hv_xyHuv);

                    if (hv_du == null)
                        hv_du = new HTuple();
                    hv_du[0] = (hv_dx.TupleSelect(0)) * (hv_xyHuv.TupleSelect(1));
                    if (hv_dv == null)
                        hv_dv = new HTuple();
                    hv_dv[0] = (hv_dy.TupleSelect(0)) * (hv_xyHuv.TupleSelect(3));

                hv_baseCoorX = hv_baseMatrix[2];
                hv_baseCoorY = hv_baseMatrix[5];


                    HOperatorSet.LineOrientation(hv_baseCoorY, hv_baseCoorX, hv_Qy, hv_Qx, out hv_Phi1);

                    HOperatorSet.LineOrientation(hv_baseCoorY, hv_baseCoorX, hv_updateCoorY, hv_updateCoorX,
                        out hv_Phi2);

                    hv_deltaPhi = hv_Phi1 - hv_Phi2;

                    HOperatorSet.HomMat2dRotate(hv_baseMatrix, hv_deltaPhi, 0, 0, out hv_HomMat2DRotate);

                    //重复上述操作
                    HOperatorSet.AffineTransPoint2d(hv_HomMat2DRotate, hv_otherCoorX, hv_otherCoorY,
                        out hv_Qx1, out hv_Qy1);
                    if (hv_dx == null)
                        hv_dx = new HTuple();
                    hv_dx[1] = hv_Qx1 - hv_updateCoorX;
                    if (hv_dy == null)
                        hv_dy = new HTuple();
                    hv_dy[1] = hv_Qy1 - hv_updateCoorY;
                    if (hv_du == null)
                        hv_du = new HTuple();
                    hv_du[1] = (hv_dx.TupleSelect(1)) * (hv_xyHuv.TupleSelect(1));
                    if (hv_dv == null)
                        hv_dv = new HTuple();
                    hv_dv[1] = (hv_dy.TupleSelect(1)) * (hv_xyHuv.TupleSelect(3));

                    HOperatorSet.AffineTransPoint2d(hv_HomMat2DRotate, hv_mapX, hv_mapY, out hv_updateMapX,
                        out hv_updateMapY);
                    HOperatorSet.AffineTransPoint2d(hv_HomMat2DRotate, hv_snapMapX, hv_snapMapY,
                        out hv_updateSnapMapX, out hv_updateSnapMapY);
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    GetErrInfo(hv_Exception, out hv_iFlag);
                }



                return;
            }
        /// <summary>
        /// 两个矫正点匹配后，映射扫描和芯片点位
        /// </summary>
        /// <param name="hv_mapX"></param>
        /// <param name="hv_mapY"></param>
        /// <param name="hv_snapMapX"></param>
        /// <param name="hv_snapMapY"></param>
        /// <param name="hv_CoorXL">左矫正点模板中心实际轴位置X</param>
        /// <param name="hv_CoorYL">左矫正点模板中心实际轴位置Y</param>
        /// <param name="hv_CoorXR">右矫正点模板中心实际轴位置X</param>
        /// <param name="hv_CoorYR">右矫正点模板中心实际轴位置Y</param>
        /// <param name="hv_updateCoorXL">左匹配后目标中心实际轴位置X</param>
        /// <param name="hv_updateCoorYL">左匹配后目标中心实际轴位置Y</param>
        /// <param name="hv_updateCoorXR">右匹配后目标中心实际轴位置X</param>
        /// <param name="hv_updateCoorYR">右匹配后目标中心实际轴位置Y</param>
        /// <param name="hv_uvHxy"></param>
        /// <param name="hv_updateMapX"></param>
        /// <param name="hv_updateMapY"></param>
        /// <param name="hv_updateSnapMapX"></param>
        /// <param name="hv_updateSnapMapY"></param>
        /// <param name="hv_iFlag"></param>
        /// <param name="hv_du"></param>
        /// <param name="hv_dv"></param>
        public static void update_map_correction(HTuple hv_mapX, HTuple hv_mapY, HTuple hv_snapMapX,
      HTuple hv_snapMapY, HTuple hv_CoorXL, HTuple hv_CoorYL, HTuple hv_CoorXR, HTuple hv_CoorYR,
      HTuple hv_updateCoorXL, HTuple hv_updateCoorYL, HTuple hv_updateCoorXR, HTuple hv_updateCoorYR,
      HTuple hv_uvHxy, out HTuple hv_updateMapX, out HTuple hv_updateMapY, out HTuple hv_updateSnapMapX,
      out HTuple hv_updateSnapMapY, out HTuple hv_iFlag, out HTuple hv_du, out HTuple hv_dv)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_dx = null, hv_dy = null, hv_Phi1 = new HTuple();
            HTuple hv_Phi2 = new HTuple(), hv_HomMat2D = new HTuple();
            HTuple hv_xyHuv = new HTuple(), hv_Qx = new HTuple(), hv_Qy = new HTuple();
            HTuple hv_Exception = null;
            // Initialize local and output iconic variables 
            hv_updateMapX = new HTuple();
            hv_updateMapY = new HTuple();
            hv_updateSnapMapX = new HTuple();
            hv_updateSnapMapY = new HTuple();
            hv_iFlag = "";

            hv_dx = new HTuple();
            hv_dy = new HTuple();
            hv_du = new HTuple();
            hv_dv = new HTuple();
            try
            {
                //HOperatorSet.LineOrientation(hv_CoorYL, hv_CoorXL, hv_CoorYR, hv_CoorXR, out hv_Phi1);
                HOperatorSet.AngleLl(0, 0, 0, 1, hv_CoorYL, hv_CoorXL, hv_CoorYR, hv_CoorXR, out hv_Phi1);
                //HOperatorSet.LineOrientation(hv_updateCoorYL, hv_updateCoorXL, hv_updateCoorYR,
                //    hv_updateCoorXR, out hv_Phi2);
                HOperatorSet.AngleLl(0, 0, 0, 1, hv_updateCoorYL, hv_updateCoorXL, hv_updateCoorYR, hv_updateCoorXR, out hv_Phi2);

                HOperatorSet.VectorAngleToRigid(hv_CoorYL, hv_CoorXL, hv_Phi1, hv_updateCoorYL,
                    hv_updateCoorXL, hv_Phi2, out hv_HomMat2D);


                HOperatorSet.AffineTransPoint2d(hv_HomMat2D, hv_CoorYL, hv_CoorXL, out hv_Qx,
                    out hv_Qy);
                if (hv_dx == null)
                    hv_dx = new HTuple();
                hv_dx[0] = hv_CoorXR - hv_updateCoorXR;
                if (hv_dy == null)
                    hv_dy = new HTuple();
                hv_dy[0] = hv_CoorYR - hv_updateCoorYR;

                HOperatorSet.HomMat2dInvert(hv_uvHxy, out hv_xyHuv);

                if (hv_du == null)
                    hv_du = new HTuple();
                hv_du[0] = (hv_dx.TupleSelect(0)) * (hv_xyHuv.TupleSelect(1));
                if (hv_dv == null)
                    hv_dv = new HTuple();
                hv_dv[0] = (hv_dy.TupleSelect(0)) * (hv_xyHuv.TupleSelect(3));


                //重复上述操作
                HOperatorSet.AffineTransPoint2d(hv_HomMat2D, hv_CoorYR, hv_CoorXR, out hv_Qx,
                    out hv_Qy);
                if (hv_dx == null)
                    hv_dx = new HTuple();
                hv_dx[1] = hv_Qy - hv_updateCoorXR;
                if (hv_dy == null)
                    hv_dy = new HTuple();
                hv_dy[1] = hv_Qx - hv_updateCoorYR;
                if (hv_du == null)
                    hv_du = new HTuple();
                hv_du[1] = (hv_dx.TupleSelect(1)) * (hv_xyHuv.TupleSelect(1));
                if (hv_dv == null)
                    hv_dv = new HTuple();
                hv_dv[1] = (hv_dy.TupleSelect(1)) * (hv_xyHuv.TupleSelect(3));

                //HOperatorSet.AffineTransPoint2d(hv_HomMat2D, hv_mapX, hv_mapY, out hv_updateMapX,
                //    out hv_updateMapY);
                //HOperatorSet.AffineTransPoint2d(hv_HomMat2D, hv_snapMapX, hv_snapMapY, out hv_updateSnapMapX,
                //    out hv_updateSnapMapY);
                HOperatorSet.AffineTransPoint2d(hv_HomMat2D,  hv_mapY, hv_mapX, out hv_updateMapY, out hv_updateMapX
                    );
                HOperatorSet.AffineTransPoint2d(hv_HomMat2D,  hv_snapMapY, hv_snapMapX, 
                    out hv_updateSnapMapY,out hv_updateSnapMapX);
            }
            // catch (Exception) 
            catch (HalconException HDevExpDefaultException1)
            {
                HDevExpDefaultException1.ToHTuple(out hv_Exception);
                GetErrInfo(hv_Exception, out hv_iFlag);
            }



            return;
        }
        #endregion

        #region 将像素坐标转成实际坐标 coor_uvToxy_point
        /// <summary>
        /// 将像素坐标转成实际坐标 coor_uvToxy_point
        /// </summary>
        /// <param name="ho_Image">图像</param>
        /// <param name="hv_defrow">模板中心像素row</param>
        /// <param name="hv_defcol">模板中心像素col</param>
        /// <param name="hv_center_coorX">采图时轴坐标x</param>
        /// <param name="hv_center_coorY">采图时轴坐标y</param>
        /// <param name="hv_uvHxy">标定矩阵</param>
        /// <param name="hv_def_coorX">输出：模板中心实际物理坐标x</param>
        /// <param name="hv_def_coorY">输出：模板中心实际物理坐标y</param>
        /// <param name="hv_iFlag">输出：为空则成功，不为空失败</param>
        public static void coor_uvToxy_point(HObject ho_Image, HTuple hv_defrow, HTuple hv_defcol,
            HTuple hv_center_coorX, HTuple hv_center_coorY, HTuple hv_uvHxy, out HTuple hv_def_coorX,
            out HTuple hv_def_coorY, out HTuple hv_iFlag)
        {
            // Local iconic variables 

            // Local control variables 

            HTuple hv_Width = new HTuple(), hv_Height = new HTuple();
            HTuple hv__deltaWidth = new HTuple(), hv__deltaHeight = new HTuple();
            HTuple hv_deltaX = new HTuple(), hv_deltaY = new HTuple();
            HTuple hv_Exception = null;
            // Initialize local and output iconic variables 

            hv_iFlag = "";
            hv_def_coorX = new HTuple();
            hv_def_coorY = new HTuple();

            try
            {
                HOperatorSet.GetImageSize(ho_Image, out hv_Width, out hv_Height);
                hv__deltaWidth = hv_defcol - (hv_Width / 2);
                hv__deltaHeight = hv_defrow - (hv_Height / 2);

                hv_deltaX = ((hv_uvHxy.TupleSelect(0)) * hv__deltaHeight) + ((hv_uvHxy.TupleSelect(
                    1)) * hv__deltaWidth);
                
                hv_deltaY = ((-hv_uvHxy.TupleSelect(3)) * hv__deltaHeight) + ((hv_uvHxy.TupleSelect(
                    4)) * hv__deltaWidth);

                hv_def_coorX = hv_center_coorX - hv_deltaX;
                hv_def_coorY = hv_center_coorY + hv_deltaY;

            }
            // catch (Exception) 
            catch (HalconException HDevExpDefaultException1)
            {
                HDevExpDefaultException1.ToHTuple(out hv_Exception);
                GetErrInfo(hv_Exception, out hv_iFlag);
            }


            return;
        }
        #endregion
        /// <summary>
        /// 生成芯片匹配区
        /// </summary>
        /// <param name="ho_dieMatchRegion">芯片匹配区</param>
        /// <param name="hv_imgCenterX">图片中心X</param>
        /// <param name="hv_imgCenterY">图片中心Y</param>
        /// <param name="hv_dieWidth">芯片宽度</param>
        /// <param name="hv_dieHeight">芯片高度</param>
        /// <param name="hv_dieX">芯片X坐标</param>
        /// <param name="hv_dieY">芯片Y坐标</param>
        /// <param name="hv_uvHxy">UV2XY矩阵</param>
        /// <param name="hv_imgWidth">图片宽度</param>
        /// <param name="hv_imgHeight">图片高度</param>
        /// <param name="hv_imgWidthFactor">图片宽度有效比例</param>
        /// <param name="hv_imgHeightFactor">图片高度有效比例</param>
        /// <param name="hv_zoomFactor">缩放比例</param>
        /// <param name="hv_dilationSize">外扩尺寸,单位像素</param>
        /// <param name="hv_mapRowCnt">芯片总行数</param>
        /// <param name="hv_mapColCnt">芯片总列数</param>
        /// <param name="hv_dieRow">芯片当前行</param>
        /// <param name="hv_dieCol">芯片当前列</param>
        /// <param name="hv_iFlag">成功标志</param>
        //  public static void gen_die_match_region(out HObject ho_dieMatchRegion, HTuple hv_imgCenterX,
        //HTuple hv_imgCenterY, HTuple hv_dieWidth, HTuple hv_dieHeight, HTuple hv_dieX,
        //HTuple hv_dieY, HTuple hv_uvHxy, HTuple hv_imgWidth, HTuple hv_imgHeight, HTuple hv_imgWidthFactor,
        //HTuple hv_imgHeightFactor, HTuple hv_zoomFactor, HTuple hv_dilationSize, HTuple hv_mapRowCnt,
        //HTuple hv_mapColCnt, out HTuple hv_dieRow, out HTuple hv_dieCol, out HTuple hv_iFlag)
        //  {



        //      // Local iconic variables 

        //      // Local control variables 
        //      hv_dieWidth= hv_dieWidth-2;

        //      HTuple hv_uvHxyScaled = new HTuple(), hv_xyHuvScale = new HTuple();
        //      HTuple hv_viewWidth = new HTuple(), hv_viewHeight = new HTuple();
        //      HTuple hv_viewXLT = new HTuple(), hv_viewYLT = new HTuple();
        //      HTuple hv_viewXRB = new HTuple(), hv_viewYRB = new HTuple();
        //      HTuple hv_dieXLT = new HTuple(), hv_dieYLT = new HTuple();
        //      HTuple hv_dieXRB = new HTuple(), hv_dieYRB = new HTuple();
        //      HTuple hv_xLTGreater = new HTuple(), hv_yLTLess = new HTuple();
        //      HTuple hv_xRBLess = new HTuple(), hv_yRBGreater = new HTuple();
        //      HTuple hv_greater = new HTuple(), hv_greaterInd = new HTuple();
        //      HTuple hv_viewDieX = new HTuple(), hv_viewDieY = new HTuple();
        //      HTuple hv_deltaX = new HTuple(), hv_deltaY = new HTuple();
        //      HTuple hv_xyHuv = new HTuple(), hv_deltaRow = new HTuple();
        //      HTuple hv_deltaCol = new HTuple(), hv_dieImgRow = new HTuple();
        //      HTuple hv_dieImgCol = new HTuple(), hv_dieImgHeight = new HTuple();
        //      HTuple hv_dieImgWidth = new HTuple(), hv_row1 = new HTuple();
        //      HTuple hv_col1 = new HTuple(), hv_row2 = new HTuple();
        //      HTuple hv_col2 = new HTuple(), hv_Exception = null;
        //      HTuple hv_Less = new HTuple(), hv_Indices1 = new HTuple(), hv_Greater = new HTuple();
        //      // Initialize local and output iconic variables 
        //      HOperatorSet.GenEmptyObj(out ho_dieMatchRegion);
        //      hv_iFlag = "";
        //      ho_dieMatchRegion.Dispose();
        //      HOperatorSet.GenEmptyObj(out ho_dieMatchRegion);
        //      hv_dieRow = new HTuple();
        //      hv_dieCol = new HTuple();
        //      try
        //      {
        //          HOperatorSet.HomMat2dScale(hv_uvHxy, 1 / hv_zoomFactor, 1 / hv_zoomFactor, 0, 0,
        //              out hv_uvHxyScaled);
        //          HOperatorSet.HomMat2dInvert(hv_uvHxyScaled, out hv_xyHuvScale);
        //          hv_viewWidth = (((((hv_uvHxy.TupleSelect(0)) * hv_imgHeight) * hv_imgHeightFactor) + (((hv_uvHxy.TupleSelect(
        //              1)) * hv_imgWidth) * hv_imgWidthFactor))).TupleAbs();
        //          hv_viewHeight = (((((hv_uvHxy.TupleSelect(3)) * hv_imgHeight) * hv_imgHeightFactor) + (((hv_uvHxy.TupleSelect(
        //              4)) * hv_imgWidth) * hv_imgWidthFactor))).TupleAbs();
        //          hv_viewXLT = hv_imgCenterX - (hv_viewWidth / 2.0);
        //          hv_viewYLT = hv_imgCenterY + (hv_viewHeight / 2.0);
        //          hv_viewXRB = hv_imgCenterX + (hv_viewWidth / 2.0);
        //          hv_viewYRB = hv_imgCenterY - (hv_viewHeight / 2.0);
        //          hv_dieXLT = hv_dieX - (hv_dieWidth / 2.0);
        //          hv_dieYLT = hv_dieY + (hv_dieHeight / 2.0);
        //          hv_dieXRB = hv_dieX + (hv_dieWidth / 2.0);
        //          hv_dieYRB = hv_dieY - (hv_dieHeight / 2.0);

        //          //gen_rectangle1_contour_xld (rectangle, viewYLT, viewXLT, viewYRB, viewXRB)
        //          //gen_rectangle1_contour_xld (rectangle1, dieYLT, dieXLT, dieYRB, dieXRB)

        //          HOperatorSet.TupleGreaterEqualElem(hv_dieXLT, hv_viewXLT, out hv_xLTGreater);
        //          HOperatorSet.TupleGreaterEqualElem(hv_viewYLT, hv_dieYLT, out hv_yLTLess);
        //          HOperatorSet.TupleLessEqualElem(hv_dieXRB, hv_viewXRB, out hv_xRBLess);
        //          HOperatorSet.TupleLessEqualElem(hv_viewYRB, hv_dieYRB, out hv_yRBGreater);
        //          hv_greater = ((hv_xLTGreater * hv_yLTLess) * hv_xRBLess) * hv_yRBGreater;
        //          HOperatorSet.TupleFind(hv_greater, 1, out hv_greaterInd);
        //          if ((int)(new HTuple(hv_greaterInd.TupleEqual(-1))) != 0)
        //          {

        //              return;
        //          }
        //          hv_viewDieX = hv_dieX.TupleSelect(hv_greaterInd);
        //          hv_viewDieY = hv_dieY.TupleSelect(hv_greaterInd);
        //          hv_deltaX = hv_imgCenterX - hv_viewDieX;
        //          hv_deltaY = hv_imgCenterY - hv_viewDieY;
        //          HOperatorSet.HomMat2dInvert(hv_uvHxy, out hv_xyHuv);
        //          hv_deltaRow = ((hv_xyHuv.TupleSelect(0)) * hv_deltaX) + ((hv_xyHuv.TupleSelect(
        //              1)) * hv_deltaY);
        //          hv_deltaCol = ((hv_xyHuv.TupleSelect(3)) * hv_deltaX) + ((hv_xyHuv.TupleSelect(
        //              4)) * hv_deltaY);
        //          hv_dieImgRow = ((hv_imgHeight - 1) / 2.0) + hv_deltaRow;
        //          hv_dieImgCol = ((hv_imgWidth - 1) / 2.0) + hv_deltaCol;
        //          hv_dieImgHeight = ((((hv_xyHuv.TupleSelect(0)) * hv_dieWidth) + ((hv_xyHuv.TupleSelect(
        //              1)) * (-hv_dieHeight)))).TupleAbs();
        //          hv_dieImgWidth = ((((hv_xyHuv.TupleSelect(3)) * hv_dieWidth) + ((hv_xyHuv.TupleSelect(
        //              4)) * (-hv_dieHeight)))).TupleAbs();
        //          hv_row1 = (hv_dieImgRow - (hv_dieImgHeight / 2.0)) - hv_dilationSize;
        //          hv_col1 = (hv_dieImgCol - (hv_dieImgWidth / 2.0)) - hv_dilationSize;
        //          hv_row2 = (hv_dieImgRow + (hv_dieImgHeight / 2.0)) + hv_dilationSize;
        //          hv_col2 = (hv_dieImgCol + (hv_dieImgWidth / 2.0)) + hv_dilationSize;
        //          //if ((int)((new HTuple((new HTuple((new HTuple(hv_row1.TupleLess(0))).TupleOr(
        //          //    new HTuple(hv_col1.TupleLess(0))))).TupleOr(
        //          //    new HTuple(hv_row2.TupleGreater(hv_imgHeight))))).TupleOr(
        //          //    new HTuple(hv_col2.TupleGreater(hv_imgWidth)))) != 0)
        //          //{

        //          //    return;
        //          //}
        //          //*2019/11/4 修改 解决膨胀区域超过图片像素时直接return的问题 上面注释的代码
        //          HOperatorSet.TupleLessElem(hv_row1, 0, out hv_Less);
        //          HOperatorSet.TupleFind(hv_Less, 1, out hv_Indices1);
        //          if ((int)(new HTuple(hv_Indices1.TupleNotEqual(-1))) != 0)
        //          {
        //              if (hv_row1 == null)
        //                  hv_row1 = new HTuple();
        //              hv_row1[hv_Indices1] = 0;
        //          }

        //          HOperatorSet.TupleLessElem(hv_col1, 0, out hv_Less);
        //          HOperatorSet.TupleFind(hv_Less, 1, out hv_Indices1);
        //          if ((int)(new HTuple(hv_Indices1.TupleNotEqual(-1))) != 0)
        //          {
        //              if (hv_col1 == null)
        //                  hv_col1 = new HTuple();
        //              hv_col1[hv_Indices1] = 0;
        //          }

        //          HOperatorSet.TupleGreaterElem(hv_row2, hv_imgHeight, out hv_Greater);
        //          HOperatorSet.TupleFind(hv_Greater, 1, out hv_Indices1);
        //          if ((int)(new HTuple(hv_Indices1.TupleNotEqual(-1))) != 0)
        //          {
        //              if (hv_row2 == null)
        //                  hv_row2 = new HTuple();
        //              hv_row2[hv_Indices1] = hv_imgHeight;
        //          }

        //          HOperatorSet.TupleGreaterElem(hv_col2, hv_imgWidth, out hv_Greater);
        //          HOperatorSet.TupleFind(hv_Less, 1, out hv_Indices1);
        //          if ((int)(new HTuple(hv_Indices1.TupleNotEqual(-1))) != 0)
        //          {
        //              if (hv_col2 == null)
        //                  hv_col2 = new HTuple();
        //              hv_col2[hv_Indices1] = hv_imgWidth;
        //          }
        //          ho_dieMatchRegion.Dispose();
        //          HOperatorSet.GenRectangle1(out ho_dieMatchRegion, hv_row1, hv_col1, hv_row2,
        //              hv_col2);
        //          hv_dieRow = hv_greaterInd / hv_mapColCnt;
        //          hv_dieCol = hv_greaterInd % hv_mapColCnt;
        //      }
        //      // catch (Exception) 
        //      catch (HalconException HDevExpDefaultException1)
        //      {
        //          HDevExpDefaultException1.ToHTuple(out hv_Exception);
        //          GetErrInfo(hv_Exception, out hv_iFlag);
        //      }



        //      return;
        //  }

        public static void gen_die_match_region(out HObject ho_dieMatchRegion, HTuple hv_imgCenterX,
HTuple hv_imgCenterY, HTuple hv_dieWidth, HTuple hv_dieHeight, HTuple hv_dieX,
HTuple hv_dieY, HTuple hv_uvHxy, HTuple hv_imgWidth, HTuple hv_imgHeight, HTuple hv_imgWidthFactor,
HTuple hv_imgHeightFactor, HTuple hv_zoomFactor, HTuple hv_dilationSize, HTuple hv_mapRowCnt,
HTuple hv_mapColCnt, out HTuple hv_dieRow, out HTuple hv_dieCol, out HTuple hv_iFlag)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_uvHxyScaled = new HTuple(), hv_xyHuvScale = new HTuple();
            HTuple hv_viewWidth = new HTuple(), hv_viewHeight = new HTuple();
            HTuple hv_viewXLT = new HTuple(), hv_viewYLT = new HTuple();
            HTuple hv_viewXRB = new HTuple(), hv_viewYRB = new HTuple();
            HTuple hv_dieXLT = new HTuple(), hv_dieYLT = new HTuple();
            HTuple hv_dieXRB = new HTuple(), hv_dieYRB = new HTuple();
            HTuple hv_xLTGreater = new HTuple(), hv_yLTLess = new HTuple();
            HTuple hv_xRBLess = new HTuple(), hv_yRBGreater = new HTuple();
            HTuple hv_greater = new HTuple(), hv_greaterInd = new HTuple();
            HTuple hv_viewDieX = new HTuple(), hv_viewDieY = new HTuple();
            HTuple hv_deltaX = new HTuple(), hv_deltaY = new HTuple();
            HTuple hv_xyHuv = new HTuple(), hv_deltaRow = new HTuple();
            HTuple hv_deltaCol = new HTuple(), hv_dieImgRow = new HTuple();
            HTuple hv_dieImgCol = new HTuple(), hv_dieImgHeight = new HTuple();
            HTuple hv_dieImgWidth = new HTuple(), hv_row1 = new HTuple();
            HTuple hv_col1 = new HTuple(), hv_row2 = new HTuple();
            HTuple hv_col2 = new HTuple(), hv_Exception = null;
            HTuple hv_Less = new HTuple(), hv_Indices1 = new HTuple(), hv_Greater = new HTuple();
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_dieMatchRegion);
            hv_iFlag = "";
            ho_dieMatchRegion.Dispose();
            HOperatorSet.GenEmptyObj(out ho_dieMatchRegion);
            hv_dieRow = new HTuple();
            hv_dieCol = new HTuple();
            try
            {
                HOperatorSet.HomMat2dScale(hv_uvHxy, 1 / hv_zoomFactor, 1 / hv_zoomFactor, 0, 0,
                    out hv_uvHxyScaled);
                HOperatorSet.HomMat2dInvert(hv_uvHxyScaled, out hv_xyHuvScale);
                hv_viewWidth = (((((hv_uvHxy.TupleSelect(0)) * hv_imgHeight) * hv_imgHeightFactor) + (((hv_uvHxy.TupleSelect(
                    1)) * hv_imgWidth) * hv_imgWidthFactor))).TupleAbs();
                hv_viewHeight = (((((hv_uvHxy.TupleSelect(3)) * hv_imgHeight) * hv_imgHeightFactor) + (((hv_uvHxy.TupleSelect(
                    4)) * hv_imgWidth) * hv_imgWidthFactor))).TupleAbs();
                hv_viewXLT = hv_imgCenterX - (hv_viewWidth / 2.0);
                hv_viewYLT = hv_imgCenterY + (hv_viewHeight / 2.0);
                hv_viewXRB = hv_imgCenterX + (hv_viewWidth / 2.0);
                hv_viewYRB = hv_imgCenterY - (hv_viewHeight / 2.0);
                hv_dieXLT = hv_dieX - (hv_dieWidth / 2.0);
                hv_dieYLT = hv_dieY + (hv_dieHeight / 2.0);
                hv_dieXRB = hv_dieX + (hv_dieWidth / 2.0);
                hv_dieYRB = hv_dieY - (hv_dieHeight / 2.0);

                //gen_rectangle1_contour_xld (rectangle, viewYLT, viewXLT, viewYRB, viewXRB)
                //gen_rectangle1_contour_xld (rectangle1, dieYLT, dieXLT, dieYRB, dieXRB)

                HOperatorSet.TupleGreaterEqualElem(hv_dieXLT, hv_viewXLT, out hv_xLTGreater);
                HOperatorSet.TupleGreaterEqualElem(hv_viewYLT, hv_dieYLT, out hv_yLTLess);
                HOperatorSet.TupleLessEqualElem(hv_dieXRB, hv_viewXRB, out hv_xRBLess);
                HOperatorSet.TupleLessEqualElem(hv_viewYRB, hv_dieYRB, out hv_yRBGreater);
                hv_greater = ((hv_xLTGreater * hv_yLTLess) * hv_xRBLess) * hv_yRBGreater;
                HOperatorSet.TupleFind(hv_greater, 1, out hv_greaterInd);
                if ((int)(new HTuple(hv_greaterInd.TupleEqual(-1))) != 0)
                {

                    return;
                }
                hv_viewDieX = hv_dieX.TupleSelect(hv_greaterInd);
                hv_viewDieY = hv_dieY.TupleSelect(hv_greaterInd);
                hv_deltaX = hv_imgCenterX - hv_viewDieX;
                hv_deltaY = hv_imgCenterY - hv_viewDieY;
                HOperatorSet.HomMat2dInvert(hv_uvHxy, out hv_xyHuv);
                hv_deltaRow = ((hv_xyHuv.TupleSelect(0)) * hv_deltaX) + ((hv_xyHuv.TupleSelect(
                    1)) * hv_deltaY);
                hv_deltaCol = ((hv_xyHuv.TupleSelect(3)) * hv_deltaX) + ((hv_xyHuv.TupleSelect(
                    4)) * hv_deltaY);
                hv_dieImgRow = ((hv_imgHeight - 1) / 2.0) + hv_deltaRow;
                hv_dieImgCol = ((hv_imgWidth - 1) / 2.0) + hv_deltaCol;
                hv_dieImgHeight = ((((hv_xyHuv.TupleSelect(0)) * hv_dieWidth) + ((hv_xyHuv.TupleSelect(
                    1)) * (-hv_dieHeight)))).TupleAbs();
                hv_dieImgWidth = ((((hv_xyHuv.TupleSelect(3)) * hv_dieWidth) + ((hv_xyHuv.TupleSelect(
                    4)) * (-hv_dieHeight)))).TupleAbs();
                hv_row1 = (hv_dieImgRow - (hv_dieImgHeight / 2.0)) - hv_dilationSize;
                hv_col1 = (hv_dieImgCol - (hv_dieImgWidth / 2.0)) - hv_dilationSize;
                hv_row2 = (hv_dieImgRow + (hv_dieImgHeight / 2.0)) + hv_dilationSize;
                hv_col2 = (hv_dieImgCol + (hv_dieImgWidth / 2.0)) + hv_dilationSize;
                //if ((int)((new HTuple((new HTuple((new HTuple(hv_row1.TupleLess(0))).TupleOr(
                //    new HTuple(hv_col1.TupleLess(0))))).TupleOr(
                //    new HTuple(hv_row2.TupleGreater(hv_imgHeight))))).TupleOr(
                //    new HTuple(hv_col2.TupleGreater(hv_imgWidth)))) != 0)
                //{

                //    return;
                //}
                //*2019/11/4 修改 解决膨胀区域超过图片像素时直接return的问题 上面注释的代码
                HOperatorSet.TupleLessElem(hv_row1, 0, out hv_Less);
                HOperatorSet.TupleFind(hv_Less, 1, out hv_Indices1);
                if ((int)(new HTuple(hv_Indices1.TupleNotEqual(-1))) != 0)
                {
                    if (hv_row1 == null)
                        hv_row1 = new HTuple();
                    hv_row1[hv_Indices1] = 0;
                }

                HOperatorSet.TupleLessElem(hv_col1, 0, out hv_Less);
                HOperatorSet.TupleFind(hv_Less, 1, out hv_Indices1);
                if ((int)(new HTuple(hv_Indices1.TupleNotEqual(-1))) != 0)
                {
                    if (hv_col1 == null)
                        hv_col1 = new HTuple();
                    hv_col1[hv_Indices1] = 0;
                }

                HOperatorSet.TupleGreaterElem(hv_row2, hv_imgHeight, out hv_Greater);
                HOperatorSet.TupleFind(hv_Greater, 1, out hv_Indices1);
                if ((int)(new HTuple(hv_Indices1.TupleNotEqual(-1))) != 0)
                {
                    if (hv_row2 == null)
                        hv_row2 = new HTuple();
                    hv_row2[hv_Indices1] = hv_imgHeight;
                }

                HOperatorSet.TupleGreaterElem(hv_col2, hv_imgWidth, out hv_Greater);
                HOperatorSet.TupleFind(hv_Less, 1, out hv_Indices1);
                if ((int)(new HTuple(hv_Indices1.TupleNotEqual(-1))) != 0)
                {
                    if (hv_col2 == null)
                        hv_col2 = new HTuple();
                    hv_col2[hv_Indices1] = hv_imgWidth;
                }
                ho_dieMatchRegion.Dispose();
                HOperatorSet.GenRectangle1(out ho_dieMatchRegion, hv_row1, hv_col1, hv_row2,
                    hv_col2);
                hv_dieRow = hv_greaterInd / hv_mapColCnt;
                hv_dieCol = hv_greaterInd % hv_mapColCnt;
            }
            // catch (Exception) 
            catch (HalconException HDevExpDefaultException1)
            {
                HDevExpDefaultException1.ToHTuple(out hv_Exception);
                GetErrInfo(hv_Exception, out hv_iFlag);
            }



            return;
        }


        public static void find_model_ext(HObject ho_image, HObject ho_roi, HObject ho_show_contour,
            out HObject ho_update_show_contour, HTuple hv_model_type, HTuple hv_model_id,
            HTuple hv_angle_start, HTuple hv_angle_extent, HTuple hv_score_thresh, HTuple hv_match_num,
            HTuple hv_def_row, HTuple hv_def_col, out HTuple hv_found_row, out HTuple hv_found_col,
            out HTuple hv_found_angle, out HTuple hv_found_score, out HTuple hv_update_def_row,
            out HTuple hv_update_def_col, out HTuple hv_model_H_new, out HTuple hv_iFlag)
        {




            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];

            // Local iconic variables 

            HObject ho_complement_region, ho_paint_image;
            HObject ho_reduced_image, ho_affine_show_contour = null;

            // Local copy input parameter variables 
            HObject ho_image_COPY_INP_TMP;
            ho_image_COPY_INP_TMP = ho_image.CopyObj(1, -1);



            // Local control variables 

            HTuple hv_Channels = null, hv_inv_model_row = new HTuple();
            HTuple hv_inv_model_col = new HTuple(), hv_ncc_numlevs = new HTuple();
            HTuple hv_angle_step = new HTuple(), hv_ncc_metric = new HTuple();
            HTuple hv_local_row = new HTuple(), hv_local_col = new HTuple();
            HTuple hv_local_angle = new HTuple(), hv_local_score = new HTuple();
            HTuple hv_shape_numlevs = new HTuple(), hv_shape_scale_min = new HTuple();
            HTuple hv_shape_scale_max = new HTuple(), hv_shape_scale_step = new HTuple();
            HTuple hv_shape_metric = new HTuple(), hv_shape_min_contrast = new HTuple();
            HTuple hv_Greatereq = null, hv_GreaterInd = null, hv_model_row = new HTuple();
            HTuple hv_model_col = new HTuple(), hv_def_row_ind = new HTuple();
            HTuple hv_def_col_ind = new HTuple(), hv_i = new HTuple();
            HTuple hv_model_H_any = new HTuple(), hv__update_def_row = new HTuple();
            HTuple hv__update_def_col = new HTuple(), hv_update_model_row = new HTuple();
            HTuple hv_update_model_col = new HTuple();
            HTuple hv_angle_extent_COPY_INP_TMP = hv_angle_extent.Clone();
            HTuple hv_angle_start_COPY_INP_TMP = hv_angle_start.Clone();

            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_update_show_contour);
            HOperatorSet.GenEmptyObj(out ho_complement_region);
            HOperatorSet.GenEmptyObj(out ho_paint_image);
            HOperatorSet.GenEmptyObj(out ho_reduced_image);
            HOperatorSet.GenEmptyObj(out ho_affine_show_contour);
            try
            {
                hv_update_def_row = new HTuple();
                hv_update_def_col = new HTuple();
                hv_found_row = new HTuple();
                hv_found_col = new HTuple();
                hv_found_angle = new HTuple();
                hv_found_score = new HTuple();
                hv_model_H_new = new HTuple();
                hv_iFlag = 0;
                ho_update_show_contour.Dispose();
                HOperatorSet.GenEmptyObj(out ho_update_show_contour);

                ho_complement_region.Dispose();
                HOperatorSet.Complement(ho_roi, out ho_complement_region);
                HOperatorSet.CountChannels(ho_image_COPY_INP_TMP, out hv_Channels);
                if ((int)(new HTuple(hv_Channels.TupleNotEqual(1))) != 0)
                {
                    {
                        HObject ExpTmpOutVar_0;
                        HOperatorSet.Rgb1ToGray(ho_image_COPY_INP_TMP, out ExpTmpOutVar_0);
                        ho_image_COPY_INP_TMP.Dispose();
                        ho_image_COPY_INP_TMP = ExpTmpOutVar_0;
                    }
                }
                ho_paint_image.Dispose();
                HOperatorSet.PaintRegion(ho_complement_region, ho_image_COPY_INP_TMP, out ho_paint_image,
                    255, "fill");
                ho_reduced_image.Dispose();
                HOperatorSet.ReduceDomain(ho_paint_image, ho_roi, out ho_reduced_image);
                //******NCC/bin Ncc
                if ((int)(new HTuple(hv_model_type.TupleEqual(0))) != 0)
                {
                    HOperatorSet.GetNccModelOrigin(hv_model_id, out hv_inv_model_row, out hv_inv_model_col);
                    if ((int)((new HTuple(hv_angle_start_COPY_INP_TMP.TupleEqual(-1))).TupleOr(
                        new HTuple(hv_angle_extent_COPY_INP_TMP.TupleEqual(-1)))) != 0)
                    {
                        HOperatorSet.GetNccModelParams(hv_model_id, out hv_ncc_numlevs, out hv_angle_start_COPY_INP_TMP,
                            out hv_angle_extent_COPY_INP_TMP, out hv_angle_step, out hv_ncc_metric);
                    }
                    else
                    {
                        hv_angle_start_COPY_INP_TMP = hv_angle_start_COPY_INP_TMP.TupleRad();
                        hv_angle_extent_COPY_INP_TMP = hv_angle_extent_COPY_INP_TMP.TupleRad();
                    }
                    HOperatorSet.FindNccModel(ho_reduced_image, hv_model_id, hv_angle_start_COPY_INP_TMP,
                        hv_angle_extent_COPY_INP_TMP, 0.3, hv_match_num, 0.5, "true", 0, out hv_local_row,
                        out hv_local_col, out hv_local_angle, out hv_local_score);
                    //******Shape/Shape Xld
                }
                else
                {
                    HOperatorSet.GetShapeModelOrigin(hv_model_id, out hv_inv_model_row, out hv_inv_model_col);
                    if ((int)((new HTuple(hv_angle_start_COPY_INP_TMP.TupleEqual(-1))).TupleOr(
                        new HTuple(hv_angle_extent_COPY_INP_TMP.TupleEqual(-1)))) != 0)
                    {
                        HOperatorSet.GetShapeModelParams(hv_model_id, out hv_shape_numlevs, out hv_angle_start_COPY_INP_TMP,
                            out hv_angle_extent_COPY_INP_TMP, out hv_angle_step, out hv_shape_scale_min,
                            out hv_shape_scale_max, out hv_shape_scale_step, out hv_shape_metric,
                            out hv_shape_min_contrast);
                    }
                    else
                    {
                        hv_angle_start_COPY_INP_TMP = hv_angle_start_COPY_INP_TMP.TupleRad();
                        hv_angle_extent_COPY_INP_TMP = hv_angle_extent_COPY_INP_TMP.TupleRad();
                    }
                    HOperatorSet.FindShapeModel(ho_reduced_image, hv_model_id, hv_angle_start_COPY_INP_TMP,
                        hv_angle_extent_COPY_INP_TMP, 0.2, hv_match_num, 0.5, "least_squares",
                        0, 0.9, out hv_local_row, out hv_local_col, out hv_local_angle, out hv_local_score);
                }

                if ((int)(new HTuple((new HTuple(hv_local_score.TupleLength())).TupleLess(1))) != 0)
                {
                    hv_iFlag = -2;
                    ho_image_COPY_INP_TMP.Dispose();
                    ho_complement_region.Dispose();
                    ho_paint_image.Dispose();
                    ho_reduced_image.Dispose();
                    ho_affine_show_contour.Dispose();

                    return;
                }
                HOperatorSet.TupleGreaterEqualElem(hv_local_score, hv_score_thresh, out hv_Greatereq);
                HOperatorSet.TupleFind(hv_Greatereq, 1, out hv_GreaterInd);
                if ((int)(new HTuple(hv_GreaterInd.TupleEqual(-1))) != 0)
                {
                    hv_iFlag = -2;
                    ho_image_COPY_INP_TMP.Dispose();
                    ho_complement_region.Dispose();
                    ho_paint_image.Dispose();
                    ho_reduced_image.Dispose();
                    ho_affine_show_contour.Dispose();

                    return;
                }
                else
                {
                    //***获取模板中心坐标
                    hv_model_row = -hv_inv_model_row;
                    hv_model_col = -hv_inv_model_col;
                    HOperatorSet.TupleFind(hv_def_row, -1, out hv_def_row_ind);
                    HOperatorSet.TupleFind(hv_def_col, -1, out hv_def_col_ind);
                    for (hv_i = 0; (int)hv_i <= (int)((new HTuple(hv_GreaterInd.TupleLength())) - 1); hv_i = (int)hv_i + 1)
                    {
                        HOperatorSet.VectorAngleToRigid(0, 0, 0, hv_local_row.TupleSelect(hv_GreaterInd.TupleSelect(
                            hv_i)), hv_local_col.TupleSelect(hv_GreaterInd.TupleSelect(hv_i)),
                            hv_local_angle.TupleSelect(hv_GreaterInd.TupleSelect(hv_i)), out hv_model_H_any);
                        ho_affine_show_contour.Dispose();
                        HOperatorSet.AffineTransContourXld(ho_show_contour, out ho_affine_show_contour,
                            hv_model_H_any);

                        if ((int)((new HTuple(hv_def_row_ind.TupleEqual(-1))).TupleAnd(new HTuple(hv_def_col_ind.TupleEqual(
                            -1)))) != 0)
                        {
                            HOperatorSet.AffineTransPoint2d(hv_model_H_any, hv_def_row, hv_def_col,
                                out hv__update_def_row, out hv__update_def_col);
                        }
                        else
                        {
                            hv__update_def_row = new HTuple();
                            hv__update_def_col = new HTuple();
                        }
                        {
                            HObject ExpTmpOutVar_0;
                            HOperatorSet.ConcatObj(ho_update_show_contour, ho_affine_show_contour,
                                out ExpTmpOutVar_0);
                            ho_update_show_contour.Dispose();
                            ho_update_show_contour = ExpTmpOutVar_0;
                        }
                        //*****更新实际的模板坐标
                        HOperatorSet.AffineTransPoint2d(hv_model_H_any, hv_model_row, hv_model_col,
                            out hv_update_model_row, out hv_update_model_col);
                        hv_found_row = hv_found_row.TupleConcat(hv_update_model_row);
                        hv_found_col = hv_found_col.TupleConcat(hv_update_model_col);
                        hv_found_angle = hv_found_angle.TupleConcat(((hv_local_angle.TupleSelect(
                            hv_GreaterInd.TupleSelect(hv_i)))).TupleDeg());
                        hv_found_score = hv_found_score.TupleConcat(hv_local_score.TupleSelect(
                            hv_GreaterInd.TupleSelect(hv_i)));
                        hv_update_def_row = hv_update_def_row.TupleConcat(hv__update_def_row);
                        hv_update_def_col = hv_update_def_col.TupleConcat(hv__update_def_col);
                        hv_model_H_new = hv_model_H_new.TupleConcat(hv_model_H_any);
                    }
                }

                ho_image_COPY_INP_TMP.Dispose();
                ho_complement_region.Dispose();
                ho_paint_image.Dispose();
                ho_reduced_image.Dispose();
                ho_affine_show_contour.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_image_COPY_INP_TMP.Dispose();
                ho_complement_region.Dispose();
                ho_paint_image.Dispose();
                ho_reduced_image.Dispose();
                ho_affine_show_contour.Dispose();

                throw HDevExpDefaultException;
            }
        }

        public static void gen_rectangle1_contour_xld(out HObject ho_rectangle, HTuple hv_row1,
          HTuple hv_col1, HTuple hv_row2, HTuple hv_col2)
        {


            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_rectangle);
            ho_rectangle.Dispose();
            HOperatorSet.GenRectangle2ContourXld(out ho_rectangle, (hv_row1 + hv_row2) / 2.0,
                (hv_col1 + hv_col2) / 2.0, HTuple.TupleGenConst(new HTuple(hv_row1.TupleLength()
                ), 0), (hv_col2 - hv_col1) / 2.0, (hv_row2 - hv_row1) / 2.0);

            return;
        }
        #endregion
        #region 二维码
        /// <summary>
        ///1.训练二维码
        ///1.1 移动至二维码拍照位,采集图像
        ///1.2 交互画一个临时的包含二维码的区域ho_dataCode2DRegion
        ///1.3 调用函数TrainDataCode2D训练二维码
        /// </summary>
        /// <param name="ho_image"></param>
        /// <param name="ho_dataCode2DRegion"></param>
        /// <param name="ho_dataCode2DContour"></param>
        /// <param name="hv_dataCodeHandle"></param>
        /// <param name="hv_dataCodeType"></param>
        /// <param name="hv_dataCodeString"></param>
        /// <param name="hv_iFlag"></param>

        public static void TrainDataCode2D(HObject ho_image, HObject ho_dataCode2DRegion, out HObject ho_dataCode2DContour,
              out HTuple hv_dataCodeHandle, out HTuple hv_dataCodeType, out HTuple hv_dataCodeString,
              out HTuple hv_iFlag)
        {



            // Local iconic variables 

            HObject ho_reducedImg = null;

            // Local control variables 

            HTuple hv__dataCodeType = new HTuple(), hv_i = new HTuple();
            HTuple hv_resultHandles = new HTuple(), hv_Exception = null;
            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_dataCode2DContour);
            HOperatorSet.GenEmptyObj(out ho_reducedImg);
            try
            {
                hv_dataCodeHandle = new HTuple();
                hv_dataCodeType = new HTuple();
                hv_dataCodeString = new HTuple();
                ho_dataCode2DContour.Dispose();
                HOperatorSet.GenEmptyObj(out ho_dataCode2DContour);
                hv_iFlag = "";

                try
                {
                    ho_reducedImg.Dispose();
                    HOperatorSet.ReduceDomain(ho_image, ho_dataCode2DRegion, out ho_reducedImg
                        );
                    hv__dataCodeType = new HTuple();
                    hv__dataCodeType[0] = "Aztec Code";
                    hv__dataCodeType[1] = "Data Matrix ECC 200";
                    hv__dataCodeType[2] = "GS1 Aztec Code";
                    hv__dataCodeType[3] = "GS1 DataMatrix";
                    hv__dataCodeType[4] = "GS1 QR Code";
                    hv__dataCodeType[5] = "Micro QR Code";
                    hv__dataCodeType[6] = "PDF417";
                    hv__dataCodeType[7] = "QR Code";
                    for (hv_i = 0; (int)hv_i <= (int)((new HTuple(hv__dataCodeType.TupleLength())) - 1); hv_i = (int)hv_i + 1)
                    {
                        HOperatorSet.CreateDataCode2dModel(hv__dataCodeType.TupleSelect(hv_i),
                            new HTuple(), new HTuple(), out hv_dataCodeHandle);
                        ho_dataCode2DContour.Dispose();
                        HOperatorSet.FindDataCode2d(ho_reducedImg, out ho_dataCode2DContour, hv_dataCodeHandle,
                            "train", "all", out hv_resultHandles, out hv_dataCodeString);
                        if ((int)(new HTuple(hv_dataCodeString.TupleNotEqual(new HTuple()))) != 0)
                        {
                            hv_dataCodeType = hv__dataCodeType.TupleSelect(hv_i);
                            ho_reducedImg.Dispose();

                            return;
                        }
                    }
                }
                // catch (Exception) 
                catch (HalconException HDevExpDefaultException1)
                {
                    HDevExpDefaultException1.ToHTuple(out hv_Exception);
                    GetErrInfo(hv_Exception, out hv_iFlag);
                }

                ho_reducedImg.Dispose();

                return;
            }
            catch (HalconException HDevExpDefaultException)
            {
                ho_reducedImg.Dispose();

                throw HDevExpDefaultException;
            }
        }

        ////2.保存二维码模板,文件名以.dcm为扩展名
        //HOperatorSet.WriteDataCode2dModel(hv_dataCodeHandle, filePath);
        ////3.读取二维码模板
        //HOperatorSet.ReadDataCode2dModel(filePath, out hv_dataCodeHandle);	  
        ////4.清楚资源函数  
        //HOperatorSet.ClearDataCode2dModel(hv_dataCodeHandle);
        ////5.流程中读取二维码函数,二维码结果返回在hv_dataCodeString
        //HOperatorSet.FindDataCode2d(ho_Image1, out ho_dataCode2DContour, hv_dataCodeHandle, 
        //			  new HTuple(), new HTuple(), out hv_ResultHandles, out hv_dataCodeString);
        #endregion

    }

}